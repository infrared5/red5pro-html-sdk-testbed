/*!
 * 
 *   red5pro-sdk - Red5 Pro HTML Publisher and Subscriber SDK.
 *   Author: Infrared5 Inc.
 *   Version: 10.10.0
 *   Url: https://github.com/red5pro/red5pro-html-sdk#readme
 * 
 *   Copyright Â© 2015 Infrared5, Inc. All rights reserved.
 * 
 *   The accompanying code comprising examples for use solely in conjunction with Red5 Pro (the "Example Code") 
 *   is  licensed  to  you  by  Infrared5  Inc.  in  consideration  of  your  agreement  to  the  following  
 *   license terms  and  conditions.  Access,  use,  modification,  or  redistribution  of  the  accompanying  
 *   code  constitutes your acceptance of the following license terms and conditions.
 * 
 *   Permission is hereby granted, free of charge, to you to use the Example Code and associated documentation 
 *   files (collectively, the "Software") without restriction, including without limitation the rights to use, 
 *   copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit 
 *   persons to whom the Software is furnished to do so, subject to the following conditions:
 * 
 *   The Software shall be used solely in conjunction with Red5 Pro. Red5 Pro is licensed under a separate end 
 *   user  license  agreement  (the  "EULA"),  which  must  be  executed  with  Infrared5,  Inc.   
 *   An  example  of  the EULA can be found on our website at: https://account.red5pro.com/assets/LICENSE.txt.
 * 
 *   The above copyright notice and this license shall be included in all copies or portions of the Software.
 * 
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,  INCLUDING  BUT  
 *   NOT  LIMITED  TO  THE  WARRANTIES  OF  MERCHANTABILITY, FITNESS  FOR  A  PARTICULAR  PURPOSE  AND  
 *   NONINFRINGEMENT.   IN  NO  EVENT  SHALL INFRARED5, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 *   WHETHER IN  AN  ACTION  OF  CONTRACT,  TORT  OR  OTHERWISE,  ARISING  FROM,  OUT  OF  OR  IN CONNECTION 
 *   WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["red5prosdk"] = factory();
	else
		root["red5prosdk"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * !This is a stripped down version of Bunyan targeted specifically for the browser
 *
 * -------------------------------------------------------------------------------
 *
 * Copyright (c) 2014 Trent Mick. All rights reserved.
 * Copyright (c) 2014 Joyent Inc. All rights reserved.
 *
 * The bunyan logging library for node.js.
 *
 * -*- mode: js -*-
 * vim: expandtab:ts=4:sw=4
 */



var VERSION = '0.2.3';

// Bunyan log format version. This becomes the 'v' field on all log records.
// `0` is until I release a version '1.0.0' of node-bunyan. Thereafter,
// starting with `1`, this will be incremented if there is any backward
// incompatible change to the log record format. Details will be in
// 'CHANGES.md' (the change log).
var LOG_VERSION = 0;

//---- Internal support stuff

/**
 * A shallow copy of an object. Bunyan logging attempts to never cause
 * exceptions, so this function attempts to handle non-objects gracefully.
 */
function objCopy(obj) {
    if (typeof obj === 'undefined' || obj === null) {  // null or undefined
        return obj;
    } else if (Array.isArray(obj)) {
        return obj.slice();
    } else if (typeof (obj) === 'object') {
        var copy = {};
        Object.keys(obj).forEach(function (k) {
            copy[k] = obj[k];
        });
        return copy;
    } else {
        return obj;
    }
}

var format = function(f) {

    if(f === null) {
        return 'null';
    }

    if(typeof f !== 'string') {
        return f.toString();
    }
    var formatRegExp = /%[sdj%]/g;

    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x) {
        if (x === '%%') {
            return '%';
        }
        if (i >= len) {
            return x;
        }
        switch (x) {
            case '%s': return String(args[i++]);
            case '%d': return Number(args[i++]);
            case '%j':
                try {
                    return JSON.stringify(args[i++]);
                } catch (_) {
                    return '[Circular]';
                }
                break;
            default:
                return x;
        }
    });
    for (var x = args[i]; i < len; x = args[++i]) {
        str += ' ' + x;
    }
    return str;
};

/**
 * Gather some caller info 3 stack levels up.
 * See <http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi>.
 */
function getCaller3Info() {
    var obj = {};
    var saveLimit = Error.stackTraceLimit;
    var savePrepare = Error.prepareStackTrace;
    Error.stackTraceLimit = 3;
    //Error.captureStackTrace(this, getCaller3Info);

    Error.prepareStackTrace = function (_, stack) {
        var caller = stack[2];
        obj.file = caller.getFileName();
        obj.line = caller.getLineNumber();
        var func = caller.getFunctionName();
        if (func) {
            obj.func = func;
        }
    };
    Error.stackTraceLimit = saveLimit;
    Error.prepareStackTrace = savePrepare;
    return obj;
}


function _indent(s, indent) {
    if (!indent) {
        indent = '    ';
    }
    var lines = s.split(/\r?\n/g);
    return indent + lines.join('\n' + indent);
}


/**
 * Warn about an bunyan processing error.
 *
 * @param msg {String} Message with which to warn.
 * @param dedupKey {String} Optional. A short string key for this warning to
 *      have its warning only printed once.
 */
function _warn(msg, dedupKey) {
    if (dedupKey) {
        if (_warned[dedupKey]) {
            return;
        }
        _warned[dedupKey] = true;
    }
    console.error(msg + '\n');
}
function _haveWarned(dedupKey) {
    return _warned[dedupKey];
}
var _warned = {};


function ConsoleRawStream() {
}
ConsoleRawStream.prototype.write = function (rec) {
    if (rec.level < INFO) {
        console.log(rec);
    } else if (rec.level < WARN) {
        console.info(rec);
    } else if (rec.level < ERROR) {
        console.warn(rec);
    } else {
        console.error(rec);
    }

    if(rec.err && rec.err.stack) {
        console.error(rec.err.stack);
    }
};

function ConsoleFormattedStream() {}
ConsoleFormattedStream.prototype.write = function (rec) {

    var levelCss, defaultCss = 'color: DimGray', msgCss = 'color: SteelBlue';

    if (rec.level < DEBUG) {
        levelCss = 'color: DeepPink';
    } else if (rec.level < INFO) {
        levelCss = 'color: GoldenRod';
    } else if (rec.level < WARN) {
        levelCss = 'color: DarkTurquoise';
    } else if (rec.level < ERROR) {
        levelCss = 'color: Purple';
    } else if (rec.level < FATAL) {
        levelCss = 'color: Crimson';
    } else {
        levelCss = 'color: Black';
    }

    var loggerName = rec.childName ? rec.name + '/' + rec.childName : rec.name;

    //get level name and pad start with spacs
    var levelName = nameFromLevel[rec.level].toUpperCase();
    levelName = Array(6 - levelName.length).join(' ') + levelName;

    function padZeros(number, len) {
        return Array((len + 1) - (number + '').length).join('0') + number;
    }

    console.log('[%s:%s:%s:%s] %c%s%c: %s: %c%s',
        padZeros(rec.time.getHours(), 2), padZeros(rec.time.getMinutes(), 2),
        padZeros(rec.time.getSeconds(), 2), padZeros(rec.time.getMilliseconds(), 4),
        levelCss, levelName,
        defaultCss, loggerName,
        msgCss, rec.msg);
    if(rec.err && rec.err.stack) {
        console.log('%c%s,', levelCss, rec.err.stack);
    }
};

//---- Levels

var TRACE = 10;
var DEBUG = 20;
var INFO = 30;
var WARN = 40;
var ERROR = 50;
var FATAL = 60;

var levelFromName = {
    'trace': TRACE,
    'debug': DEBUG,
    'info': INFO,
    'warn': WARN,
    'error': ERROR,
    'fatal': FATAL
};
var nameFromLevel = {};
Object.keys(levelFromName).forEach(function (name) {
    nameFromLevel[levelFromName[name]] = name;
});


/**
 * Resolve a level number, name (upper or lowercase) to a level number value.
 *
 * @api public
 */
function resolveLevel(nameOrNum) {
    var level = (typeof (nameOrNum) === 'string' ? levelFromName[nameOrNum.toLowerCase()] : nameOrNum);
    return level;
}


//---- Logger class

/**
 * Create a Logger instance.
 *
 * @param options {Object} See documentation for full details. At minimum
 *    this must include a 'name' string key. Configuration keys:
 *      - `streams`: specify the logger output streams. This is an array of
 *        objects with these fields:
 *          - `type`: The stream type. See README.md for full details.
 *            Often this is implied by the other fields. Examples are
 *            'file', 'stream' and "raw".
 *          - `level`: Defaults to 'info'.
 *          - `path` or `stream`: The specify the file path or writeable
 *            stream to which log records are written. E.g.
 *            `stream: process.stdout`.
 *          - `closeOnExit` (boolean): Optional. Default is true for a
 *            'file' stream when `path` is given, false otherwise.
 *        See README.md for full details.
 *      - `level`: set the level for a single output stream (cannot be used
 *        with `streams`)
 *      - `stream`: the output stream for a logger with just one, e.g.
 *        `process.stdout` (cannot be used with `streams`)
 *      - `serializers`: object mapping log record field names to
 *        serializing functions. See README.md for details.
 *      - `src`: Boolean (default false). Set true to enable 'src' automatic
 *        field with log call source info.
 *    All other keys are log record fields.
 *
 * An alternative *internal* call signature is used for creating a child:
 *    new Logger(<parent logger>, <child options>[, <child opts are simple>]);
 *
 * @param _childSimple (Boolean) An assertion that the given `_childOptions`
 *    (a) only add fields (no config) and (b) no serialization handling is
 *    required for them. IOW, this is a fast path for frequent child
 *    creation.
 */
function Logger(options, _childOptions, _childSimple) {
    if (!(this instanceof Logger)) {
        return new Logger(options, _childOptions);
    }

    // Input arg validation.
    var parent;
    if (_childOptions !== undefined) {
        parent = options;
        options = _childOptions;
        if (!(parent instanceof Logger)) {
            throw new TypeError(
                'invalid Logger creation: do not pass a second arg');
        }
    }
    if (!options) {
        throw new TypeError('options (object) is required');
    }
    if (!parent) {
        if (!options.name) {
            throw new TypeError('options.name (string) is required');
        }
    } else {
        if (options.name) {
            throw new TypeError(
                'invalid options.name: child cannot set logger name');
        }
    }
    if (options.stream && options.streams) {
        throw new TypeError('cannot mix "streams" and "stream" options');
    }
    if (options.streams && !Array.isArray(options.streams)) {
        throw new TypeError('invalid options.streams: must be an array');
    }
    if (options.serializers && (typeof (options.serializers) !== 'object' || Array.isArray(options.serializers))) {
        throw new TypeError('invalid options.serializers: must be an object');
    }

    var fields, name, i;

    // Fast path for simple child creation.
    if (parent && _childSimple) {
        // `_isSimpleChild` is a signal to stream close handling that this child
        // owns none of its streams.
        this._isSimpleChild = true;

        this._level = parent._level;
        this.streams = parent.streams;
        this.serializers = parent.serializers;
        this.src = parent.src;
        fields = this.fields = {};
        var parentFieldNames = Object.keys(parent.fields);
        for (i = 0; i < parentFieldNames.length; i++) {
            name = parentFieldNames[i];
            fields[name] = parent.fields[name];
        }
        var names = Object.keys(options);
        for (i = 0; i < names.length; i++) {
            name = names[i];
            fields[name] = options[name];
        }
        return;
    }

    // Null values.
    var self = this;
    if (parent) {
        this._level = parent._level;
        this.streams = [];
        for (i = 0; i < parent.streams.length; i++) {
            var s = objCopy(parent.streams[i]);
            s.closeOnExit = false; // Don't own parent stream.
            this.streams.push(s);
        }
        this.serializers = objCopy(parent.serializers);
        this.src = parent.src;
        this.fields = objCopy(parent.fields);
        if (options.level) {
            this.level(options.level);
        }
    } else {
        this._level = Number.POSITIVE_INFINITY;
        this.streams = [];
        this.serializers = null;
        this.src = false;
        this.fields = {};
    }

    // Handle *config* options (i.e. options that are not just plain data
    // for log records).
    if (options.stream) {
        self.addStream({
            type: 'stream',
            stream: options.stream,
            closeOnExit: false,
            level: options.level
        });
    } else if (options.streams) {
        options.streams.forEach(function (s) {
            self.addStream(s, options.level);
        });
    } else if (parent && options.level) {
        this.level(options.level);
    } else if (!parent) {

        /*
         * In the browser we'll be emitting to console.log by default.
         * Any console.log worth its salt these days can nicely render
         * and introspect objects (e.g. the Firefox and Chrome console)
         * so let's emit the raw log record. Are there browsers for which
         * that breaks things?
         */
        self.addStream({
            type: 'raw',
            stream: new ConsoleRawStream(),
            closeOnExit: false,
            level: options.level
        });

    }
    if (options.serializers) {
        self.addSerializers(options.serializers);
    }
    if (options.src) {
        this.src = true;
    }

    // Fields.
    // These are the default fields for log records (minus the attributes
    // removed in this constructor). To allow storing raw log records
    // (unrendered), `this.fields` must never be mutated. Create a copy for
    // any changes.
    fields = objCopy(options);
    delete fields.stream;
    delete fields.level;
    delete fields.streams;
    delete fields.serializers;
    delete fields.src;
    if (this.serializers) {
        this._applySerializers(fields);
    }
    Object.keys(fields).forEach(function (k) {
        self.fields[k] = fields[k];
    });
}

/**
 * Add a stream
 *
 * @param stream {Object}. Object with these fields:
 *    - `type`: The stream type. See README.md for full details.
 *      Often this is implied by the other fields. Examples are
 *      'file', 'stream' and "raw".
 *    - `path` or `stream`: The specify the file path or writeable
 *      stream to which log records are written. E.g.
 *      `stream: process.stdout`.
 *    - `level`: Optional. Falls back to `defaultLevel`.
 *    - `closeOnExit` (boolean): Optional. Default is true for a
 *      'file' stream when `path` is given, false otherwise.
 *    See README.md for full details.
 * @param defaultLevel {Number|String} Optional. A level to use if
 *      `stream.level` is not set. If neither is given, this defaults to INFO.
 */
Logger.prototype.addStream = function addStream(s, defaultLevel) {
    var self = this;
    if (defaultLevel === null || defaultLevel === undefined) {
        defaultLevel = INFO;
    }

    s = objCopy(s);

    // Implicit 'type' from other args.
    if (!s.type && s.stream) {
        s.type = 'raw';
    }
    s.raw = (s.type === 'raw');  // PERF: Allow for faster check in `_emit`.

    if (s.level) {
        s.level = resolveLevel(s.level);
    } else {
        s.level = resolveLevel(defaultLevel);
    }
    if (s.level < self._level) {
        self._level = s.level;
    }

    switch (s.type) {
        case 'stream':
            if (!s.closeOnExit) {
                s.closeOnExit = false;
            }
            break;
        case 'raw':
            if (!s.closeOnExit) {
                s.closeOnExit = false;
            }
            break;
        default:
            throw new TypeError('unknown stream type "' + s.type + '"');
    }

    self.streams.push(s);
    delete self.haveNonRawStreams;  // reset
};


/**
 * Add serializers
 *
 * @param serializers {Object} Optional. Object mapping log record field names
 *    to serializing functions. See README.md for details.
 */
Logger.prototype.addSerializers = function addSerializers(serializers) {
    var self = this;

    if (!self.serializers) {
        self.serializers = {};
    }
    Object.keys(serializers).forEach(function (field) {
        var serializer = serializers[field];
        if (typeof (serializer) !== 'function') {
            throw new TypeError(format(
                'invalid serializer for "%s" field: must be a function',
                field));
        } else {
            self.serializers[field] = serializer;
        }
    });
};


/**
 * Create a child logger, typically to add a few log record fields.
 *
 * This can be useful when passing a logger to a sub-component, e.g. a
 * 'wuzzle' component of your service:
 *
 *    var wuzzleLog = log.child({component: 'wuzzle'})
 *    var wuzzle = new Wuzzle({..., log: wuzzleLog})
 *
 * Then log records from the wuzzle code will have the same structure as
 * the app log, *plus the component='wuzzle' field*.
 *
 * @param options {Object} Optional. Set of options to apply to the child.
 *    All of the same options for a new Logger apply here. Notes:
 *      - The parent's streams are inherited and cannot be removed in this
 *        call. Any given `streams` are *added* to the set inherited from
 *        the parent.
 *      - The parent's serializers are inherited, though can effectively be
 *        overwritten by using duplicate keys.
 *      - Can use `level` to set the level of the streams inherited from
 *        the parent. The level for the parent is NOT affected.
 * @param simple {Boolean} Optional. Set to true to assert that `options`
 *    (a) only add fields (no config) and (b) no serialization handling is
 *    required for them. IOW, this is a fast path for frequent child
 *    creation. See 'tools/timechild.js' for numbers.
 */
Logger.prototype.child = function (options, simple) {
    return new (this.constructor)(this, options || {}, simple);
};

/**
 * Get/set the level of all streams on this logger.
 *
 * Get Usage:
 *    // Returns the current log level (lowest level of all its streams).
 *    log.level() -> INFO
 *
 * Set Usage:
 *    log.level(INFO)       // set all streams to level INFO
 *    log.level('info')     // can use 'info' et al aliases
 */
Logger.prototype.level = function level(value) {
    if (value === undefined) {
        return this._level;
    }
    var newLevel = resolveLevel(value);
    var len = this.streams.length;
    for (var i = 0; i < len; i++) {
        this.streams[i].level = newLevel;
    }
    this._level = newLevel;
};


/**
 * Get/set the level of a particular stream on this logger.
 *
 * Get Usage:
 *    // Returns an array of the levels of each stream.
 *    log.levels() -> [TRACE, INFO]
 *
 *    // Returns a level of the identified stream.
 *    log.levels(0) -> TRACE      // level of stream at index 0
 *    log.levels('foo')           // level of stream with name 'foo'
 *
 * Set Usage:
 *    log.levels(0, INFO)         // set level of stream 0 to INFO
 *    log.levels(0, 'info')       // can use 'info' et al aliases
 *    log.levels('foo', WARN)     // set stream named 'foo' to WARN
 *
 * Stream names: When streams are defined, they can optionally be given
 * a name. For example,
 *       log = new Logger({
 *         streams: [
 *           {
 *             name: 'foo',
 *             path: '/var/log/my-service/foo.log'
 *             level: 'trace'
 *           },
 *         ...
 *
 * @param name {String|Number} The stream index or name.
 * @param value {Number|String} The level value (INFO) or alias ('info').
 *    If not given, this is a 'get' operation.
 * @throws {Error} If there is no stream with the given name.
 */
Logger.prototype.levels = function levels(name, value) {
    if (name === undefined) {
        return this.streams.map(
            function (s) {
                return s.level;
            });
    }
    var stream;
    if (typeof (name) === 'number') {
        stream = this.streams[name];
        if (stream === undefined) {
            throw new Error('invalid stream index: ' + name);
        }
    } else {
        var len = this.streams.length;
        for (var i = 0; i < len; i++) {
            var s = this.streams[i];
            if (s.name === name) {
                stream = s;
                break;
            }
        }
        if (!stream) {
            throw new Error(format('no stream with name "%s"', name));
        }
    }
    if (value === undefined) {
        return stream.level;
    } else {
        var newLevel = resolveLevel(value);
        stream.level = newLevel;
        if (newLevel < this._level) {
            this._level = newLevel;
        }
    }
};


/**
 * Apply registered serializers to the appropriate keys in the given fields.
 *
 * Pre-condition: This is only called if there is at least one serializer.
 *
 * @param fields (Object) The log record fields.
 * @param excludeFields (Object) Optional mapping of keys to `true` for
 *    keys to NOT apply a serializer.
 */
Logger.prototype._applySerializers = function (fields, excludeFields) {
    var self = this;

    // Check each serializer against these (presuming number of serializers
    // is typically less than number of fields).
    Object.keys(this.serializers).forEach(function (name) {
        if (fields[name] === undefined ||
            (excludeFields && excludeFields[name])) {
            return;
        }
        try {
            fields[name] = self.serializers[name](fields[name]);
        } catch (err) {
            _warn(format('bunyan: ERROR: Exception thrown from the "%s" ' +
                    'Bunyan serializer. This should never happen. This is a bug' +
                    'in that serializer function.\n%s',
                name, err.stack || err));
            fields[name] = format('(Error in Bunyan log "%s" serializer broke field. See stderr for details.)', name);
        }
    });
};


/**
 * Emit a log record.
 *
 * @param rec {log record}
 * @param noemit {Boolean} Optional. Set to true to skip emission
 *      and just return the JSON string.
 */
Logger.prototype._emit = function (rec, noemit) {
    var i;

    // Lazily determine if this Logger has non-'raw' streams. If there are
    // any, then we need to stringify the log record.
    if (this.haveNonRawStreams === undefined) {
        this.haveNonRawStreams = false;
        for (i = 0; i < this.streams.length; i++) {
            if (!this.streams[i].raw) {
                this.haveNonRawStreams = true;
                break;
            }
        }
    }

    // Stringify the object. Attempt to warn/recover on error.
    var str;
    if (noemit || this.haveNonRawStreams) {
        try {
            str = JSON.stringify(rec, safeCycles()) + '\n';
        } catch (e) {
            var dedupKey = e.stack.split(/\n/g, 2).join('\n');
            _warn('bunyan: ERROR: Exception in ' +
                    '`JSON.stringify(rec)`. You can install the ' +
                    '"safe-json-stringify" module to have Bunyan fallback ' +
                    'to safer stringification. Record:\n' +
                    _indent(format('%s\n%s', rec, e.stack)),
                dedupKey);
            str = format('(Exception in JSON.stringify(rec): %j. See stderr for details.)\n', e.message);

        }
    }

    if (noemit) {
        return str;
    }


    var level = rec.level;
    for (i = 0; i < this.streams.length; i++) {
        var s = this.streams[i];
        if (s.level <= level) {
            s.stream.write(s.raw ? rec : str);
        }
    }

    return str;
};


/**
 * Build a log emitter function for level minLevel. I.e. this is the
 * creator of `log.info`, `log.error`, etc.
 */
function mkLogEmitter(minLevel) {
    return function () {
        var log = this;

        function mkRecord(args) {
            var excludeFields;
            if (args[0] instanceof Error) {
                // `log.<level>(err, ...)`
                fields = {
                    // Use this Logger's err serializer, if defined.
                    err: (log.serializers && log.serializers.err ? log.serializers.err(args[0]) : Logger.stdSerializers.err(args[0]))
                };
                excludeFields = {err: true};
                if (args.length === 1) {
                    msgArgs = [fields.err.message];
                } else {
                    msgArgs = Array.prototype.slice.call(args, 1);
                }
            } else if (typeof (args[0]) !== 'object' && args[0] !== null ||
                Array.isArray(args[0])) {
                // `log.<level>(msg, ...)`
                fields = null;
                msgArgs = Array.prototype.slice.call(args);
            } else {  // `log.<level>(fields, msg, ...)`
                fields = args[0];
                msgArgs = Array.prototype.slice.call(args, 1);
            }

            // Build up the record object.
            var rec = objCopy(log.fields);
            rec.level = minLevel;
            var recFields = (fields ? objCopy(fields) : null);
            if (recFields) {
                if (log.serializers) {
                    log._applySerializers(recFields, excludeFields);
                }
                Object.keys(recFields).forEach(function (k) {
                    rec[k] = recFields[k];
                });
            }
            rec.levelName = nameFromLevel[minLevel];
            rec.msg = format.apply(log, msgArgs);
            if (!rec.time) {
                rec.time = (new Date());
            }
            // Get call source info
            if (log.src && !rec.src) {
                rec.src = getCaller3Info();
            }
            rec.v = LOG_VERSION;

            return rec;
        }

        var fields = null;
        var msgArgs = arguments;
        var rec = null;
        if (!this._emit) {
            /*
             * Show this invalid Bunyan usage warning *once*.
             *
             * See <https://github.com/trentm/node-bunyan/issues/100> for
             * an example of how this can happen.
             */
            var dedupKey = 'unbound';
            if (!_haveWarned[dedupKey]) {
                var caller = getCaller3Info();
                _warn(format('bunyan usage error: %s:%s: attempt to log with an unbound log method: `this` is: %s',
                        caller.file, caller.line, this.toString()),
                    dedupKey);
            }
            return;
        } else if (arguments.length === 0) {   // `log.<level>()`
            return (this._level <= minLevel);
        } else if (this._level > minLevel) {
            /* pass through */
        } else {
            rec = mkRecord(msgArgs);
            this._emit(rec);
        }
    };
}


/**
 * The functions below log a record at a specific level.
 *
 * Usages:
 *    log.<level>()  -> boolean is-trace-enabled
 *    log.<level>(<Error> err, [<string> msg, ...])
 *    log.<level>(<string> msg, ...)
 *    log.<level>(<object> fields, <string> msg, ...)
 *
 * where <level> is the lowercase version of the log level. E.g.:
 *
 *    log.info()
 *
 * @params fields {Object} Optional set of additional fields to log.
 * @params msg {String} Log message. This can be followed by additional
 *    arguments that are handled like
 *    [util.format](http://nodejs.org/docs/latest/api/all.html#util.format).
 */
Logger.prototype.trace = mkLogEmitter(TRACE);
Logger.prototype.debug = mkLogEmitter(DEBUG);
Logger.prototype.info = mkLogEmitter(INFO);
Logger.prototype.warn = mkLogEmitter(WARN);
Logger.prototype.error = mkLogEmitter(ERROR);
Logger.prototype.fatal = mkLogEmitter(FATAL);


//---- Standard serializers
// A serializer is a function that serializes a JavaScript object to a
// JSON representation for logging. There is a standard set of presumed
// interesting objects in node.js-land.

Logger.stdSerializers = {};

/*
 * This function dumps long stack traces for exceptions having a cause()
 * method. The error classes from
 * [verror](https://github.com/davepacheco/node-verror) and
 * [restify v2.0](https://github.com/mcavage/node-restify) are examples.
 *
 * Based on `dumpException` in
 * https://github.com/davepacheco/node-extsprintf/blob/master/lib/extsprintf.js
 */
function getFullErrorStack(ex) {
    var ret = ex.stack || ex.toString();
    if (ex.cause && typeof (ex.cause) === 'function') {
        var cex = ex.cause();
        if (cex) {
            ret += '\nCaused by: ' + getFullErrorStack(cex);
        }
    }
    return (ret);
}

// Serialize an Error object
// (Core error properties are enumerable in node 0.4, not in 0.6).
Logger.stdSerializers.err = function(err) {
    if (!err || !err.stack) {
        return err;
    }

    var obj = {
        message: err.message,
        name: err.name,
        stack: getFullErrorStack(err),
        code: err.code,
        signal: err.signal
    };
    return obj;
};


// A JSON stringifier that handles cycles safely.
// Usage: JSON.stringify(obj, safeCycles())
function safeCycles() {
    var seen = [];
    return function (key, val) {
        if (!val || typeof (val) !== 'object') {
            return val;
        }
        if (seen.indexOf(val) !== -1) {
            return '[Circular]';
        }
        seen.push(val);
        return val;
    };
}

//---- Exports

module.exports = Logger;

module.exports.TRACE = TRACE;
module.exports.DEBUG = DEBUG;
module.exports.INFO = INFO;
module.exports.WARN = WARN;
module.exports.ERROR = ERROR;
module.exports.FATAL = FATAL;
module.exports.resolveLevel = resolveLevel;
module.exports.levelFromName = levelFromName;
module.exports.nameFromLevel = nameFromLevel;

module.exports.VERSION = VERSION;
module.exports.LOG_VERSION = LOG_VERSION;

module.exports.createLogger = function createLogger(options) {
    return new Logger(options);
};

// Useful for custom `type == 'raw'` streams that may do JSON stringification
// of log records themselves. Usage:
//    var str = JSON.stringify(rec, bunyan.safeCycles());
module.exports.safeCycles = safeCycles;

//streams
module.exports.ConsoleFormattedStream = ConsoleFormattedStream;
module.exports.ConsoleRawStream = ConsoleRawStream;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(2);


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "RTCConferenceParticipant", function() { return /* reexport */ participant; });
__webpack_require__.d(__webpack_exports__, "Red5ProSubscriber", function() { return /* binding */ js_Red5ProSubscriber; });
__webpack_require__.d(__webpack_exports__, "RTCSubscriber", function() { return /* binding */ js_RTCSubscriber; });
__webpack_require__.d(__webpack_exports__, "WHEPClient", function() { return /* binding */ js_WHEPClient; });
__webpack_require__.d(__webpack_exports__, "RTMPSubscriber", function() { return /* binding */ js_RTMPSubscriber; });
__webpack_require__.d(__webpack_exports__, "HLSSubscriber", function() { return /* binding */ js_HLSSubscriber; });
__webpack_require__.d(__webpack_exports__, "PlaybackView", function() { return /* reexport */ playback; });
__webpack_require__.d(__webpack_exports__, "Red5ProPublisher", function() { return /* binding */ js_Red5ProPublisher; });
__webpack_require__.d(__webpack_exports__, "RTCPublisher", function() { return /* binding */ js_RTCPublisher; });
__webpack_require__.d(__webpack_exports__, "WHIPClient", function() { return /* binding */ js_WHIPClient; });
__webpack_require__.d(__webpack_exports__, "RTMPPublisher", function() { return /* binding */ js_RTMPPublisher; });
__webpack_require__.d(__webpack_exports__, "PublisherView", function() { return /* reexport */ view_publish; });
__webpack_require__.d(__webpack_exports__, "PlaybackControls", function() { return /* reexport */ PlaybackControls; });
__webpack_require__.d(__webpack_exports__, "Red5ProSharedObject", function() { return /* binding */ js_Red5ProSharedObject; });
__webpack_require__.d(__webpack_exports__, "Red5ProSharedObjectSocket", function() { return /* binding */ js_Red5ProSharedObjectSocket; });
__webpack_require__.d(__webpack_exports__, "Red5ProSharedObjectPeerConnection", function() { return /* binding */ js_Red5ProSharedObjectPeerConnection; });
__webpack_require__.d(__webpack_exports__, "PublisherEventTypes", function() { return /* binding */ js_PublisherEventTypes; });
__webpack_require__.d(__webpack_exports__, "RTCPublisherEventTypes", function() { return /* binding */ js_RTCPublisherEventTypes; });
__webpack_require__.d(__webpack_exports__, "FailoverPublisherEventTypes", function() { return /* binding */ js_FailoverPublisherEventTypes; });
__webpack_require__.d(__webpack_exports__, "SubscriberEventTypes", function() { return /* binding */ js_SubscriberEventTypes; });
__webpack_require__.d(__webpack_exports__, "RTCSubscriberEventTypes", function() { return /* binding */ js_RTCSubscriberEventTypes; });
__webpack_require__.d(__webpack_exports__, "RTMPSubscriberEventTypes", function() { return /* binding */ js_RTMPSubscriberEventTypes; });
__webpack_require__.d(__webpack_exports__, "FailoverSubscriberEventTypes", function() { return /* binding */ js_FailoverSubscriberEventTypes; });
__webpack_require__.d(__webpack_exports__, "SharedObjectEventTypes", function() { return /* binding */ js_SharedObjectEventTypes; });
__webpack_require__.d(__webpack_exports__, "MessageTransportStateEventTypes", function() { return /* binding */ js_MessageTransportStateEventTypes; });
__webpack_require__.d(__webpack_exports__, "RTCConferenceParticipantEventType", function() { return /* binding */ RTCConferenceParticipantEventType; });
__webpack_require__.d(__webpack_exports__, "PlaybackAudioEncoder", function() { return /* binding */ js_PlaybackAudioEncoder; });
__webpack_require__.d(__webpack_exports__, "PlaybackVideoEncoder", function() { return /* binding */ js_PlaybackVideoEncoder; });
__webpack_require__.d(__webpack_exports__, "IceTransportTypes", function() { return /* binding */ js_IceTransportTypes; });
__webpack_require__.d(__webpack_exports__, "setLogLevel", function() { return /* binding */ js_setLogLevel; });
__webpack_require__.d(__webpack_exports__, "getRecordedLogs", function() { return /* reexport */ getRecordedLogs; });
__webpack_require__.d(__webpack_exports__, "LOG_LEVELS", function() { return /* binding */ LOG_LEVELS; });
__webpack_require__.d(__webpack_exports__, "getLogger", function() { return /* binding */ js_getLogger; });

// EXTERNAL MODULE: ./node_modules/browser-bunyan/lib/bunyan.js
var bunyan = __webpack_require__(0);

// CONCATENATED MODULE: ./src/js/log/bunyan-writer.js


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }


/**
 * Custom logger for bunyon.
 *
 * @private
 */
var bunyan_writer_RawStream = /*#__PURE__*/function () {
  function RawStream() {
    _classCallCheck(this, RawStream);
  }
  _createClass(RawStream, [{
    key: "write",
    value: function write(rec) {
      console.log('%s - [%s] %s: %s',
      // eslint-disable-line no-console
      rec.time.toISOString(), rec.name, bunyan["nameFromLevel"][rec.level], rec.msg);
    }
  }]);
  return RawStream;
}();
// CONCATENATED MODULE: ./src/js/log/index.js




var logger;
var store;
var formatMessage = function formatMessage(dispatcher) {
  return function (message) {
    return "(".concat(dispatcher, ") ").concat(message);
  };
};
var log_decorate = function decorate(level) {
  return function (source, message) {
    logger[level](formatMessage(source)(message));
  };
};

/*
 * The log levels supported.
 */
var LEVELS = {
  TRACE: 'trace',
  INFO: 'info',
  DEBUG: 'debug',
  WARN: 'warn',
  ERROR: 'error',
  FATAL: 'fatal'
};

/**
 * Establish logger to use at level.
 *
 * @param {String} level
 *        The level type from `LEVELS`.
 * @param {Array} streamList
 *        The streamList to use in creating bunyon-based logger.
 *
 * @private
 */
var log_establishLogger = function establishLogger(level) {
  var record = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var streamList = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  var streams = [];
  streams.push({
    level: level,
    stream: new bunyan_writer_RawStream(),
    type: 'raw'
  });
  if (streamList) {
    var list = streamList.map(function (item) {
      item.level = level;
    });
    streams = streams.concat(list);
  }
  if (record) {
    store = [];
    streams.push({
      level: level,
      stream: {
        write: function write(rec) {
          var log = "[".concat(rec.time.toISOString(), "] ").concat(bunyan["nameFromLevel"][rec.level], ": ").concat(rec.msg);
          store.push(log);
        }
      }
    });
  }
  logger = Object(bunyan["createLogger"])({
    level: level,
    name: 'red5pro-sdk',
    streams: streams
  });
};

/**
 * Return the determined logger instance.
 *
 * @return {Object}
 *
 * @private
 */
var getLogger = function getLogger() {
  return logger;
};

/**
 * Returns the stored logs if requested to `record` on establishment of logger.
 *
 * @return {Array}
 */
var getRecordedLogs = function getRecordedLogs() {
  return store;
};

/* Quick access to logger level types. */
var trace = log_decorate(LEVELS.TRACE);
var info = log_decorate(LEVELS.INFO);
var log_debug = log_decorate(LEVELS.DEBUG);
var log_warn = log_decorate(LEVELS.WARN);
var log_error = log_decorate(LEVELS.ERROR);
var log_fatal = log_decorate(LEVELS.FATAL);
// CONCATENATED MODULE: ./src/js/util/promise.js


/**
 * A DeferredPromise allows for construction and assignment of a future fullfilment of a `Promise`.
 *
 * @private
 */
function promise_typeof(obj) { "@babel/helpers - typeof"; return promise_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, promise_typeof(obj); }
function promise_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, promise_toPropertyKey(descriptor.key), descriptor); } }
function promise_createClass(Constructor, protoProps, staticProps) { if (protoProps) promise_defineProperties(Constructor.prototype, protoProps); if (staticProps) promise_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function promise_toPropertyKey(arg) { var key = promise_toPrimitive(arg, "string"); return promise_typeof(key) === "symbol" ? key : String(key); }
function promise_toPrimitive(input, hint) { if (promise_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (promise_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function promise_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
var _DeferredPromise = /*#__PURE__*/promise_createClass(function _DeferredPromise() {
  var _this = this;
  promise_classCallCheck(this, _DeferredPromise);
  this.resolve = undefined;
  this.reject = undefined;
  this.promise = new Promise(function (resolve, reject) {
    _this.resolve = resolve;
    _this.reject = reject;
  });
});
/**
 * A Future determines if existant DeferredPromise is available or creates and returns a new one.
 *
 * @param {DeferredPromise} deferredIfExist
 *        An object tested for truthy-ness.
 * @return {DeferredPromise}
 *
 * @private
 */
var _Future = {
  createIfNotExist: function createIfNotExist(deferredIfExist) {
    var f = deferredIfExist;
    if (!f) {
      f = new _DeferredPromise();
    }
    return f;
  }
};
var DeferredPromise = _DeferredPromise;
var Future = _Future;
// CONCATENATED MODULE: ./src/js/util/impl-factory-order.js


function impl_factory_order_typeof(obj) { "@babel/helpers - typeof"; return impl_factory_order_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, impl_factory_order_typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == impl_factory_order_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function impl_factory_order_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function impl_factory_order_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, impl_factory_order_toPropertyKey(descriptor.key), descriptor); } }
function impl_factory_order_createClass(Constructor, protoProps, staticProps) { if (protoProps) impl_factory_order_defineProperties(Constructor.prototype, protoProps); if (staticProps) impl_factory_order_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function impl_factory_order_toPropertyKey(arg) { var key = impl_factory_order_toPrimitive(arg, "string"); return impl_factory_order_typeof(key) === "symbol" ? key : String(key); }
function impl_factory_order_toPrimitive(input, hint) { if (impl_factory_order_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (impl_factory_order_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

var impl_factory_order_map = new WeakMap();
var pvt = function pvt(ctx) {
  if (!impl_factory_order_map.has(ctx)) {
    impl_factory_order_map.set(ctx, {});
  }
  return impl_factory_order_map.get(ctx);
};

/**
 * Implementation Factory.
 *
 * This is used by the fail-over for Publisher and Subscriber to determine browser support of order list of implementations.
 *
 * @private
 */
var impl_factory_order_ImplFactoryOrder = /*#__PURE__*/function () {
  function ImplFactoryOrder() {
    var _this = this;
    impl_factory_order_classCallCheck(this, ImplFactoryOrder);
    this.listorder = function () {
      return /*#__PURE__*/_regeneratorRuntime().mark(function listorder(list) {
        return _regeneratorRuntime().wrap(function listorder$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(list.length > 0)) {
                _context.next = 5;
                break;
              }
              _context.next = 3;
              return list.shift();
            case 3:
              _context.next = 0;
              break;
            case 5:
            case "end":
              return _context.stop();
          }
        }, listorder);
      });
    }();

    /**
     * Attempt to check support and initialize Class instance within the order. Optionally, can invoke an initialization with configuration object.
     *
     * @param {Object} iterator
     *        Iterator used in accessing possible Class instance next in linked list of order.
     * @param {Object} map
     *        Map of order type to Class.
     * @param {Object} options
     *        Map of initialization configurations to types.
     * @param {Promise} promise
     *        The `Promise` instance to use in resolve or reject once either a valid instance is created or order has been exhausted, respectively.
     * @param {Function} initFn
     *        Optional function to invoke upon instantiation attempt.
     * @param {String} lastError
     *        Optional - and compounded - last string error that caused a failure in establishing a supported instance. This error is delivered on the rejection of the `Promise`.
     *
     * @private
     */
    pvt(this).find = function (iterator, map, options, promise) {
      var initFn = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var lastError = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
      var _pvt$next = pvt(_this).next(iterator, map),
        _pvt$next2 = _slicedToArray(_pvt$next, 2),
        type = _pvt$next2[0],
        Impl = _pvt$next2[1];
      if (!Impl) {
        promise.reject(lastError);
      } else {
        var p;
        var src = options[type];
        src = src || options;
        if (initFn) {
          p = new Impl()[initFn](src);
        } else {
          p = new Impl(src);
        }
        p.then(function (concrete) {
          promise.resolve(concrete);
        }).catch(function (error) {
          // eslint-disable-line no-unused-vars
          lastError = error;
          pvt(_this).find(iterator, map, options, promise, initFn, lastError);
        });
      }
    };

    /**
     * Iterate next in order.
     *
     * @private
     */
    pvt(this).next = function (order, map) {
      var Impl;
      var key;
      var next = order.next();
      if (!next.done) {
        key = next.value;
        Impl = map.get(key);
      }
      return [key, Impl];
    };
  }

  /**
   * Request to locate supported implementation and initialize it, resolving the `Promise` with the instance.
   *
   * @param {Array} order
   * @param {Object} map
   *        Map of Class to order type.
   * @param {Object} options
   *        Initialization object to pass to constructor of Class in browser test of support.
   * @param {Function} initFn
   *        Optional initialization function to invoke with the `options` config.
   *
   * @private
   */
  impl_factory_order_createClass(ImplFactoryOrder, [{
    key: "create",
    value: function create(order, map, options) {
      var initFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var promise = new DeferredPromise();
      pvt(this).find(this.listorder(order.slice()), map, options, promise, initFn);
      return promise.promise;
    }
  }]);
  return ImplFactoryOrder;
}();
/* harmony default export */ var impl_factory_order = (impl_factory_order_ImplFactoryOrder);
// CONCATENATED MODULE: ./src/js/core/event-emitter.js
function event_emitter_typeof(obj) { "@babel/helpers - typeof"; return event_emitter_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, event_emitter_typeof(obj); }
function event_emitter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function event_emitter_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, event_emitter_toPropertyKey(descriptor.key), descriptor); } }
function event_emitter_createClass(Constructor, protoProps, staticProps) { if (protoProps) event_emitter_defineProperties(Constructor.prototype, protoProps); if (staticProps) event_emitter_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function event_emitter_toPropertyKey(arg) { var key = event_emitter_toPrimitive(arg, "string"); return event_emitter_typeof(key) === "symbol" ? key : String(key); }
function event_emitter_toPrimitive(input, hint) { if (event_emitter_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (event_emitter_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var WILDCARD = '*';
var WILDCARD_KEY = 'RED5PRO';

/**
 * Base class for an Event Emitter.
 */
var EventEmitter = /*#__PURE__*/function () {
  function EventEmitter() {
    event_emitter_classCallCheck(this, EventEmitter);
    this._callbacks = {};
    this._callbacks[WILDCARD_KEY] = [];
  }

  /**
   * Invokes event handlers.
   *
   * @param {Array} callbacks
   * @param {Event} event
   *
   * @private
   */
  event_emitter_createClass(EventEmitter, [{
    key: "_notify",
    value: function _notify(callbacks, event) {
      var i,
        length = callbacks.length;
      for (i = 0; i < length; i++) {
        callbacks[i](event);
      }
    }

    /**
     * Assign a callback handler to an event type.
     *
     * @param {String} type
     * @param {Function} fn
     */
  }, {
    key: "on",
    value: function on(type, fn) {
      if (typeof fn !== 'function') {
        return;
      }
      if (type === WILDCARD) {
        this._callbacks[WILDCARD_KEY].push(fn);
        return;
      }
      if (this._callbacks[type] === undefined) {
        this._callbacks[type] = [];
      }
      if (this._callbacks[type].indexOf(fn) === -1) {
        this._callbacks[type].push(fn);
      }
    }

    /**
     * Remove a callback handler for an event type.
     *
     * @param {String} type
     * @param {Function} fn
     */
  }, {
    key: "off",
    value: function off(type, fn) {
      var map = this._callbacks[type];
      if (type === WILDCARD) {
        map = this._callbacks[WILDCARD_KEY];
      }
      if (map) {
        var index = map.indexOf(fn);
        if (index !== -1) {
          map.splice(index, 1);
        }
      }
    }

    /**
     * Dispatch an event to be handled by any assigned callbacks.
     *
     * @param {Event} event
     */
  }, {
    key: "trigger",
    value: function trigger(event) {
      var type = event.type;
      if (this._callbacks[type]) {
        this._notify(this._callbacks[type], event);
      }
      this._notify(this._callbacks[WILDCARD_KEY], event);
    }
  }]);
  return EventEmitter;
}();
/* harmony default export */ var event_emitter = (EventEmitter);
// CONCATENATED MODULE: ./src/js/exception/errors.js


/**
 * Exception for missing element when assigning Presentation Controllers for Publishers and Subscribers.
 */
function errors_typeof(obj) { "@babel/helpers - typeof"; return errors_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, errors_typeof(obj); }
function errors_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, errors_toPropertyKey(descriptor.key), descriptor); } }
function errors_createClass(Constructor, protoProps, staticProps) { if (protoProps) errors_defineProperties(Constructor.prototype, protoProps); if (staticProps) errors_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function errors_toPropertyKey(arg) { var key = errors_toPrimitive(arg, "string"); return errors_typeof(key) === "symbol" ? key : String(key); }
function errors_toPrimitive(input, hint) { if (errors_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (errors_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function errors_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
var NoElementFoundError = /*#__PURE__*/errors_createClass(function NoElementFoundError(message) {
  errors_classCallCheck(this, NoElementFoundError);
  this.name = 'NoElementFound';
  this.message = message;
});

/**
 * Exception when requesting media with a `MediaConstraint` that the browser cannot support.
 * WebRTC Only.
 */
var NoSupportedCameraResolutionsError = /*#__PURE__*/errors_createClass(function NoSupportedCameraResolutionsError(message) {
  errors_classCallCheck(this, NoSupportedCameraResolutionsError);
  this.name = 'NoSupportedCameraResolutionsError';
  this.message = message;
});
// CONCATENATED MODULE: ./src/js/env/metadata-util.js


var metadata_util_this = undefined;
var jsonAttr = /['"](.*?)['"]:/gi;
var jsonVal = /:['"](.*?)['"]/gi;
var metadataMap = new WeakMap(); // {<player>: {<property>: fn[]} }

/**
 * Reads the UTF string of the data passed in.
 *
 * @param {String} data
 * @param {Number} start
 * @param {Number} len
 *
 * @return {String}
 *         The Parsed information.
 *
 * @private
 */
function readUTF(data, start, len) {
  var result = '',
    offset = start,
    end = start + len;
  do {
    result += String.fromCharCode(data[offset++]);
  } while (offset < end);
  return result;
}

/**
 * Parses incoming metadata JSON data and returns property if available.
 *
 * @param {String} test
 *        The JSON string to parse.
 *
 * @param {String} property
 *        The property name to access from the parsed JSON.
 *
 * @private
 */
function parseJSONForProperty(text, property) {
  try {
    var value = JSON.parse(text);
    return value[property];
  } catch (e) {
    var match = jsonAttr.exec(text);
    var match2;
    if (match && match.length > 1) {
      match2 = jsonVal.exec(text);
      if (match[1] === property && match2 && match2.length > 1) {
        return match2[1];
      }
    }
    return undefined;
  }
}

/**
 * Parses and interprets the orientation data from passed in JSON string.
 *
 * @param {String} text
 *
 * @return {Object}
 *          The parsed object with an `orientation` property if parsed properly.
 *
 * @private
 */
function parseJSONForOrientation(text) {
  var orientation = parseJSONForProperty(text, 'orientation');
  if (orientation) {
    return {
      orientation: parseInt(orientation)
    };
  }
  return undefined;
}
function parseJSONForStreamingMode(text) {
  var streamingMode = parseJSONForProperty(text, 'streamingMode');
  if (streamingMode) {
    return {
      streamingMode: streamingMode
    };
  }
  return undefined;
}
var getMetadataMapForPlayer = function getMetadataMapForPlayer(player) {
  return metadataMap.get(player);
};
var enableMetadataMonitor = function enableMetadataMonitor(player) {
  var textTracks = typeof player.textTracks === 'function' ? player.textTracks() : player.textTracks;
  if (textTracks) {
    player.addTextTrack('metadata');
    textTracks.addEventListener('addtrack', function (addTrackEvent) {
      var track = addTrackEvent.track;
      track.mode = 'hidden';
      track.addEventListener('cuechange', function (cueChangeEvent) {
        var cues;
        var i;
        // Mostly Chrome.
        if (cueChangeEvent && cueChangeEvent.currentTarget) {
          cues = cueChangeEvent.currentTarget.cues;
        } else if (undefined === metadata_util_this) {
          cues = track.cues;
          cues = cues && cues.length > 0 ? cues : track.activeCues;
        } else if (undefined !== metadata_util_this) {
          // Mostly Firefox & Safari.
          cues = cues && cues.length > 0 ? cues : metadata_util_this.activeCues;
        }
        // Mostly failure.
        cues = cues || [];
        var _loop = function _loop() {
          var data = cues[i];
          if (data.value) {
            var text = typeof data.value.data === 'string' ? data.value.data : readUTF(data.value.data, 0, data.size);
            var orientation = parseJSONForOrientation(text);
            var streamingMode = parseJSONForStreamingMode(text);
            var map = getMetadataMapForPlayer(player);
            if (orientation && map && map.orientation) {
              map.orientation.forEach(function (fn) {
                fn(orientation);
              });
            }
            if (streamingMode && map && map.streamingMode) {
              map.streamingMode.forEach(function (fn) {
                fn(streamingMode);
              });
            }
          }
        };
        for (i = 0; i < cues.length; i++) {
          _loop();
        }
      });
    });
  }
};

/**
 * Event handler for metadata related to orientation information.
 *
 * @param {Element} player
 *        The media element related to the metadata.
 * @param {Function} callback
 *        The callback to invoke with the parsed orientation information.
 *
 * @private
 */
var onOrientationMetadata = function onOrientationMetadata(player, callback) {
  var map = metadataMap.get(player);
  if (!metadataMap.has(player)) {
    enableMetadataMonitor(player);
    metadataMap.set(player, {
      orientation: []
    });
  } else if (!map.hasOwnProperty('orientation')) {
    metadataMap.get(player).orientation = [];
  }
  metadataMap.get(player).orientation.push(callback);
};

/**
 * Event handler for metadata related to streamingMode information.
 *
 * @param {Element} player
 *        The media element related to the metadata.
 * @param {Function} callback
 *        The callback to invoke with the parsed streamingMode information.
 *
 * @private
 */
var onStreamingModeMetadata = function onStreamingModeMetadata(player, callback) {
  var map = metadataMap.get(player);
  if (!metadataMap.has(player)) {
    enableMetadataMonitor(player);
    metadataMap.set(player, {
      streamingMode: []
    });
  } else if (!map.hasOwnProperty('streamingMode')) {
    metadataMap.get(player).streamingMode = [];
  }
  metadataMap.get(player).streamingMode.push(callback);
};

/**
 * Request to remove reference to player form metadata delegate mapping.
 *
 * @private
 */
var removePlayerDelegates = function removePlayerDelegates(player) {
  if (metadataMap.has(player)) {
    metadataMap.delete(player);
  }
};
// CONCATENATED MODULE: ./src/js/env/browser.js
function browser_typeof(obj) { "@babel/helpers - typeof"; return browser_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, browser_typeof(obj); }




var rtmpSubscriberAssignments = [];

/* Properties and methods related to interaction with the screenfull.js library. */
var fullscreenHandlers = [];
var screenfullHandlerAssigned = false;
function enableScreenfullHandler() {
  if (!screenfullHandlerAssigned && window.screenfull && window.screenfull.enabled) {
    screenfullHandlerAssigned = true;
    window.screenfull.onchange(function () {
      var i,
        length = fullscreenHandlers.length;
      for (i = 0; i < length; i++) {
        fullscreenHandlers[i](window.screenfull.isFullscreen);
      }
    });
  }
}

/* Properties and methods related to device browser orientation change. */
var orientationHandlers = [];
function onorientationchange(event) {
  // eslint-disable-line no-unused-vars
  var screenOrientation = screen.orientation ? screen.orientation.angle : undefined;
  var orientationValue = typeof screenOrientation === 'undefined' ? window.matchMedia("(orientation: portrait)").matches ? 0 : 90 : screenOrientation;
  var i,
    length = orientationHandlers.length;
  log_debug("[window:onorientationchange]", "orientation(".concat(orientationValue, ")."));
  for (i = 0; i < length; i++) {
    orientationHandlers[i]((orientationValue + 90) % 360);
  }
}

/* Properies and methods related to window close operation. */
var closeHandlers = [];
var hasOnWindowClose = false;
function onwindowclose(e) {
  // eslint-disable-line no-unused-vars
  //  closeHandlers.forEach(h => h())
  var i,
    length = closeHandlers.length;
  for (i = 0; i < length; i++) {
    closeHandlers[i]();
  }
  hasOnWindowClose = true;
  // Returning a string value forces a leaving confirmation popup on the browser.
  //  e.returnValue = 'goodbye'
  //  return 'goodbye'
}

/* Check to see what the current flash version is, if plugin is enabled. */
// https://github.com/videojs/video.js/blob/master/src/js/tech/flash.js#L476
var flashVersion = function flashVersion() {
  var version = '0,0,0';
  // IE
  try {
    version = new window.ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];

    // other browsers
  } catch (e) {
    try {
      if (navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin) {
        version = (navigator.plugins['Shockwave Flash 2.0'] || navigator.plugins['Shockwave Flash']).description.replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
      }
    } catch (err) {
      // nada
    }
  }
  return version.split(',');
};

/* Shim for `requestAnimationFrame` of browser. */
var requestFrame = function (time) {
  return window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function (fn) {
    return window.setTimeout(fn, time);
  };
}(1000);
var hasAdapterShim = window.adapter;

/* Browser test to see if Mozilla-based. */
var isMoz = !!navigator.mozGetUserMedia;

/* Browser test to see if Edge-based. */
var isIE =  false || !!document.documentMode;
var isEdge = hasAdapterShim ? window.adapter.browserDetails.browser.toLowerCase() === 'edge' : !isIE && !!window.StyleMedia;

/* Determine if current browser has touch capabilities. */
var _isTouchEnabled = 'ontouchstart' in window || window.DocumentTouch && window.document instanceof window.DocumentTouch;

// If developer has not used adapter.js.
if (!hasAdapterShim) {
  navigator.getUserMedia = navigator.mediaDevices && navigator.mediaDevices.getUserMedia || navigator.getUserMedia || navigator.mozGetUserMedia || navigator.webkitGetUserMedia || navigator.msGetUserMedia;
}

/* Proxy to browser-based, specific functions. */
/* harmony default export */ var browser = ({
  requestFrame: requestFrame,
  getIsMoz: function getIsMoz() {
    return isMoz;
  },
  getIsEdge: function getIsEdge() {
    return isEdge;
  },
  isTouchEnabled: function isTouchEnabled() {
    return _isTouchEnabled;
  },
  supportsWebSocket: function supportsWebSocket() {
    return !!window.WebSocket;
  },
  supportsHLS: function supportsHLS() {
    var el = document.createElement('video');
    return el.canPlayType('application/vnd.apple.mpegURL').length > 0 || el.canPlayType('application/x-mpegURL').length > 0 || el.canPlayType('audio/mpegurl').length > 0 || el.canPlayType('audio/x-mpegurl').length > 0;
  },
  supportsNonNativeHLS: function supportsNonNativeHLS() {
    // hls.js
    return !!window.Hls && window.Hls.isSupported();
  },
  createHLSClient: function createHLSClient() {
    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return new window.Hls(opt);
  },
  getHLSClientEventEnum: function getHLSClientEventEnum() {
    return window.Hls.Events;
  },
  supportsFlashVersion: function supportsFlashVersion(version) {
    var delimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '.';
    return flashVersion()[0] >= version.split(delimiter)[0];
  },
  resolveElement: function resolveElement(id) {
    try {
      var el = document.getElementById(id);
      if (!el) {
        throw new NoElementFoundError("Element with id(".concat(id, ") could not be found."));
      }
      return el;
    } catch (e) {
      throw new NoElementFoundError("Error in accessing element with id(".concat(id, "). ").concat(e.message));
    }
  },
  createWebSocket: function createWebSocket(url) {
    return new WebSocket(url);
  },
  setVideoSource: function setVideoSource(videoElement, mediaStream) {
    var autoplay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    try {
      videoElement.srcObject = mediaStream;
    } catch (e) {
      log_warn('[setVideoSource:obj]', "Could not set srcObject: ".concat(e.message));
      if (isMoz) {
        videoElement['mozSrcObject'] = mediaStream;
      } else {
        videoElement.src = window.URL.createObjectURL(mediaStream);
      }
    }
    if (autoplay) {
      try {
        var maybePromise = videoElement.play();
        if (maybePromise) {
          maybePromise.then(function () {
            return log_debug('[setVideoSource:action]', 'play (START)');
          }).catch(function (err) {
            return log_warn('[setVideoSource:action]', 'play (FAULT) ' + (err.message ? err.message : err));
          });
        }
      } catch (e) {
        // Mobile Browsers: Uncaught (in promise) DOMException: play() can only be initiated by a user gesture.
        log_warn('[setVideoSource:action]', 'play (CATCH::FAULT) ' + e.message);
        try {
          videoElement.setAttribute('autoplay', false);
          videoElement.pause();
        } catch (err) {
          log_warn('[setVideoSource:action]', 'pause (CATCH::FAULT) ' + err.message);
        }
      }
    } else {
      try {
        videoElement.setAttribute('autoplay', false);
        videoElement.pause();
      } catch (e) {
        // nada.
      }
    }
  },
  injectScript: function injectScript(url) {
    var dfd = new DeferredPromise();
    var script = document.createElement('script');
    script.type = 'text/javascript';
    script.onload = function () {
      dfd.resolve();
    };
    script.onreadystatechange = function () {
      if (script.readyState === 'loaded' || script.readyState === 'complete') {
        script.onreadystatechange = null;
        dfd.resolve();
      }
    };
    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
    return dfd.promise;
  },
  gUM: function gUM(constraints) {
    return (navigator.mediaDevices || navigator).getUserMedia(constraints);
  },
  setGlobal: function setGlobal(prop, value) {
    window[prop] = value;
  },
  getSwfObject: function getSwfObject() {
    return window.swfobject;
  },
  getEmbedObject: function getEmbedObject(id) {
    return document.getElementById(id);
  },
  getElementId: function getElementId(el) {
    return el.getAttribute('id');
  },
  addOrientationChangeHandler: function addOrientationChangeHandler(handler) {
    var andCall = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var supportsOrientationChange = ('onorientationchange' in window);
    if (supportsOrientationChange) {
      log_debug('[window:orientation]', '[addOrientationChangeHandler]', 'adding responder.');
      orientationHandlers.push(handler);
      if (andCall) {
        onorientationchange();
      }
    }
    if (orientationHandlers.length === 1) {
      log_debug('[window:orientation]', '[addOrientationChangeHandler]', 'onorientationchange added.');
      window.addEventListener('orientationchange', onorientationchange);
    }
  },
  removeOrientationChangeHandler: function removeOrientationChangeHandler(handler) {
    var i = orientationHandlers.length;
    while (--i > -1) {
      if (orientationHandlers[i] === handler) {
        orientationHandlers.slice(i, 1);
        break;
      }
    }
    if (orientationHandlers.length === 0) {
      log_debug('[window:orientation]', '[removeOrientationChangeHandler]:: onorientationchange removed.');
      window.removeEventListener('onorientationchange', onorientationchange);
    }
  },
  addCloseHandler: function addCloseHandler(handler) {
    var insertValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    closeHandlers.splice(insertValue === -1 ? closeHandlers.length : insertValue, 0, handler);
    // NOTE: Removed onbeforeunload in favor of developers properly handling shutdown.
    //    if (window.onbeforeunload !== onwindowclose) {
    // window.onbeforeunload = onwindowclose
    if (!hasOnWindowClose) {
      window.addEventListener('unload', onwindowclose);
    }
    // }
  },

  removeCloseHandler: function removeCloseHandler(handler) {
    var i = closeHandlers.length;
    while (--i > -1) {
      if (closeHandlers[i] === handler) {
        closeHandlers.slice(i, 1);
        break;
      }
    }
  },
  invoke: function invoke(methodName, data) {
    if (window.hasOwnProperty(methodName)) {
      window[methodName].call(window, data);
    }
  },
  // requires <script src="lib/screenfull/screenfull.min.js"></script>
  toggleFullScreen: function toggleFullScreen(element) {
    if (window.screenfull && window.screenfull.enabled) {
      window.screenfull.toggle(element);
    }
  },
  onFullScreenStateChange: function onFullScreenStateChange(cb) {
    fullscreenHandlers.push(cb);
    enableScreenfullHandler(window.screenfull);
  },
  onOrientationMetadata: onOrientationMetadata,
  onStreamingModeMetadata: onStreamingModeMetadata,
  hasAttributeDefined: function hasAttributeDefined(elem, attribute) {
    var att = elem.getAttribute(attribute);
    return att !== null && browser_typeof(att) !== undefined && typeof att === 'string' && (att === '' || att === 'true' || att === attribute);
  },
  hasClassDefined: function hasClassDefined(elem, className) {
    return elem.classList.contains(className);
  },
  createElement: function createElement(tagName, opts) {
    if (tagName === 'text') {
      return document.createTextNode(opts.toString());
    }
    return document.createElement(tagName, opts);
  },
  addSubscriptionAssignmentHandler: function addSubscriptionAssignmentHandler(fn) {
    rtmpSubscriberAssignments.push(fn);
    if (window.setSubscriberId === undefined) {
      window.setSubscriberId = function (id) {
        rtmpSubscriberAssignments.shift()(id);
      };
    }
  },
  getMouseXFromEvent: function getMouseXFromEvent(event) {
    if (!event) {
      event = window.event;
    }
    if (event.pageX) {
      return event.pageX;
    } else if (event.clientX) {
      return event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
    }
    return 0;
  },
  getScrollX: function getScrollX() {
    return window.pageXOffset !== undefined ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
  },
  createEvent: function createEvent(EventType) {
    return document.createEvent(EventType);
  },
  getGlobal: function getGlobal() {
    return window;
  }
});
// CONCATENATED MODULE: ./src/js/env/translation-util.js

var translation_util_requestFrame = browser.requestFrame;

/* || Translation Styles used on Orientation-change metadata from Mobile broadcasters. || */
var origin = ['webkitTransformOrigin', 'mozTransformOrigin', 'msTransformOrigin', 'oTransformOrigin', 'transformOrigin'];
var styles = ['webkitTransform', 'mozTransform', 'msTransform', 'oTransform', 'transform'];
var transition = ['webkitTransition', 'mozTransition', 'msTransition', 'oTransition', 'transition'];
var rotationTranslations = {
  '0': {
    origin: 'center center',
    transform: 'rotate(0deg)'
  },
  '90': {
    origin: 'left top',
    transform: 'rotate(90deg) translateY(-100%)'
  },
  '180': {
    origin: 'center center',
    transform: 'rotate(180deg)'
  },
  '270': {
    origin: 'top left',
    transform: 'rotate(270deg) translateX(-100%) translateY(0%)'
  },
  '-90': {
    origin: 'left top',
    transform: 'rotate(-90deg) translateX(-100%)'
  },
  '-180': {
    origin: 'center center',
    transform: 'rotate(-180deg)'
  },
  '-270': {
    origin: 'top left',
    transform: 'rotate(-270deg) translateY(-100%)'
  }
};

/* Utility method to track and resize an element on enter frame. */
var trackResize = function trackResize(element, raf) {
  var isRotated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return function () {
    var parent = element.parentNode;
    if (parent) {
      var pwidth = parent.clientWidth;
      var pheight = parent.clientHeight;
      if (isRotated) {
        element.style.width = pheight + 'px';
      } else {
        element.style.width = pwidth + 'px';
      }
      var ewidth = element.clientWidth;
      var eheight = element.clientHeight;
      var margin = (isRotated ? pwidth - eheight : pwidth - ewidth) * 0.5;
      element.style.position = 'relative';
      element.style.left = margin + 'px';
    }
    if (raf) {
      raf(trackResize(element, raf, isRotated));
    }
  };
};
var applyOrientation = function applyOrientation(element, value, resolution) {
  // eslint-disable-line no-unused-vars
  var i,
    length = styles.length;
  value = value % 360;
  var isRotated = value % 180 !== 0;
  var parent = element.parentNode;
  var pwidth = element.width ? element.width : parent.clientWidth;
  var pheight = element.height ? element.height : parent.clientHeight;
  var translations = rotationTranslations[value.toString()];
  for (i = 0; i < length; i++) {
    element.style[origin[i]] = translations.origin;
    element.style[styles[i]] = translations.transform;
    element.style[transition[i]] = 'transform 0.0s linear';
  }
  if (isRotated) {
    // const scale = pwidth > pheight ? pheight / pwidth : pwidth / pheight
    element.style.width = pheight + 'px';
    parent.style.height = pheight + 'px';
    // element.style.height = (pwidth * scale) + 'px'
  } else {
    element.style.width = pwidth + 'px';
    element.style.height = pheight + 'px';
    parent.style.height = 'unset';
  }
  if (document.attachEvent) {
    parent.attachEvent('resize', trackResize(element, translation_util_requestFrame, isRotated));
  } else {
    trackResize(element, translation_util_requestFrame, isRotated)();
  }
};
// CONCATENATED MODULE: ./src/js/util/index.js


// http://blog.carbonfive.com/2015/01/14/gettin-freaky-functional-wcurried-javascript/
/**
 * Basic curry implementation.
 *
 * @private
 */
var curry = function curry(fx) {
  var arity = fx.length;
  return function f1() {
    var args = Array.prototype.slice.call(arguments, 0);
    if (args.length >= arity) {
      return fx.apply(null, args);
    } else {
      return function f2() {
        var args2 = Array.prototype.slice.call(arguments, 0);
        return f1.apply(null, args.concat(args2));
      };
    }
  };
};

/**
 * Basic filter implementation.
 *
 * @private
 */
var filter = curry(function (fn, list) {
  var idx = 0;
  var len = list.length;
  var result = [];
  while (idx < len) {
    if (fn(list[idx])) {
      result[result.length] = list[idx];
    }
    idx += 1;
  }
  return result;
});

/**
 * Converts a value to integer.
 *
 * @param {Object} value
 * @returns {Number}
 *
 * @private
 */
var toInt = function toInt(value) {
  if (typeof value === 'string') {
    return parseInt(value, 10);
  } else {
    return Math.round(value);
  }
};

/**
 * Checks truthy-ness of `value` and returns default if false.
 *
 * @param {Object} value
 * @param {Object} defaultValue
 *
 * @private
 */
var getOrElse = function getOrElse(value, defaultValue) {
  return value || defaultValue;
};

/**
 * Checks truthy-ness of `value` as a Number and returns default if false.
 *
 * @param {Object} value
 * @param {Object} defaultValue
 *
 * @private
 */
var getIntOrElse = function getIntOrElse(value, defaultValue) {
  return !isNaN(toInt(value)) ? toInt(value) : defaultValue;
};
// CONCATENATED MODULE: ./src/js/util/object.js


/**
 * Deep-defines an `Object` in place with namespaced attribute value.
 *
 * @private
 */
var deepDefine = function deepDefine(object, paths, value) {
  var i = 0;
  var tail = object;
  var prop = paths.pop();
  var length = paths.length;
  for (i; i < length; i++) {
    var path = paths[i];
    tail[path] = tail[path] || {};
    tail = tail[path];
  }
  tail[prop] = value;
};

/**
 * Deep-copy utilizing JSON API.
 *
 * @private
 */
var deepCopy = function deepCopy(obj) {
  var str = JSON.stringify(obj);
  return JSON.parse(str);
};

/**
 * Simple util to parse resolution from metadata.
 *
 * @param {String} value
 *        The resolution value from metadata: e.g, `640,480`.
 * @return {Object}
 *        The structured dimensions Object with `width` and `height` properties.
 *
 * @private
 */
var metadataResolutionToObject = function metadataResolutionToObject(value) {
  if (typeof value === 'string') {
    var dims = value.split(',');
    return {
      width: parseInt(dims[0]),
      height: parseInt(dims[1])
    };
  }
  return value;
};

/**
 * Utility check if providing Object is empty (without any properties.
 *
 * @private
 */
var isObjectEmpty = function isObjectEmpty(obj) {
  return Object.keys(obj).length === 0 && obj.constructor === Object;
};
// CONCATENATED MODULE: ./src/js/adapter/webrtc.js







// import { NoSupportedCameraResolutionsError } from '../exception/errors'

// Resolutions borrowed from https://github.com/webrtcHacks/WebRTC-Camera-Resolution/blob/master/js/resolutionScan.js
var formats = [{
  label: '4K(UHD)',
  width: 3840,
  height: 2160
}, {
  label: '1080p(FHD)',
  width: 1920,
  height: 1080
}, {
  label: 'UXGA',
  width: 1600,
  height: 1200
}, {
  label: '720p(HD)',
  width: 1280,
  height: 720
}, {
  label: 'SVGA',
  width: 800,
  height: 600
}, {
  label: 'VGA',
  width: 640,
  height: 480
}, {
  label: '360p(nHD)',
  width: 640,
  height: 360
}, {
  label: 'CIF',
  width: 352,
  height: 288
}, {
  label: 'QVGA',
  width: 320,
  height: 240
}, {
  label: 'QCIF',
  width: 176,
  height: 144
}, {
  label: 'QQVGA',
  width: 160,
  height: 120
}];

/**
 * Detects if resolutions are defined on the provied constraints.
 *
 * @param {Object} constraints
 *        The Media Constraints to test against.
 * @return {Boolean}
 *
 * @private
 */
var hasResolutionsDefined = function hasResolutionsDefined(constraints) {
  return constraints.hasOwnProperty('video') && (constraints.video.hasOwnProperty('width') || constraints.video.hasOwnProperty('height'));
};

/**
 * Return value on attribute based on failover test of attribute availability on provided object.
 *
 * @param {Object} attribute
 * @return {Object}
 *
 * @private
 */
var getValueFromConstraintAttribute = function getValueFromConstraintAttribute(attribute) {
  return attribute.exact || attribute.ideal || attribute.max || attribute.min || attribute;
};

/**
 * Test if video on Media Constraint is either set to `true` or if the constraints and format objects have the same dimension values.
 *
 * @param {Object} constraints
 * @param {Object} format
 * @return {Boolean}
 *
 * @private
 */
var isExact = curry(function (constraints, format) {
  if (typeof constraints.video === 'boolean') {
    return true;
  }
  var w = constraints.video.hasOwnProperty('width') ? getValueFromConstraintAttribute(constraints.video.width) : 0;
  var h = constraints.video.hasOwnProperty('height') ? getValueFromConstraintAttribute(constraints.video.height) : 0;
  var confirmed = w === format.width && h === format.height;
  if (confirmed) {
    log_debug('[gum:isExact]', "Found matching resolution for ".concat(format.width, ", ").concat(format.height, "."));
  }
  return confirmed;
});

/**
 * Test if the area on the provide format is lower than the area on the Media Constraints.
 * This is used in trying to find the next nearest neighbor of dimensions that the browser supports.
 *
 * @param {Object} constraints
 * @param {Object} format
 * @return {Boolean}
 *
 * @private
 */
var isLower = curry(function (constraints, format) {
  var w = constraints.video.hasOwnProperty('width') ? getValueFromConstraintAttribute(constraints.video.width) : 0;
  var h = constraints.video.hasOwnProperty('height') ? getValueFromConstraintAttribute(constraints.video.height) : 0;
  var desired = w * h;
  var dimensions = format.width * format.height;
  return dimensions < desired;
});

/**
 * Returns filtered of Media Constraint format if matching the canned list of support form `formats`.
 *
 * @param {Array} formatList
 * @param {Object} constraints
 * @return {Array}
 *
 * @private
 */
var hasMatchingFormat = curry(function (formatsList, constraints) {
  var filtered = filter(isExact(constraints))(formatsList);
  log_debug('[gum:hasMatchingFormat]', 'Filtered list: ' + JSON.stringify(filtered, null, 2));
  return filtered.length > 0;
});

/**
 * Returns list of filter lower resolution constraints from the provided Media constraints.
 *
 * @param {Array} formayList
 * @param {Object} constraints
 * @return {Array}
 *
 * @private
 */
var findLowerResolutions = curry(function (formatsList, constraints) {
  var resIsLower = isLower(constraints);
  return filter(resIsLower)(formatsList);
});

/**
 * Allows the browser to try and determine the resolution to use based on `video: true` attribute in `getUserMedia` call.
 *
 * @param {Object} data
 *        The Media Constaints object.
 * @param {Promise} p
 *        The `Promise` to resolve or reject on detemination of allowed Media Constraints on the browser.
 *
 * @private
 */
var webrtc_allowBrowserToDefineResolution = function allowBrowserToDefineResolution(data, p) {
  // default to `video: true` in hopes the browser can decide on its own.
  data.video = true;
  browser.gUM(data).then(function (media) {
    p.resolve({
      media: media,
      constraints: data
    });
  }).catch(function (err) {
    // eslint-disable-line no-unused-vars
    var msg = typeof err === 'string' ? err : [err.name, err.message].join(': ');
    log_debug('[gum:getUserMedia]', "Failure in getUserMedia: ".concat(msg, ". Attempting other resolution tests..."));
    log_debug('[gUM:findformat]', "Constraints declined by browser: ".concat(JSON.stringify(data, null, 2)));
    p.reject('Could not find proper camera for provided constraints.');
  });
};

/**
 * Attempts to select the best resolution based on whether the browser throws an exception when requesting `MediaStream` on `getUserMedia`.
 *
 * @param {Object} data
 *        The Media Constaints object.
 * @param {Array} selections
 *        The listing of formats to test on.
 * @param {Promise} p
 *        The `Promise` to resolve or reject on detemination of allowed Media Constraints on the browser.
 *
 * @private
 */
var webrtc_findNextSelection = function findNextSelection(data, selections, p) {
  if (selections.length == 0) {
    // if we got here, there is no support.
    webrtc_allowBrowserToDefineResolution(data, p);
    return;
  }
  var selection = selections.shift();
  data.video.width = {
    exact: selection.width
  };
  data.video.height = {
    exact: selection.height
  };
  browser.gUM(data).then(function (media) {
    p.resolve({
      media: media,
      constraints: data
    });
  }).catch(function (err) {
    // eslint-disable-line no-unused-vars
    var msg = typeof err === 'string' ? err : [err.name, err.message].join(': ');
    log_debug('[gum:getUserMedia]', "Failure in getUserMedia: ".concat(msg, ". Attempting other resolution tests..."));
    log_debug('[gUM:findformat]', "Constraints declined by browser: ".concat(JSON.stringify(data, null, 2)));
    findNextSelection(data, selections, p);
  });
};

/**
 * Quick test if resolution is supported on the browser.
 *
 * @param {Object} constraints
 *
 * @private
 */
var webrtc_quickResolutionSupport = function quickResolutionSupport(constraints) {
  var data = deepCopy(constraints);
  // if video: `true`, returned unscathed.
  if (typeof constraints.video === 'boolean') {
    return data;
  }
  // else, define exact.
  if (constraints.video.width) {
    data.video.width = {
      exact: getValueFromConstraintAttribute(constraints.video.width)
    };
  }
  if (constraints.video.height) {
    data.video.height = {
      exact: getValueFromConstraintAttribute(constraints.video.height)
    };
  }
  return data;
};

/**
 * Detemine the supported resolution on the browser based on the Media Constraints requested.
 *
 * @param {Object} constraints
 *
 * @private
 */
var webrtc_determineSupportedResolution = function determineSupportedResolution(constraints) {
  log_debug('[gum:determineSupportedResolution]', 'Determine next neighbor based on constraints: ' + JSON.stringify(constraints, null, 2));
  var deferred = new DeferredPromise();
  var selections = findLowerResolutions(formats)(constraints);
  var data = deepCopy(constraints);
  webrtc_findNextSelection(data, selections, deferred);
  return deferred.promise;
};

/**
 * Quick test to see if WebRTC is supported in the current environment.
 *
 * @return {Boolean}
 *
 * @private
 */
var webrtc_isSupported = function isSupported() {
  return _RTCPeerConnection && _RTCIceCandidate && _RTCSessionDescription;
};

/**
 * Detects if essential RTCDataChannel API is available in browser.
 *
 * @private
 */
var webrtc_supportsDataChannel = function supportsDataChannel() {
  try {
    var pc = new _RTCPeerConnection(null);
    var dc = pc.createDataChannel({
      name: 'test'
    });
    dc.close();
    pc.close();
    return !!webrtc_isSupported();
  } catch (e) {
    log_debug("Could not detect RTCDataChannel support: ".concat(e.message));
    return false;
  }
};

/**
 * Proxy on `getUserMedia` to try and resolve to the best possible resolution for broadcast based on Media Constraints object provided.
 *
 * @param {Object} constraints
 *        The Media Constraints to request
 * @param {Function} rejectionCB
 *        The callback for rejection on `getUserMedia` request.
 * @return {Promise}
 *        The `Promise` will resolve or reject on properly accessing a `MediaStream` from `getUserMedia` on the browser.
 *
 * @private
 */
var webrtc_getUserMedia = function getUserMedia(constraints, rejectionCB) {
  // Wrapping `getUserMedia` requests in another deferred promise so we can return the selected resolutions if successful.
  var dfd = new DeferredPromise();
  var isAvailableInFormats = hasMatchingFormat(formats);
  log_debug('[gum:getUserMedia]', 'Is Available in format listing: ' + isAvailableInFormats(constraints));
  var failover = function failover(err) {
    if (err) {
      var msg = typeof err === 'string' ? err : [err.name, err.message].join(': ');
      log_debug('[gum:getUserMedia]', "Failure in getUserMedia: ".concat(msg, ". Attempting other resolution tests..."));
    }
    webrtc_determineSupportedResolution(constraints).then(function (res) {
      dfd.resolve({
        media: res.media,
        constraints: res.constraints
      });
    }).catch(function (error) {
      if (rejectionCB) {
        rejectionCB(constraints);
      }
      dfd.reject({
        error: error,
        constraints: constraints
      });
    });
  };
  if (!hasResolutionsDefined(constraints)) {
    log_debug('[gum:getUserMedia]', 'Constraints were not defined properly. Attempting failover...');
    browser.gUM(constraints).then(function (media) {
      dfd.resolve({
        media: media,
        constraints: constraints
      });
    }).catch(failover);
  } else if (isAvailableInFormats(constraints)) {
    log_debug('[gum:getUserMedia]', 'Found constraints in list. Checking quick support for faster setup with: ' + JSON.stringify(constraints, null, 2));
    // Try quick setting of `exact` resolution...
    var available = webrtc_quickResolutionSupport(constraints);
    browser.gUM(available).then(function (media) {
      dfd.resolve({
        media: media,
        constraints: available
      });
    }).catch(failover);
  } else {
    log_debug('[gum:getUserMedia]', 'Could not find contraints in list. Attempting failover...');
    if (rejectionCB) {
      rejectionCB(constraints);
    }
    failover();
  }
  return dfd.promise;
};

/**
 * Force to call `getUserMedia` directly on the browser and bypass the resolution detection mechanism provided by other methods on this module.
 *
 * @private
 */
var webrtc_forceUserMedia = function forceUserMedia(constraints) {
  return browser.gUM(constraints);
};
var cleanWhipSDP = function cleanWhipSDP(sdp) {
  var offensive = ['a=sendrecv', 'a=end-of-candidates'];
  var s = sdp.split('\r\n');
  var i = s.length;
  while (--i > -1) {
    if (offensive.indexOf(s[i]) > -1) {
      s.splice(i, 1);
    }
  }
  return s.join('\r\n');
};
var stripExtMaps = function stripExtMaps(sdp) {
  var extReg = /^a=extmap/;
  var s = sdp.split('\r\n');
  var i = s.length;
  while (--i > -1) {
    if (extReg.exec(s[i])) {
      s.splice(i, 1);
    }
  }
  return s.join('\r\n');
};
var rtpmaps = function (list) {
  var regx = [];
  list.forEach(function (line) {
    return regx.push(new RegExp("a=(".concat(line, ")"), 'g'));
  });
  return regx;
}(['rtpmap:(\\d{1,}) ISAC', 'rtpmap:(\\d{1,}) G722', 'rtpmap:(\\d{1,}) CN', 'rtpmap:(\\d{1,}) PCMU', 'rtpmap:(\\d{1,}) PCMA', 'rtpmap:(\\d{1,}) telephone-event']);
var stripRTPMaps = function stripRTPMaps(sdp) {
  var format = function format(id) {
    return "^a=(rtcp-fb|fmtp):".concat(id, " .*");
  };
  var s = sdp.split('\r\n');
  var i = s.length;
  var j, rx;
  var match;
  var formats = [];
  var formatStr;
  // Find offending maps
  while (--i > -1) {
    for (j = 0; j < rtpmaps.length; j++) {
      rx = rtpmaps[j];
      rx.lastIndex = 0;
      match = rx.exec(s[i]);
      if (match) {
        //        console.log(`[SDP] removing ${s[i]}`)
        formatStr = format(match[match.length - 1]);
        if (formats.indexOf(formatStr) === -1) {
          formats.push(formatStr);
        }
        s.splice(i, 1);
        break;
      }
    }
  }
  // Find offending associated formats of removed media mappings.
  if (rx) rx.lastIndex = 0;
  i = s.length;
  //  console.log('formats', formats)
  while (--i > -1) {
    for (j = 0; j < formats.length; j++) {
      rx = new RegExp(formats[j], 'g');
      rx.lastIndex = 0;
      if (rx.exec(s[i])) {
        //        console.log(`[SDP] removing ${s[i]}`)
        s.splice(i, 1);
        break;
      }
    }
  }
  return s.join('\r\n');
};
var stripNonH264 = function stripNonH264(sdp) {
  var maps = /^a=((rtpmap|rtcp-fb|fmtp):(\d{1,}).*)/gi;
  var h264 = /^a=fmtp:(\d{1,}).*profile-level-id=\b42/gi;
  var types = [];
  var s = sdp.split('\r\n');
  var i = s.length;
  var j = 0;
  var match, rx;
  while (--i > -1) {
    h264.lastIndex = 0;
    match = h264.exec(s[i]);
    if (match && types.indexOf(match[match.length - 1]) === -1) {
      types.push(match[match.length - 1]);
    }
  }
  i = s.length;
  //  console.log('types', types)
  while (--i > -1) {
    for (j = 0; j < types.length; j++) {
      maps.lastIndex = 0;
      match = maps.exec(s[i]);
      if (match && types.indexOf(match[match.length - 1]) === -1) {
        //        console.log(`[SDP] removing ${s[i]}`)
        s.splice(i, 1);
        break;
      }
    }
  }
  return s.join('\r\n');
};
var stripNonH264FromVideo = function stripNonH264FromVideo(sdp) {
  var r = /^video/g;
  var videos = sdp.split('m=');
  var out = videos.map(function (entry) {
    if (entry.match(r)) {
      if (entry.indexOf('a=sendrecv') !== -1) {
        return stripNonH264(entry);
      }
    }
    return entry;
  });
  return out.join('m=');
};
var ssrc = /a=ssrc/gi;
var flipRecvOnly = function flipRecvOnly(sdp, mline, match) {
  var media = sdp.split(mline);
  var index = 0;
  // a=sendrecv -> a=recvonly
  var out = media.map(function (entry) {
    if (entry.match(match)) {
      if (++index > 1) {
        var str = entry.replace('a=sendrecv', 'a=recvonly');
        var _out = str.split('\r\n');
        var i = _out.length;
        while (--i > -1) {
          ssrc.lastIndex = 0;
          if (ssrc.exec(_out[i])) {
            _out.splice(i, 1);
          }
        }
        return _out.join('\r\n');
      }
    }
    return entry;
  });
  return out.join(mline);
};
var flipRecvOnlyOnExtraAudio = function flipRecvOnlyOnExtraAudio(sdp) {
  return flipRecvOnly(sdp, 'm=', /^audio/g);
};
var flipRecvOnlyOnExtraVideo = function flipRecvOnlyOnExtraVideo(sdp) {
  return flipRecvOnly(sdp, 'm=', /^video/g);
};

// https://github.com/muaz-khan/WebRTC-Experiment/blob/master/RTCPeerConnection/RTCPeerConnection-v1.6.js#L158
// Muaz Khan     - github.com/muaz-khan
// MIT License   - www.WebRTC-Experiment.com/licence
// Documentation - github.com/muaz-khan/WebRTC-Experiment/tree/master/RTCPeerConnection
var updateBandwidth = function updateBandwidth(options, sdp) {
  var a_index = sdp.indexOf('m=audio');
  var v_index = sdp.indexOf('m=video');
  var l_index, front, back;
  if (a_index > -1) {
    if (options.audio) {
      l_index = sdp.indexOf('\r\n', a_index);
      front = sdp.slice(0, l_index);
      back = sdp.slice(l_index + '\r\n'.length, sdp.length);
      sdp = [front, 'b=AS:' + options.audio, back].join('\r\n');
    }
    v_index = sdp.indexOf('m=video');
  }
  if (v_index > -1) {
    if (options.video) {
      l_index = sdp.indexOf('\r\n', v_index);
      front = sdp.slice(0, l_index);
      back = sdp.slice(l_index + '\r\n'.length, sdp.length);
      sdp = [front, 'b=AS:' + options.video, back].join('\r\n');
    }
  }
  // Legacy Chrome.
  if (a_index === -1 && v_index === -1) {
    sdp = sdp.replace(/b=AS([^\r\n]+\r\n)/g, '');
    if (options.audio) {
      sdp = sdp.replace(/a=mid:audio\r\n/g, 'a=mid:audio\r\nb=AS:' + options.audio + '\r\n');
    }
    if (options.video) {
      sdp = sdp.replace(/a=mid:video\r\n/g, 'a=mid:video\r\nb=AS:' + options.video + '\r\n');
    }
  }
  return sdp;
};
var forceStereoOnLocalAnswer = function forceStereoOnLocalAnswer(sdp) {
  return sdp.includes('stereo=1') ? sdp : sdp.replace('useinbandfec=1', 'useinbandfec=1;stereo=1;sprop-stereo=1');
};

/**
 * For WHIP/WHEP trickle ice candidates, this will generate the fragment required to send in a PATCH.
 * @param {string} sdp The full SDP with candidate listings to parse
 * @param {string} type The desired candidate type (if any). Either `host` or `srflx`.
 * @param {boolean}} isEnd Flag to append end of candidates in the fragment.
 * @returns
 */
var generateSDPCandidateFrag = function generateSDPCandidateFrag(sdp) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  var isEnd = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var end = 'a=end-of-candidates';
  var candidateReg = /^a=candidate:/;
  var fragReg = /^a=ice-ufrag:/;
  var pwdReg = /^a=ice-pwd:/;
  var mReg = /^m=(audio|video|application)\ /;
  var lines = sdp.split('\r\n');
  var iceFrag = '';
  var icePwd = '';
  var mLine;
  var id = 'a=mid:0';
  var candidates = [];
  lines.forEach(function (l) {
    if (!mLine && mReg.exec(l)) {
      mLine = l;
    } else if (fragReg.exec(l)) {
      iceFrag = l;
    } else if (pwdReg.exec(l)) {
      icePwd = l;
    } else if (candidateReg.exec(l)) {
      if (type && l.indexOf(type) != -1) {
        candidates.push(l);
      } else if (!type) {
        candidates.push(l);
      }
    }
  });
  if (isEnd && candidates[candidates.length - 1] !== end) {
    candidates.push(end);
  }
  var fragList = [iceFrag, icePwd, mLine, id].concat(candidates);
  return fragList.join('\r\n');
};

/* -- handled by adapter.js -- */
var _RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
var _RTCIceCandidate = window.RTCIceCandidate || window.mozRTCIceCandidate || window.webkitRTCIceCandidate;
var _RTCSessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription || window.webkitRTCSessionDescription;
var RTCPeerConnection = _RTCPeerConnection;
var RTCIceCandidate = _RTCIceCandidate;
var RTCSessionDescription = _RTCSessionDescription;
// CONCATENATED MODULE: ./src/js/adapter/websocket.js




/**
 * Test for WebSocket support in environment.
 *
 * @return {Boolean}
 *
 * @private
 */
var websocket_isSupported = function isSupported() {
  return browser.supportsWebSocket();
};

/**
 * Attempt at creating new instance of a `WebSocket` at endpoint URL.
 *
 * @param {String} url
 * @return {WebSocket}
 *
 * @private
 */
var websocket_create = function create(url) {
  return browser.createWebSocket(url);
};
// CONCATENATED MODULE: ./src/js/event/publisher-event.js
/**
 * Common Publisher-based event types.
 */
var PublisherEventTypes = Object.freeze({
  CONNECT_SUCCESS: 'Connect.Success',
  CONNECT_FAILURE: 'Connect.Failure',
  PUBLISH_START: 'Publish.Start',
  PUBLISH_FAIL: 'Publish.Fail',
  PUBLISH_INVALID_NAME: 'Publish.InvalidName',
  UNPUBLISH_SUCCESS: 'Unpublish.Success',
  PUBLISH_METADATA: 'Publish.Metadata',
  PUBLISH_STATUS: 'Publish.Status',
  PUBLISH_AVAILABLE: 'Publish.Available',
  PUBLISH_INSUFFICIENT_BANDWIDTH: 'Publish.InsufficientBW',
  PUBLISH_SUFFICIENT_BANDWIDTH: 'Publish.SufficientBW',
  PUBLISH_RECOVERING_BANDWIDTH: 'Publish.RecoveringBW',
  PUBLISH_SEND_INVOKE: 'Publish.Send.Invoke',
  CONNECTION_CLOSED: 'Publisher.Connection.Closed',
  DIMENSION_CHANGE: 'Publisher.Video.DimensionChange'
});

/**
 * Event types dispacthed from and specific to `Red5ProPublisher`.
 *
 * @see {Red5ProPublisher}
 */
var FailoverPublisherEventTypes = Object.freeze({
  PUBLISHER_REJECT: 'Publisher.Reject',
  PUBLISHER_ACCEPT: 'Publisher.Accept'
});

/**
 * Event types dispatched from and specific to `RTCPublisher`.
 *
 * @see {RTCPublisher}
 */
var RTCPublisherEventTypes = Object.freeze({
  CONSTRAINTS_ACCEPTED: 'WebRTC.MediaConstraints.Accepted',
  CONSTRAINTS_REJECTED: 'WebRTC.MediaConstraints.Rejected',
  MEDIA_STREAM_AVAILABLE: 'WebRTC.MediaStream.Available',
  PEER_CONNECTION_AVAILABLE: 'WebRTC.PeerConnection.Available',
  OFFER_START: 'WebRTC.Offer.Start',
  OFFER_END: 'WebRTC.Offer.End',
  PEER_CANDIDATE_END: 'WebRTC.PeerConnection.CandidateEnd',
  ICE_TRICKLE_COMPLETE: 'WebRTC.IceTrickle.Complete',
  SOCKET_MESSAGE: 'WebRTC.Socket.Message',
  DATA_CHANNEL_OPEN: 'WebRTC.DataChannel.Open',
  DATA_CHANNEL_AVAILABLE: 'WebRTC.DataChannel.Available',
  DATA_CHANNEL_CLOSE: 'WebRTC.DataChannel.Close',
  DATA_CHANNEL_MESSAGE: 'WebRTC.DataChannel.Message',
  DATA_CHANNEL_ERROR: 'WebRTC.DataChannel.Error',
  PEER_CONNECTION_OPEN: 'WebRTC.PeerConnection.Open',
  TRACK_ADDED: 'WebRTC.PeerConnection.OnTrack'
});

/**
 * Event types dispatched from and specific to `RTMPPublisher`.
 *
 * @see {RTMPPublisher}
 */
var RTMPPublisherEventTypes = Object.freeze({
  EMBED_SUCCESS: 'FlashPlayer.Embed.Success',
  EMBED_FAILURE: 'FlashPlayer.Embed.Failure'
});
// CONCATENATED MODULE: ./src/js/event/subscriber-event.js
/**
 * Common event types on all Subscribers.
 */
var SubscriberEventTypes = Object.freeze({
  CONNECT_SUCCESS: 'Connect.Success',
  CONNECT_FAILURE: 'Connect.Failure',
  SUBSCRIBE_START: 'Subscribe.Start',
  SUBSCRIBE_STOP: 'Subscribe.Stop',
  SUBSCRIBE_FAIL: 'Subscribe.Fail',
  SUBSCRIBE_INVALID_NAME: 'Subscribe.InvalidName',
  SUBSCRIBE_METADATA: 'Subscribe.Metadata',
  SUBSCRIBE_STATUS: 'Subscribe.Status',
  SUBSCRIBE_SEND_INVOKE: 'Subscribe.Send.Invoke',
  SUBSCRIBE_PUBLISHER_CONGESTION: 'Subscribe.Publisher.NetworkCongestion',
  SUBSCRIBE_PUBLISHER_RECOVERY: 'Subscribe.Publisher.NetworkRecovery',
  PLAY_UNPUBLISH: 'Subscribe.Play.Unpublish',
  CONNECTION_CLOSED: 'Subscribe.Connection.Closed',
  ORIENTATION_CHANGE: 'Subscribe.Orientation.Change',
  STREAMING_MODE_CHANGE: 'Subscribe.StreamingMode.Change',
  VIDEO_DIMENSIONS_CHANGE: 'Subscribe.VideoDimensions.Change',
  VOLUME_CHANGE: 'Subscribe.Volume.Change',
  SEEK_CHANGE: 'Subscribe.Seek.Change',
  PLAYBACK_TIME_UPDATE: 'Subscribe.Time.Update',
  PLAYBACK_STATE_CHANGE: 'Subscribe.Playback.Change',
  FULL_SCREEN_STATE_CHANGE: 'Subscribe.FullScreen.Change',
  AUTO_PLAYBACK_FAILURE: 'Subscribe.Autoplay.Failure',
  AUTO_PLAYBACK_MUTED: 'Subscribe.Autoplay.Muted'
});

/**
 * Event types dispatched from and specific to `Red5ProSubscriber`.
 *
 * @see {Red5ProSubscriber}
 */
var FailoverSubscriberEventTypes = Object.freeze({
  SUBSCRIBER_REJECT: 'Subscriber.Reject',
  SUBSCRIBER_ACCEPT: 'Subscriber.Accept'
});

/**
 * Event types dispatched from and specific to `RTCSubscriber`.
 *
 * @see {RTCSubscriber}
 */
var RTCSubscriberEventTypes = Object.freeze({
  PEER_CONNECTION_AVAILABLE: 'WebRTC.PeerConnection.Available',
  OFFER_START: 'WebRTC.Offer.Start',
  OFFER_END: 'WebRTC.Offer.End',
  ANSWER_START: 'WebRTC.Answer.Start',
  ANSWER_END: 'WebRTC.Answer.End',
  CANDIDATE_START: 'WebRTC.Candidate.Start',
  CANDIDATE_END: 'WebRTC.Candidate.End',
  PEER_CANDIDATE_END: 'WebRTC.PeerConnection.CandidateEnd',
  ICE_TRICKLE_COMPLETE: 'WebRTC.IceTrickle.Complete',
  SOCKET_MESSAGE: 'WebRTC.Socket.Message',
  DATA_CHANNEL_MESSAGE: 'WebRTC.DataChannel.Message',
  DATA_CHANNEL_OPEN: 'WebRTC.DataChannel.Open',
  DATA_CHANNEL_AVAILABLE: 'WebRTC.DataChannel.Available',
  DATA_CHANNEL_CLOSE: 'WebRTC.DataChannel.Close',
  DATA_CHANNEL_ERROR: 'WebRTC.DataChannel.Error',
  PEER_CONNECTION_OPEN: 'WebRTC.PeerConnection.Open',
  ON_ADD_STREAM: 'WebRTC.Add.Stream',
  LIVE_SEEK_ERROR: 'WebRTC.LiveSeek.Error',
  LIVE_SEEK_ENABLED: 'WebRTC.LiveSeek.Enabled',
  LIVE_SEEK_DISABLED: 'WebRTC.LiveSeek.Disabled',
  LIVE_SEEK_LOADING: 'WebRTC.LiveSeek.FragmentLoading',
  LIVE_SEEK_LOADED: 'WebRTC.LiveSeek.FragmentLoaded'
});

/**
 * Event type dispatched from and specific to `RTMPSubscriber`.
 *
 * @see {RTMPSubscriber}
 */
var RTMPSubscriberEventTypes = Object.freeze({
  EMBED_SUCCESS: 'FlashPlayer.Embed.Success',
  EMBED_FAILURE: 'FlashPlayer.Embed.Failure',
  // Stream Manager + ABR Specific
  ABR_LEVEL_CHANGE: 'RTMP.AdaptiveBitrate.Level'
});
// CONCATENATED MODULE: ./src/js/event/sharedobject-event.js
/**
 * Common event types on SharedObject.
 *
 * @see {Red5ProSharedObject}
 */
var SharedObjectEventTypes = Object.freeze({
  CONNECT_SUCCESS: 'Connect.Success',
  CONNECT_FAILURE: 'Connect.Failure',
  PROPERTY_UPDATE: 'SharedObject.PropertyUpdate',
  PROPERTY_REMOVE: 'SharedObject.PropertyRemove',
  METHOD_UPDATE: 'SharedObject.MethodUpdate',
  CONNECTION_CLOSED: 'SharedObject.Connection.Closed'
});
// CONCATENATED MODULE: ./src/js/event/message-transport-event.js
/**
 * Common state event types from a message transport layer (WebSocket or RTCDataChannel).
 */
var MessageTransportStateEventTypes = Object.freeze({
  OPEN: 'MessageTransport.Open',
  CLOSE: 'MessageTransport.Close',
  CHANGE: 'MessageTransport.Change',
  ERROR: 'MessageTransport.Error'
});
// CONCATENATED MODULE: ./src/js/event/participant-event.js
var RTCConferenceParticipantEventTypes = Object.freeze({
  AUDIO_STREAM: 'Conference.AudioStream',
  VIDEO_STREAM: 'Conference.VideoStream',
  MEDIA_STREAM: 'Conference.MediaStream'
});
// CONCATENATED MODULE: ./src/js/event/index.js
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (event_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function event_typeof(obj) { "@babel/helpers - typeof"; return event_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, event_typeof(obj); }
function event_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function event_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, event_toPropertyKey(descriptor.key), descriptor); } }
function event_createClass(Constructor, protoProps, staticProps) { if (protoProps) event_defineProperties(Constructor.prototype, protoProps); if (staticProps) event_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function event_toPropertyKey(arg) { var key = event_toPrimitive(arg, "string"); return event_typeof(key) === "symbol" ? key : String(key); }
function event_toPrimitive(input, hint) { if (event_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (event_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * Base class for all events.
 */
var Event = /*#__PURE__*/function () {
  function Event(type) {
    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
    event_classCallCheck(this, Event);
    this._type = type;
    this._data = data;
  }

  /**
   * Type accessor.
   *
   * @type {String}
   */
  event_createClass(Event, [{
    key: "type",
    get: function get() {
      return this._type;
    }

    /**
     * Data related to event.
     *
     * @type {Object}
     */
  }, {
    key: "data",
    get: function get() {
      return this._data;
    }
  }]);
  return Event;
}();
/**
 * Base Publisher-related Event.
 *
 * @extends Event
 */
var PublisherEvent = /*#__PURE__*/function (_Event) {
  _inherits(PublisherEvent, _Event);
  var _super = _createSuper(PublisherEvent);
  function PublisherEvent(type, publisher, data) {
    var _this;
    event_classCallCheck(this, PublisherEvent);
    _this = _super.call(this, type, data);
    _this._publisher = publisher;
    return _this;
  }

  /**
   * The Publisher instance that dispatched the event.
   *
   * @type {Object}
   *
   * @see Red5ProPublisher
   * @see RTCPublisher
   * @see RTMPPublisher
   */
  event_createClass(PublisherEvent, [{
    key: "publisher",
    get: function get() {
      return this._publisher;
    }
  }]);
  return PublisherEvent;
}(Event);
/**
 * Base Subscriber-related Event.
 *
 * @extends Event
 */
var SubscriberEvent = /*#__PURE__*/function (_Event2) {
  _inherits(SubscriberEvent, _Event2);
  var _super2 = _createSuper(SubscriberEvent);
  function SubscriberEvent(type, subscriber, data) {
    var _this2;
    event_classCallCheck(this, SubscriberEvent);
    _this2 = _super2.call(this, type, data);
    _this2._subscriber = subscriber;
    return _this2;
  }

  /**
   * The Subscriber instance that dispatched the event.
   *
   * @type {Object}
   *
   * @see Red5ProSubscriber
   * @see RTCSubscriber
   * @see RTMPSubscriber
   * @see HLSubscriber
   */
  event_createClass(SubscriberEvent, [{
    key: "subscriber",
    get: function get() {
      return this._subscriber;
    }
  }]);
  return SubscriberEvent;
}(Event);
/**
 * Base SharedObject-related Event.
 *
 * @extends Event
 */
var SharedObjectEvent = /*#__PURE__*/function (_Event3) {
  _inherits(SharedObjectEvent, _Event3);
  var _super3 = _createSuper(SharedObjectEvent);
  function SharedObjectEvent(type, sharedObjectName, data) {
    var _this3;
    event_classCallCheck(this, SharedObjectEvent);
    _this3 = _super3.call(this, type, data);
    _this3._name = sharedObjectName;
    return _this3;
  }

  /**
   * The name of the Shared Object.
   *
   * @type {String}
   *
   * @see {Red5ProSharedObject}
   */
  event_createClass(SharedObjectEvent, [{
    key: "name",
    get: function get() {
      return this._name;
    }
  }]);
  return SharedObjectEvent;
}(Event);
/**
 * Base WebSocketProxy-related state Event.
 *
 * @extends Event
 */
var MessageTransportStateEvent = /*#__PURE__*/function (_Event4) {
  _inherits(MessageTransportStateEvent, _Event4);
  var _super4 = _createSuper(MessageTransportStateEvent);
  function MessageTransportStateEvent(type, name, data) {
    var _this4;
    event_classCallCheck(this, MessageTransportStateEvent);
    _this4 = _super4.call(this, type, data);
    _this4._name = name;
    return _this4;
  }

  /**
   * The name of the WebSocket.
   *
   * @type {String}
   *
   * @see {Red5ProSharedObject}
   */
  event_createClass(MessageTransportStateEvent, [{
    key: "name",
    get: function get() {
      return this._name;
    }
  }]);
  return MessageTransportStateEvent;
}(Event);
/**
 * Base RTCConferenceParticipant state Event.
 *
 * @extends Event
 */
var RTCConferenceParticipantEvent = /*#__PURE__*/function (_Event5) {
  _inherits(RTCConferenceParticipantEvent, _Event5);
  var _super5 = _createSuper(RTCConferenceParticipantEvent);
  function RTCConferenceParticipantEvent(type, participant, data) {
    var _this5;
    event_classCallCheck(this, RTCConferenceParticipantEvent);
    _this5 = _super5.call(this, type, data);
    _this5._participant = participant;
    return _this5;
  }

  /**
   * The RTCConferenceParticipant.
   *
   * @type {RTCConferenceParticipant}
   *
   * @see {RTCConferenceParticipant}
   */
  event_createClass(RTCConferenceParticipantEvent, [{
    key: "participant",
    get: function get() {
      return this._participant;
    }
  }]);
  return RTCConferenceParticipantEvent;
}(Event);

















// CONCATENATED MODULE: ./src/js/subscriber/controls/event.js


function controls_event_typeof(obj) { "@babel/helpers - typeof"; return controls_event_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, controls_event_typeof(obj); }
function controls_event_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function controls_event_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, controls_event_toPropertyKey(descriptor.key), descriptor); } }
function controls_event_createClass(Constructor, protoProps, staticProps) { if (protoProps) controls_event_defineProperties(Constructor.prototype, protoProps); if (staticProps) controls_event_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function controls_event_toPropertyKey(arg) { var key = controls_event_toPrimitive(arg, "string"); return controls_event_typeof(key) === "symbol" ? key : String(key); }
function controls_event_toPrimitive(input, hint) { if (controls_event_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (controls_event_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function event_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) event_setPrototypeOf(subClass, superClass); }
function event_setPrototypeOf(o, p) { event_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return event_setPrototypeOf(o, p); }
function event_createSuper(Derived) { var hasNativeReflectConstruct = event_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = event_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = event_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return event_possibleConstructorReturn(this, result); }; }
function event_possibleConstructorReturn(self, call) { if (call && (controls_event_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return event_assertThisInitialized(self); }
function event_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function event_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function event_getPrototypeOf(o) { event_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return event_getPrototypeOf(o); }


/**
 * Events for Slider Control.
 *
 * @see {SliderControl}
 *
 * @private
 */
var SliderEvent = /*#__PURE__*/function (_Event) {
  event_inherits(SliderEvent, _Event);
  var _super = event_createSuper(SliderEvent);
  function SliderEvent(type, control, data) {
    var _this;
    controls_event_classCallCheck(this, SliderEvent);
    _this = _super.call(this, type, data);
    _this._control = control;
    return _this;
  }
  controls_event_createClass(SliderEvent, [{
    key: "control",
    get: function get() {
      return this._control;
    }
  }]);
  return SliderEvent;
}(Event);
/**
 * Enumeration of Slider Event types.
 *
 * @private
 */
var SliderEventTypes = Object.freeze({
  CHANGE_START: 'changestart',
  CHANGE: 'change',
  CHANGE_COMPLETE: 'changecomplete'
});
var SeekEventTypes = Object.freeze({
  SEEK_START: 'seekstart',
  SEEK_END: 'seekend'
});



// CONCATENATED MODULE: ./src/js/subscriber/controls/slider.js


function slider_typeof(obj) { "@babel/helpers - typeof"; return slider_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, slider_typeof(obj); }
function slider_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function slider_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, slider_toPropertyKey(descriptor.key), descriptor); } }
function slider_createClass(Constructor, protoProps, staticProps) { if (protoProps) slider_defineProperties(Constructor.prototype, protoProps); if (staticProps) slider_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function slider_toPropertyKey(arg) { var key = slider_toPrimitive(arg, "string"); return slider_typeof(key) === "symbol" ? key : String(key); }
function slider_toPrimitive(input, hint) { if (slider_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (slider_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function slider_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) slider_setPrototypeOf(subClass, superClass); }
function slider_setPrototypeOf(o, p) { slider_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return slider_setPrototypeOf(o, p); }
function slider_createSuper(Derived) { var hasNativeReflectConstruct = slider_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = slider_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = slider_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return slider_possibleConstructorReturn(this, result); }; }
function slider_possibleConstructorReturn(self, call) { if (call && (slider_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return slider_assertThisInitialized(self); }
function slider_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function slider_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function slider_getPrototypeOf(o) { slider_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return slider_getPrototypeOf(o); }




var NAME = 'ControlSlider';

/**
 * Custom slider control for Playback Controls.
 *
 * @private
 */
var slider_ControlSlider = /*#__PURE__*/function (_EventEmitter) {
  slider_inherits(ControlSlider, _EventEmitter);
  var _super = slider_createSuper(ControlSlider);
  function ControlSlider(type) {
    var _this;
    slider_classCallCheck(this, ControlSlider);
    _this = _super.call(this);
    _this.name = [NAME, type].join('::');
    log_debug(_this.name, '[init]');
    _this._container = browser.createElement('div');
    _this._button = _this.createButton();
    _this._track = _this.createTrack();
    _this._progressBar = _this.createProgressBar();
    _this._container.appendChild(_this._track);
    _this._container.appendChild(_this._progressBar);
    _this._container.appendChild(_this._button);
    _this._value = 0; // 0 - 1
    _this._disabled = false;
    _this._eventStartPosition = 0;
    _this._layout();
    _this._mouseupHandler = _this._mouseup.bind(slider_assertThisInitialized(_this));
    _this._mousedownHandler = _this._mousedown.bind(slider_assertThisInitialized(_this));
    _this._mousemoveHandler = _this._mousemove.bind(slider_assertThisInitialized(_this));
    _this._touchupHandler = _this._touchproxy.bind(slider_assertThisInitialized(_this));
    _this._touchdownHandler = _this._touchproxy.bind(slider_assertThisInitialized(_this));
    _this._touchmoveHandler = _this._touchproxy.bind(slider_assertThisInitialized(_this));
    _this._updateHandlers(_this._disabled);
    return _this;
  }

  /**
   * Touch event proxy to bubble out mouse events for handling interaction.
   *
   * @private
   */
  slider_createClass(ControlSlider, [{
    key: "_touchproxy",
    value: function _touchproxy(event) {
      event.preventDefault();
      if (event.touches.length > 1 || event.type == "touchend" && event.touches.length > 0) {
        return;
      }
      var evt = browser.createEvent('MouseEvent');
      var type, touch;
      var t = event.originalTarget || event.target;
      switch (event.type) {
        case 'touchstart':
          type = 'mousedown';
          touch = event.changedTouches[0];
          break;
        case 'touchmove':
          type = 'mousemove';
          touch = event.changedTouches[0];
          break;
        case 'touchend':
          type = 'mouseup';
          touch = event.changedTouches[0];
          break;
      }
      evt.initMouseEvent(type, true, true, t.ownerDocument.defaultView, 0, touch.screenX, touch.screenY, touch.clientX, touch.clientY, event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, 0, null);
      t.dispatchEvent(evt);
    }

    /**
     * Event handler for mouse up.
     *
     * @private
     */
  }, {
    key: "_mouseup",
    value: function _mouseup() {
      this._eventStartPosition = 0;
      document.removeEventListener('mousemove', this._mousemoveHandler);
      document.removeEventListener('mouseup', this._mouseupHandler);
      document.removeEventListener('touchmove', this._touchmoveHandler);
      document.removeEventListener('touchup', this._touchupHandler);
      this.trigger(new SliderEvent(SliderEventTypes.CHANGE_COMPLETE, this));
    }

    /**
     * Event handler for mouse move.
     *
     * @private
     */
  }, {
    key: "_mousemove",
    value: function _mousemove(event) {
      var positionOffset = browser.getMouseXFromEvent(event) - this._eventStartPosition;
      var rect = this._button.parentNode.getBoundingClientRect();
      var position = this._eventStartPosition + positionOffset - rect.left; // - environment.getScrollX()
      position = Math.max(0, position);
      position = Math.min(position, rect.width);
      var percentage = position / rect.width;
      this.trigger(new SliderEvent(SliderEventTypes.CHANGE, this, percentage));
    }

    /**
     * Event handler for mouse down.
     *
     * @private
     */
  }, {
    key: "_mousedown",
    value: function _mousedown(event) {
      this._eventStartPosition = browser.getMouseXFromEvent(event);
      this.trigger(new SliderEvent(SliderEventTypes.CHANGE_START, this));
      document.addEventListener('mousemove', this._mousemoveHandler);
      document.addEventListener('mouseup', this._mouseupHandler);
      document.addEventListener('touchmove', this._touchmoveHandler);
      document.addEventListener('touchup', this._touchupHandler);
    }

    /**
     * Adds or removes control hanlders based on flag of overall control being disabled.
     *
     * @param {Boolean} isDisabled
     *
     * @private
     */
  }, {
    key: "_updateHandlers",
    value: function _updateHandlers(isDisabled) {
      this._eventStartPosition = 0;
      if (isDisabled) {
        this._track.removeEventListener('click', this._mousemoveHandler);
        this._progressBar.removeEventListener('click', this._mousemoveHandler);
        this._button.removeEventListener('mousedown', this._mousedownHandler);
        document.removeEventListener('mousemove', this._mousemoveHandler);
        document.removeEventListener('mouseup', this._mouseupHandler);
        document.removeEventListener('touchmove', this._touchmoveHandler);
        document.removeEventListener('touchup', this._touchupHandler);
        this._track.classList.add('red5pro-media-slider-disabled');
        this._progressBar.classList.add('red5pro-media-slider-disabled');
        this._button.classList.add('red5pro-media-slider-disabled');
      } else {
        this._track.addEventListener('click', this._mousemoveHandler);
        this._progressBar.addEventListener('click', this._mousemoveHandler);
        this._button.addEventListener('mousedown', this._mousedownHandler);
        this._button.addEventListener('touchstart', this._touchdownHandler);
        this._track.classList.remove('red5pro-media-slider-disabled');
        this._progressBar.classList.remove('red5pro-media-slider-disabled');
        this._button.classList.remove('red5pro-media-slider-disabled');
      }
    }

    /**
     * Re-layout sub controls.
     *
     * @private
     */
  }, {
    key: "_layout",
    value: function _layout() {
      var position = this._progressBar.parentNode.clientWidth * this._value;
      this._progressBar.style.width = position + 'px';
      this._button.style.left = position - this._button.clientWidth * 0.5 + 'px';
    }

    /**
     * Creates the button element.
     *
     * @private
     */
  }, {
    key: "createButton",
    value: function createButton() {
      var span = browser.createElement('span');
      span.classList.add('red5pro-media-slider-button');
      return span;
    }

    /**
     * Creates the progress bar element.
     *
     * @private
     */
  }, {
    key: "createProgressBar",
    value: function createProgressBar() {
      var span = browser.createElement('span');
      span.classList.add('red5pro-media-slider-progress');
      return span;
    }

    /**
     * Creates the track element.
     *
     * @private
     */
  }, {
    key: "createTrack",
    value: function createTrack() {
      var span = browser.createElement('span');
      span.classList.add('red5pro-media-slider-track');
      return span;
    }

    /**
     * Returns the current value.
     *
     * @return {Number}
     */
  }, {
    key: "value",
    get: function get() {
      return this._value;
    }

    /**
     * Sets the current value.
     *
     * @param {Number} 0..1
     */,
    set: function set(percentValue /* 0 - 1 */) {
      this._value = percentValue;
      this._layout();
    }

    /**
     * Returns disabled flag.
     *
     * @return {Boolean}
     */
  }, {
    key: "disabled",
    get: function get() {
      return this._disabled;
    }

    /**
     * Sets the disabled flag.
     *
     * @param {Boolean} bool
     */,
    set: function set(bool) {
      this._disabled = bool;
      this._updateHandlers(bool);
    }

    /**
     * Returns the target container this control is assigned to in the DOM.
     *
     * @return {Element}
     */
  }, {
    key: "view",
    get: function get() {
      return this._container;
    }
  }]);
  return ControlSlider;
}(event_emitter);
/* harmony default export */ var controls_slider = (slider_ControlSlider);
// CONCATENATED MODULE: ./src/js/subscriber/controls/state.js
/**
 * Enumeration of Playback State.
 *
 * @see {SubscriberPlaybackControls}
 */
var PlaybackState = Object.freeze({
  UNAVAILABLE: 1000,
  AVAILABLE: 0,
  IDLE: 1,
  PLAYING: 2,
  PAUSED: 3
});

/**
 * Human readable playback state.
 *
 * @see {SubscriberPlaybackControls}
 * @private
 */
var PlaybackStateReadable = Object.freeze({
  1000: 'Playback.UNAVAILABLE',
  0: 'Playback.AVAILABLE',
  1: 'Playback.IDLE',
  2: 'Playback.PLAYING',
  3: 'Playback.PAUSED'
});
// CONCATENATED MODULE: ./src/js/subscriber/controls/index.js


function controls_typeof(obj) { "@babel/helpers - typeof"; return controls_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, controls_typeof(obj); }
function controls_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function controls_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, controls_toPropertyKey(descriptor.key), descriptor); } }
function controls_createClass(Constructor, protoProps, staticProps) { if (protoProps) controls_defineProperties(Constructor.prototype, protoProps); if (staticProps) controls_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function controls_toPropertyKey(arg) { var key = controls_toPrimitive(arg, "string"); return controls_typeof(key) === "symbol" ? key : String(key); }
function controls_toPrimitive(input, hint) { if (controls_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (controls_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function controls_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) controls_setPrototypeOf(subClass, superClass); }
function controls_setPrototypeOf(o, p) { controls_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return controls_setPrototypeOf(o, p); }
function controls_createSuper(Derived) { var hasNativeReflectConstruct = controls_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = controls_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = controls_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return controls_possibleConstructorReturn(this, result); }; }
function controls_possibleConstructorReturn(self, call) { if (call && (controls_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return controls_assertThisInitialized(self); }
function controls_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function controls_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function controls_getPrototypeOf(o) { controls_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return controls_getPrototypeOf(o); }







var controls_NAME = 'PlaybackControls';

/**
 * Interface contract for playback controller actions.
 *
 * @extends EventEmitter
 */
var SubscriberPlaybackController = /*#__PURE__*/function (_EventEmitter) {
  controls_inherits(SubscriberPlaybackController, _EventEmitter);
  var _super = controls_createSuper(SubscriberPlaybackController);
  function SubscriberPlaybackController() {
    controls_classCallCheck(this, SubscriberPlaybackController);
    return _super.call(this);
  }

  /**
   * Request to start playing the stream.
   */
  controls_createClass(SubscriberPlaybackController, [{
    key: "play",
    value: function play() {}
    /**
     * Request to pause playback of stream.
     */
  }, {
    key: "pause",
    value: function pause() {}
    /**
     * Request to resume playback od stream.
     */
  }, {
    key: "resume",
    value: function resume() {}
    /**
     * Request to stop playback of stream.
     */
  }, {
    key: "stop",
    value: function stop() {}
    /**
     * Request to mute the audio of the stream.
     */
  }, {
    key: "mute",
    value: function mute() {}
    /**
     * Request to unmute the audio of the stream.
     */
  }, {
    key: "unmute",
    value: function unmute() {}
    /**
     * Request to set volume of audio of stream.
     *
     * @param {Number} value
     *        From 0..1.
     */
  }, {
    key: "setVolume",
    value: function setVolume(value) {} // eslint-disable-line no-unused-vars
    /**
     * Request to set playback point in time.
     *
     * @param {Number} value
     *        Either the percentage of the duration (if provided) or the time in seconds.
     * @param {Number} duration
     *        Optional duration of video (when known through VOD) to use to determine time based on first param passed as percentage.
     */
  }, {
    key: "seekTo",
    value: function seekTo(value) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
    } // eslint-disable-line no-unused-vars
    /**
     * Request to toggle fullscreen state.
     */
  }, {
    key: "toggleFullScreen",
    value: function toggleFullScreen() {}
  }]);
  return SubscriberPlaybackController;
}(event_emitter);
/**
 * Interface for PlaybackControls used by Subscribers with `controls` and `class="red5pro-media` defined on target elements. This interface serves as a presentation controller and playback API for target DOM elements.
 *
 * You can use this as a prototype for creating and providing your own custom Playback Controls. To do so: provide an implementation of this Class as the `controls` property on the initialization configuration map provided in the `init()` call of a Subscriber.
 *
 * TODO: Fully vet the viability of developers being adhere to this contract for custom controls.
 * @private
 */
var SubscriberPlaybackControls = /*#__PURE__*/function (_EventEmitter2) {
  controls_inherits(SubscriberPlaybackControls, _EventEmitter2);
  var _super2 = controls_createSuper(SubscriberPlaybackControls);
  function SubscriberPlaybackControls() {
    controls_classCallCheck(this, SubscriberPlaybackControls);
    return _super2.call(this);
  }

  /**
   * Returns the volume level.
   *
   * @return {Number} 0..1
   */
  controls_createClass(SubscriberPlaybackControls, [{
    key: "getVolume",
    value: function getVolume() {}

    /**
     * Sets the volume level of playback.
     *
     * @param {Number} value
     *        0..1
     */
  }, {
    key: "setVolume",
    value: function setVolume(value) {} // eslint-disable-line no-unused-vars

    /**
     * Request to set playback point in time.
     *
     * @param {Number} value
     *        Either the percentage of the duration (if provided) or the time in seconds.
     * @param {Number} duration
     *        Optional duration of video (when known through VOD) to use to determine time based on first param passed as percentage.
     */
  }, {
    key: "setSeekTime",
    value: function setSeekTime(value) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    } // eslint-disable-line no-unused-vars

    /**
     * Sets the playback duration of the stream, if available from VOD (Video On Demand).
     *
     * @param {Number} value
     *        In seconds.
     */
  }, {
    key: "setPlaybackDuration",
    value: function setPlaybackDuration(value) {} // eslint-disable-line no-unused-vars

    /**
     * Returns the current playback state.
     *
     * @return {Number}
     * @see {PlaybackState}
     */
  }, {
    key: "getState",
    value: function getState() {}

    /**
     * Set the current playback state.
     *
     * @param {Number} state
     * @see {PlaybackState}
     */
  }, {
    key: "setState",
    value: function setState(state) {} // eslint-disable-line no-unused-vars

    /**
     * Sets playback as VOD (Video On Demand) type.
     *
     * @param {Boolean} value
     */
  }, {
    key: "setAsVOD",
    value: function setAsVOD(value) {} // eslint-disable-line no-unused-vars

    /**
    * Enables controls and event handlers.
    *
    * @private
    */
  }, {
    key: "enable",
    value: function enable(value) {} // eslint-disable-line no-unused-vars
  }]);
  return SubscriberPlaybackControls;
}(event_emitter);
/**
 * Default implementation of `SubscriberPlaybackControls` used internally in the SDK.
 *
 * @private
 */
var controls_SubscriberPlaybackControlsImpl = /*#__PURE__*/function (_SubscriberPlaybackCo) {
  controls_inherits(SubscriberPlaybackControlsImpl, _SubscriberPlaybackCo);
  var _super3 = controls_createSuper(SubscriberPlaybackControlsImpl);
  function SubscriberPlaybackControlsImpl(player, container) {
    var _this;
    controls_classCallCheck(this, SubscriberPlaybackControlsImpl);
    _this = _super3.call(this);
    _this.player = player;
    _this.container = container;
    _this._controlbar = undefined;
    _this._playPauseButton = undefined;
    _this._muteButton = undefined;
    _this._volumeField = undefined;
    _this._seekTimeField = undefined;
    _this._timeField = undefined;
    _this._fullScreenButton = undefined;
    _this._state = PlaybackState.IDLE;
    _this._mutedState = false;
    _this._resumeAfterSeek = false;
    _this._playbackDuration = 0;
    _this._volumeValue = 1;
    _this._onPlayPauseClickBound = _this._onPlayPauseClick.bind(controls_assertThisInitialized(_this));
    _this.decorate(_this.container);
    return _this;
  }

  /**
   * Decorates target container with playback control elements.
   *
   * @param {Element} container
   *
   * @private
   */
  controls_createClass(SubscriberPlaybackControlsImpl, [{
    key: "decorate",
    value: function decorate(container) {
      log_debug(controls_NAME, '[decorate]');
      var controlbar = browser.createElement('div');
      controlbar.classList.add('red5pro-media-control-bar');
      this._playPauseButton = this._createPlayPauseButton();
      this._muteButton = this._createMuteButton();
      this._volumeField = this._createVolumeControl();
      this._seekTimeField = this._createSeekControl();
      this._timeField = this._createPlaybackTime();
      this._fullScreenButton = this._createFullScreenToggle();
      controlbar.appendChild(this._playPauseButton);
      controlbar.appendChild(this._timeField);
      controlbar.appendChild(this._seekTimeField.view);
      controlbar.appendChild(this._muteButton);
      controlbar.appendChild(this._volumeField.view);
      controlbar.appendChild(this._fullScreenButton);
      container.appendChild(controlbar);
      this._controlbar = controlbar;
      var controlBarOff;
      var delayControlBarOff = function delayControlBarOff() {
        clearTimeout(controlBarOff);
        controlBarOff = setTimeout(function () {
          controlbar.classList.remove('red5pro-media-control-bar-show');
        }, 6000);
      };
      if (browser.isTouchEnabled()) {
        controlbar.classList.add('red5pro-media-control-bar-show');
        this.container.addEventListener('touchend', function () {
          controlbar.classList.toggle('red5pro-media-control-bar-show');
          delayControlBarOff();
        });
        delayControlBarOff();
      } else {
        this.container.addEventListener('mouseover', function () {
          controlbar.classList.add('red5pro-media-control-bar-show');
        });
        this.container.addEventListener('mouseout', function () {
          controlbar.classList.remove('red5pro-media-control-bar-show');
        });
      }
      this.setState(PlaybackState.IDLE).onFullScreenChange(false).setSeekTime(0).enable(false);
    }

    /**
     * Click handler for play/pause control.
     *
     * @private
     */
  }, {
    key: "_onPlayPauseClick",
    value: function _onPlayPauseClick() {
      if (this.getState() === PlaybackState.PLAYING) {
        this.player.pause(true);
      } else if (this.getState() === PlaybackState.PAUSED) {
        this.player.resume(true);
      } else {
        this.player.play(true);
      }
    }

    /**
     * Creates play/pause control.
     *
     * @private
     */
  }, {
    key: "_createPlayPauseButton",
    value: function _createPlayPauseButton() {
      var button = browser.createElement('button');
      button.setAttribute('aria-label', 'Toggle Playback');
      button.classList.add('red5pro-media-control-element');
      button.classList.add('red5pro-media-element-button');
      button.classList.add('red5pro-media-playpause-button');
      return button;
    }

    /**
     * Creates mute/unmute control.
     *
     * @private
     */
  }, {
    key: "_createMuteButton",
    value: function _createMuteButton() {
      var self = this;
      var button = browser.createElement('button');
      button.setAttribute('aria-label', 'Toggle Mute Audio');
      button.classList.add('red5pro-media-control-element');
      button.classList.add('red5pro-media-element-button');
      button.classList.add('red5pro-media-muteunmute-button');
      button.addEventListener('click', function () {
        if (self.getMutedState()) {
          self.player.unmute();
          self.setMutedState(false);
        } else {
          self.player.mute();
          self.setMutedState(true);
        }
      });
      return button;
    }

    /**
     * Creates volume control.
     *
     * @private
     */
  }, {
    key: "_createVolumeControl",
    value: function _createVolumeControl() {
      var self = this;
      var slider = new controls_slider('volume');
      slider.view.classList.add('red5pro-media-control-element');
      slider.view.classList.add('red5pro-media-volume-slider');
      slider.view.classList.add('red5pro-media-slider');
      slider.on(SliderEventTypes.CHANGE, function (event) {
        var percentage = Number(event.data);
        self.player.setVolume(percentage);
      });
      return slider;
    }

    /**
     * Creates seek control.
     *
     * @private
     */
  }, {
    key: "_createSeekControl",
    value: function _createSeekControl() {
      var self = this;
      var slider = new controls_slider('seek');
      slider.view.classList.add('red5pro-media-control-element');
      slider.view.classList.add('red5pro-media-seektime-slider');
      slider.view.classList.add('red5pro-media-slider');
      slider.on(SliderEventTypes.CHANGE_START, function () {
        if (self.getState() === PlaybackState.PLAYING) {
          self._resumeAfterSeek = true;
          self.player.pause(true, true);
        }
        self.trigger(new Event(SeekEventTypes.SEEK_START));
      });
      slider.on(SliderEventTypes.CHANGE, function (event) {
        var percentage = Number(event.data);
        self.player.seekTo(percentage, self._playbackDuration === 0 ? undefined : self._playbackDuration);
        self.setSeekTime(percentage * self._playbackDuration, self._playbackDuration);
      });
      slider.on(SliderEventTypes.CHANGE_COMPLETE, function () {
        if (self._resumeAfterSeek && self.getState() === PlaybackState.PAUSED) {
          self._resumeAfterSeek = false;
          self.player.resume(true, true);
        }
        self.trigger(new Event(SeekEventTypes.SEEK_END));
      });
      return slider;
    }

    /**
     * Creates playback time field.
     *
     * @private
     */
  }, {
    key: "_createPlaybackTime",
    value: function _createPlaybackTime() {
      var span = browser.createElement('span');
      var text = browser.createElement('text', 'hello!');
      span.classList.add('red5pro-media-control-element');
      span.classList.add('red5pro-media-time-field');
      span.appendChild(text);
      return span;
    }

    /**
     * Create fullscreen toggle control.
     *
     * @private
     */
  }, {
    key: "_createFullScreenToggle",
    value: function _createFullScreenToggle() {
      var self = this;
      var button = browser.createElement('button');
      button.setAttribute('aria-label', 'Toggle Fullscreen');
      button.classList.add('red5pro-media-control-element');
      button.classList.add('red5pro-media-element-button');
      button.classList.add('red5pro-media-fullscreen-button');
      button.addEventListener('click', function () {
        self.player.toggleFullScreen();
      });
      return button;
    }

    /**
     * Enables controls and event handlers.
     *
     * @private
     */
  }, {
    key: "enable",
    value: function enable(value) {
      if (value) {
        this._playPauseButton.classList.remove('red5pro-media-element-button-disabled');
        this._playPauseButton.addEventListener('click', this._onPlayPauseClickBound);
      } else {
        this._playPauseButton.classList.add('red5pro-media-element-button-disabled');
        this._playPauseButton.removeEventListener('click', this._onPlayPauseClickBound);
      }
    }

    /**
     * Formats the time value.
     *
     * @param {value} Number
     * @return {String}
     */
  }, {
    key: "formatTime",
    value: function formatTime(value) {
      var hrs = 0;
      var mins = value === 0 || isNaN(value) ? 0 : parseInt(value / 60);
      var secs = 0;
      if (mins >= 60) {
        hrs = parseInt(mins / 60);
        mins = mins % 60;
      }
      secs = value === 0 || isNaN(value) ? 0 : parseInt(value % 60);
      var formattedArr = hrs < 10 ? ['0' + hrs] : [hrs];
      formattedArr.push(mins < 10 ? ['0' + mins] : [mins]);
      formattedArr.push(secs < 10 ? ['0' + secs] : [secs]);
      return formattedArr.join(':');
    }

    /**
     * Returns the volume level.
     *
     * @return {Number} 0..1
     */
  }, {
    key: "getVolume",
    value: function getVolume() {
      return this._volumeValue;
    }

    /**
     * Sets the volume level of playback.
     *
     * @param {Number} value
     *        0..1
     */
  }, {
    key: "setVolume",
    value: function setVolume(value) {
      this._volumeField.value = value;
      this._volumeValue = value;
      if (value === 0) {
        this.setMutedState(true);
      } else if (this.getMutedState()) {
        this.setMutedState(false);
      }
      return this;
    }

    /**
     * Request to set playback point in time.
     *
     * @param {Number} value
     *        Either the percentage of the duration (if provided) or the time in seconds.
     * @param {Number} duration
     *        Optional duration of video (when known through VOD) to use to determine time based on first param passed as percentage.
     */
  }, {
    key: "setSeekTime",
    value: function setSeekTime(value) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this._seekTimeField.value = length === 0 ? 0 : value / length;
      if (this._playbackDuration !== 0 && parseInt(this._playbackDuration) <= parseInt(value)) {
        this._seekTimeField.value = 1;
      }
      this._timeField.innerText = this.formatTime(Math.floor(value));
      return this;
    }

    /**
     * Sets the playback duration of the stream, if available from VOD (Video On Demand).
     *
     * @param {Number} value
     *        In seconds.
     */
  }, {
    key: "setPlaybackDuration",
    value: function setPlaybackDuration(value) {
      log_debug(controls_NAME, '[setplaybackduration]: ' + value);
      this._playbackDuration = value;
    }
  }, {
    key: "getPlaybackDuration",
    value: function getPlaybackDuration() {
      return this._playbackDuration;
    }

    /**
     * Returns the current playback state.
     *
     * @return {Number}
     * @see {PlaybackState}
     */
  }, {
    key: "getState",
    value: function getState() {
      return this._state;
    }

    /**
     * Set the current playback state.
     *
     * @param {Number} state
     * @see {PlaybackState}
     */
  }, {
    key: "setState",
    value: function setState(state) {
      log_debug(controls_NAME, '[setState]: ' + PlaybackStateReadable[state]);
      this._state = state;
      this.onStateChange(this._state);
      return this;
    }

    /**
     * Returns the current state of the playback being muted.
     * This differs from just the volume level being 0. The controls can be muted, but have a volume level greater than 0 - meaning, unmute will return back to the volume level previously set.
     *
     * @return {Boolean}
     */
  }, {
    key: "getMutedState",
    value: function getMutedState() {
      return 'muted' in this.player ? this.player.muted : this._mutedState;
    }

    /**
     * Sets the muted state of the playback.
     *
     * @param {Boolean} state
     */
  }, {
    key: "setMutedState",
    value: function setMutedState(state) {
      this._mutedState = state;
      this.onMutedStateChange(this._mutedState);
      return this;
    }

    /**
     * Handler for change in state.
     *
     * @param {Number} state
     *        The PlaybackState
     *
     * @private
     */
  }, {
    key: "onStateChange",
    value: function onStateChange(state) {
      if (state === PlaybackState.PLAYING) {
        this._playPauseButton.classList.remove('red5pro-media-play-button');
        this._playPauseButton.classList.add('red5pro-media-pause-button');
      } else {
        this._playPauseButton.classList.add('red5pro-media-play-button');
        this._playPauseButton.classList.remove('red5pro-media-pause-button');
      }
      return this;
    }

    /**
     * Handler for change in mute state.
     *
     * @param {Boolean} state
     *
     * @private
     */
  }, {
    key: "onMutedStateChange",
    value: function onMutedStateChange(state) {
      if (state) {
        this._muteButton.classList.add('red5pro-media-mute-button');
        this._muteButton.classList.remove('red5pro-media-unmute-button');
        this._volumeField.value = 0;
      } else {
        this._muteButton.classList.remove('red5pro-media-mute-button');
        this._muteButton.classList.add('red5pro-media-unmute-button');
        this._volumeField.value = this._volumeValue;
      }
    }

    /**
     * Handler for change in fullscreen state.
     *
     * @param {Boolean} isFullScreen
     *
     * @private
     */
  }, {
    key: "onFullScreenChange",
    value: function onFullScreenChange(isFullScreen) {
      if (isFullScreen) {
        this._fullScreenButton.classList.add('red5pro-media-exit-fullscreen-button');
        this._fullScreenButton.classList.remove('red5pro-media-fullscreen-button');
      } else {
        this._fullScreenButton.classList.remove('red5pro-media-exit-fullscreen-button');
        this._fullScreenButton.classList.add('red5pro-media-fullscreen-button');
      }
      return this;
    }

    /**
     * Sets playback as VOD (Video On Demand) type.
     *
     * @param {Boolean} value
     */
  }, {
    key: "setAsVOD",
    value: function setAsVOD(isVOD) {
      log_debug(controls_NAME, '[setAsVOD]: ' + isVOD);
      if (!isVOD) {
        this._seekTimeField.value = 0;
        this._seekTimeField.disabled = true;
      } else {
        this._seekTimeField.disabled = false;
      }
    }

    /**
     * Request to detach the control bar to provided container.
     */
  }, {
    key: "detach",
    value: function detach() {
      this.enable(false);
      if (this._controlbar && this._controlbar.parentNode) {
        this._controlbar.parentNode.removeChild(this._controlbar);
      }
      this._controlbar = undefined;
      this.container = undefined;
    }
  }]);
  return SubscriberPlaybackControlsImpl;
}(SubscriberPlaybackControls);
var PlaybackController = SubscriberPlaybackController;
var PlaybackControls = SubscriberPlaybackControls;
var PlaybackControlsImpl = controls_SubscriberPlaybackControlsImpl;
// CONCATENATED MODULE: ./src/js/subscriber/red5pro-source-handler-rtc.js


function red5pro_source_handler_rtc_typeof(obj) { "@babel/helpers - typeof"; return red5pro_source_handler_rtc_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, red5pro_source_handler_rtc_typeof(obj); }
function red5pro_source_handler_rtc_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function red5pro_source_handler_rtc_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, red5pro_source_handler_rtc_toPropertyKey(descriptor.key), descriptor); } }
function red5pro_source_handler_rtc_createClass(Constructor, protoProps, staticProps) { if (protoProps) red5pro_source_handler_rtc_defineProperties(Constructor.prototype, protoProps); if (staticProps) red5pro_source_handler_rtc_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function red5pro_source_handler_rtc_toPropertyKey(arg) { var key = red5pro_source_handler_rtc_toPrimitive(arg, "string"); return red5pro_source_handler_rtc_typeof(key) === "symbol" ? key : String(key); }
function red5pro_source_handler_rtc_toPrimitive(input, hint) { if (red5pro_source_handler_rtc_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (red5pro_source_handler_rtc_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function red5pro_source_handler_rtc_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) red5pro_source_handler_rtc_setPrototypeOf(subClass, superClass); }
function red5pro_source_handler_rtc_setPrototypeOf(o, p) { red5pro_source_handler_rtc_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return red5pro_source_handler_rtc_setPrototypeOf(o, p); }
function red5pro_source_handler_rtc_createSuper(Derived) { var hasNativeReflectConstruct = red5pro_source_handler_rtc_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = red5pro_source_handler_rtc_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = red5pro_source_handler_rtc_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return red5pro_source_handler_rtc_possibleConstructorReturn(this, result); }; }
function red5pro_source_handler_rtc_possibleConstructorReturn(self, call) { if (call && (red5pro_source_handler_rtc_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return red5pro_source_handler_rtc_assertThisInitialized(self); }
function red5pro_source_handler_rtc_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function red5pro_source_handler_rtc_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function red5pro_source_handler_rtc_getPrototypeOf(o) { red5pro_source_handler_rtc_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return red5pro_source_handler_rtc_getPrototypeOf(o); }






var red5pro_source_handler_rtc_NAME = 'RTCSourceHandler';

/**
 * Source Handler for WebRTC-based Subscribers, which serves as a Presentation Controller between view and subscriber.
 *
 * @extends EventEmitter
 * @extends SubscriberPlaybackController
 *
 * @private
 */
var red5pro_source_handler_rtc_RTCSourceHandler = /*#__PURE__*/function (_PlaybackController) {
  red5pro_source_handler_rtc_inherits(RTCSourceHandler, _PlaybackController);
  var _super = red5pro_source_handler_rtc_createSuper(RTCSourceHandler);
  function RTCSourceHandler(media, type) {
    var _this;
    red5pro_source_handler_rtc_classCallCheck(this, RTCSourceHandler);
    _this = _super.call(this);
    _this.media = media;
    var usePlaybackControls = browser.hasAttributeDefined(_this.media, 'controls') && browser.hasClassDefined(_this.media, 'red5pro-media');
    if (usePlaybackControls) {
      _this.clone = _this.media.cloneNode(true);
      _this.parent = _this.media.parentNode;
      _this.holder = _this._determineHolder(_this.media);
    }
    _this.playerType = type;
    _this._isVOD = false;
    _this._controls = undefined;
    _this._playbackNotificationCenter = _this.media;
    browser.onFullScreenStateChange(_this._handleFullScreenChange.bind(red5pro_source_handler_rtc_assertThisInitialized(_this)));
    return _this;
  }

  /**
   * Established DOM Element order for playback.
   *
   * @param {Element} media
   *        The target media element: e.g., `video` or `audio`.
   *
   * @private
   */
  red5pro_source_handler_rtc_createClass(RTCSourceHandler, [{
    key: "_determineHolder",
    value: function _determineHolder(media) {
      if (media.parentNode.classList.contains('red5pro-media-container')) {
        return media.parentNode;
      } else {
        var parent = media.parentNode;
        var div = browser.createElement('div');
        div.classList.add('red5pro-media-container');
        parent.insertBefore(div, media);
        parent.removeChild(media);
        div.appendChild(media);
        return div;
      }
    }

    /**
     * Established DOM Element order for playback.
     *
     * @param {Element} media
     *        The target media element: e.g., `video` or `audio`.
     *
     * @private
     */
  }, {
    key: "_cleanUp",
    value: function _cleanUp() {
      if (!this.clone) return;

      // Return to prior DOM manipulation.
      var el = this.media;
      var elParent = el.parentNode;
      var mediaHolder = this.holder;
      if (elParent) {
        elParent.removeChild(el);
        // The object parent could be a wrapper child in the original parent element.
        if (elParent !== this.parent) {
          elParent.parentNode.removeChild(elParent);
          mediaHolder = this.parent;
        }
      } else {
        try {
          el.remove();
        } catch (e) {
          log_warn(red5pro_source_handler_rtc_NAME, "Issue in DOM cleanup of WebRTC video object: ".concat(e.message));
        }
      }
      this.media = this.clone.cloneNode(true);
      mediaHolder.appendChild(this.media);
      if (this._controls) {
        this._controls.detach();
      }
    }

    /**
     * Assigns and handlers event notificiations coming from the media notifier (e.g., `video` or `audio` element).
     *
     * @param {Object} notifier
     *
     * @private
     */
  }, {
    key: "_addPlaybackHandlers",
    value: function _addPlaybackHandlers(notifier) {
      var _this2 = this;
      var controls = this.getControls();
      var hasControls = typeof controls !== 'undefined';
      notifier.oncanplay = function () {
        log_debug(red5pro_source_handler_rtc_NAME, '[videoelement:event] canplay');
        if (controls) {
          controls.enable(true);
        }
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
          code: PlaybackState.AVAILABLE,
          state: PlaybackStateReadable[PlaybackState.AVAILABLE]
        }));
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.VOLUME_CHANGE, undefined, {
          volume: notifier.volume
        }));
      };
      notifier.ondurationchange = function (event) {
        // eslint-disable-line no-unused-vars
        log_debug(red5pro_source_handler_rtc_NAME, '[videoelement:event] durationchange');
        if (!isNaN(notifier.duration) && Number.isFinite(notifier.duration)) {
          _this2.isVOD = true;
        }
        if (hasControls) {
          controls.setPlaybackDuration(notifier.duration);
        }
      };
      notifier.onended = function () {
        log_debug(red5pro_source_handler_rtc_NAME, '[videoelement:event] ended');
        if (hasControls) {
          controls.setState(PlaybackState.IDLE);
        }
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
          code: PlaybackState.IDLE,
          state: PlaybackStateReadable[PlaybackState.IDLE]
        }));
      };
      notifier.ontimeupdate = function (event) {
        // eslint-disable-line no-unused-vars
        if (hasControls) {
          controls.setSeekTime(notifier.currentTime, self.isVOD ? notifier.duration : undefined);
        }
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.PLAYBACK_TIME_UPDATE, undefined, {
          time: notifier.currentTime,
          duration: notifier.duration
        }));
      };
      notifier.onseeked = function (event) {// eslint-disable-line no-unused-vars
        //      debug(NAME, 'Seeked.')
      };
      notifier.onseeking = function (event) {// eslint-disable-line no-unused-vars
        //      debug(NAME, 'Seeking.')
      };
      notifier.onplay = function () {
        log_debug(red5pro_source_handler_rtc_NAME, '[videoelement:event] play');
        if (hasControls) {
          controls.setState(PlaybackState.PLAYING);
        }
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
          code: PlaybackState.PLAYING,
          state: PlaybackStateReadable[PlaybackState.PLAYING]
        }));
      };
      notifier.onpause = function () {
        log_debug(red5pro_source_handler_rtc_NAME, '[videoelement:event] pause');
        if (hasControls) {
          controls.setState(PlaybackState.PAUSED);
        }
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
          code: PlaybackState.PAUSED,
          state: PlaybackStateReadable[PlaybackState.PAUSED]
        }));
      };
      notifier.onvolumechange = function (event) {
        // eslint-disable-line no-unused-vars
        if (hasControls && controls.getVolume() !== _this2.media.volume) {
          controls.setVolume(_this2.media.volume);
        }
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.VOLUME_CHANGE, undefined, {
          volume: notifier.muted ? 0 : notifier.volume
        }));
      };
      // for debugging purposes.
      notifier.onencrypted = function () {
        log_debug(red5pro_source_handler_rtc_NAME, '[videoelement:event] encrypted');
      };
      notifier.onemptied = function () {
        log_debug(red5pro_source_handler_rtc_NAME, '[videoelement:event] emptied');
      };
      notifier.onloadeddata = function () {
        log_debug(red5pro_source_handler_rtc_NAME, '[videoelement:event] loadeddata');
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.VIDEO_DIMENSIONS_CHANGE, undefined, {
          width: _this2.media.videoWidth,
          height: _this2.media.videoHeight
        }));
      };
      notifier.onresize = function () {
        log_debug(red5pro_source_handler_rtc_NAME, '[videoelement:event] resize');
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.VIDEO_DIMENSIONS_CHANGE, undefined, {
          width: _this2.media.videoWidth,
          height: _this2.media.videoHeight
        }));
      };
      notifier.onloadedmetadata = function () {
        log_debug(red5pro_source_handler_rtc_NAME, '[videoelement:event] loadedmetadata');
      };
      notifier.onloadstart = function () {
        log_debug(red5pro_source_handler_rtc_NAME, '[videoelement:event] loadedstart');
      };
      notifier.onstalled = function () {
        log_debug(red5pro_source_handler_rtc_NAME, '[videoelement:event] stalled');
      };
      notifier.onsuspend = function () {
        log_debug(red5pro_source_handler_rtc_NAME, '[videoelement:event] suspend');
      };
      notifier.onwaiting = function () {
        log_debug(red5pro_source_handler_rtc_NAME, '[videoelement:event] waiting');
      };
      //    notifier.onprogress = () => { debug(NAME, '[videoelement:event] progress. Played: ' + notifier.played.length + ', Buffered: ' + notifier.buffered.length + '.') }
    }

    /**
     * Event handler for change in fullscreen state.
     *
     * @param {Boolean} isFullScreen
     *
     * @private
     */
  }, {
    key: "_handleFullScreenChange",
    value: function _handleFullScreenChange(isFullScreen) {
      if (isFullScreen) {
        if (this.holder) {
          this.holder.classList.add('red5pro-media-container-full-screen');
        }
        this.media.classList.add('red5pro-media-container-full-screen');
      } else {
        if (this.holder) {
          this.holder.classList.remove('red5pro-media-container-full-screen');
        }
        this.media.classList.remove('red5pro-media-container-full-screen');
      }
      this.trigger(new SubscriberEvent(SubscriberEventTypes.FULL_SCREEN_STATE_CHANGE, undefined, isFullScreen));
    }

    /**
     * Request to setup the presentation of a playback stream using WebRTC.
     *
     * @param {Object} options
     *        The initialization configuration map.
     *
     * @returns {Promise}
     */
  }, {
    key: "addSource",
    value: function addSource(options) {
      log_debug(red5pro_source_handler_rtc_NAME, '[addsource]');
      var usePlaybackControls = browser.hasAttributeDefined(this.media, 'controls') && browser.hasClassDefined(this.media, 'red5pro-media');
      if (usePlaybackControls) {
        this.holder = this._determineHolder(this.media);
      }
      var deferred = new DeferredPromise();
      var hasDefinedControls = options.controls;
      var isMuted = browser.hasAttributeDefined(this.media, 'muted');
      if (hasDefinedControls || usePlaybackControls) {
        if (hasDefinedControls) {
          this._controls = options.controls;
        } else {
          this._controls = new PlaybackControlsImpl(this, this.holder);
        }
        this.media.controls = false;
        this._controls.setAsVOD(this.isVOD);
        this._controls.setMutedState(isMuted);
      }
      this._addPlaybackHandlers(this._playbackNotificationCenter);
      deferred.resolve();
      return deferred.promise;
    }

    /**
     * Request to connect to stream.
     */
  }, {
    key: "connect",
    value: function connect() {
      log_debug(red5pro_source_handler_rtc_NAME, '[connect]');
    }
  }, {
    key: "attemptAutoplay",
    value: function attemptAutoplay() {
      var _this3 = this;
      var muteOnAutoplay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.play().catch(function (e) {
        if (muteOnAutoplay) {
          _this3.mute();
          _this3.play().then(function () {
            _this3.trigger(new SubscriberEvent(SubscriberEventTypes.AUTO_PLAYBACK_MUTED, undefined, {
              element: _this3.media
            }));
          }).catch(function (err) {
            _this3.trigger(new SubscriberEvent(SubscriberEventTypes.AUTO_PLAYBACK_FAILURE, undefined, {
              error: err.message ? err.message : err,
              element: _this3.media
            }));
          });
        } else {
          _this3.trigger(new SubscriberEvent(SubscriberEventTypes.AUTO_PLAYBACK_FAILURE, undefined, {
            error: e.message ? e.message : e,
            element: _this3.media
          }));
        }
      });
    }
  }, {
    key: "play",
    value: function play() {
      log_debug(red5pro_source_handler_rtc_NAME, '[videoelement:action] play');
      var deferred = new DeferredPromise();
      try {
        var maybePromise = this.media.play();
        if (maybePromise) {
          maybePromise.then(function () {
            log_debug(red5pro_source_handler_rtc_NAME, '[videoelement:action] play (START)');
            deferred.resolve();
          }).catch(deferred.reject);
        } else {
          log_debug(red5pro_source_handler_rtc_NAME, '[videoelement:action] play (START)');
          deferred.resolve();
        }
      } catch (e) {
        log_error(red5pro_source_handler_rtc_NAME, '[videoelement:action] play (FAULT) - ' + e.message);
        deferred.reject(e);
      }
      return deferred.promise;
    }
  }, {
    key: "pause",
    value: function pause() {
      log_debug(red5pro_source_handler_rtc_NAME, '[videoelement:action] pause');
      try {
        this.media.pause();
      } catch (e) {
        log_warn(red5pro_source_handler_rtc_NAME, '[videoelement:action] pause (CATCH::FAULT) - ' + e.message);
      }
    }
  }, {
    key: "resume",
    value: function resume() {
      log_debug(red5pro_source_handler_rtc_NAME, '[videoelement:action] resume');
      try {
        var maybePromise = this.media.play();
        if (maybePromise) {
          maybePromise.then(function () {
            return log_debug(red5pro_source_handler_rtc_NAME, '[videoelement:action] play (START)');
          }).catch(function (err) {
            return log_warn(red5pro_source_handler_rtc_NAME, '[videoelement:action] play (CATCH::FAULT) ' + (err.message ? err.message : err));
          });
        }
      } catch (e) {
        log_warn(red5pro_source_handler_rtc_NAME, '[videoelement:action] resume (CATCH::FAULT) - ' + e.message);
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      log_debug(red5pro_source_handler_rtc_NAME, '[videoelement:action] stop');
      try {
        this.media.stop();
      } catch (e) {
        // ok.
      }
    }
  }, {
    key: "mute",
    value: function mute() {
      this.media.muted = true;
      var controls = this.getControls();
      if (controls) {
        controls.setMutedState(true);
      }
    }
  }, {
    key: "unmute",
    value: function unmute() {
      this.media.muted = false;
      var controls = this.getControls();
      if (controls) {
        controls.setMutedState(false);
      }
    }
  }, {
    key: "setVolume",
    value: function setVolume(value) {
      this.unmute();
      this.media.volume = value;
    }
  }, {
    key: "seekTo",
    value: function seekTo(percentage) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      this.media.currentTime = duration ? percentage * duration : percentage;
    }
  }, {
    key: "toggleFullScreen",
    value: function toggleFullScreen() {
      try {
        if (this.holder) {
          browser.toggleFullScreen(this.holder);
        }
      } catch (e) {
        throw e;
        // nada.
      }
    }

    /**
     * Notification of current stream being in an unpublished state.
     * The stream enters an unpublished state when the broadcaster stop the stream and the subscriber is still connected.
     */
  }, {
    key: "unpublish",
    value: function unpublish() {
      try {
        this.stop();
        this.media.onended.call(this.media);
      } catch (e) {
        // nada.
      }
    }

    /**
     * Request to disconnect playback.
     */
  }, {
    key: "disconnect",
    value: function disconnect() {
      this._cleanUp();
    }

    /**
     * Responder to change in orientation received through metadata.
     *
     * @param {Number} orientation
     *        The orientation value.
     *
     * @private
     */
  }, {
    key: "handleOrientationChange",
    value: function handleOrientationChange(orientation) {
      if (this._controls && orientation % 180 !== 0) {
        if (this.holder) {
          this.holder.classList.add('red5pro-media-background');
        }
        this.media.classList.remove('red5pro-media-background');
      }
    }

    /*
     * || SHARED OBJECT INTEGRATION NOT AVAILABLE FOR HLS PLAYBACK ||
     */
    // eslint-disable-next-line no-unused-vars
  }, {
    key: "addSharedObjectResponseHandler",
    value: function addSharedObjectResponseHandler(handler) {}

    // eslint-disable-next-line no-unused-vars
  }, {
    key: "removeSharedObjectResponseHandler",
    value: function removeSharedObjectResponseHandler(handler) {}

    // eslint-disable-next-line no-unused-vars
  }, {
    key: "sendToSharedObject",
    value: function sendToSharedObject(name, callName, message) {}

    // eslint-disable-next-line no-unused-vars
  }, {
    key: "sendPropertyToSharedObject",
    value: function sendPropertyToSharedObject(name, key, value) {}

    // eslint-disable-next-line no-unused-vars
  }, {
    key: "getRemoteSharedObject",
    value: function getRemoteSharedObject(sharedObjectName) {}

    // eslint-disable-next-line no-unused-vars
  }, {
    key: "connectToSharedObject",
    value: function connectToSharedObject(sharedObjectName) {}

    // eslint-disable-next-line no-unused-vars
  }, {
    key: "closeSharedObject",
    value: function closeSharedObject(sharedObjectName) {}

    /**
     * Returns playback controls if available.
     *
     * @returns {PlaybackControls}
     */
  }, {
    key: "getControls",
    value: function getControls() {
      return this._controls;
    }

    /**
     * Returns the subscriber type associated with this controller.
     *
     * @returns {String}
     */
  }, {
    key: "getType",
    value: function getType() {
      return this.playerType;
    }

    /**
     * Returns flag of video being recognized as VOD (Video On Demand).
     *
     * @returns {Boolean}
     */
  }, {
    key: "isVOD",
    get: function get() {
      return this._isVOD;
    }

    /**
     * Sets flag of video being considered as VOD (Video On Demand).
     *
     * @param {Boolean} value
     */,
    set: function set(value) {
      this._isVOD = value;
      if (this._controls) {
        this._controls.setAsVOD(value);
      }
    }
  }]);
  return RTCSourceHandler;
}(PlaybackController);
/* harmony default export */ var red5pro_source_handler_rtc = (red5pro_source_handler_rtc_RTCSourceHandler);
// CONCATENATED MODULE: ./src/js/subscriber/red5pro-source-handler-rtc-seekable.js


function red5pro_source_handler_rtc_seekable_typeof(obj) { "@babel/helpers - typeof"; return red5pro_source_handler_rtc_seekable_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, red5pro_source_handler_rtc_seekable_typeof(obj); }
function red5pro_source_handler_rtc_seekable_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function red5pro_source_handler_rtc_seekable_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, red5pro_source_handler_rtc_seekable_toPropertyKey(descriptor.key), descriptor); } }
function red5pro_source_handler_rtc_seekable_createClass(Constructor, protoProps, staticProps) { if (protoProps) red5pro_source_handler_rtc_seekable_defineProperties(Constructor.prototype, protoProps); if (staticProps) red5pro_source_handler_rtc_seekable_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function red5pro_source_handler_rtc_seekable_toPropertyKey(arg) { var key = red5pro_source_handler_rtc_seekable_toPrimitive(arg, "string"); return red5pro_source_handler_rtc_seekable_typeof(key) === "symbol" ? key : String(key); }
function red5pro_source_handler_rtc_seekable_toPrimitive(input, hint) { if (red5pro_source_handler_rtc_seekable_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (red5pro_source_handler_rtc_seekable_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function red5pro_source_handler_rtc_seekable_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) red5pro_source_handler_rtc_seekable_setPrototypeOf(subClass, superClass); }
function red5pro_source_handler_rtc_seekable_setPrototypeOf(o, p) { red5pro_source_handler_rtc_seekable_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return red5pro_source_handler_rtc_seekable_setPrototypeOf(o, p); }
function red5pro_source_handler_rtc_seekable_createSuper(Derived) { var hasNativeReflectConstruct = red5pro_source_handler_rtc_seekable_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = red5pro_source_handler_rtc_seekable_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = red5pro_source_handler_rtc_seekable_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return red5pro_source_handler_rtc_seekable_possibleConstructorReturn(this, result); }; }
function red5pro_source_handler_rtc_seekable_possibleConstructorReturn(self, call) { if (call && (red5pro_source_handler_rtc_seekable_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return red5pro_source_handler_rtc_seekable_assertThisInitialized(self); }
function red5pro_source_handler_rtc_seekable_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function red5pro_source_handler_rtc_seekable_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function red5pro_source_handler_rtc_seekable_getPrototypeOf(o) { red5pro_source_handler_rtc_seekable_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return red5pro_source_handler_rtc_seekable_getPrototypeOf(o); }






var red5pro_source_handler_rtc_seekable_NAME = 'RTCSeekableSourceHandler';
var MAX_TS = 6;
/**
 * Source Handler for WebRTC-based Subscribers, which serves as a Presentation Controller between view and subscriber.
 *
 * @extends EventEmitter
 * @extends SubscriberPlaybackController
 *
 * @private
 */
var red5pro_source_handler_rtc_seekable_RTCSeekableSourceHandler = /*#__PURE__*/function (_PlaybackController) {
  red5pro_source_handler_rtc_seekable_inherits(RTCSeekableSourceHandler, _PlaybackController);
  var _super = red5pro_source_handler_rtc_seekable_createSuper(RTCSeekableSourceHandler);
  function RTCSeekableSourceHandler(media, type) {
    var _this;
    red5pro_source_handler_rtc_seekable_classCallCheck(this, RTCSeekableSourceHandler);
    _this = _super.call(this);
    _this.media = media;
    var usePlaybackControls = true; // force true.
    if (usePlaybackControls) {
      _this.clone = _this.media.cloneNode(true);
      _this.parent = _this.media.parentNode;
      _this.holder = _this._determineHolder(_this.media);
    }
    _this.playerType = type;
    _this._isVOD = false;
    _this._isSeekable = false; // can be seekable but not VOD when doing live scrub.
    _this._isHLSPlaybackActive = false; // when we have switched over to VOD playback.
    _this._isFragLoading = false; // when scrubbed and loading landed fragment.
    _this._hlsRecoverFlop = false; // https://github.com/video-dev/hls.js/blob/master/docs/API.md#hlsswapaudiocodec
    _this._hlsRecoverAttempts = 0;
    _this._lastDurationUpdate = 0; // the currentTime of the RTC stream when switched to live playback.
    _this._controls = undefined;
    _this._resizeObserver = undefined;
    _this._playbackNotificationCenter = _this.media;
    browser.onFullScreenStateChange(_this._handleFullScreenChange.bind(red5pro_source_handler_rtc_seekable_assertThisInitialized(_this)));

    // Live Seek HLS Support
    // Possible HLS.JS instance.
    _this.hls = undefined;
    // The DOMElement for HLS playback.
    _this.hlsElement = undefined;
    return _this;
  }

  /**
   * Established DOM Element order for playback.
   *
   * @param {Element} media
   *        The target media element: e.g., `video` or `audio`.
   *
   * @private
   */
  red5pro_source_handler_rtc_seekable_createClass(RTCSeekableSourceHandler, [{
    key: "_determineHolder",
    value: function _determineHolder(media) {
      if (media.parentNode.classList.contains('red5pro-media-container')) {
        return media.parentNode;
      } else {
        var parent = media.parentNode;
        var div = browser.createElement('div');
        div.classList.add('red5pro-media-container');
        parent.insertBefore(div, media);
        parent.removeChild(media);
        div.appendChild(media);
        return div;
      }
    }

    /**
     * Generates video element for HLS playback and adds it in container properly ordered.
     *
     * @param {DOMElement} holder
     * @param {DOMElement} media
     *
     * @returns DOMElement
     */
  }, {
    key: "_generateHLSLivePlayback",
    value: function _generateHLSLivePlayback(holder, media) {
      var id = 'red5pro-hls-vod';
      var hlsElement = document.querySelector("#".concat(id));
      if (!hlsElement) {
        hlsElement = document.createElement('video');
        hlsElement.id = 'red5pro-hls-vod';
        hlsElement.playsinline = 'playsinline';
        hlsElement.style.width = '100%'; // `${media.clientWidth}px`
        hlsElement.style.height = '100%'; // `${media.clientHeight}px`
        hlsElement.style.position = 'absolute';
        hlsElement.style.display = 'none';
        holder.insertBefore(hlsElement, media);
        // eslint-disable-next-line no-undef
        //       this._resizeObserver = new ResizeObserver((entries) => {
        //         for (const entry of entries) {
        //           if (entry.contentRect) {
        // //            hlsElement.style.width = `${entry.contentRect.width}px`
        // //            hlsElement.style.height = `${entry.contentRect.height}px`
        //           }
        //         }
        //       })
        //       this._resizeObserver.observe(media)
      }

      return hlsElement;
    }
  }, {
    key: "_showHLSLivePlayback",
    value: function _showHLSLivePlayback(flag, hlsMedia, media, holder) {
      if (this._isHLSPlaybackActive === flag) {
        return;
      }
      this._isHLSPlaybackActive = flag;
      var isMuted = flag ? media.muted : hlsMedia.muted;
      if (flag) {
        hlsMedia.volume = media.volume;
        hlsMedia.muted = isMuted;
        media.muted = true;
        hlsMedia.style.display = 'inline-block';
        media.style.display = 'none';
        holder.style.position = 'relative';
      } else {
        media.volume = hlsMedia.volume;
        hlsMedia.muted = true;
        media.muted = isMuted;
        media.style.display = 'inline-block';
        try {
          if (!hlsMedia.paused) {
            this.pause(true);
            this.play();
          } else {
            this.pause(false);
          }
        } catch (e) {
          log_warn("Could not start playback: ".concat(e.message, "."));
        }
        hlsMedia.style.display = 'none';
      }
    }

    /**
     * Established DOM Element order for playback.
     *
     * @param {Element} media
     *        The target media element: e.g., `video` or `audio`.
     *
     * @private
     */
  }, {
    key: "_cleanUp",
    value: function _cleanUp() {
      if (!this.clone) return;

      // Return to prior DOM manipulation.
      var el = this.media;
      var elParent = el.parentNode;
      var mediaHolder = this.holder;
      this._removePlaybackHandlers(el);
      // Note: enableLiveSeek requires custom controls, so we should always arrive here.
      if (this.hls) {
        this.hls.detachMedia();
        this.hls = undefined;
      }
      if (this.hlsElement) {
        this._removeSeekableHandlers(this.hlsElement);
        if (this.hlsElement.parentNode) {
          this.hlsElement.parentNode.removeChild(this.hlsElement);
        }
        this.hlsElement = undefined;
      }
      if (this._controls) {
        this._controls.detach();
        this._controls = undefined;
      }
      if (elParent) {
        elParent.removeChild(el);
        // The object parent could be a wrapper child in the original parent element.
        if (elParent !== this.parent) {
          elParent.parentNode.removeChild(elParent);
          mediaHolder = this.parent;
        }
      } else {
        try {
          el.remove();
        } catch (e) {
          log_warn(red5pro_source_handler_rtc_seekable_NAME, "Issue in DOM cleanup of WebRTC video object: ".concat(e.message));
        }
      }
      this.media = this.clone.cloneNode(true);
      mediaHolder.appendChild(this.media);
      if (this._resizeObserver) {
        this._resizeObserver.unobserve();
        this._resizeObserver = undefined;
      }
      this._isVOD = false;
      this._isSeekable = false;
      this._isHLSPlaybackActive = false;
      this._isFragLoading = false;
      this._hlsRecoverFlop = false;
      this._hlsRecoverAttempts = 0;
    }

    /**
     * Assigns and handlers event notificiations coming from the media notifier (e.g., `video` or `audio` element).
     *
     * @param {Object} notifier
     *
     * @private
     */
  }, {
    key: "_addPlaybackHandlers",
    value: function _addPlaybackHandlers(notifier) {
      var _this2 = this;
      var controls = this.getControls();
      notifier.oncanplay = function () {
        log_debug(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:event] canplay');
        if (controls) {
          controls.enable(true);
        }
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
          code: PlaybackState.AVAILABLE,
          state: PlaybackStateReadable[PlaybackState.AVAILABLE]
        }));
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.VOLUME_CHANGE, undefined, {
          volume: notifier.volume
        }));
      };
      notifier.onended = function () {
        return _this2._onRTCEnded.bind(_this2);
      };
      notifier.ondurationchange = this._onRTCDurationChange.bind(this);
      notifier.ontimeupdate = this._onRTCTimeUpdate.bind(this);
      notifier.onplay = this._onRTCPlay.bind(this);
      notifier.onpause = this._onRTCPause.bind(this);
      notifier.onvolumechange = function (event) {
        // eslint-disable-line no-unused-vars
        if (controls.getVolume() !== _this2.media.volume) {
          controls.setVolume(_this2.media.volume);
        }
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.VOLUME_CHANGE, undefined, {
          volume: notifier.muted ? 0 : notifier.volume
        }));
      };
      // for debugging purposes.
      notifier.onencrypted = function () {
        log_debug(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:event] encrypted');
      };
      notifier.onemptied = function () {
        log_debug(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:event] emptied');
      };
      notifier.onloadeddata = function () {
        log_debug(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:event] loadeddata');
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.VIDEO_DIMENSIONS_CHANGE, undefined, {
          width: _this2.media.videoWidth,
          height: _this2.media.videoHeight
        }));
      };
      notifier.onresize = function () {
        log_debug(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:event] resize');
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.VIDEO_DIMENSIONS_CHANGE, undefined, {
          width: _this2.media.videoWidth,
          height: _this2.media.videoHeight
        }));
      };
      notifier.onloadedmetadata = function () {
        log_debug(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:event] loadedmetadata');
      };
      notifier.onloadstart = function () {
        log_debug(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:event] loadedstart');
      };
      notifier.onstalled = function () {
        log_debug(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:event] stalled');
      };
      notifier.onsuspend = function () {
        log_debug(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:event] suspend');
      };
      notifier.onwaiting = function () {
        log_debug(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:event] waiting');
      };
      //    notifier.onprogress = () => { debug(NAME, '[videoelement:event] progress. Played: ' + notifier.played.length + ', Buffered: ' + notifier.buffered.length + '.') }
    }
  }, {
    key: "_removePlaybackHandlers",
    value: function _removePlaybackHandlers(notifier) {
      notifier.oncanplay = undefined;
      notifier.onended = undefined;
      notifier.ondurationchange = undefined;
      notifier.ontimeupdate = undefined;
      notifier.onplay = undefined;
      notifier.onpause = undefined;
      notifier.onvolumechange = undefined;
      notifier.onencrypted = undefined;
      notifier.onemptied = undefined;
      notifier.onloadeddata = undefined;
      notifier.onresize = undefined;
      notifier.onloadedmetadata = undefined;
      notifier.onloadstart = undefined;
      notifier.onstalled = undefined;
      notifier.onsuspend = undefined;
      notifier.onwaiting = undefined;
    }
  }, {
    key: "_addSeekableHandlers",
    value: function _addSeekableHandlers(element, control) {
      var _this3 = this;
      if (control) {
        // HLS.JS
        // eslint-disable-next-line no-unused-vars
        control.on(browser.getHLSClientEventEnum().ERROR, function (event, data) {
          var type = data.type,
            details = data.details,
            fatal = data.fatal,
            url = data.url;
          if (type.toLowerCase() === 'networkerror') {
            if (details.toLowerCase() === 'levelemptyerror') {
              _this3.trigger(new SubscriberEvent(RTCSubscriberEventTypes.LIVE_SEEK_DISABLED, undefined, {
                hlsElement: element,
                hlsControl: control
              }));
              _this3.isSeekable = false;
              // Try, try again.
              control.destroy();
              var t = setTimeout(function () {
                clearTimeout(t);
                _this3.enableLiveSeek(url, false);
              }, 3000);
              return;
            } else {
              _this3.trigger(new SubscriberEvent(RTCSubscriberEventTypes.LIVE_SEEK_ERROR, undefined, {
                hlsElement: element,
                hlsControl: control,
                error: data
              }));
            }
          } else {
            _this3.trigger(new SubscriberEvent(RTCSubscriberEventTypes.LIVE_SEEK_ERROR, undefined, {
              hlsElement: element,
              hlsControl: control,
              error: data
            }));
          }
          if (type.toLowerCase() === 'mediaerror') {
            if (_this3._hlsRecoverFlop) {
              control.swapAudioCodec();
            }
            _this3._hlsRecoverFlop = !_this3._hlsRecoverFlop;
            _this3._hlsRecoverAttempts = _this3._hlsRecoverAttempts + 1;
            control.recoverMediaError();
          }
          if (fatal && type.toLowerCase() === 'networkerror') {
            control.startLoad();
          }
        });
        control.on(browser.getHLSClientEventEnum().MANIFEST_PARSED, function () {
          // console.log(data.levels[0].details.fragments)
          try {
            element.pause();
          } catch (e) {
            log_debug(red5pro_source_handler_rtc_seekable_NAME, "Could not pause seekable live stream: ".concat(e.message));
          }
          _this3.isSeekable = true;
          _this3.trigger(new SubscriberEvent(RTCSubscriberEventTypes.LIVE_SEEK_ENABLED, undefined, {
            hlsElement: element,
            hlsControl: control
          }));
        });
        control.on(browser.getHLSClientEventEnum().FRAG_LOAD_PROGRESS, function (event, data) {
          var _data$stats = data.stats,
            loaded = _data$stats.loaded,
            total = _data$stats.total;
          _this3.trigger(new SubscriberEvent(RTCSubscriberEventTypes.LIVE_SEEK_LOADING, undefined, {
            hlsElement: element,
            hlsControl: control,
            progress: loaded / total * 100
          }));
          if (!_this3.isHLSPlaybackActive && !_this3._isFragLoading) return;
          _this3._isFragLoading = loaded / total >= 1;
        });
        // control.on(environment.getHLSClientEventEnum().FRAG_LOAD_PROGRESS, (event, data) => {
        //   console.log('LiveSeek', data)
        // })
        control.on(browser.getHLSClientEventEnum().FRAG_LOADED, function (event, data) {
          _this3._isFragLoading = false;
          if (!_this3.isHLSPlaybackActive) {
            var endDTS = data.frag.endDTS;
            if (!endDTS) return;
            var offset = MAX_TS;
            //          controls.setPlaybackDuration(endDTS + offset)
            log_debug(red5pro_source_handler_rtc_seekable_NAME, "fragload, [HLS:videoelement:duration] ".concat(endDTS, " + ").concat(offset));
          }
          _this3.trigger(new SubscriberEvent(RTCSubscriberEventTypes.LIVE_SEEK_LOADED, undefined, {
            hlsElement: element,
            hlsControl: control
          }));
        });
      }
      element.ondurationchange = this._onHLSDurationChange.bind(this);
      element.ontimeupdate = this._onHLSTimeUpdate.bind(this);
      element.onplay = this._onHLSPlay.bind(this);
      element.onpause = this._onHLSPause.bind(this);
    }
  }, {
    key: "_removeSeekableHandlers",
    value: function _removeSeekableHandlers(element) {
      element.ondurationchange = undefined;
      element.ontimeupdate = undefined;
      element.onplay = undefined;
      element.onpause = undefined;
    }
  }, {
    key: "_onRTCEnded",
    value: function _onRTCEnded() {
      log_debug(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:event] ended');
      // Note: If scrubbed, we are playing HLS VOD at a specific fragment and not live playback.
      if (this.isHLSPlaybackActive) {
        return;
      }
      this.getControls().setState(PlaybackState.IDLE);
      this.trigger(new SubscriberEvent(SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
        code: PlaybackState.IDLE,
        state: PlaybackStateReadable[PlaybackState.IDLE]
      }));
    }
  }, {
    key: "_onRTCDurationChange",
    value: function _onRTCDurationChange(event) {
      var element = event.target;
      log_debug(red5pro_source_handler_rtc_seekable_NAME, 'video, [videoelement:event] durationchange (' + element.duration + ')');
      if (!this.isSeekable) {
        this.getControls().setPlaybackDuration(element.duration);
      }
    }
  }, {
    key: "_onRTCTimeUpdate",
    value: function _onRTCTimeUpdate(event) {
      var element = event.target;
      if (this.isSeekable) {
        if (!this._isHLSPlaybackActive) {
          var hlsDuration = this.hlsElement.duration;
          var offset = element.currentTime - this._lastDurationUpdate;
          var time = isNaN(hlsDuration) || hlsDuration === 0 ? element.currentTime : hlsDuration + MAX_TS + offset;
          this.getControls().setSeekTime(time, time);
          this.trigger(new SubscriberEvent(SubscriberEventTypes.PLAYBACK_TIME_UPDATE, undefined, {
            time: time,
            duration: time
          }));
        }
      } else if (!this.isSeekable) {
        this.getControls().setSeekTime(element.currentTime, undefined);
        this.trigger(new SubscriberEvent(SubscriberEventTypes.PLAYBACK_TIME_UPDATE, undefined, {
          time: element.currentTime,
          duration: element.duration
        }));
      }
    }
  }, {
    key: "_onRTCPlay",
    value: function _onRTCPlay() {
      log_debug(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:event] play');
      this.getControls().setState(PlaybackState.PLAYING);
      this.trigger(new SubscriberEvent(SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
        code: PlaybackState.PLAYING,
        state: PlaybackStateReadable[PlaybackState.PLAYING]
      }));
    }
  }, {
    key: "_onRTCPause",
    value: function _onRTCPause() {
      log_debug(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:event] pause');
      this.getControls().setState(PlaybackState.PAUSED);
      this.trigger(new SubscriberEvent(SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
        code: PlaybackState.PAUSED,
        state: PlaybackStateReadable[PlaybackState.PAUSED]
      }));
    }
  }, {
    key: "_onHLSDurationChange",
    value: function _onHLSDurationChange(event) {
      var element = event.target;
      var offset = MAX_TS;
      this._lastDurationUpdate = this.media.currentTime;
      log_debug(red5pro_source_handler_rtc_seekable_NAME, "[HLS:videoelement:duration] ".concat(element.duration, ", ").concat(offset));
      this.getControls().setPlaybackDuration(element.duration + offset);
    }
  }, {
    key: "_onHLSTimeUpdate",
    value: function _onHLSTimeUpdate(event) {
      var element = event.target;
      var controls = this.getControls();
      controls.setSeekTime(element.currentTime, controls.getPlaybackDuration());
      if (element.currentTime >= element.duration) {
        this._showHLSLivePlayback(false, this.hlsElement, this.media, this.holder);
      }
    }
  }, {
    key: "_onHLSPlay",
    value: function _onHLSPlay() {
      log_debug(red5pro_source_handler_rtc_seekable_NAME, '[HLS:videoelement:event] play');
      this.getControls().setState(PlaybackState.PLAYING);
      this.trigger(new SubscriberEvent(SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
        code: PlaybackState.PLAYING,
        state: PlaybackStateReadable[PlaybackState.PLAYING]
      }));
    }
  }, {
    key: "_onHLSPause",
    value: function _onHLSPause() {
      log_debug(red5pro_source_handler_rtc_seekable_NAME, '[HLS:videoelement:event] pause');
      this.getControls().setState(PlaybackState.PAUSED);
      this.trigger(new SubscriberEvent(SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
        code: PlaybackState.PAUSED,
        state: PlaybackStateReadable[PlaybackState.PAUSED]
      }));
    }

    /**
     * Event handler for change in fullscreen state.
     *
     * @param {Boolean} isFullScreen
     *
     * @private
     */
  }, {
    key: "_handleFullScreenChange",
    value: function _handleFullScreenChange(isFullScreen) {
      if (isFullScreen) {
        if (this.holder) {
          this.holder.classList.add('red5pro-media-container-full-screen');
        }
        if (this.hlsElement) {
          this.hlsElement.classList.add('red5pro-media-container-full-screen');
        }
        this.media.classList.add('red5pro-media-container-full-screen');
      } else {
        if (this.holder) {
          this.holder.classList.remove('red5pro-media-container-full-screen');
        }
        if (this.hlsElement) {
          this.hlsElement.classList.remove('red5pro-media-container-full-screen');
        }
        this.media.classList.remove('red5pro-media-container-full-screen');
      }
      this.trigger(new SubscriberEvent(SubscriberEventTypes.FULL_SCREEN_STATE_CHANGE, undefined, isFullScreen));
    }

    /**
     * Request to setup the presentation of a playback stream using WebRTC.
     *
     * @param {Object} options
     *        The initialization configuration map.
     *
     * @returns {Promise}
     */
  }, {
    key: "addSource",
    value: function addSource(options) {
      log_debug(red5pro_source_handler_rtc_seekable_NAME, '[addsource]');
      // Forcing custom controls on Seekable implementation.
      this.media.controls = true;
      this.media.classList.add('red5pro-media');
      var usePlaybackControls = browser.hasAttributeDefined(this.media, 'controls') && browser.hasClassDefined(this.media, 'red5pro-media');
      if (usePlaybackControls) {
        this.holder = this._determineHolder(this.media);
      }
      var deferred = new DeferredPromise();
      var hasDefinedControls = options.controls;
      var isMuted = browser.hasAttributeDefined(this.media, 'muted');
      if (hasDefinedControls || usePlaybackControls) {
        if (hasDefinedControls) {
          this._controls = options.controls;
        } else {
          this._controls = new PlaybackControlsImpl(this, this.holder);
        }
        this.media.controls = false;
        this._controls.setAsVOD(this.isSeekable);
        this._controls.setMutedState(isMuted);
      }
      this._addPlaybackHandlers(this._playbackNotificationCenter);
      deferred.resolve();
      return deferred.promise;
    }

    /**
     * Request to connect to stream.
     */
  }, {
    key: "connect",
    value: function connect() {
      log_debug(red5pro_source_handler_rtc_seekable_NAME, '[connect]');
    }
  }, {
    key: "attemptAutoplay",
    value: function attemptAutoplay() {
      var _this4 = this;
      var muteOnAutoplay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.play().catch(function (e) {
        if (muteOnAutoplay) {
          _this4.mute();
          _this4.play().then(function () {
            _this4.trigger(new SubscriberEvent(SubscriberEventTypes.AUTO_PLAYBACK_MUTED, undefined, {
              element: _this4.media
            }));
          }).catch(function (err) {
            _this4.trigger(new SubscriberEvent(SubscriberEventTypes.AUTO_PLAYBACK_FAILURE, undefined, {
              error: err.message ? err.message : err,
              element: _this4.media
            }));
          });
        } else {
          _this4.trigger(new SubscriberEvent(SubscriberEventTypes.AUTO_PLAYBACK_FAILURE, undefined, {
            error: e.message ? e.message : e,
            element: _this4.media
          }));
        }
      });
    }

    // eslint-disable-next-line no-unused-vars
  }, {
    key: "enableLiveSeek",
    value: function enableLiveSeek(hlsURL, hasNativeSupport) {
      var controls = this.getControls();
      controls.setSeekTime(1, 1);
      this.hlsElement = this._generateHLSLivePlayback(this.holder, this.media);
      this._showHLSLivePlayback(this.isHLSPlaybackActive, this.hlsElement, this.media, this.holder);
      // Enforce HLS.JS on Safari as well.
      /*
      if (hasNativeSupport) {
        this._addSeekableHandlers(this.hlsElement, null)
        this.hlsElement.controls = true
        let src = document.createElement('source')
        src.src = hlsURL
        this.hlsElement.appendChild(src)
        this.isSeekable = true
      } else {
      */
      var hls = browser.createHLSClient({
        debug: true,
        backBufferLength: 0
      });
      this._addSeekableHandlers(this.hlsElement, hls);
      hls.attachMedia(this.hlsElement);
      hls.on(browser.getHLSClientEventEnum().MEDIA_ATTACHED, function () {
        hls.loadSource(hlsURL);
      });
      this.hls = hls;
      window.r5pro_hls_control = this.hls;
      /*
      }
      */
    }
  }, {
    key: "play",
    value: function play() {
      var fromControls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      log_debug(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:action] play');
      var deferred = new DeferredPromise();
      try {
        var maybePromise;
        if (fromControls && this.hlsElement && this.hlsElement.paused) {
          maybePromise = this.hlsElement.play();
        } else {
          maybePromise = this.media.play();
        }
        if (maybePromise) {
          maybePromise.then(function () {
            log_debug(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:action] play (START)');
            deferred.resolve();
          }).catch(deferred.reject);
        } else {
          log_debug(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:action] play (START)');
          deferred.resolve();
        }
      } catch (e) {
        log_error(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:action] play (FAULT) - ' + e.message);
        deferred.reject(e);
      }
      return deferred.promise;
    }
  }, {
    key: "pause",
    value: function pause() {
      var fromControls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var fromActionSeek = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      log_debug(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:action] pause');
      try {
        if (fromControls && fromActionSeek && this.hlsElement) {
          this.hlsElement.pause();
          this.media.pause();
        } else if (fromControls && !this.hlsElement.paused && this.hlsElement) {
          this.hlsElement.pause();
        } else {
          this.media.pause();
        }
      } catch (e) {
        log_warn(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:action] pause (CATCH::FAULT) - ' + e.message);
      }
    }
  }, {
    key: "resume",
    value: function resume() {
      var fromControls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      log_debug(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:action] resume');
      try {
        var maybePromise = this.isHLSPlaybackActive && this.hlsElement ? this.hlsElement.play() : this.media.play();
        if (fromControls && this.isHLSPlaybackActive) {
          this.media.play().catch(function (err) {
            return log_warn(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:action] play (CATCH::FAULT) ' + (err.message ? err.message : err));
          });
        }
        if (maybePromise) {
          maybePromise.then(function () {
            return log_debug(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:action] play (START)');
          }).catch(function (err) {
            return log_warn(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:action] play (CATCH::FAULT) ' + (err.message ? err.message : err));
          });
        }
      } catch (e) {
        log_warn(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:action] resume (CATCH::FAULT) - ' + e.message);
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      log_debug(red5pro_source_handler_rtc_seekable_NAME, '[videoelement:action] stop');
      try {
        if (this.hlsElement) {
          this.hlsElement.stop();
        }
        this.media.stop();
      } catch (e) {
        // ok.
      }
    }
  }, {
    key: "mute",
    value: function mute() {
      if (this.hlsElement) {
        this.hlsElement.muted = this.isHLSPlaybackActive;
      }
      this.media.muted = true;
      var controls = this.getControls();
      if (controls) {
        controls.setMutedState(true);
      }
    }
  }, {
    key: "unmute",
    value: function unmute() {
      if (this.hlsElement) {
        this.hlsElement.muted = !this.isHLSPlaybackActive;
        this.media.muted = this.isHLSPlaybackActive;
      } else {
        this.media.muted = false;
      }
      var controls = this.getControls();
      if (controls) {
        controls.setMutedState(false);
      }
    }
  }, {
    key: "setVolume",
    value: function setVolume(value) {
      this.unmute();
      if (this.hlsElement && this.isHLSPlaybackActive) {
        this.hlsElement.volume = value;
      } else {
        this.media.volume = value;
      }
    }
  }, {
    key: "seekTo",
    value: function seekTo(percentage) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      if (this.isSeekable) {
        this._controls.setSeekTime(percentage, duration);
        this.trigger(new SubscriberEvent(SubscriberEventTypes.SEEK_CHANGE, undefined, {
          seek: percentage,
          duration: duration
        }));
        if (this.hlsElement && percentage < 1.0) {
          try {
            this.hlsElement.classList.remove('hidden');
            this.hlsElement.currentTime = this.hlsElement.duration * percentage;
            this._isFragLoading = true;
            this._showHLSLivePlayback(true, this.hlsElement, this.media, this.holder);
          } catch (e) {
            log_warn(red5pro_source_handler_rtc_seekable_NAME, '[hlsvod:action] play (CATCH::FAULT) - ' + e.message);
          }
        } else if (this.hlsElement && percentage >= 1.0) {
          this._isFragLoading = false;
          this._showHLSLivePlayback(false, this.hlsElement, this.media, this.holder);
        }
      } else {
        this.media.currentTime = duration ? percentage * duration : percentage;
      }
    }
  }, {
    key: "toggleFullScreen",
    value: function toggleFullScreen() {
      try {
        if (this.holder) {
          browser.toggleFullScreen(this.holder);
        }
      } catch (e) {
        throw e;
        // nada.
      }
    }

    /**
     * Notification of current stream being in an unpublished state.
     * The stream enters an unpublished state when the broadcaster stop the stream and the subscriber is still connected.
     */
  }, {
    key: "unpublish",
    value: function unpublish() {
      try {
        this.stop();
        this.media.onended.call(this.media);
      } catch (e) {
        // nada.
      }
    }

    /**
     * Request to disconnect playback.
     */
  }, {
    key: "disconnect",
    value: function disconnect() {
      this._cleanUp();
    }

    /**
     * Responder to change in orientation received through metadata.
     *
     * @param {Number} orientation
     *        The orientation value.
     *
     * @private
     */
  }, {
    key: "handleOrientationChange",
    value: function handleOrientationChange(orientation) {
      if (this._controls && orientation % 180 !== 0) {
        if (this.holder) {
          this.holder.classList.add('red5pro-media-background');
        }
        this.media.classList.remove('red5pro-media-background');
      }
    }

    /*
     * || SHARED OBJECT INTEGRATION NOT AVAILABLE FOR HLS PLAYBACK ||
     */
    // eslint-disable-next-line no-unused-vars
  }, {
    key: "addSharedObjectResponseHandler",
    value: function addSharedObjectResponseHandler(handler) {}

    // eslint-disable-next-line no-unused-vars
  }, {
    key: "removeSharedObjectResponseHandler",
    value: function removeSharedObjectResponseHandler(handler) {}

    // eslint-disable-next-line no-unused-vars
  }, {
    key: "sendToSharedObject",
    value: function sendToSharedObject(name, callName, message) {}

    // eslint-disable-next-line no-unused-vars
  }, {
    key: "sendPropertyToSharedObject",
    value: function sendPropertyToSharedObject(name, key, value) {}

    // eslint-disable-next-line no-unused-vars
  }, {
    key: "getRemoteSharedObject",
    value: function getRemoteSharedObject(sharedObjectName) {}

    // eslint-disable-next-line no-unused-vars
  }, {
    key: "connectToSharedObject",
    value: function connectToSharedObject(sharedObjectName) {}

    // eslint-disable-next-line no-unused-vars
  }, {
    key: "closeSharedObject",
    value: function closeSharedObject(sharedObjectName) {}

    /**
     * Returns playback controls if available.
     *
     * @returns {PlaybackControls}
     */
  }, {
    key: "getControls",
    value: function getControls() {
      return this._controls;
    }

    /**
     * Returns the subscriber type associated with this controller.
     *
     * @returns {String}
     */
  }, {
    key: "getType",
    value: function getType() {
      return this.playerType;
    }

    /**
     * Returns flag of video being recognized as VOD (Video On Demand).
     *
     * @returns {Boolean}
     */
  }, {
    key: "isVOD",
    get: function get() {
      return false;
    }

    /**
     * Sets flag of video being considered as VOD (Video On Demand).
     *
     * @param {Boolean} value
     */,
    set: function set(value) {
      // swallow
    }
  }, {
    key: "isSeekable",
    get: function get() {
      return this._isSeekable;
    },
    set: function set(value) {
      this._isSeekable = value;
      if (this._controls) {
        this._controls.setAsVOD(value);
      }
    }

    /**
     * Returns flag of current playback state being "scrubbed" (if enableLiveSeek is true and not at head time).
     *
     * Setter is private internal.
     *
     * @return Boolean
     */
  }, {
    key: "isHLSPlaybackActive",
    get: function get() {
      return this._isHLSPlaybackActive;
    }
  }]);
  return RTCSeekableSourceHandler;
}(PlaybackController);
/* harmony default export */ var red5pro_source_handler_rtc_seekable = (red5pro_source_handler_rtc_seekable_RTCSeekableSourceHandler);
// CONCATENATED MODULE: ./src/js/helper/message-transport.js
function message_transport_typeof(obj) { "@babel/helpers - typeof"; return message_transport_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, message_transport_typeof(obj); }
function message_transport_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function message_transport_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, message_transport_toPropertyKey(descriptor.key), descriptor); } }
function message_transport_createClass(Constructor, protoProps, staticProps) { if (protoProps) message_transport_defineProperties(Constructor.prototype, protoProps); if (staticProps) message_transport_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function message_transport_toPropertyKey(arg) { var key = message_transport_toPrimitive(arg, "string"); return message_transport_typeof(key) === "symbol" ? key : String(key); }
function message_transport_toPrimitive(input, hint) { if (message_transport_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (message_transport_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function message_transport_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) message_transport_setPrototypeOf(subClass, superClass); }
function message_transport_setPrototypeOf(o, p) { message_transport_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return message_transport_setPrototypeOf(o, p); }
function message_transport_createSuper(Derived) { var hasNativeReflectConstruct = message_transport_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = message_transport_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = message_transport_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return message_transport_possibleConstructorReturn(this, result); }; }
function message_transport_possibleConstructorReturn(self, call) { if (call && (message_transport_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return message_transport_assertThisInitialized(self); }
function message_transport_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function message_transport_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function message_transport_getPrototypeOf(o) { message_transport_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return message_transport_getPrototypeOf(o); }



var message_transport_NAME = 'MessageTransport';

/**
 * Base class for MessageTransport implementations.
 */
var message_transport_MessageTransport = /*#__PURE__*/function (_EventEmitter) {
  message_transport_inherits(MessageTransport, _EventEmitter);
  var _super = message_transport_createSuper(MessageTransport);
  function MessageTransport(name) {
    var _this;
    message_transport_classCallCheck(this, MessageTransport);
    _this = _super.call(this);
    _this._name = name || message_transport_NAME;
    _this._responseHandlers = [];
    _this._asyncTickets = [];
    return _this;
  }

  /**
   * Request to parse JSON from message received over WebSocket.
   *
   * @param {Object} message
   *        String or Object.
   */
  message_transport_createClass(MessageTransport, [{
    key: "getJsonFromSocketMessage",
    value: function getJsonFromSocketMessage(message) {
      try {
        return typeof message.data === 'string' ? JSON.parse(message.data) : message.data;
      } catch (e) {
        log_warn(this._name, 'Could not parse message as JSON. Message= ' + message.data + '. Error= ' + e.message);
      }
      return null;
    }

    /**
     * Adds a response handler to be invoked with `respond()` to message and return a boolean of whether the handler handled the message.
     *
     * @param {Object} handler
     *        Handler object that has the message `respond(message)` on its API.
     */
  }, {
    key: "addResponseHandler",
    value: function addResponseHandler(handler) {
      this._responseHandlers.push(handler);
    }

    /**
     * Responds to messages coming over the WebSocket connection.
     *
     * @param {Object} message
     */
  }, {
    key: "respond",
    value: function respond(message) {
      // eslint-disable-line no-unused-vars
      log_warn(this._name, 'respond() should be overriden.');
    }

    /**
     * Posts request over message layer.
     *
     * @param {Object}
     *        Request object to be turned into JSON string for transport.
     */
  }, {
    key: "post",
    value: function post(request) {
      // eslint-disable-line no-unused-vars
      log_warn(this._name, 'post() should be overriden.');
    }

    /**
     * Request to post data over message layer and receive a call back asynchronously from the server.
     *
     * @param {Object} sendRequest
     */
  }, {
    key: "postAsync",
    value: function postAsync(sendRequest) {
      var p = new DeferredPromise();
      var id = Math.floor(Math.random() * 0x10000).toString(16);
      sendRequest.id = id;
      sendRequest.async = true;
      this._asyncTickets.push({
        id: id,
        promise: p
      });
      this.post(sendRequest);
      return p.promise;
    }

    /**
     * Adds a SharedObject response handler. Handlers are requested to respond to a message in `handleMessageResponse`.
     *
     * @param {Object} handler
     */
  }, {
    key: "addSharedObjectResponseHandler",
    value: function addSharedObjectResponseHandler(handler) {
      this._responseHandlers.push(handler);
    }

    /**
     * Removes a SharedObject response handler.
     *
     * @param {Object} handler
     */
  }, {
    key: "removeSharedObjectResponseHandler",
    value: function removeSharedObjectResponseHandler(handler) {
      var i = this._responseHandlers.length;
      var rHandler;
      while (--i > -1) {
        rHandler = this._responseHandlers[i];
        if (rHandler === handler) {
          this._responseHandlers.splice(i, 1);
          return;
        }
      }
    }

    /**
     * Traverses list of response handlers and returns flag of it being handled within the chain.
     *
     * @param {Object} message
     * @return {Boolean}
     */
  }, {
    key: "handleMessageResponse",
    value: function handleMessageResponse(message) {
      var i, handler;
      var length = this._responseHandlers.length;
      for (i = 0; i < length; i++) {
        handler = this._responseHandlers[i];
        if (handler.respond(message)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Request to get SharedObject from server over WebSocket.
     *
     * @param {String} name
     */
  }, {
    key: "getRemoteSharedObject",
    value: function getRemoteSharedObject(name) {
      this.post({
        sharedObjectGetRemote: {
          name: name
        }
      });
    }

    /**
     * Request to connect to SharedObject from server over WebSocket.
     *
     * @param {String} name
     */
  }, {
    key: "connectToSharedObject",
    value: function connectToSharedObject(name) {
      this.post({
        sharedObjectConnect: {
          name: name
        }
      });
    }

    /**
     * Request to send method call to SharedObject over WebSocket.
     *
     * @param {String} name
     * @param {String} methodName
     * @param {Object} data
     */
  }, {
    key: "sendToSharedObject",
    value: function sendToSharedObject(name, methodName, data) {
      this.post({
        sharedObjectSend: {
          name: name,
          method: methodName,
          message: data
        }
      });
    }

    /**
     * Request to update property on SharedObject over WebSocket.
     *
     * @param {String} name
     * @param {String} key
     * @param {String} value
     */
  }, {
    key: "sendPropertyToSharedObject",
    value: function sendPropertyToSharedObject(name, key, value) {
      this.post({
        sharedObjectSetProperty: {
          name: name,
          key: key,
          value: value
        }
      });
    }

    /**
     * Request to close the SharedObject connection over WebSocket.
     *
     * @param {String} name
     */
  }, {
    key: "closeSharedObject",
    value: function closeSharedObject(name) {
      this.post({
        sharedObjectClose: {
          name: name
        }
      });
    }
  }]);
  return MessageTransport;
}(event_emitter);

// CONCATENATED MODULE: ./src/js/helper/socket-helper.js


function socket_helper_typeof(obj) { "@babel/helpers - typeof"; return socket_helper_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, socket_helper_typeof(obj); }
function socket_helper_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function socket_helper_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, socket_helper_toPropertyKey(descriptor.key), descriptor); } }
function socket_helper_createClass(Constructor, protoProps, staticProps) { if (protoProps) socket_helper_defineProperties(Constructor.prototype, protoProps); if (staticProps) socket_helper_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function socket_helper_toPropertyKey(arg) { var key = socket_helper_toPrimitive(arg, "string"); return socket_helper_typeof(key) === "symbol" ? key : String(key); }
function socket_helper_toPrimitive(input, hint) { if (socket_helper_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (socket_helper_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function socket_helper_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) socket_helper_setPrototypeOf(subClass, superClass); }
function socket_helper_setPrototypeOf(o, p) { socket_helper_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return socket_helper_setPrototypeOf(o, p); }
function socket_helper_createSuper(Derived) { var hasNativeReflectConstruct = socket_helper_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = socket_helper_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = socket_helper_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return socket_helper_possibleConstructorReturn(this, result); }; }
function socket_helper_possibleConstructorReturn(self, call) { if (call && (socket_helper_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return socket_helper_assertThisInitialized(self); }
function socket_helper_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function socket_helper_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function socket_helper_getPrototypeOf(o) { socket_helper_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return socket_helper_getPrototypeOf(o); }





var socket_helper_NAME = 'R5ProSocketProxy';

/**
 * Base Proxy for communication with WebSocket.
 *
 * @private
 */
var socket_helper_SocketHelper = /*#__PURE__*/function (_MessageTransport) {
  socket_helper_inherits(SocketHelper, _MessageTransport);
  var _super = socket_helper_createSuper(SocketHelper);
  function SocketHelper(responder, name) {
    var _this;
    socket_helper_classCallCheck(this, SocketHelper);
    _this = _super.call(this, name || socket_helper_NAME);
    _this._responder = responder;
    _this._pendingPostRequests = [];
    _this._websocket = undefined;
    _this._connectionPromise = undefined;
    _this._responseHandlers = [];
    _this._isTerminated = false;
    _this._retryCount = 0;
    _this._retryLimit = 1;
    _this._readyCheckCount = 0;
    _this._readyCheckLimit = 10;
    _this._openState = 0;
    _this._onclose = _this.tearDown.bind(socket_helper_assertThisInitialized(_this));
    _this._onopenTimeout = 0;
    return _this;
  }
  socket_helper_createClass(SocketHelper, [{
    key: "_resetOnopenTimeout",
    value: function _resetOnopenTimeout(ws, promise) {
      var _this2 = this;
      // const forceReconnect = environment.getIsMoz() || environment.getIsEdge()
      var timeout = setTimeout(function () {
        clearTimeout(timeout);
        if (ws.readyState === 1) {
          info(_this2._name, '[websocketopen]');
          _this2._openState = 1;
          while (_this2._pendingPostRequests.length > 0) {
            _this2.post(_this2._pendingPostRequests.shift());
          }
          if (_this2._responder && _this2._responder.onSocketOpen) {
            _this2._responder.onSocketOpen();
          }
          _this2.trigger(new MessageTransportStateEvent(MessageTransportStateEventTypes.OPEN, _this2._name, {
            socket: _this2
          }));
        } else if (ws.readyState === 0) {
          if (++_this2._readyCheckCount > _this2._readyCheckLimit) {
            log_warn(_this2._name, "WebSocket connection issue. We have waited for ".concat(_this2._readyCheckCount - 1, " samples, without any connection."));
            // If Firefox/Edge, try a second connection attempt or fail.
            /*
            if (forceReconnect && ++this._retryCount < this._retryLimit) {
              warn(this._name, `WebSocket attempting retry...`)
              this._removeSocketHandlers(ws)
              this._onopenTimeout = setTimeout(() => {
                clearTimeout(this._onopenTimeout)
                this.setUp(ws.url, promise)
              }, 2000)
            } else {
              promise.reject({type: 'Timeout'})
            }
            */
            _this2.clearRetry();
            promise.reject({
              type: 'Timeout'
            });
            _this2.tearDown();
          } else {
            info(_this2._name, "WebSocket connection is still opening, will let it continue (".concat(_this2._readyCheckCount, ")..."));
            _this2._onopenTimeout = _this2._resetOnopenTimeout(ws, promise);
          }
        } else {
          info(_this2._name, "WebSocket connection attempts have ended with state (".concat(ws.readyState, ")."));
        }
      }, 500);
      return timeout;
    }

    /**
     * Removes event handlers from WebSocket.
     *
     * @param {WebSocket} ws
     *
     * @private
     */
  }, {
    key: "_removeSocketHandlers",
    value: function _removeSocketHandlers(ws) {
      if (ws) {
        ws.onopen = undefined;
        ws.onmessage = undefined;
        ws.onerror = undefined;
        ws.onclose = undefined;
      }
    }

    /**
     * Assigns event handler to WebSocket.
     *
     * @param {WebSocket} ws
     * @param {Promise}
     *        The `Promise` to reject on error in connection to WebSocket.
     *
     * @private
     */
  }, {
    key: "_addSocketHandlers",
    value: function _addSocketHandlers(ws, promise) {
      var _this3 = this;
      /* 
       * Removing this in favor of checking readyState for verification of open.
       *
      ws.onopen = () => {
        info(this._name, '[websocketopen]')
        while (this._pendingPostRequests.length > 0) {
          this.post(this._pendingPostRequests.shift())
        }
      }
      */

      this._openState = 0;
      this._readyCheckCount = 0;
      clearTimeout(this._onopenTimeout);
      this._onopenTimeout = this._resetOnopenTimeout(ws, promise);
      ws.onerror = function (error) {
        log_warn(_this3._name, "[websocketerror]: Error from WebSocket. ".concat(error.type, "."));
        _this3.clearRetry();
        promise.reject(error);
        _this3.trigger(new MessageTransportStateEvent(MessageTransportStateEventTypes.ERROR, _this3._name, {
          socket: _this3,
          error: error
        }));
      };
      ws.onmessage = function (message) {
        _this3.respond(message);
      };
      ws.onclose = function (event) {
        if (event.code > 1000) {
          log_warn(_this3._name, "[websocketclose]: ".concat(event.code));
        } else {
          log_debug(_this3._name, "[websocketclose]: ".concat(event.code));
        }
        if (_this3._responder && _this3._responder.onSocketClose) {
          _this3._responder.onSocketClose(event);
        }
        _this3.clearRetry();
        _this3._removeSocketHandlers(ws || _this3._websocket);
        _this3._openState = 0;
        _this3.trigger(new MessageTransportStateEvent(MessageTransportStateEventTypes.CLOSE, _this3._name, {
          socket: _this3,
          event: event
        }));
      };
    }

    /**
     * Handler for unexpected error through WebSocket.
     *
     * @param {Object} error
     *
     * @private
     */
  }, {
    key: "_onUnexpectedSocketError",
    value: function _onUnexpectedSocketError(error) {
      if (this._responder && this._responder.onSocketClose) {
        this._responder.onSocketClose(error);
      }
      this.trigger(new MessageTransportStateEvent(MessageTransportStateEventTypes.CLOSE, this._name, {
        socket: this
      }));
      log_warn(this._name, "[websocketerror]: Possible Unexpected Error from WebSocket. ".concat(error.type, ", ").concat(error.detail));
      this.clearRetry();
      this._removeSocketHandlers(this._websocket);
    }

    /**
     * Clears the retry count to allow for single publisher to retry again after an unpublish.
     *
     * @private
     */
  }, {
    key: "clearRetry",
    value: function clearRetry() {
      this._retryCount = 0;
      this._readyCheckCount = 0;
      clearTimeout(this._onopenTimeout);
    }

    /**
     * Request to setup WebSocket connection for communication.
     *
     * @param {String} url
     *        Endpoint URL of the socket to connect to.
     * @param {Promise} setupPromise
     *        The `Promise` to resolve or reject on success of setup WebSocket connection.
     */
  }, {
    key: "setUp",
    value: function setUp(url, setupPromise) {
      var _this4 = this;
      var forceReconnect = browser.getIsMoz() || browser.getIsEdge();
      log_debug(this._name, "[websocket:setup] ".concat(url, "."));
      this.tearDown();
      this._isTerminated = false;
      this._connectionPromise = setupPromise;
      browser.addCloseHandler(this._onclose);
      this._websocket = websocket_create(url);
      this._addSocketHandlers(this._websocket, this._connectionPromise);
      if (forceReconnect && this._retryCount++ < this._retryLimit) {
        log_debug(this._name, 'We have determined it is Firefox and are setting up a retry limit.');
        var timeout = setTimeout(function () {
          if (_this4._websocket && _this4._websocket.readyState === 0) {
            log_debug(_this4._name, "[websocket:FF-timeout]");
            log_debug(_this4._name, 'Our connection on Firefox to the wss endpoint has timed out. Let\'s try that again.');
            _this4._removeSocketHandlers(_this4._websocket);
            _this4.setUp(url, setupPromise);
          }
          clearTimeout(timeout);
        }, 2000);
      }
    }

    /**
     * Request to setup WebSocket connection for communication.
     * USE WITH CAUTION. It is assumed you know what you are doing by providing a previously established WebSocket instance.
     *
     * @param {WebSocket} socket
     *        Previously established WebSocket to use for communication and monitoring.
     * @param {Promise} setupPromise
     *        The `Promise` to resolve or reject on success of setup WebSocket connection.
     */
  }, {
    key: "setUpWithSocket",
    value: function setUpWithSocket(socket, setupPromise) {
      log_debug(this._name, "[websocket:setupWithSocket] ".concat(socket.url, "."));
      this.tearDown();
      this._isTerminated = false;
      this._connectionPromise = setupPromise;
      browser.addCloseHandler(this._onclose);
      this._websocket = socket;
      this._addSocketHandlers(this._websocket, this._connectionPromise);
    }

    /**
     * Severs (chops) the connection to the server through a POST request.
     */
  }, {
    key: "sever",
    value: function sever(request) {
      log_debug(this._name, '[websocket:sever]');
      if (this._websocket) {
        if (request) {
          this.post(request);
        }
        this._removeSocketHandlers(this._websocket);
        this.tearDown();
      }
    }

    /**
     * Request to tear down any WebSocket connection.
     */
  }, {
    key: "tearDown",
    value: function tearDown() {
      this._pendingPostRequests.length = 0;
      if (typeof this._websocket !== 'undefined' && !this._isTerminated) {
        log_debug(this._name, '[teardown] >>');
        log_debug(this._name, "[WebSocket(".concat(this._websocket.url, ")] close() >>"));
        //      this._removeSocketHandlers(this._websocket)
        try {
          this._websocket.close();
        } catch (e) {
          log_warn(this._name, "Attempt to close WebSocket failed: ".concat(e.message, "."));
          this._removeSocketHandlers(this._websocket);
        } finally {
          if (this._websocket) {
            log_debug(this._name, "<< [WebSocket(".concat(this._websocket.url, ")] close()"));
          }
        }
        log_debug(this._name, '<< [teardown]');
      }
      this._websocket = undefined;
      this._isTerminated = true;
      this._openState = 0;
      while (this._responseHandlers.length > 0) {
        this._responseHandlers.shift();
      }
      browser.removeCloseHandler(this._onclose);
    }

    /**
     * Request to post notification of end of candidates in WebRTC scenario.
     */
  }, {
    key: "postEndOfCandidates",
    value: function postEndOfCandidates(streamName) {
      this.post({
        handleCandidate: streamName,
        data: {
          candidate: {
            type: 'candidate',
            candidate: ''
          }
        }
      });
    }

    /**
     * Request to post data over WebSocket connection.
     * Queues messages if WebSocket connection is still being established.
     *
     * @param {Object} sendRequest
     */
  }, {
    key: "post",
    value: function post(sendRequest) {
      if (this._websocket !== undefined && this._openState === 1 /* WebSocket.OPEN */) {
        try {
          log_debug(this._name, '[websocket-post]: ' + JSON.stringify(sendRequest, null, 2));
          this._websocket.send(JSON.stringify(sendRequest));
          return true;
        } catch (e) {
          log_debug(this._name, "Could not send request: ".concat(sendRequest, ". ").concat(e));
          return false;
        }
      } else if (this._websocket !== undefined && (this._websocket.readyState === 2 || this._websocket.readyState === 3)) /* WebSocket.(CLOSING | CLOSED) */{
          return false;
        } else if (this._isTerminated) {
        return false;
      } else {
        this._pendingPostRequests.push(sendRequest);
        return true;
      }
    }

    /**
     * Responds to messages coming over the WebSocket connection.
     *
     * @param {Object} message
     */
  }, {
    key: "respond",
    value: function respond(message) {
      // eslint-disable-line no-unused-vars
      var handled = this.handleMessageResponse(message);
      if (!handled && message.data) {
        var json = this.getJsonFromSocketMessage(message);
        if (json === null) {
          log_warn(this._name, 'Determined websocket response not in correct format. Aborting message handle.');
          return true;
        }
        log_debug(this._name, '[websocket-response]: ' + JSON.stringify(json, null, 2));
        if (json.isAvailable !== undefined) {
          if (typeof json.isAvailable === 'boolean' && json.isAvailable) {
            if (this._responder) {
              this._responder.onStreamAvailable(json);
            }
            return true;
          } else {
            if (this._responder) {
              this._responder.onStreamUnavailable(json);
            }
            return true;
          }
        } else if (json.async && json.id) {
          var ticket = this._asyncTickets.find(function (el) {
            return el.id === json.id;
          });
          var promise = ticket.promise;
          if (promise && json.data) {
            promise.resolve(json.data);
          } else if (promise && json.error) {
            promise.reject(json.error);
          }
        } else if (json.data !== undefined) {
          var data = json.data;
          if (data.message !== undefined) {
            if (data.type === 'error' && this._responder) {
              this._responder.onSocketMessageError(data.message, data.detail);
              return true;
            }
          } else if (data.type === 'status') {
            if (data.code === 'NetConnection.Connect.Success') {
              this._websocket.onerror = this._onUnexpectedSocketError.bind(this);
              this._connectionPromise.resolve(this);
              return true;
            } else if (data.code === 'NetConnection.DataChannel.Available') {
              this._responder.onDataChannelAvailable(data.description);
              return true;
            } else if (data.code === 'NetConnection.Connect.Rejected') {
              this._connectionPromise.reject('NetConnection.Connect.Rejected');
              return true;
            }
          } else if (data.type === 'error') {
            if (data.code === 'NetConnection.Connect.Rejected') {
              this._connectionPromise.reject('NetConnection.Connect.Rejected');
              return true;
            } else if (data.code === 'NetConnection.Connect.Failed') {
              this._connectionPromise.reject('NetConnection.Connect.Failed');
              return true;
            }
          }
        }
      }
      return handled;
    }

    /**
     * Returns flag of socket being closed and temrinated.
     *
     * @returns {Boolean}
     */
  }, {
    key: "isTerminated",
    get: function get() {
      return this._isTerminated;
    }
  }]);
  return SocketHelper;
}(message_transport_MessageTransport);
/* harmony default export */ var socket_helper = (socket_helper_SocketHelper);
// CONCATENATED MODULE: ./src/js/helper/socket-helper-sub.js


function socket_helper_sub_typeof(obj) { "@babel/helpers - typeof"; return socket_helper_sub_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, socket_helper_sub_typeof(obj); }
function socket_helper_sub_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function socket_helper_sub_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, socket_helper_sub_toPropertyKey(descriptor.key), descriptor); } }
function socket_helper_sub_createClass(Constructor, protoProps, staticProps) { if (protoProps) socket_helper_sub_defineProperties(Constructor.prototype, protoProps); if (staticProps) socket_helper_sub_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function socket_helper_sub_toPropertyKey(arg) { var key = socket_helper_sub_toPrimitive(arg, "string"); return socket_helper_sub_typeof(key) === "symbol" ? key : String(key); }
function socket_helper_sub_toPrimitive(input, hint) { if (socket_helper_sub_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (socket_helper_sub_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = socket_helper_sub_getPrototypeOf(object); if (object === null) break; } return object; }
function socket_helper_sub_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) socket_helper_sub_setPrototypeOf(subClass, superClass); }
function socket_helper_sub_setPrototypeOf(o, p) { socket_helper_sub_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return socket_helper_sub_setPrototypeOf(o, p); }
function socket_helper_sub_createSuper(Derived) { var hasNativeReflectConstruct = socket_helper_sub_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = socket_helper_sub_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = socket_helper_sub_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return socket_helper_sub_possibleConstructorReturn(this, result); }; }
function socket_helper_sub_possibleConstructorReturn(self, call) { if (call && (socket_helper_sub_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return socket_helper_sub_assertThisInitialized(self); }
function socket_helper_sub_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function socket_helper_sub_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function socket_helper_sub_getPrototypeOf(o) { socket_helper_sub_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return socket_helper_sub_getPrototypeOf(o); }


 // eslint-disable-line no-unused-vars

var socket_helper_sub_NAME = 'R5ProSubscriptionSocket';

/**
 * Subscriber-based extension of `SocketHelper`.
 *
 * @extends {SocketHelper}
 *
 * @private
 */
var socket_helper_sub_SubscriptionSocketHelper = /*#__PURE__*/function (_SocketHelper) {
  socket_helper_sub_inherits(SubscriptionSocketHelper, _SocketHelper);
  var _super = socket_helper_sub_createSuper(SubscriptionSocketHelper);
  function SubscriptionSocketHelper(responder) {
    socket_helper_sub_classCallCheck(this, SubscriptionSocketHelper);
    return _super.call(this, responder, socket_helper_sub_NAME);
  }

  /**
   * Override to respond to messages coming over WebSocket.
   */
  socket_helper_sub_createClass(SubscriptionSocketHelper, [{
    key: "respond",
    value: function respond(message) {
      if (message.data) {
        var json = this.getJsonFromSocketMessage(message);
        if (!_get(socket_helper_sub_getPrototypeOf(SubscriptionSocketHelper.prototype), "respond", this).call(this, message)) {
          if (json.data !== undefined) {
            if (json.data.sdp !== undefined) {
              if (json.data.sdp.type === 'offer') {
                this._responder.onSDPOffer(json.data);
                return true;
              }
            }
            if (json.data.candidate !== undefined) {
              if (isObjectEmpty(json.data.candidate)) {
                this._responder.onEmptyCandidate();
                return true;
              } else {
                this._responder.onAddIceCandidate(json.data.candidate);
                return true;
              }
            }
            if (json.data.type === 'status') {
              if (json.data.code === 'NetConnection.ICE.TricleCompleted' || json.data.code === 'NetConnection.ICE.TrickleCompleted') {
                this._responder.onSocketIceCandidateEnd();
                return true;
              } else if (json.data.code === 'NetStream.Play.UnpublishNotify') {
                this._responder.onUnpublish();
                return true;
              } else if (json.data.code === 'NetConnection.Connect.Closed') {
                this._responder.onConnectionClosed();
                return true;
              } else {
                this._responder.onSubscriberStatus(json.data);
                return true;
              }
            }
            if (json.data.hasOwnProperty('status')) {
              if (json.data.status === 'NetStream.Play.UnpublishNotify') {
                this._responder.onUnpublish();
                return true;
              }
            }
            if (json.type !== undefined) {
              if (json.type === 'metadata') {
                // It is a `send` API invocation.
                if (json.method !== undefined) {
                  this._responder.onSendReceived(json.method, json.data);
                  return true;
                } else {
                  this._responder.onMetaData(json.data);
                  return true;
                }
              }
            }
          } else if (json.type !== undefined) {
            if (json.type === 'metadata') {
              this._responder.onMetaData(json.metadata);
              return true;
            }
          }
          this._responder.onSocketMessage(this, message);
        }
      } else {
        log_warn(socket_helper_sub_NAME, '[ws.onmessage] - No Message Data.');
      }
    }
  }]);
  return SubscriptionSocketHelper;
}(socket_helper);
/* harmony default export */ var socket_helper_sub = (socket_helper_sub_SubscriptionSocketHelper);
// CONCATENATED MODULE: ./src/js/helper/webrtc-helper.js
function webrtc_helper_typeof(obj) { "@babel/helpers - typeof"; return webrtc_helper_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, webrtc_helper_typeof(obj); }
function webrtc_helper_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function webrtc_helper_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, webrtc_helper_toPropertyKey(descriptor.key), descriptor); } }
function webrtc_helper_createClass(Constructor, protoProps, staticProps) { if (protoProps) webrtc_helper_defineProperties(Constructor.prototype, protoProps); if (staticProps) webrtc_helper_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function webrtc_helper_toPropertyKey(arg) { var key = webrtc_helper_toPrimitive(arg, "string"); return webrtc_helper_typeof(key) === "symbol" ? key : String(key); }
function webrtc_helper_toPrimitive(input, hint) { if (webrtc_helper_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (webrtc_helper_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function webrtc_helper_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) webrtc_helper_setPrototypeOf(subClass, superClass); }
function webrtc_helper_setPrototypeOf(o, p) { webrtc_helper_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return webrtc_helper_setPrototypeOf(o, p); }
function webrtc_helper_createSuper(Derived) { var hasNativeReflectConstruct = webrtc_helper_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = webrtc_helper_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = webrtc_helper_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return webrtc_helper_possibleConstructorReturn(this, result); }; }
function webrtc_helper_possibleConstructorReturn(self, call) { if (call && (webrtc_helper_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return webrtc_helper_assertThisInitialized(self); }
function webrtc_helper_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function webrtc_helper_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function webrtc_helper_getPrototypeOf(o) { webrtc_helper_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return webrtc_helper_getPrototypeOf(o); }





var webrtc_helper_NAME = 'R5ProWebRTCPeer';
var webrtc_helper_WebRTCPeerHelper = /*#__PURE__*/function (_MessageTransport) {
  webrtc_helper_inherits(WebRTCPeerHelper, _MessageTransport);
  var _super = webrtc_helper_createSuper(WebRTCPeerHelper);
  function WebRTCPeerHelper(responder, name) {
    var _this;
    webrtc_helper_classCallCheck(this, WebRTCPeerHelper);
    _this = _super.call(this, name || webrtc_helper_NAME);
    _this._responder = responder;
    _this._dataChannel = undefined;
    _this._peerConnection = undefined;
    _this._onDataChannelMessage = _this._onDataChannelMessage.bind(webrtc_helper_assertThisInitialized(_this));
    return _this;
  }

  /**
   * Remove handlers assigned to the optional data channel on the connection.
   *
   * @param {RTCDataChannel} dataChannel
   */
  webrtc_helper_createClass(WebRTCPeerHelper, [{
    key: "_removeDataChannelHandlers",
    value: function _removeDataChannelHandlers(dataChannel) {
      dataChannel.onopen = undefined;
      dataChannel.onerror = undefined;
      dataChannel.onclose = undefined;
      dataChannel.onmessage = undefined;
    }

    /** 
     * Assigns event handlers to the optional data channel on the connection.
     *
     * @param {RTCDataChannel} dataChannel
     */
  }, {
    key: "_addDataChannelHandlers",
    value: function _addDataChannelHandlers(dataChannel) {
      var _this2 = this;
      dataChannel.onerror = function (event) {
        _this2._responder.onDataChannelError(dataChannel, event.error.message);
      };
      dataChannel.onmessage = this._onDataChannelMessage;
      dataChannel.onopen = function () {
        _this2._responder.onDataChannelOpen(dataChannel);
      };
      dataChannel.onclose = function (event) {
        _this2._responder.onDataChannelClose(dataChannel);
        _this2.trigger(new MessageTransportStateEvent(MessageTransportStateEventTypes.CLOSE, _this2._name, {
          socket: _this2,
          event: event
        }));
      };
    }

    /**
     * Removes handlers assigned to the peer connection instance.
     *
     * @param {RTCPeerConnection} connection
     */
    // eslint-disable-next-line no-unused-vars
  }, {
    key: "_removeConnectionHandlers",
    value: function _removeConnectionHandlers(connection) {
      log_warn(this._name, '_removeConnectionHandlers is abstract.');
    }

    /**
     * Assigns handlers to events on the peer connection instance.
     *
     * @param {RTCPeerConnection} connection
     * @param {Promise} promise
     *        The `Promise` to resolve or reject on success of connection.
     */
    // eslint-disable-next-line no-unused-vars
  }, {
    key: "_addConnectionHandlers",
    value: function _addConnectionHandlers(connection, promise) {
      log_warn(this._name, '_addConnectionHandlers is abstract.');
    }

    /**
     * Message event listener on RTCDataChannel
     *
     * @param {Event} event
     *
     * @private
     */
  }, {
    key: "_onDataChannelMessage",
    value: function _onDataChannelMessage(event) {
      var message = event;
      if (this.handleMessageResponse(message)) {
        return true;
      }
      var json = this.getJsonFromSocketMessage(message);
      if (json === null) {
        log_warn(this._name, 'Determined websocket response not in correct format. Aborting message handle.');
        return true;
      }
      log_debug(this._name, '[datachannel-response]: ' + JSON.stringify(json, null, 2));
      var data = json.data,
        method = json.method,
        type = json.type,
        id = json.id;
      if (data && data.message && data.type === 'error') {
        this._responder.onDataChannelError(this._dataChannel, data.message);
        return true;
      }
      if (data && data.code && data.type === 'error') {
        this._responder.onDataChannelError(this._dataChannel, data.code);
        return true;
      } else if (method) {
        this._responder.onSendReceived(method, data);
        return true;
      } else if (type === 'metadata') {
        this._responder.onMetaData(data);
        return true;
      } else if (data && data.type === 'status') {
        if (data.code === 'NetConnection.Connect.Closed') {
          this._responder.onConnectionClosed();
          return true;
        }
        log_debug(webrtc_helper_NAME, "[datachannel.message] status :: ".concat(data.code));
      } else if (json.async && id) {
        var ticket = this._asyncTickets.find(function (el) {
          return el.id === id;
        });
        var promise = ticket.promise;
        if (promise && json.data) {
          promise.resolve(json.data);
          return true;
        } else if (promise && json.error) {
          promise.reject(json.error);
          return true;
        }
      }
      return false;
    }

    /**
     * Deprecated.
     * Request to setup the proxied Peer Connection instance.
     * Use either `setUp` or `setUpWithPeerConfiguration`.
     *
     * @param {Array} iceServers
     *        List of ICE servers to use in the connection.
     * @param {Promise} setUpPromise
     *        The `Promise` to resolve or reject on in success in setting up the Peer Connection.
     * @param {String} rtcpMuxPolicy
     *        The type of mux policy to use.
     * @return {Promise}
     *
     * @note Marked for deprecation after 5.4.0 release.
     */
  }, {
    key: "setUp",
    value: function setUp(iceServers) {
      var setUpPromise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var rtcpMuxPolicy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      this.tearDown();
      var p = setUpPromise || new DeferredPromise();
      try {
        var peerConfig = {
          iceServers: iceServers,
          iceCandidatePoolSize: 2,
          bundlePolicy: 'max-bundle'
        };
        if (typeof rtcpMuxPolicy !== 'undefined') {
          peerConfig.rtcpMuxPolicy = rtcpMuxPolicy;
        }
        log_debug(webrtc_helper_NAME, "[peerconnection:setup]: ".concat(JSON.stringify(peerConfig, null, 2)));
        var peer = new RTCPeerConnection(peerConfig, {
          optional: [{
            RtpDataChannels: false
          }, {
            googCpuOveruseDetection: true
          }]
        });
        this._addConnectionHandlers(peer);
        this._peerConnection = peer;
        p.resolve(peer);
      } catch (e) {
        log_warn(webrtc_helper_NAME, "Could not establish a PeerConnection. ".concat(e.message));
        p.reject(e.message);
      }
      return p.hasOwnProperty('promise') ? p.promise : p;
    }

    /**
     * Request to setup the proxied Peer Connection instance with defined RTCConfiguration.
     * Use either `setUp` or `setUpWithPeerConfiguration`.
     * https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/RTCPeerConnection#RTCConfiguration_dictionary
     *
     * @param {RTCConfiguration} configuration
     *        A custom RTCConfiguration.
     * @param {Object} dataChannelConfiguration
     *        An object detailing optional data channel configuration options.
     * @param {Promise} setUpPromise
     *        The `Promise` to resolve or reject on in success in setting up the Peer Connection.
     * @return {Promise}
     */
  }, {
    key: "setUpWithPeerConfiguration",
    value: function setUpWithPeerConfiguration(configuration) {
      var dataChannelConfiguration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var setUpPromise = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      this.tearDown();
      var p = setUpPromise || new DeferredPromise();
      try {
        log_debug(webrtc_helper_NAME, "[peerconnection:setUpWithPeerConfiguration]: ".concat(JSON.stringify(configuration, null, 2)));
        var peer = new RTCPeerConnection(configuration);
        if (dataChannelConfiguration) {
          this._dataChannel = peer.createDataChannel(dataChannelConfiguration.name, {
            ordered: true
          });
          this._addDataChannelHandlers(this._dataChannel);
        }
        this._addConnectionHandlers(peer);
        this._peerConnection = peer;
        p.resolve(peer);
      } catch (e) {
        log_warn(webrtc_helper_NAME, "Could not establish a PeerConnection. ".concat(e.message));
        p.reject(e.message);
      }
      return p.hasOwnProperty('promise') ? p.promise : p;
    }

    /**
     * Request to tear down proxied Peer Connection instance.
     */
  }, {
    key: "tearDown",
    value: function tearDown() {
      if (this._dataChannel) {
        this._removeDataChannelHandlers(this._dataChannel);
        try {
          this._dataChannel.close();
        } catch (e) {
          log_warn(webrtc_helper_NAME, "[datachannel.close] error: ".concat(e.message));
        } finally {
          this._dataChannel = undefined;
        }
      }
      if (this._peerConnection) {
        log_debug(webrtc_helper_NAME, '[teardown]');
        this._removeConnectionHandlers(this._peerConnection);
        try {
          this._peerConnection.close();
        } catch (e) {
          log_warn(webrtc_helper_NAME, "[peerconnection.close] error: ".concat(e.message));
        } finally {
          this._peerConnection = undefined;
        }
      }
    }

    /**
     * Request to set local description on the Peer Connection.
     *
     * @param {Object} sessionDescription
     * @return {Promise}
     */
  }, {
    key: "setLocalDescription",
    value: function setLocalDescription(sessionDescription) {
      log_debug(webrtc_helper_NAME, '[setlocaldescription]');
      return this._peerConnection.setLocalDescription(sessionDescription);
    }

    /**
     * Request to set remote description.
     *
     * @param {Object} sdp
     *        The Session Description tot set on the Peer Connection.
     * @return {Promise}
     */
  }, {
    key: "setRemoteDescription",
    value: function setRemoteDescription(sdp) {
      log_debug(webrtc_helper_NAME, '[setremotedescription]');
      return this._peerConnection.setRemoteDescription(new RTCSessionDescription(sdp));
    }

    /**
     * Request to add ICE candidate to Peer Connection.
     *
     * @param {Object} candidate
     * @return {Promise}
     */
  }, {
    key: "addIceCandidate",
    value: function addIceCandidate(candidate) {
      log_debug(webrtc_helper_NAME, '[addcandidate]');
      return this._peerConnection.addIceCandidate(candidate);
    }

    /**
     * Posts request over optional RTCDataChannel.
     *
     * @param {Object}
     *        Request object to be turned into JSON string for transport.
     */
  }, {
    key: "post",
    value: function post(request) {
      if (this._dataChannel) {
        var message = typeof request === 'string' ? request : JSON.stringify(request, null, 2);
        log_debug(webrtc_helper_NAME, "[datachannel.send] message: ".concat(message));
        try {
          this._dataChannel.send(message);
          return true;
        } catch (err) {
          log_error(webrtc_helper_NAME, err.hasOwnProperty('message') ? err.message : err);
        }
      }
      return false;
    }

    /**
     * Accessor for the proxied RTCPeerConnection instance.
     *
     * @return {RTCPeerConnection}
     */
  }, {
    key: "connection",
    get: function get() {
      return this._peerConnection;
    }

    /**
     * Accessor for the optional underlying RTCDataChannel instance.
     *
     * @return {RTCDataChannel}
     */
  }, {
    key: "dataChannel",
    get: function get() {
      return this._dataChannel;
    }
  }]);
  return WebRTCPeerHelper;
}(message_transport_MessageTransport);
/* harmony default export */ var webrtc_helper = (webrtc_helper_WebRTCPeerHelper);
// CONCATENATED MODULE: ./src/js/helper/webrtc-helper-sub.js


function webrtc_helper_sub_typeof(obj) { "@babel/helpers - typeof"; return webrtc_helper_sub_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, webrtc_helper_sub_typeof(obj); }
function webrtc_helper_sub_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function webrtc_helper_sub_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, webrtc_helper_sub_toPropertyKey(descriptor.key), descriptor); } }
function webrtc_helper_sub_createClass(Constructor, protoProps, staticProps) { if (protoProps) webrtc_helper_sub_defineProperties(Constructor.prototype, protoProps); if (staticProps) webrtc_helper_sub_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function webrtc_helper_sub_toPropertyKey(arg) { var key = webrtc_helper_sub_toPrimitive(arg, "string"); return webrtc_helper_sub_typeof(key) === "symbol" ? key : String(key); }
function webrtc_helper_sub_toPrimitive(input, hint) { if (webrtc_helper_sub_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (webrtc_helper_sub_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function webrtc_helper_sub_get() { if (typeof Reflect !== "undefined" && Reflect.get) { webrtc_helper_sub_get = Reflect.get.bind(); } else { webrtc_helper_sub_get = function _get(target, property, receiver) { var base = webrtc_helper_sub_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return webrtc_helper_sub_get.apply(this, arguments); }
function webrtc_helper_sub_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = webrtc_helper_sub_getPrototypeOf(object); if (object === null) break; } return object; }
function webrtc_helper_sub_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) webrtc_helper_sub_setPrototypeOf(subClass, superClass); }
function webrtc_helper_sub_setPrototypeOf(o, p) { webrtc_helper_sub_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return webrtc_helper_sub_setPrototypeOf(o, p); }
function webrtc_helper_sub_createSuper(Derived) { var hasNativeReflectConstruct = webrtc_helper_sub_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = webrtc_helper_sub_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = webrtc_helper_sub_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return webrtc_helper_sub_possibleConstructorReturn(this, result); }; }
function webrtc_helper_sub_possibleConstructorReturn(self, call) { if (call && (webrtc_helper_sub_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return webrtc_helper_sub_assertThisInitialized(self); }
function webrtc_helper_sub_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function webrtc_helper_sub_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function webrtc_helper_sub_getPrototypeOf(o) { webrtc_helper_sub_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return webrtc_helper_sub_getPrototypeOf(o); }





var webrtc_helper_sub_NAME = 'R5ProSubscriptionPeer';

/**
 * Utility to check if candidate is empty, and considered the end of the trickle negotiation for a subscriber.
 *
 * @param {Object} candidate
 *
 * @private
 */
var isEmptyCandidate = function isEmptyCandidate(candidate) {
  return typeof candidate === 'undefined' || typeof candidate === 'string' && candidate.length === 0;
};

/**
 * Proxy to Peer Connection for Subscribers.
 *
 * @private
 */
var webrtc_helper_sub_SubscriptionPeerHelper = /*#__PURE__*/function (_WebRTCPeerHelper) {
  webrtc_helper_sub_inherits(SubscriptionPeerHelper, _WebRTCPeerHelper);
  var _super = webrtc_helper_sub_createSuper(SubscriptionPeerHelper);
  function SubscriptionPeerHelper(responder) {
    webrtc_helper_sub_classCallCheck(this, SubscriptionPeerHelper);
    return _super.call(this, responder, webrtc_helper_sub_NAME);
  }

  /**
   * Removes handlers assigned to the peer connection instance.
   *
   * @param {RTCPeerConnection} connection
   *
   * @private
   */
  webrtc_helper_sub_createClass(SubscriptionPeerHelper, [{
    key: "_removeConnectionHandlers",
    value: function _removeConnectionHandlers(connection) {
      connection.onconnectionstatechange = undefined;
      connection.oniceconnectionstatechange = undefined;
      connection.onicecandidate = undefined;
      //    connection.onaddstream = undefined
      connection.ontrack = undefined;
      connection.ondatachannel = undefined;
    }

    /**
     * Assigns handlers to events on the peer connection instance.
     *
     * @param {RTCPeerConnection} connection
     * @param {Promise} promise
     *        The `Promise` to resolve or reject on success of connection.
     *
     *  @private
     */
  }, {
    key: "_addConnectionHandlers",
    value: function _addConnectionHandlers(connection, promise) {
      var _this = this;
      var reconnectTimeout;
      var timeoutLimit = 5000;
      connection.onconnectionstatechange = function () {
        log_debug(webrtc_helper_sub_NAME, "[peer.onconnectionstatechange] - State: ".concat(connection.connectionState));
        if (connection.connectionState === 'connected') {
          log_debug(webrtc_helper_sub_NAME, '[peerconnection:open]');
          if (promise) {
            promise.resolve(_this);
          } else {
            _this._responder.onPeerConnectionOpen();
          }
        } else if (connection.connectionState === 'failed' || connection.connectionState === 'disconnected') {
          log_warn(webrtc_helper_sub_NAME, '[peerconnection:error]');
          if (promise) {
            promise.reject();
          }
        }
      };
      connection.onicecandidate = function (event) {
        log_debug(webrtc_helper_sub_NAME, "[peer.onicecandidate] - Peer Candidate: ".concat(event.candidate));
        if (event.candidate) {
          _this._responder.onIceCandidate(event.candidate);
        } else if (event.candidate === null && _this._pendingMediaStream) {
          // null means they have finished sending candidates back and forth?
          _this._responder.onIceCandidateTrickleEnd(_this._pendingMediaStream);
          _this._pendingMediaStream = undefined;
        }
      };

      /*
      connection.onaddstream = (event) => {
        debug(NAME, `(onaddstream) Peer Add Stream: ${event.stream}`)
        if (event.stream && this._pendingMediaStream === undefined) {
          this._pendingMediaStream = event.stream
          this._responder.onAnswerMediaStream(event.stream)
        }
      }
      */

      // Picked up by Firefox, all others TCe `onaddstream`, but adapter.js will call both, so we limit.
      connection.ontrack = function (event) {
        log_debug(webrtc_helper_sub_NAME, "(ontrack) Peer Add Stream: ".concat(event.streams));
        if (event.streams && event.streams.length > 0 && _this._pendingMediaStream === undefined) {
          _this._pendingMediaStream = event.streams[0];
          _this._responder.onAnswerMediaStream(event.streams[0]);
        }
      };
      connection.oniceconnectionstatechange = function (event) {
        var state = connection.iceConnectionState;
        log_debug(webrtc_helper_sub_NAME, "[peer.oniceconnectionstatechange] - State: ".concat(state));
        if (state === 'connected' && browser.getIsEdge()) {
          // Support for ORTC order of candidates.
          // Typically this will be invoked from a `onicegatheringstatechange` event on the Connection.
          // Edge doesn't notify on that event.
          log_debug(webrtc_helper_sub_NAME, '[edge/ortc:notify complete]');
          _this._responder.onPeerGatheringComplete();
          // Trick for edge to receive null candidate and start playback.
          // TODO: Fix me?
          connection.onicecandidate({
            candidate: null
          });
        } else if (state === 'failed') {
          if (reconnectTimeout) {
            clearTimeout(reconnectTimeout);
          }
          _this._responder.onPeerConnectionFail();
          _this._responder.onPeerConnectionClose(event);
        } else if (state === 'disconnected') {
          // may receive a disconnect temporarily that will then return to a connection.
          reconnectTimeout = setTimeout(function () {
            log_debug(webrtc_helper_sub_NAME, "[peer.oniceconnectionstatechange] - Reconnect timeout reached. Closing PeerConnection.");
            clearTimeout(reconnectTimeout);
            _this._responder.onPeerConnectionClose(event);
          }, timeoutLimit);
        } else {
          if (reconnectTimeout) {
            log_debug(webrtc_helper_sub_NAME, "[peer.oniceconnectionstatechange] - Clearing timeout for reconnect.");
            clearTimeout(reconnectTimeout);
          }
        }
      };
      connection.onicegatheringstatechange = function () {
        var state = connection.iceGatheringState;
        log_debug(webrtc_helper_sub_NAME, "[peer.onicegatheringstatechange] - State: ".concat(state));
        if (state === 'complete') {
          _this._responder.onPeerGatheringComplete();
        }
      };
      connection.onremovestream = function () {
        log_debug(webrtc_helper_sub_NAME, "[peer.onremovestream]");
      };
    }

    /**
     * Message event listener on RTCDataChannel
     *
     * @param {Event} event
     *
     * @private
     */
  }, {
    key: "_onDataChannelMessage",
    value: function _onDataChannelMessage(event) {
      var message = event;
      if (webrtc_helper_sub_get(webrtc_helper_sub_getPrototypeOf(SubscriptionPeerHelper.prototype), "_onDataChannelMessage", this).call(this, event)) {
        return true;
      }
      var json = this.getJsonFromSocketMessage(message);
      if (json === null) {
        log_warn(this._name, 'Determined websocket response not in correct format. Aborting message handle.');
        return true;
      }
      log_debug(this._name, '[datachannel-response]: ' + JSON.stringify(json, null, 2));
      var data = json.data;
      if (data && data.type === 'status') {
        if (data.code === 'NetStream.Play.UnpublishNotify') {
          this._responder.onUnpublish();
          this._responder.onConnectionClosed();
          return true;
        }
        log_debug(webrtc_helper_sub_NAME, "[datachannel.message] status :: ".concat(data.code));
        this._responder.onSubscriberStatus(data);
        return true;
      } else if (data && data.status && data.status === 'NetStream.Play.UnpublishNotify') {
        this._responder.onUnpublish();
        this._responder.onConnectionClosed();
        return true;
      }
      this._responder.onDataChannelMessage(this._dataChannel, message);
      return false;
    }

    /**
     * Request to create answer on Peer Connection.
     *
     * @param {Object} sdp
     *        The Session Description to set as remote description.
     * @return {Promise}
     */
  }, {
    key: "createAnswer",
    value: function createAnswer(sdp) {
      var _this2 = this;
      log_debug(webrtc_helper_sub_NAME, '[createanswer]');
      var deferred = new DeferredPromise();
      this._peerConnection.setRemoteDescription(sdp).then(this._responder.onSDPSuccess).catch(function (err) {
        _this2._responder.onSDPError(err);
      });
      // here the answer sdp has to be munged or stereo from the offer wont be enabled in chrome
      this._peerConnection.createAnswer().then(function (sessionDescription) {
        sessionDescription.sdp = forceStereoOnLocalAnswer(sessionDescription.sdp);
        _this2._peerConnection.setLocalDescription(sessionDescription).then(_this2._responder.onSDPSuccess).catch(function (err) {
          _this2._responder.onSDPError(err);
        });
        deferred.resolve(sessionDescription);
      }).catch(deferred.reject);
      return deferred.promise;
    }

    /**
     * Request to add ICE candidate to Peer Connection.
     *
     * @param {Object} candidate
     * @return {Promise}
     */
  }, {
    key: "addIceCandidate",
    value: function addIceCandidate(candidate) {
      log_debug(webrtc_helper_sub_NAME, 'checking if empty...');
      if (isEmptyCandidate(candidate)) {
        log_debug(webrtc_helper_sub_NAME, '[addicecandidate]:: empty');
      } else if (candidate !== null) {
        log_debug(webrtc_helper_sub_NAME, '[addicecandidate] :: non-empty');
        var iceCandidate = new RTCIceCandidate({
          sdpMLineIndex: candidate.sdpMLineIndex,
          candidate: candidate.candidate
        });
        this._peerConnection.addIceCandidate(iceCandidate).then(function () {
          // nada
        }).catch(function (err) {
          log_error(webrtc_helper_sub_NAME, "Error in add of ICE Candidiate + ".concat(err));
        });
      } else {
        log_debug(webrtc_helper_sub_NAME, '[addicecandidate] :: null');
        this._peerConnection.addIceCandidate(candidate).then(function () {
          // nada
        }).catch(function (err) {
          log_error(webrtc_helper_sub_NAME, "Error in add of ICE Candidiate + ".concat(err));
        });
      }
    }
  }]);
  return SubscriptionPeerHelper;
}(webrtc_helper);
/* harmony default export */ var webrtc_helper_sub = (webrtc_helper_sub_SubscriptionPeerHelper);
// CONCATENATED MODULE: ./src/js/view/playback.js


function playback_typeof(obj) { "@babel/helpers - typeof"; return playback_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, playback_typeof(obj); }
function playback_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function playback_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, playback_toPropertyKey(descriptor.key), descriptor); } }
function playback_createClass(Constructor, protoProps, staticProps) { if (protoProps) playback_defineProperties(Constructor.prototype, protoProps); if (staticProps) playback_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function playback_toPropertyKey(arg) { var key = playback_toPrimitive(arg, "string"); return playback_typeof(key) === "symbol" ? key : String(key); }
function playback_toPrimitive(input, hint) { if (playback_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (playback_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }


var playback_NAME = 'R5ProPlaybackView';
var playbackId = 'red5pro-subscriber';

/**
 * Bridge between DOM Element view and Subscriber implementation.
 * Still used, but internalized as of 4.0.0. Up for deprecation, up for discussion.
 *
 * @private
 */
var playback_PlaybackView = /*#__PURE__*/function () {
  /**
   * @param {String} elementId
   *        The element `id` to use for playback display.
   *
   * @private
   */
  function PlaybackView() {
    var elementId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : playbackId;
    playback_classCallCheck(this, PlaybackView);
    try {
      // Target video/audio element.
      this._targetElement = browser.resolveElement(elementId);
    } catch (e) {
      log_error(playback_NAME, "Could not instantiate a new instance of Red5ProSubscriber. Reason: ".concat(e.message));
      throw e;
    }
  }

  /**
   * Associates Subscriber instance with this view manager.
   *
   * @param {Object} subscriber
   *        The Subscriber instance.
   *
   * @private
   */
  playback_createClass(PlaybackView, [{
    key: "attachSubscriber",
    value: function attachSubscriber(subscriber) {
      log_debug(playback_NAME, '[attachsubscriber]');
      subscriber.setView(this, browser.getElementId(this._targetElement));
    }

    /**
     * Assign the `MediaStream` object to the view.
     *
     * @param {MediaStream} mediaStream
     *
     * @private
     */
  }, {
    key: "attachStream",
    value: function attachStream(mediaStream) {
      var autoplay = this.isAutoplay;
      log_debug(playback_NAME, '[attachstream]');
      browser.setVideoSource(this._targetElement, mediaStream, autoplay);
    }

    /**
     * Removes the `MediaStream` object from the view.
     *
     * @private
     */
  }, {
    key: "detachStream",
    value: function detachStream() {
      log_debug(playback_NAME, '[detachstream]');
      browser.setVideoSource(this._targetElement, null, this.isAutoplay);
    }

    /**
     * Returns recognized `autoplay` attribute on the DOM element.
     *
     * @private
     */
  }, {
    key: "isAutoplay",
    get: function get() {
      return browser.hasAttributeDefined(this._targetElement, 'autoplay');
    }

    /**
     * Returns the DOM element.
     *
     * @private
     */
  }, {
    key: "view",
    get: function get() {
      return this._targetElement;
    }
  }]);
  return PlaybackView;
}();
/* harmony default export */ var playback = (playback_PlaybackView);
// CONCATENATED MODULE: ./src/js/util/url-endpoint.js


/**
 * Recent changes have moved the WebSocket port of the server to 5080 or 443.
 * Our previous recommendation was to use 8081 or 8083.
 *
 * This is for backward compatibility and should be upgraded to DEPRECATION.
 *
 * @private
 */
var getBackgroundCompatWebSocketPort = function getBackgroundCompatWebSocketPort(port) {
  switch (port) {
    case 8083:
    case '8083':
      console.warn('The default WebSocket port on the server has changed from 8083 to 443 for secure connections.'); // eslint-disable-line no-console
      return 443;
    case 8081:
    case '8081':
      console.warn('The default WebSocket port on the server has changed from 8081 to 5080 or 80 for secure connections.'); // eslint-disable-line no-console
      return 5080;
  }
  return port;
};

/**
 * Encode the value of each key and return a new object.
 *
 * @param {Object} valueObject
 *        The object whose values should be encoded.
 * @return {Object}
 *
 * @private
 */
var encodeKeyValues = function encodeKeyValues(valueObject) {
  var encoded = {};
  Object.keys(valueObject).forEach(function (key, index) {
    // eslint-disable-line no-unused-vars
    encoded[key] = encodeURIComponent(valueObject[key]);
  });
  return encoded;
};

/**
 * Construct endpoint to use for WebSocket connection based on configuration object and optional params to append to query.
 *
 * @param {Object} options
 *        The configuration options provided in `init()` of WebRTC based publisher or subscriber.
 * @param {Object} params
 *        The optional params to append to the endpoint. Used by server in connection parse.
 * @private
 */
var rtcSocketEndpointFromOptions = function rtcSocketEndpointFromOptions(options) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  var protocol = options.wsprotocol || options.protocol;
  var port = getBackgroundCompatWebSocketPort(options.wsport || options.port);
  var appEndpoint = options.context ? [options.app, options.context].join('/') : options.app;
  var endpoint = "".concat(protocol, "://").concat(options.host, ":").concat(port, "/").concat(appEndpoint, "/");
  if (typeof options.connectionParams !== 'undefined') {
    var encodedParams = encodeKeyValues(options.connectionParams);
    params = Object.assign(params, encodedParams);
  }
  if (typeof params !== 'undefined') {
    var kv = [];
    Object.keys(params).forEach(function (key, index) {
      // eslint-disable-line no-unused-vars
      kv.push([key, params[key]].join('='));
    });
    if (kv.length > 0) {
      endpoint += '?' + kv.join('&');
    }
  }
  return endpoint;
};

/**
 * Construct endpoint to use for WebSocket connection based on configuration object and optional params to append to query.
 * This allows for such things as authentication prior to request of playback of HLS file.
 * Requires a `socketParams` attribute in the init configuration that describe the WebSocket endpoint to make the request on.
 *
 * @param {Object} options
 *        The configuration options provided in `init()` of HLS based subscriber.
 * @param {Object} params
 *        The optional params to append to the endpoint. Used by server in connection parse.
 *
 * @example
 *  var subscriber = new HLSubscriber()
 *  subscriber.init({
 *    protocol: 'https',
 *    host: 'mycompany.org',
 *    app: 'live',
 *    streamName: 'mystream',
 *    socketParams: {
 *      protocol: 'wss',
 *      host: 'mycompany.org',
 *      app: 'live'
 *    },
 *    connectionParams: {
 *      user: 'foo',
 *      password: 'bar'
 *    }
 *  })
 * @private
 */
var hlsSocketEndpointFromOptions = function hlsSocketEndpointFromOptions(options) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  var socketParams = options.socketParams,
    connectionParams = options.connectionParams;
  var protocol = socketParams.protocol;
  var port = getBackgroundCompatWebSocketPort(socketParams.port || (protocol === 'wss' ? 443 : 5080));
  var endpoint = "".concat(protocol, "://").concat(socketParams.host, ":").concat(port, "/").concat(socketParams.app, "/");
  if (connectionParams) {
    var encodedParams = encodeKeyValues(options.connectionParams);
    params = Object.assign(params, encodedParams);
  }
  if (params) {
    var kv = [];
    Object.keys(params).forEach(function (key, index) {
      // eslint-disable-line no-unused-vars
      kv.push([key, params[key]].join('='));
    });
    if (kv.length > 0) {
      endpoint += '?' + kv.join('&');
    }
  }
  return endpoint;
};

/**
 * Util to return the endpoint for an HLS video file.
 *
 * @param {Object} options
 *        The initialization object.
 * @return {String}
 *
 * @private
 */
var optionsToHlsURL = function optionsToHlsURL(options) {
  var host = options.host,
    hlsprotocol = options.hlsprotocol,
    protocol = options.protocol,
    hlsport = options.hlsport,
    port = options.port,
    context = options.context,
    app = options.app,
    streamName = options.streamName,
    connectionParams = options.connectionParams,
    apiVersion = options.apiVersion;
  var theHost = host;
  var theProtocol = hlsprotocol || (protocol === 'ws' ? 'http' : 'https');
  var thePort = hlsport || (port === 5080 ? 5080 : 443);
  var appEndpoint = context ? [app, context].join('/') : app;
  var theVersion = apiVersion || '4.0';
  if (connectionParams && app === 'streammanager') {
    // https://streammanager.red5pro.cloud/streammanager/api/4.0/file/{app_name}/{stream_name}
    return "".concat(theProtocol, "://").concat(theHost, ":").concat(thePort, "/streammanager/api/").concat(theVersion, "/file/").concat(connectionParams.app, "/").concat(streamName, ".m3u8");
  }
  return "".concat(theProtocol, "://").concat(theHost, ":").concat(thePort, "/").concat(appEndpoint, "/").concat(streamName, ".m3u8");
};
var optionsFromWhipWhepUrl = function optionsFromWhipWhepUrl(url) {
  // http://10.0.0.35:5080/live/whip/endpoint/stream1
  var host, protocol, port, app, streamName;
  var pattern = new URL(url);
  var paths = pattern.pathname.split('/').filter(function (p) {
    return p.length > 0;
  });
  protocol = pattern.protocol;
  host = pattern.hostname;
  port = pattern.port.length > 0 ? pattern.port : 443;
  app = paths[0];
  streamName = paths[paths.length - 1];
  return {
    protocol: protocol,
    port: port,
    app: app,
    host: host,
    streamName: streamName
  };
};
// CONCATENATED MODULE: ./src/js/enum/playback.js
/**
 * Enumeration of Playback Types.
 */
var PlaybackTypes = Object.freeze({
  RTC: 'rtc',
  RTMP: 'rtmp',
  HLS: 'hls'
});

/**
 * Enumeration of Audio Encoder types to request for Playback
 */
var PlaybackAudioEncoder = Object.freeze({
  OPUS: 'Opus',
  PCMU: 'PCMU',
  PCMA: 'PCMA',
  SPEEX: 'Speex',
  NONE: 'NONE'
});

/**
 * Enumeration of Video Encoder types to request for Playback.
 */
var PlaybackVideoEncoder = Object.freeze({
  VP8: 'VP8',
  H264: 'H264',
  NONE: 'NONE'
});
// CONCATENATED MODULE: ./src/js/enum/webrtc.js
/**
 * Enumeration of Support ICE Transport types.
 */
var IceTransportTypes = Object.freeze({
  UDP: 'udp',
  TCP: 'tcp'
});
// CONCATENATED MODULE: ./src/js/subscriber/red5pro-rtc.js


function red5pro_rtc_typeof(obj) { "@babel/helpers - typeof"; return red5pro_rtc_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, red5pro_rtc_typeof(obj); }
function red5pro_rtc_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function red5pro_rtc_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, red5pro_rtc_toPropertyKey(descriptor.key), descriptor); } }
function red5pro_rtc_createClass(Constructor, protoProps, staticProps) { if (protoProps) red5pro_rtc_defineProperties(Constructor.prototype, protoProps); if (staticProps) red5pro_rtc_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function red5pro_rtc_toPropertyKey(arg) { var key = red5pro_rtc_toPrimitive(arg, "string"); return red5pro_rtc_typeof(key) === "symbol" ? key : String(key); }
function red5pro_rtc_toPrimitive(input, hint) { if (red5pro_rtc_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (red5pro_rtc_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function red5pro_rtc_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) red5pro_rtc_setPrototypeOf(subClass, superClass); }
function red5pro_rtc_setPrototypeOf(o, p) { red5pro_rtc_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return red5pro_rtc_setPrototypeOf(o, p); }
function red5pro_rtc_createSuper(Derived) { var hasNativeReflectConstruct = red5pro_rtc_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = red5pro_rtc_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = red5pro_rtc_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return red5pro_rtc_possibleConstructorReturn(this, result); }; }
function red5pro_rtc_possibleConstructorReturn(self, call) { if (call && (red5pro_rtc_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return red5pro_rtc_assertThisInitialized(self); }
function red5pro_rtc_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function red5pro_rtc_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function red5pro_rtc_getPrototypeOf(o) { red5pro_rtc_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return red5pro_rtc_getPrototypeOf(o); }




















var subStartRegex = /(.*) starting/i;
var red5pro_rtc_NAME = 'RTCSubscriber';

/**
 * Simple generation of unique subscriber id.
 *
 * @return {String}
 *
 * @private
 */
var generateSubscriptionId = function generateSubscriptionId() {
  var id = Math.floor(Math.random() * 0x10000).toString(16);
  return "subscriber-".concat(id);
};

// Default to secure settings.
var defaultOptions = {
  protocol: 'wss',
  port: 443,
  app: 'live',
  autoLayoutOrientation: true,
  mediaElementId: 'red5pro-subscriber',
  rtcConfiguration: {
    iceServers: [{
      urls: 'stun:stun2.l.google.com:19302'
    }],
    iceCandidatePoolSize: 2,
    bundlePolicy: 'max-bundle'
  },
  // Favored over iceServers.
  iceServers: undefined,
  // Deprecated. Preserved for backward-compatibility.
  iceTransport: IceTransportTypes.UDP,
  muteOnAutoplayRestriction: true,
  maintainConnectionOnSubscribeErrors: false,
  signalingSocketOnly: true,
  dataChannelConfiguration: undefined,
  socketSwitchDelay: 1000,
  bypassAvailable: false,
  maintainStreamVariant: false,
  enableLiveSeek: false
};

/**
 * Main entry for WebRTC-based Subscriber.
 *
 * @extends EventEmitter
 * @extends SubscriberPlaybackController
 */
var red5pro_rtc_RTCSubscriber = /*#__PURE__*/function (_PlaybackController) {
  red5pro_rtc_inherits(RTCSubscriber, _PlaybackController);
  var _super = red5pro_rtc_createSuper(RTCSubscriber);
  function RTCSubscriber() {
    var _this;
    red5pro_rtc_classCallCheck(this, RTCSubscriber);
    _this = _super.call(this);
    _this._view = undefined;
    _this._options = undefined;
    _this._peerHelper = undefined;
    _this._socketHelper = undefined;
    _this._messageTransport = undefined;
    _this._connectionClosed = true;
    _this._sourceHandler = undefined;
    _this._mediaStream = undefined;
    _this._viewResolver = new DeferredPromise();
    _this._availabilityResolver = new DeferredPromise();
    _this._subscriptionResolver = new DeferredPromise();
    _this._orientation = 0;
    _this._streamingMode = 'Video/Audio';
    _this._switchChannelRequest = undefined;
    return _this;
  }
  red5pro_rtc_createClass(RTCSubscriber, [{
    key: "_getViewResolverPromise",
    value: function _getViewResolverPromise() {
      return this._viewResolver.promise;
    }
  }, {
    key: "_getAvailabilityResolverPromise",
    value: function _getAvailabilityResolverPromise() {
      return this._availabilityResolver.promise;
    }
  }, {
    key: "_getSubscriptionResolverPromise",
    value: function _getSubscriptionResolverPromise() {
      return this._subscriptionResolver.promise;
    }

    /**
     * Gloms the Playback Controls API onto this instance to provide ease in 3se.
     *
     * @param {Object} handler
     *        The method request handler to bind and forward calls on.
     *
     * @private
     */
  }, {
    key: "_glomSourceHandlerAPI",
    value: function _glomSourceHandlerAPI(handler) {
      var _this2 = this;
      this.play = handler.play.bind(handler);
      this.pause = handler.pause.bind(handler);
      this.resume = handler.resume.bind(handler);
      this.stop = handler.stop.bind(handler);
      this.mute = handler.mute.bind(handler);
      this.unmute = handler.unmute.bind(handler);
      this.setVolume = handler.setVolume.bind(handler);
      this.seekTo = handler.seekTo.bind(handler);
      this.toggleFullScreen = handler.toggleFullScreen.bind(handler);
      handler.on('*', function (event) {
        _this2.trigger(new SubscriberEvent(event.type, _this2, event.data));
      });
    }

    /**
     * Still in use, but hold-over of previous 3.x SDK versions designed to pair views and subscribers. In 4.0.0 it has been internalized.
     * API deprecated.
     *
     * @private
     */
  }, {
    key: "_setViewIfNotExist",
    value: function _setViewIfNotExist(currentView) {
      var mediaElementId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      if (typeof currentView === 'undefined' && mediaElementId !== undefined) {
        var view = new playback(mediaElementId);
        view.attachSubscriber(this);
      }
    }

    /**
     * Attempt to initialize the subscription handler for WebRTC.
     *
     * @param {Object} options
     *        The initialization configuration.
     * @param {Object} handler
     *        The handler instance that will manage view interaction and events.
     *
     * @private
     */
  }, {
    key: "_initHandler",
    value: function _initHandler(options, handler) {
      if (options && handler) {
        handler.on('*', this._boundBubbleSubscriberEvents);
        handler.addSource(options);
      }
    }

    /**
     * Request available stream by name on server through WebSocket request.
     *
     * @param {String} streamName
     *        The name of the stream to look up.
     * @private
     */
  }, {
    key: "_requestAvailability",
    value: function _requestAvailability(streamName) {
      log_debug(red5pro_rtc_NAME, '[requestavailability]');
      // message on socket returns -> onStream(Un)Available
      this._socketHelper.post({
        isAvailable: streamName
      });
    }

    /**
     * Request offer over WebSocket.
     *
     * @param {String} streamName
     *        The name of the stream to subscribe to.
     * @param {String} subscriptionId
     *        The unique id of this subscriber.
     * @param {String} transport
     *        The transport type to use.
     * @param {Boolean} useDataChannel
     *        Whether to use data channel for signalling.
     * @param {Boolean} maintainVariant
     *        Whether to notify the server to keep the specified stream name when transcoding, and not switch to variants on network conditions.
     * @param {String} vEncoding
     *        Optional encoding type for video. Defaults to server selection.
     * @param {String} aEncoding
     *        Optional encoding type for audio. Defaults to server selection.
     *
     * @private
     */
  }, {
    key: "_requestOffer",
    value: function _requestOffer(streamName, subscriptionId, transport, useDataChannel, maintainVariant) {
      var vEncoding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;
      var aEncoding = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;
      log_debug(red5pro_rtc_NAME, '[requestoffer]');
      var offer = {
        requestOffer: streamName,
        requestId: subscriptionId,
        transport: transport,
        datachannel: useDataChannel,
        doNotSwitch: maintainVariant
      };
      if (typeof vEncoding !== 'undefined' && vEncoding !== PlaybackVideoEncoder.NONE) {
        offer.videoEncoding = vEncoding;
      } else if (browser.getIsEdge()) {
        // Force VP8 on Edge if not specified in the init config.
        // offer.videoEncoding = PlaybackVideoEncoder.VP8
      }
      if (typeof aEncoding !== 'undefined' && aEncoding !== PlaybackAudioEncoder.NONE) {
        offer.audioEncoding = aEncoding;
      }
      this.trigger(new SubscriberEvent(RTCSubscriberEventTypes.OFFER_START, this));
      // message on socket returns -> onSDPOffer
      this._socketHelper.post(offer);
      return true;
    }

    /**
     * Creates and sends an answer based on provided SDP.
     *
     * @param {Object} sdp
     *        The SDP object to use in creating an SDP answer to send back.
     *
     * @private
     */
  }, {
    key: "_requestAnswer",
    value: function _requestAnswer(sdp) {
      var _this3 = this;
      log_debug(red5pro_rtc_NAME, '[requestanswer]');
      // invokes -> sendAnswer
      this._peerHelper.createAnswer(sdp).then(function (sessionDescription) {
        log_debug(red5pro_rtc_NAME, '[onanswercreated]');
        log_debug(red5pro_rtc_NAME, '[> sendanswer]');
        _this3._sendAnswer(_this3._options.streamName, _this3._options.subscriptionId, sessionDescription);
      }).catch(function (error) {
        _this3.onSDPError(error);
      });
    }

    /**
     * Posts SDP answer to server over WebSocket.
     *
     * @param {String} streamName
     *        The target stream name.
     * @param {String} subscriptionId
     *        The unique id of this subscriber.
     * @param {Object} sdp
     *        The SDP to send as an answer.
     *
     * @private
     */
  }, {
    key: "_sendAnswer",
    value: function _sendAnswer(streamName, subscriptionId, sdp) {
      log_debug(red5pro_rtc_NAME, "[sendanswer]: streamname(".concat(streamName, "), subscriptionid(").concat(subscriptionId, ")"));
      this.trigger(new SubscriberEvent(RTCSubscriberEventTypes.ANSWER_START, this, sdp));
      // message on socket response -> onAddIceCandidate
      // message on peer response -> onaddstream
      this._socketHelper.post({
        handleAnswer: streamName,
        requestId: subscriptionId,
        data: {
          sdp: sdp
        }
      });
    }

    /**
     * Sends a candidate to the server over WebSocket.
     *
     * @param {Object} candidate
     *        The peer candidate description.
     *
     * @private
     */
  }, {
    key: "_sendCandidate",
    value: function _sendCandidate(candidate) {
      log_debug(red5pro_rtc_NAME, '[sendcandidate]');
      this.trigger(new SubscriberEvent(RTCSubscriberEventTypes.CANDIDATE_START, this, candidate));
      // message on peer response -> onicecandidate
      this._socketHelper.post({
        handleCandidate: this._options.streamName,
        requestId: this._options.subscriptionId,
        data: {
          candidate: candidate
        }
      });
    }

    /**
     * Setup and connect to begin a subscription.
     * This is invoked once the availability of the stream is recognized on the server and notified on this instance.
     *
     * @param {RTCConfiguration} rtcConfiguration
     *        A custom RTCConfiguration
     * @param {Object} dataChannelConfiguration
     *        Optional configuration for data channel communicaton.
     * @param {Array} iceServers
     *        The ICE server list to use in trickle.
     * @note For backward compatibility, keeping arguments as optional, with at least one being fulfilled. The `configuration` param will be favored after 5.4.0, `iceServers` is up for deprecation.
     *
     * @private
     */
  }, {
    key: "_connect",
    value: function _connect(configuration) {
      var _this4 = this;
      var dataChannelConfiguration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var iceServers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      log_debug(red5pro_rtc_NAME, '[connect]');
      if (iceServers && configuration) {
        log_warn('The iceServers configuration property is considered deprecated. Please use the rtcConfiguration configuration property upon which you can assign iceServers. Reference: https://www.red5pro.com/docs/streaming/migrationguide.html');
        configuration.iceServers = iceServers;
      }
      this._options.iceServers = configuration ? configuration.iceServers : iceServers;
      var p;
      if (configuration !== undefined) {
        p = this._peerHelper.setUpWithPeerConfiguration(configuration, dataChannelConfiguration, undefined);
      } else {
        p = this._peerHelper.setUp(this._options.iceServers, undefined, this._options.rtcpMuxPolicy);
      }
      p.then(function (connection) {
        _this4.trigger(new SubscriberEvent(RTCSubscriberEventTypes.PEER_CONNECTION_AVAILABLE, _this4, connection));
        _this4._requestOffer(_this4._options.streamName, _this4._options.subscriptionId, _this4._options.iceTransport, _this4._options.signalingSocketOnly, _this4._options.maintainStreamVariant, _this4._options.videoEncoding, _this4._options.audioEncoding);
      }).catch(function (e) {
        log_warn(red5pro_rtc_NAME, 'Could not establish RTCPeerConnection.');
        _this4.trigger(new SubscriberEvent(SubscriberEventTypes.CONNECT_FAILURE, _this4));
      });
      //  TODO: Normalize returns to either all be chainable or not be chainable
      return this;
    }

    /**
     * Disconnect and teardown after close of subscription.
     *
     * @private
     */
  }, {
    key: "_disconnect",
    value: function _disconnect() {
      if (this._socketHelper) {
        log_debug(red5pro_rtc_NAME, '[disconnect:socket]');
        this._socketHelper.tearDown();
      }
      if (this._peerHelper) {
        log_debug(red5pro_rtc_NAME, '[disconnect:peer]');
        this._peerHelper.tearDown();
      }
      if (this._view) {
        this._view.detachStream();
      }
      this._socketHelper = undefined;
      this._peerHelper = undefined;
      this._messageTransport = undefined;
      if (this._sourceHandler) {
        log_debug(red5pro_rtc_NAME, '[disconnect:source]');
        this._sourceHandler.disconnect();
        this._sourceHandler = undefined;
      }
      this._connectionClosed = true;
    }

    /**
     * Request to kick off autoplay if setting is flagged.
     *
     * @param {Object} options
     *        The initialization object.
     * @param {Element} view
     *        The target element view that will playback the stream.
     *
     * @private
     */
  }, {
    key: "_playIfAutoplaySet",
    value: function _playIfAutoplaySet(options, view) {
      if (options && view) {
        options.autoplay = browser.hasAttributeDefined(view.view, 'autoplay');
        if (options.autoplay) {
          this._sourceHandler.attemptAutoplay(options.muteOnAutoplayRestriction);
        }
      }
    }

    /**
     * Request to enabled scrubbable/seekeable playback with HLS.
     *
     * @private
     */
  }, {
    key: "_startSeekable",
    value: function _startSeekable(options) {
      var enableLiveSeek = options.enableLiveSeek;
      if (!enableLiveSeek) return;
      try {
        if (browser.supportsHLS() || browser.supportsNonNativeHLS()) {
          this._sourceHandler.enableLiveSeek(optionsToHlsURL(options), browser.supportsHLS());
        } else {
          throw new Error();
        }
      } catch (e) {
        log_error(red5pro_rtc_NAME, "Could not utilize the 'enableLiveSeek' request. This feature requires either native HLS playback or hls.js as a depenency.");
      }
    }

    /**
     * Request to begin subscription on server over WebSocket.
     *
     * @private
     */
  }, {
    key: "_sendSubscribe",
    value: function _sendSubscribe() {
      log_debug(red5pro_rtc_NAME, '[sendsubscribe]');
      this._socketHelper.post({
        subscribe: this._options.streamName,
        requestId: this._options.subscriptionId
      });
    }

    /**
     * Request to initialize the WebRTC-based Subscriber based on configuration.
     * The returned `Promise` will either resolve with a reference to this instance or reject with an error `String` in failure.
     *
     * @param {Object} options
     *        The initialization configuration map.
     * @return {Promise}
     */
  }, {
    key: "init",
    value: function init(options) {
      var _this5 = this;
      var deferred = new DeferredPromise();
      if (!webrtc_isSupported() || !websocket_isSupported()) {
        deferred.reject('Cannot create WebRTC playback instance. Your environment does not support WebRTC and/or WebSockets.');
      } else {
        this._disconnect();
        this._options = Object.assign({}, defaultOptions, options);
        this._options.subscriptionId = this._options.subscriptionId || generateSubscriptionId();
        this._peerHelper = new webrtc_helper_sub(this);
        this._socketHelper = new socket_helper_sub(this);
        this._messageTransport = this._messageTransport || this._socketHelper;
        var socketPromise = new DeferredPromise();
        var socketurl = rtcSocketEndpointFromOptions(this._options, {
          id: this._options.subscriptionId
        });
        socketPromise.promise.then(function () {
          deferred.resolve(_this5);
          _this5._connectionClosed = false;
          _this5.trigger(new SubscriberEvent(SubscriberEventTypes.CONNECT_SUCCESS, _this5));
        }).catch(function (error) {
          deferred.reject(error);
          _this5.trigger(new SubscriberEvent(SubscriberEventTypes.CONNECT_FAILURE, _this5, error));
        });
        this._socketHelper.setUp(socketurl, socketPromise);
      }
      return deferred.promise;
    }

    /**
     * Still in use for assigning document element view management to this instance.
     * API deprecated in 4.0.0.
     *
     * @private
     */
  }, {
    key: "setView",
    value: function setView(view) {
      this._view = view;
      this._viewResolver.resolve(this._view);
      return this;
    }

    /**
     * Request to begin subscribing to a stream.
     *
     * @return {Promise}
     *          The returned `Promise` will resolve or reject on successful start of playback.
     *        There are several processes that occur in order to establish a WebRTC subscription that involve - but are not limited to - ICE communication and assigning of local and remote SDPs on peer connections.
     */
  }, {
    key: "subscribe",
    value: function subscribe() {
      var _this6 = this;
      var _this$_options = this._options,
        streamName = _this$_options.streamName,
        mediaElementId = _this$_options.mediaElementId,
        rtcConfiguration = _this$_options.rtcConfiguration,
        enableLiveSeek = _this$_options.enableLiveSeek;
      var _this$_options2 = this._options,
        signalingSocketOnly = _this$_options2.signalingSocketOnly,
        dataChannelConfiguration = _this$_options2.dataChannelConfiguration;
      // Set default data channel configuration if not defined and severing socket on signal end.
      // TODO: Set this as more "private" with `red5pro-<streamname>`
      var dataChannelAllowed = signalingSocketOnly && webrtc_supportsDataChannel();
      if (dataChannelAllowed && !dataChannelConfiguration) {
        dataChannelConfiguration = {
          name: "red5pro"
        };
      }
      this._options.signalingSocketOnly = dataChannelAllowed;
      this._getViewResolverPromise().then(function (view) {
        if (enableLiveSeek) {
          if (browser.supportsHLS() || browser.supportsNonNativeHLS()) {
            _this6._sourceHandler = new red5pro_source_handler_rtc_seekable(view.view, _this6.getType());
          } else {
            log_error(red5pro_rtc_NAME, "Could not utilize the 'enableLiveSeek' request. This feature requires either native HLS playback or hls.js as a depenency.");
            _this6._sourceHandler = new red5pro_source_handler_rtc(view.view, _this6.getType());
          }
        } else {
          _this6._sourceHandler = new red5pro_source_handler_rtc(view.view, _this6.getType());
        }
        _this6._glomSourceHandlerAPI(_this6._sourceHandler);
        _this6._initHandler(_this6._options, _this6._sourceHandler);
      }).catch(function () {
        // passed up through overarching promise.
      });
      this._getAvailabilityResolverPromise().then(function () {
        _this6._connect(rtcConfiguration, dataChannelConfiguration, _this6._options.iceServers);
      }).catch(function () {
        // passed up through overarching promise.
      });
      this._setViewIfNotExist(this._view, mediaElementId);
      if (this._options.bypassAvailable) {
        this._availabilityResolver.resolve(this);
      } else {
        this._requestAvailability(streamName);
      }
      return this._getSubscriptionResolverPromise();
    }

    /**
     * Request to stop a subscription.
     * The returned `Promise` will either resolve or reject on successful stop of subscription.
     *
     * @return {Promise}
     */
  }, {
    key: "unsubscribe",
    value: function unsubscribe() {
      log_debug(red5pro_rtc_NAME, '[unsubscribe]');
      var deferred = new DeferredPromise();
      this.stop();
      this._disconnect();
      this._mediaStream = undefined;
      deferred.resolve(this);
      this.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_STOP, this));
      return deferred.promise;
    }

    /**
     * Event handler for stream being available on server.
     *
     * @private
     */
  }, {
    key: "onStreamAvailable",
    value: function onStreamAvailable(receipt) {
      log_debug(red5pro_rtc_NAME, '[onstreamavailable]: ' + JSON.stringify(receipt, null, 2));
      this._availabilityResolver.resolve(this);
    }

    /**
     * Event handler for stream being unavailable on server.
     *
     * @private
     */
  }, {
    key: "onStreamUnavailable",
    value: function onStreamUnavailable(receipt) {
      log_debug(red5pro_rtc_NAME, "Stream ".concat(this._options.streamName, " does not exist."));
      log_debug(red5pro_rtc_NAME, '[onstreamunavailable]: ' + JSON.stringify(receipt, null, 2));
      this.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_INVALID_NAME, this));
      this._availabilityResolver.reject("Stream ".concat(this._options.streamName, " does not exist."));
      this._subscriptionResolver.reject("Stream ".concat(this._options.streamName, " does not exist."));
      if (!this._options.maintainConnectionOnSubscribeErrors) {
        this._disconnect();
      } else {
        // Reset promise for possible retry.
        this._availabilityResolver = new DeferredPromise();
        this._subscriptionResolver = new DeferredPromise();
      }
    }

    /**
     * Event handler for success of SDP being added remotely and locally through the Peer Connection.
     *
     * @param {Object} receipt
     *
     * @private
     */
  }, {
    key: "onSDPSuccess",
    value: function onSDPSuccess(receipt) {
      log_debug(red5pro_rtc_NAME, '[onsdpsuccess]: ' + JSON.stringify(receipt, null, 2));
    }

    /**
     * Event handler for success in SDP offer.
     *
     * @param {Object} receipt
     *        The optional successful object.
     *
     * @private
     */
  }, {
    key: "onSDPOffer",
    value: function onSDPOffer(receipt) {
      log_debug(red5pro_rtc_NAME, '[onsdpoffer]: ' + JSON.stringify(receipt, null, 2));
      /*
      // Comment out in favor of `datachannel:true` in request offer.
      if (this._options.signalingSocketOnly) {
        const {
          sdp
        } = receipt
        const ufragregx = /a=ice-ufrag:(.*)/g
        const pwdregx = /a=ice-pwd:(.*)/g
        const fingerprintregx = /a=fingerprint:(.*)/g
        receipt.sdp.sdp = sdp.sdp.replace('a=group:BUNDLE audio video', 'a=group:BUNDLE audio video 2')
        // Below is remote.
        // receipt.sdp.sdp += `m=application 9 UDP/DTLS/SCTP 5000\r\nc=IN IP4 73.143.36.217\r\na=ice-ufrag:${ufragregx.exec(sdp.sdp)[1]}\r\na=ice-pwd:${pwdregx.exec(sdp.sdp)[1]}\r\na=fingerprint:${fingerprintregx.exec(sdp.sdp)[1]}\r\na=setup:passive\r\na=mid:2\r\na=sendrecv\r\na=sctpmap:5000 webrtc-datachannel 1024`
         // Below is local.
        receipt.sdp.sdp += `m=application 9 UDP/DTLS/SCTP webrtc-datachannel\r\nc=IN IP4 0.0.0.0\r\na=ice-ufrag:${ufragregx.exec(sdp.sdp)[1]}\r\na=ice-pwd:${pwdregx.exec(sdp.sdp)[1]}\r\na=ice-options:trickle\r\na=fingerprint:${fingerprintregx.exec(sdp.sdp)[1]}\r\na=setup:actpass\r\na=mid:2\r\na=sctp-port:5000\r\na=max-message-size:262144\r\n`
      }
      */
      var sessionDescription = new RTCSessionDescription(receipt.sdp);
      this.trigger(new SubscriberEvent(RTCSubscriberEventTypes.OFFER_END, this));
      this._requestAnswer(sessionDescription);
    }

    /**
     * Event handler for all errors related to SDP through the Peer Connection.
     *
     * @param {Object} receipt
     *        The optional error object.
     *
     * @private
     */
  }, {
    key: "onSDPError",
    value: function onSDPError(receipt) {
      this.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_FAIL, this, receipt));
      this._subscriptionResolver.reject('Invalid SDP.');
      log_error(red5pro_rtc_NAME, '[onsdperror]');
      log_error(red5pro_rtc_NAME, receipt);
    }

    /**
     * Event handler for receipt of a `MediaStream`.
     *
     * @param {MediaStream} stream
     *        The stream returned on the Peer Connection.
     *
     * @private
     */
  }, {
    key: "onAnswerMediaStream",
    value: function onAnswerMediaStream() {
      var stream = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      // eslint-disable-line no-unused-vars
      this.trigger(new SubscriberEvent(RTCSubscriberEventTypes.ANSWER_END, this));
    }

    /**
     * Event handler on receipt of ICE candidate.
     *
     * @param {Object} candidate
     *        The ICE candidate.
     *
     * @private
     */
  }, {
    key: "onIceCandidate",
    value: function onIceCandidate(candidate) {
      log_debug(red5pro_rtc_NAME, '[onicecandidate]');
      this.trigger(new SubscriberEvent(RTCSubscriberEventTypes.CANDIDATE_END, this));
      this._sendCandidate(candidate);
    }

    /**
     * Event handler for end of ICE communication (trickle).
     *
     * @param {MediaStream} stream
     *        The `MediaStream` that has become available post-trickle.
     *
     * @private
     */
  }, {
    key: "onIceCandidateTrickleEnd",
    value: function onIceCandidateTrickleEnd(stream) {
      var _this7 = this;
      log_debug(red5pro_rtc_NAME, '[onicetrickleend]');
      this._getViewResolverPromise().then(function (view) {
        view.attachStream(stream);
        _this7._mediaStream = stream;
        _this7.trigger(new SubscriberEvent(RTCSubscriberEventTypes.ON_ADD_STREAM, _this7, _this7._mediaStream));
      });
    }

    /**
     * Event handler to add ICE candidate to Peer Connection.
     *
     * @param {Object} candidate
     *
     * @private
     */
  }, {
    key: "onAddIceCandidate",
    value: function onAddIceCandidate(candidate) {
      log_debug(red5pro_rtc_NAME, '[onaddicecandidate]');
      this._peerHelper.addIceCandidate(candidate);
    }

    /**
     * Event handler for receipt of empty candidate during ICE negotiation.
     *
     * @private
     */
  }, {
    key: "onEmptyCandidate",
    value: function onEmptyCandidate() {
      log_debug(red5pro_rtc_NAME, '[icecandidatetrickle:empty]');
      this.trigger(new SubscriberEvent(RTCSubscriberEventTypes.PEER_CANDIDATE_END));
    }

    /**
     * Event handler for completion of peer ice candidate gathering.
     *
     * @private
     */
  }, {
    key: "onPeerGatheringComplete",
    value: function onPeerGatheringComplete() {
      log_debug(red5pro_rtc_NAME, '[icecandidategathering:end]');
      if (this._socketHelper) {
        this._socketHelper.postEndOfCandidates(this._options.streamName);
      }
    }

    /**
     * Event handler for notification of end in ice candidates over the WebSocket.
     *
     * @private
     */
  }, {
    key: "onSocketIceCandidateEnd",
    value: function onSocketIceCandidateEnd() {
      log_debug(red5pro_rtc_NAME, '[onsocketicecandidateend]');
      this.trigger(new SubscriberEvent(RTCSubscriberEventTypes.ICE_TRICKLE_COMPLETE, this));
      this._sendSubscribe();
    }

    /**
     * General event handler for all messages.
     *
     * @private
     */
  }, {
    key: "onSocketMessage",
    value: function onSocketMessage(socket, message) {
      this.trigger(new SubscriberEvent(RTCSubscriberEventTypes.SOCKET_MESSAGE, this, {
        socket: socket,
        message: message
      }));
    }

    /**
     * General event handler for errors coming over the WebSocket.
     *
     * @param {String} message
     * @param {Object} detail
     *        Optional additional detail.
     *
     * @private
     */
  }, {
    key: "onSocketMessageError",
    value: function onSocketMessageError(message) {
      var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      log_error(red5pro_rtc_NAME, "Error in stream subscription: ".concat(message, ".\n[Optional detail]: ").concat(detail));
      this._subscriptionResolver.reject("Error in stream subscription: ".concat(message, "."));
      this.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_FAIL, this, message));
    }

    /**
     * Event handler for close on the WebSocket.
     *
     * @param {Event} closeEvent
     *
     * @private
     */
  }, {
    key: "onSocketClose",
    value: function onSocketClose(closeEvent) {
      log_debug(red5pro_rtc_NAME, '[onsocketclose]');
      if (this._peerHelper) {
        this._peerHelper.tearDown();
      }
      this.onConnectionClosed(closeEvent);
    }

    /**
     * Event handler for fail in Peer Connection.
     *
     * @private
     */
  }, {
    key: "onPeerConnectionFail",
    value: function onPeerConnectionFail() {
      log_debug(red5pro_rtc_NAME, '[onpeerconnectionfail]');
      this.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_FAIL, this, 'fail'));
      this._subscriptionResolver.reject('Peer Connection Failed.');
    }

    /**
     * Event handler for close of Peer Connection.
     *
     * @param {Event} event
     *
     * @private
     */
  }, {
    key: "onPeerConnectionClose",
    value: function onPeerConnectionClose(event) {
      log_debug(red5pro_rtc_NAME, '[onpeerconnectionclose]');
      if (this._socketHelper) {
        this._socketHelper.tearDown();
      }
      this.onSocketClose(event);
    }

    /**
     * Event handler for open of Peer Connection.
     *
     * @private
     */
  }, {
    key: "onPeerConnectionOpen",
    value: function onPeerConnectionOpen() {
      log_debug(red5pro_rtc_NAME, '[onpeerconnectionopen]');
      this.trigger(new SubscriberEvent(RTCSubscriberEventTypes.PEER_CONNECTION_OPEN), this, this.getPeerConnection());
    }

    /**
     * Event handler for `Unpublish` of stream subscribed to. Occurs when a broadcaster stops their stream while this subscription stream is open.
     *
     * @private
     */
  }, {
    key: "onUnpublish",
    value: function onUnpublish() {
      log_debug(red5pro_rtc_NAME, '[onunpublish]');
      if (this._sourceHandler) {
        this._sourceHandler.unpublish();
      }
      this.trigger(new SubscriberEvent(SubscriberEventTypes.PLAY_UNPUBLISH, this));
      this.unsubscribe();
    }

    /**
     * Event handler for connection on stream being closed.
     *
     * @private
     */
  }, {
    key: "onConnectionClosed",
    value: function onConnectionClosed() {
      var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      if (!this._connectionClosed) {
        log_debug(red5pro_rtc_NAME, '[onconnectionclosed]');
        this._disconnect();
        this.trigger(new SubscriberEvent(SubscriberEventTypes.CONNECTION_CLOSED, this, event));
      }
    }

    /**
     * Event handler for accepting data through the `send` API of a Publisher. This is the receiving end of the communication channel in which a Publisher can send data to all subscribers.
     *
     * @param {String} methodName
     *        The target method name associated with the communication.
     * @param {Object} data
     *        The data being sent.
     *
     * @private
     */
  }, {
    key: "onSendReceived",
    value: function onSendReceived(methodName, data) {
      if (methodName === 'onMetaData') {
        this.onMetaData(data);
      } else if (methodName === 'onPublisherNetworkCongestion') {
        this.onPublisherNetworkCongestion(data);
      } else if (methodName === 'onPublisherNetworkRecovery') {
        this.onPublisherNetworkRecovery(data);
      } else {
        // environment.invoke(methodName, data)
        this.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_SEND_INVOKE, this, {
          methodName: methodName,
          data: data
        }));
      }
    }

    /**
     * Event handler for status notifications of the subscription stream coming over the WebSocket.
     *
     * @param {Object} status
     *        The status object.
     *
     * @private
     */
  }, {
    key: "onSubscriberStatus",
    value: function onSubscriberStatus(status) {
      log_debug(red5pro_rtc_NAME, '[subscriberstatus] - ' + JSON.stringify(status, null, 2));
      var startResult = subStartRegex.exec(status.message);
      if (startResult && startResult[1] === this._options.streamName) {
        this._subscriptionResolver.resolve(this);
        this.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_START, this));
        this._playIfAutoplaySet(this._options, this._view);
        this._startSeekable(this._options, this._view);
      } else {
        this.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_STATUS, this, status));
      }
    }

    /**
     * Event listener for Data Channel being open on server to switch signaling.
     *
     * @private
     */
  }, {
    key: "onDataChannelAvailable",
    value: function onDataChannelAvailable(channelName) {
      var _this8 = this;
      log_debug('[ondatachannel::available]');
      this._switchChannelRequest = {
        switchChannel: channelName || 'red5pro'
      };
      if (this._options.signalingSocketOnly) {
        var t = setTimeout(function () {
          clearTimeout(t);
          if (_this8._socketHelper) {
            _this8._socketHelper.sever(_this8._switchChannelRequest);
          }
          _this8._messageTransport = _this8._peerHelper;
          _this8.trigger(new MessageTransportStateEvent(MessageTransportStateEventTypes.CHANGE, _this8, {
            controller: _this8,
            transport: _this8._messageTransport
          }));
        }, this._socketHelper ? this._options.socketSwitchDelay : 100);
      }
      this.trigger(new SubscriberEvent(RTCSubscriberEventTypes.DATA_CHANNEL_AVAILABLE, this, {
        name: channelName,
        dataChannel: this.getDataChannel()
      }));
    }

    /**
     * Event handler for notifications of error on optional data channel.
     *
     * @param {RTCDataChannel} dataChannel
     * @param {String} error
     *
     * @private
     */
  }, {
    key: "onDataChannelError",
    value: function onDataChannelError(dataChannel, error) {
      this.trigger(new SubscriberEvent(RTCSubscriberEventTypes.DATA_CHANNEL_ERROR, this, {
        dataChannel: dataChannel,
        error: error
      }));
    }

    /**
     * Event handler for notifications of message on optional data channel.
     *
     * @param {RTCDataChannel} dataChannel
     * @param {Object} message
     *
     * @private
     */
  }, {
    key: "onDataChannelMessage",
    value: function onDataChannelMessage(dataChannel, messageData) {
      this.trigger(new SubscriberEvent(RTCSubscriberEventTypes.DATA_CHANNEL_MESSAGE, this, {
        dataChannel: dataChannel,
        message: messageData
      }));
    }

    /**
     * Event handler for open notification on optional data channel.
     *
     * @param {RTCDataChannel} dataChannel
     *
     * @private
     */
  }, {
    key: "onDataChannelOpen",
    value: function onDataChannelOpen(dataChannel) {
      this.trigger(new SubscriberEvent(RTCSubscriberEventTypes.DATA_CHANNEL_OPEN, this, {
        dataChannel: dataChannel
      }));
    }

    /**
     * Event handler for close notification on optional data channel.
     *
     * @param {RTCDataChannel} dataChannel
     *
     * @private
     */
  }, {
    key: "onDataChannelClose",
    value: function onDataChannelClose(dataChannel) {
      this.trigger(new SubscriberEvent(RTCSubscriberEventTypes.DATA_CHANNEL_CLOSE, this, {
        dataChannel: dataChannel
      }));
    }

    /**
     * Event handler for metadata being sent related to the subscription stream coming over the WebSocket.
     *
     * @param {Object} metadata
     *
     * @private
     */
  }, {
    key: "onMetaData",
    value: function onMetaData(metadata) {
      var orientation = metadata.orientation,
        streamingMode = metadata.streamingMode;
      var previousStreamingMode = this._streamingMode;
      if (typeof orientation !== 'undefined' && orientation !== this._orientation) {
        this._orientation = orientation;
        if (this._options.autoLayoutOrientation) {
          applyOrientation(this._view.view, parseInt(orientation, 10), metadataResolutionToObject(metadata.resolution));
          if (this._sourceHandler) {
            this._sourceHandler.handleOrientationChange(parseInt(orientation, 10));
          }
        }
        this.trigger(new SubscriberEvent(SubscriberEventTypes.ORIENTATION_CHANGE, this, {
          orientation: parseInt(orientation, 10),
          viewElement: this._view.view
        }));
      }
      if (typeof streamingMode !== 'undefined' && streamingMode !== previousStreamingMode) {
        this._streamingMode = streamingMode;
        this.trigger(new SubscriberEvent(SubscriberEventTypes.STREAMING_MODE_CHANGE, this, {
          streamingMode: streamingMode,
          previousStreamingMode: previousStreamingMode,
          viewElement: this._view.view
        }));
      }
      this.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_METADATA, this, metadata));
    }

    /**
     * Event handler for network congestion metadata coming in from server related to publisher broadcast conditions.
     *
     * @param {Object} data
     *
     * @private
     */
  }, {
    key: "onPublisherNetworkCongestion",
    value: function onPublisherNetworkCongestion(data) {
      this.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_PUBLISHER_CONGESTION, this, data));
    }

    /**
     * Event handler for network recovery metadata coming in from server related to publisher broadcast conditions.
     *
     * @param {Object} data
     *
     * @private
     */
  }, {
    key: "onPublisherNetworkRecovery",
    value: function onPublisherNetworkRecovery(data) {
      this.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_PUBLISHER_RECOVERY, this, data));
    }

    /**
     * Request to invoke a method on the Application Adapter related to the `app` config setting.
     *
     * @param {String} methodName
     *        The name of the method to invoke on thw Application Adapter
     * @param {Array} args
     *        The ordered list of arguments to invoke on the method. Do not provide anything if the method takes no arguments.
     * @return {Promise}
     */
  }, {
    key: "callServer",
    value: function callServer(methodName, args) {
      return this.getMessageTransport().postAsync({
        callAdapter: {
          method: methodName,
          arguments: args
        }
      });
    }

    /**
     * Sends an RPC log to the server which will be printed out in server logs.
     *
     * @param {String} level
     *        Valid values: TRACE, INFO, DEBUG, WARN or ERROR
     * @param {Object} message
     *        Either a String or a JSON-serializable Object. This param will be converted to a string to be sent to the server.
     */
  }, {
    key: "sendLog",
    value: function sendLog(level, message) {
      try {
        var theLevel = Object.keys(LEVELS).find(function (l) {
          return l.toLowerCase() === level.toLowerCase();
        }) ? level : LEVELS.DEBUG;
        var theMessage = typeof message === 'string' ? message : JSON.stringify(message);
        this.getMessageTransport().post({
          log: theLevel.toUpperCase(),
          message: theMessage
        });
      } catch (e) {
        var _message = e.message || e;
        log_error(red5pro_rtc_NAME, "Could not send log to server. Message parameter expected to be String or JSON-serializable object.");
        log_error(red5pro_rtc_NAME, _message);
      }
    }

    /**
     * Enters subscriber into standby mode - keeping connection open but not bothering to consume video or audio.
     */
  }, {
    key: "enableStandby",
    value: function enableStandby() {
      this.getMessageTransport().post({
        //      standby: true
        mute: {
          muteAudio: true,
          muteVideo: true
        }
      });
    }

    /**
     * Removes subscriber from standby mode - turning the audio and video back on and consumable after a mute request.
     */
  }, {
    key: "disableStandby",
    value: function disableStandby() {
      this.getMessageTransport().post({
        //      standby: false
        mute: {
          muteAudio: false,
          muteVideo: false
        }
      });
    }

    /**
     * Mutes audio being sent from the server to the subscriber. Audio packets will be held from the subscriber on the server-side.
     */
  }, {
    key: "muteAudio",
    value: function muteAudio() {
      this.getMessageTransport().post({
        mute: {
          muteAudio: true
        }
      });
    }

    /**
     * Unmutes audio being sent from the server to the subscriber. Audio packets will resume being sent to the subscriber.
     */
  }, {
    key: "unmuteAudio",
    value: function unmuteAudio() {
      this.getMessageTransport().post({
        mute: {
          muteAudio: false
        }
      });
    }

    /**
     * Mutes video being sent from the server to the subscriber. Video packets will be held from the subscriber on the server-side.
     */
  }, {
    key: "muteVideo",
    value: function muteVideo() {
      this.getMessageTransport().post({
        mute: {
          muteVideo: true
        }
      });
    }

    /**
     * Unmutes video being sent from the server to the subscriber. Video packets will resume being sent to the subscriber.
     */
  }, {
    key: "unmuteVideo",
    value: function unmuteVideo() {
      this.getMessageTransport().post({
        mute: {
          muteVideo: false
        }
      });
    }

    /**
     * Returns the Message Transport instance that posts requests to the server.
     *
     *  @return {Object}
     *          Either the socker proxy or the peer connection proxy
     *
     * @private
     */
  }, {
    key: "getMessageTransport",
    value: function getMessageTransport() {
      return this._messageTransport;
    }

    /**
     * Returns the current WebSocket connection helper if established.
     * Used in SharedObject communication.
     *
     * @return {PublisherSocketHelper}
     *
     * @private
     */
  }, {
    key: "getConnection",
    value: function getConnection() {
      return this._socketHelper;
    }

    /**
     * Returns the current RTCPeerConnection helper if established.
     *
     * @return {RTCPeerConnection}
     */
  }, {
    key: "getPeerConnection",
    value: function getPeerConnection() {
      return this._peerHelper ? this._peerHelper.connection : undefined;
    }

    /**
     * Returns the optional RTCDataChannel on the opened peer connection.
     *
     * @return {RTCDataChannel}
     */
  }, {
    key: "getDataChannel",
    value: function getDataChannel() {
      return this._peerHelper ? this._peerHelper.dataChannel : undefined;
    }

    /**
     * Returns the `MediaStream` instance if generated through `getUserMedia` and exists for broadcast.
     *
     * @return {MediaStream}
     */
  }, {
    key: "getMediaStream",
    value: function getMediaStream() {
      return this._mediaStream;
    }

    /**
     * Returns reference to playback controls if available.
     *
     * @return {PlaybackControls}
     */
  }, {
    key: "getControls",
    value: function getControls() {
      return this._sourceHandler ? this._sourceHandler.getControls() : undefined;
    }

    /**
     * Returns the target view Element.
     *
     * @return {Element}
     */
  }, {
    key: "getPlayer",
    value: function getPlayer() {
      return this._view.view;
    }

    /**
     * Returns the initialization configuration used in `init()`.
     *
     * @return {Object}
     */
  }, {
    key: "getOptions",
    value: function getOptions() {
      return this._options;
    }

    /**
     * Returns the type of implementation: `RTC`.
     *
     * @return {String}
     */
  }, {
    key: "getType",
    value: function getType() {
      return PlaybackTypes.RTC.toUpperCase();
    }
  }]);
  return RTCSubscriber;
}(PlaybackController);
/* harmony default export */ var red5pro_rtc = (red5pro_rtc_RTCSubscriber);
// CONCATENATED MODULE: ./src/js/env/embed.js





/**
 * Replaces a `video` element with a container for embedding a Flash object.
 *
 * @param {Element} targetElement
 * @param {Element} targetParent
 *
 * @private
 */
var embed_defineEmbedElement = function defineEmbedElement(targetElement, targetParent) {
  var dfd = new DeferredPromise();
  var elementId = targetElement.id;
  if (targetElement.nodeName.toLowerCase() === 'video') {
    var div = browser.createElement('div');
    div.id = elementId + '_rtmp';
    targetParent.appendChild(div);
    if (targetElement.parentElement) {
      targetElement.parentElement.removeChild(targetElement);
    }
    dfd.resolve(div.id);
  } else {
    dfd.resolve(elementId);
  }
  return dfd.promise;
};

/**
 * Request to embed a Flash object using SWFObject library.
 *
 * @param {String} idName
 * @param {Object} options
 *        Initialization configuration map.
 * @param {Object} flashvars
 *        The FlashVars to pass into the embedded object.
 * @param {Object} swfobject
 *        The loaded SWFObject library util.
 * @param {String} elementId
 *        The id of the Element to embed.
 * @return {Promise}
 *
 * @private
 */
var embed_embedSwfObject = function embedSwfObject(idName, options, flashvars, swfobject, elementId) {
  var dfd = new DeferredPromise();
  var params = {
    quality: 'high',
    wmode: 'opaque',
    bgcolor: options.backgroundColor || '#000',
    allowscriptaccess: 'always',
    allowfullscreen: 'true',
    allownetworking: 'all'
  };
  var attributes = {
    id: idName,
    name: idName,
    align: 'middle'
  };
  if (swfobject.hasFlashPlayerVersion(options.minFlashVersion)) {
    swfobject.embedSWF(options.swf, elementId, options.embedWidth || 640, options.embedHeight || 480, options.minFlashVersion, options.productInstallURL, flashvars, params, attributes, function (result) {
      if (result.success) {
        dfd.resolve();
      } else {
        dfd.reject('Flash Object embed failed.');
      }
    });
  } else {
    dfd.reject('Flash Player Version is not supported.');
  }
  return dfd.promise;
};
// CONCATENATED MODULE: ./src/js/helper/sharedobject-helper-rtmp.js


function sharedobject_helper_rtmp_typeof(obj) { "@babel/helpers - typeof"; return sharedobject_helper_rtmp_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, sharedobject_helper_rtmp_typeof(obj); }
function sharedobject_helper_rtmp_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function sharedobject_helper_rtmp_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, sharedobject_helper_rtmp_toPropertyKey(descriptor.key), descriptor); } }
function sharedobject_helper_rtmp_createClass(Constructor, protoProps, staticProps) { if (protoProps) sharedobject_helper_rtmp_defineProperties(Constructor.prototype, protoProps); if (staticProps) sharedobject_helper_rtmp_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function sharedobject_helper_rtmp_toPropertyKey(arg) { var key = sharedobject_helper_rtmp_toPrimitive(arg, "string"); return sharedobject_helper_rtmp_typeof(key) === "symbol" ? key : String(key); }
function sharedobject_helper_rtmp_toPrimitive(input, hint) { if (sharedobject_helper_rtmp_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (sharedobject_helper_rtmp_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }


var sharedobject_helper_rtmp_NAME = 'R5ProRTMPSharedObjectHandler';

/**
 * Flash-based SharedObject handler.
 *
 * @private
 */
var sharedobject_helper_rtmp_RTMPSharedObjectHandler = /*#__PURE__*/function () {
  function RTMPSharedObjectHandler() {
    sharedobject_helper_rtmp_classCallCheck(this, RTMPSharedObjectHandler);
    this._element = undefined;
    this._responseHandlers = [];
  }

  /**
   * Adds a response handler for SharedObject events.
   *
   * @param {Object} handler
   */
  sharedobject_helper_rtmp_createClass(RTMPSharedObjectHandler, [{
    key: "addResponseHandler",
    value: function addResponseHandler(handler) {
      this._responseHandlers.push(handler);
    }

    /**
     * Removes a response handler from SharedObject events.
     *
     * @param {Object} handler
     */
  }, {
    key: "removeResponseHandler",
    value: function removeResponseHandler(handler) {
      var i = this._responseHandlers.length;
      var rHandler;
      while (--i > -1) {
        rHandler = this._responseHandlers[i];
        if (rHandler === handler) {
          this._responseHandlers.splice(i, 1);
          return;
        }
      }
    }

    /**
     * Handles an event from a SharedObject.
     *
     * @param {Object} event
     */
  }, {
    key: "handleSharedObjectEvent",
    value: function handleSharedObjectEvent(event) {
      log_debug(sharedobject_helper_rtmp_NAME, '[sharedobject:event]');
      var i;
      var length = this._responseHandlers.length;
      var handler;
      for (i = 0; i < length; i++) {
        handler = this._responseHandlers[i];
        if (handler.respond(JSON.parse(event))) {
          break;
        }
      }
    }

    /**
     * Assigns a global response handler for SharedObject communication through Flash object over ExternalInterface.
     *
     * @param {String} name
     * @param {Element} el
     *        The object embed element.
     */
  }, {
    key: "assignSharedObjectResponder",
    value: function assignSharedObjectResponder(name, el) {
      var _handleSharedObjectEvent = this.handleSharedObjectEvent.bind(this);
      var elId = el.id.split('-').join('_');
      var handlerName = ['handleSharedObjectEvent', elId].join('_');
      log_debug(sharedobject_helper_rtmp_NAME, "[assign:sharedobject:responder] :: ".concat(elId));
      log_debug(sharedobject_helper_rtmp_NAME, "[sharedoject:responder] :: ".concat(handlerName));
      el.setSharedObjectResponder(name, handlerName);
      browser.setGlobal(handlerName, _handleSharedObjectEvent);
    }

    /**
     * Request to connect to SharedObject.
     */
  }, {
    key: "connect",
    value: function connect(swfId) {
      this._element = browser.getEmbedObject(swfId);
      if (!this._element) {
        log_warn("Could not locate embedded Flash object for id: ".concat(swfId));
      }
    }

    /**
     * Request to disconnect to SharedObject.
     */
  }, {
    key: "disconnect",
    value: function disconnect() {
      while (this._responseHandlers.length > 0) {
        this._responseHandlers.shift();
      }
    }

    /**
     * Attempt to send method update to SharedObject.
     *
     * @param {String} name
     * @param {String} callName
     * @param {Object} message
     *        String or Object that will be serialized to a JSON string.
     */
  }, {
    key: "sendToSharedObject",
    value: function sendToSharedObject(name, methodName, message) {
      log_debug(sharedobject_helper_rtmp_NAME, '[sendToSharedObject]');
      try {
        this._element.sharedObjectSend(name, methodName, typeof message === 'string' ? message : JSON.stringify(message));
      } catch (e) {
        log_warn('Could not send to shared object (' + name + '). Error: ' + e.message);
      }
    }

    /**
     * Attempt to update property on SharedObject.
     *
     * @param {String} name
     * @param {String} key
     * @param {Object} value
     */
  }, {
    key: "sendPropertyToSharedObject",
    value: function sendPropertyToSharedObject(name, key, value) {
      log_debug(sharedobject_helper_rtmp_NAME, '[sendPropertyToSharedObject]');
      try {
        this._element.sharedObjectSendProperty(name, key, value);
      } catch (e) {
        log_warn('Could not send to shared object (' + name + '). Error: ' + e.message);
      }
    }

    /**
     * Request to get remote ShareObject by name.
     *
     * @param {String} sharedObjectName
     */
  }, {
    key: "getRemoteSharedObject",
    value: function getRemoteSharedObject(sharedObjectName) {
      log_debug(sharedobject_helper_rtmp_NAME, '[getRemoteSharedObject]');
      try {
        this.assignSharedObjectResponder(sharedObjectName, this._element);
        this._element.getRemoteSharedObject(sharedObjectName);
      } catch (e) {
        log_warn('Could not get remote shared object (' + name + '). Error: ' + e.message);
      }
    }

    /**
     * Request to connect to SharedObject by name.
     *
     * @param {String} sharedObjectName
     */
  }, {
    key: "connectToSharedObject",
    value: function connectToSharedObject(sharedObjectName) {
      log_debug(sharedobject_helper_rtmp_NAME, '[connectToSharedObject]');
      try {
        this._element.connectToSharedObject(sharedObjectName);
      } catch (e) {
        log_warn('Could not connect to shared object (' + name + '). Error: ' + e.message);
      }
    }

    /**
     * Request to close SharedObject connection by name.
     *
     * @param {String} sharedObjectName
     */
  }, {
    key: "closeSharedObject",
    value: function closeSharedObject(sharedObjectName) {
      log_debug(sharedobject_helper_rtmp_NAME, '[disconnectToSharedObject]');
      try {
        this._element.disconnectFromSharedObject(sharedObjectName);
      } catch (e) {
        log_warn('Could not disconnect to shared object (' + name + '). Error: ' + e.message);
      }
    }
  }]);
  return RTMPSharedObjectHandler;
}();
/* harmony default export */ var sharedobject_helper_rtmp = (sharedobject_helper_rtmp_RTMPSharedObjectHandler);
// CONCATENATED MODULE: ./src/js/subscriber/red5pro-source-handler-rtmp.js


function red5pro_source_handler_rtmp_typeof(obj) { "@babel/helpers - typeof"; return red5pro_source_handler_rtmp_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, red5pro_source_handler_rtmp_typeof(obj); }
function red5pro_source_handler_rtmp_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function red5pro_source_handler_rtmp_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, red5pro_source_handler_rtmp_toPropertyKey(descriptor.key), descriptor); } }
function red5pro_source_handler_rtmp_createClass(Constructor, protoProps, staticProps) { if (protoProps) red5pro_source_handler_rtmp_defineProperties(Constructor.prototype, protoProps); if (staticProps) red5pro_source_handler_rtmp_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function red5pro_source_handler_rtmp_toPropertyKey(arg) { var key = red5pro_source_handler_rtmp_toPrimitive(arg, "string"); return red5pro_source_handler_rtmp_typeof(key) === "symbol" ? key : String(key); }
function red5pro_source_handler_rtmp_toPrimitive(input, hint) { if (red5pro_source_handler_rtmp_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (red5pro_source_handler_rtmp_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function red5pro_source_handler_rtmp_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) red5pro_source_handler_rtmp_setPrototypeOf(subClass, superClass); }
function red5pro_source_handler_rtmp_setPrototypeOf(o, p) { red5pro_source_handler_rtmp_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return red5pro_source_handler_rtmp_setPrototypeOf(o, p); }
function red5pro_source_handler_rtmp_createSuper(Derived) { var hasNativeReflectConstruct = red5pro_source_handler_rtmp_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = red5pro_source_handler_rtmp_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = red5pro_source_handler_rtmp_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return red5pro_source_handler_rtmp_possibleConstructorReturn(this, result); }; }
function red5pro_source_handler_rtmp_possibleConstructorReturn(self, call) { if (call && (red5pro_source_handler_rtmp_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return red5pro_source_handler_rtmp_assertThisInitialized(self); }
function red5pro_source_handler_rtmp_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function red5pro_source_handler_rtmp_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function red5pro_source_handler_rtmp_getPrototypeOf(o) { red5pro_source_handler_rtmp_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return red5pro_source_handler_rtmp_getPrototypeOf(o); }








var red5pro_source_handler_rtmp_NAME = 'RTMPSourceHandler';

/**
 * Simple util to convert value to Integer.
 * @private
 */
var red5pro_source_handler_rtmp_toInt = function toInt(value) {
  if (typeof value === 'string') {
    return parseInt(value, 10);
  } else {
    return Math.round(value);
  }
};

/**
 * Quick test if streamName has an extension which infers VOD.
 * @param {String} streamName
 * @return {Boolean}
 * @private
 */
var isVODStreamName = function isVODStreamName(streamName) {
  return /^.*\.(flv|mp4|mp3)/.test(streamName);
};

/**
 * Source Handler for Flash-based Subscribers, which serves as a Presentation Controller between view and subscriber.
 *
 * @extends EventEmitter
 * @extends SubscriberPlaybackController
 *
 * @private
 */
var red5pro_source_handler_rtmp_RTMPSourceHandler = /*#__PURE__*/function (_PlaybackController) {
  red5pro_source_handler_rtmp_inherits(RTMPSourceHandler, _PlaybackController);
  var _super = red5pro_source_handler_rtmp_createSuper(RTMPSourceHandler);
  function RTMPSourceHandler(notificationCenter, media, type) {
    var _this;
    var soResponder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
    red5pro_source_handler_rtmp_classCallCheck(this, RTMPSourceHandler);
    _this = _super.call(this);
    _this.media = media;
    _this.clone = _this.media.cloneNode(true);
    _this.parent = _this.media.parentNode;
    _this.holder = _this._determineHolder(_this.media);
    _this.playerType = type;
    _this._swfId = undefined;
    _this._controls = undefined;
    _this._soResponder = soResponder || new sharedobject_helper_rtmp();
    _this._playbackNotificationCenter = notificationCenter;
    browser.onFullScreenStateChange(_this._handleFullScreenChange.bind(red5pro_source_handler_rtmp_assertThisInitialized(_this)));
    return _this;
  }

  /**
   * Established DOM Element order for playback.
   *
   * @param {Element} media
   *        The target media element: e.g., `video` or `audio`.
   *
   * @private
   */
  red5pro_source_handler_rtmp_createClass(RTMPSourceHandler, [{
    key: "_determineHolder",
    value: function _determineHolder(media) {
      if (media.parentNode.classList.contains('red5pro-media-container')) {
        return media.parentNode;
      } else {
        var parent = media.parentNode;
        var div = browser.createElement('div');
        div.classList.add('red5pro-media-container');
        parent.insertBefore(div, media);
        parent.removeChild(media);
        div.appendChild(media);
        return div;
      }
    }

    /**
     * Clean up of DOM Element order upon stop of playback.
     *
     * @private
     */
  }, {
    key: "_cleanUp",
    value: function _cleanUp() {
      // Return to prior DOM manipulation.
      var el = this.getEmbeddedView();
      var elParent = el.parentNode;
      var mediaHolder = this.holder;
      if (elParent) {
        elParent.removeChild(el);
        // The object parent could be a wrapper child in the original parent element.
        if (elParent !== this.parent) {
          elParent.parentNode.removeChild(elParent);
          mediaHolder = this.parent;
        }
      } else {
        try {
          el.remove();
        } catch (e) {
          log_warn(red5pro_source_handler_rtmp_NAME, "Issue in DOM cleanup of flash object embed: ".concat(e.message));
        }
      }
      this.media = this.clone.cloneNode(true);
      mediaHolder.appendChild(this.media);
      if (this._controls) {
        this._controls.detach();
      }
    }

    /**
     * Assigns and handlers event notificiations coming from the media notifier (e.g., `video` or `audio` element).
     *
     * @param {Object} notifier
     *
     * @private
     */
  }, {
    key: "_addPlaybackHandlers",
    value: function _addPlaybackHandlers(notifier) {
      var controls = this.getControls();
      if (typeof controls === 'undefined') {
        return;
      }
      notifier.on(SubscriberEventTypes.SUBSCRIBE_START, function () {
        controls.setState(PlaybackState.PLAYING);
      });
      notifier.on(SubscriberEventTypes.SUBSCRIBE_STOP, function () {
        controls.setState(PlaybackState.IDLE);
      });
      notifier.on(SubscriberEventTypes.PLAY_UNPUBLISH, function () {
        controls.setState(PlaybackState.IDLE);
      });
      notifier.on(SubscriberEventTypes.SUBSCRIBE_METADATA, function (event) {
        if (event.data.duration) {
          controls.setPlaybackDuration(event.data.duration);
        }
      });
      notifier.on(SubscriberEventTypes.VOLUME_CHANGE, function (event) {
        controls.setVolume(event.data.volume);
      });
      notifier.on(SubscriberEventTypes.PLAYBACK_STATE_CHANGE, function (event) {
        if (event.data.code === PlaybackState.AVAILABLE) {
          controls.enable(true);
        }
        controls.setState(event.data.code);
      });
      notifier.on(SubscriberEventTypes.PLAYBACK_TIME_UPDATE, function (event) {
        controls.setSeekTime(event.data.time, event.data.duration);
      });
      notifier.on(SubscriberEventTypes.FULL_SCREEN_STATE_CHANGE, function (event) {
        controls.onFullScreenChange(event.data);
      });
    }

    /**
     * Event handler for change in fullscreen state.
     *
     * @param {Boolean} isFullScreen
     *
     * @private
     */
  }, {
    key: "_handleFullScreenChange",
    value: function _handleFullScreenChange(isFullScreen) {
      var swfobject = this.getEmbeddedView();
      if (isFullScreen) {
        this.holder.classList.add('red5pro-media-container-full-screen');
        swfobject.classList.add('red5pro-media-container-full-screen');
      } else {
        this.holder.classList.remove('red5pro-media-container-full-screen');
        swfobject.classList.remove('red5pro-media-container-full-screen');
      }
      this.trigger(new SubscriberEvent(SubscriberEventTypes.FULL_SCREEN_STATE_CHANGE, undefined, isFullScreen));
    }

    /**
     * Establishes event handler for recognizing complete on embed and initialization of Flash-based subscriber.
     *
     * @param {Promise} promise
     *        The target `Promise` object to resolve or reject upon completion.
     *
     * @private
     */
  }, {
    key: "_setUpInitCallback",
    value: function _setUpInitCallback(promise) {
      var self = this;
      browser.addSubscriptionAssignmentHandler(function (successId) {
        log_debug(red5pro_source_handler_rtmp_NAME, "Embed and init() complete for subscriber swf. successId(".concat(successId, ")."));
        promise.resolve(successId);
        self._tearDownInitCallback();
      });
    }

    /**
     * Tears down established handler for completion of Flash embed and init.
     *
     * @private
     */
  }, {
    key: "_tearDownInitCallback",
    value: function _tearDownInitCallback() {}

    /**
      * Request to setup the presentation of a playback stream using HLS.
      *
      * @param {String} url
      *        The endpoint URL for playback.
      * @param {Object} options
      *        The initialization configuration map.
      * @param {String} swfUrl
      *        The endpoint url to the SWF to embed. Defaults to relative link to red5pro-subscriber.swf of the SDK distribution.
      * @param {String} minFlashVersion
      *        The minimum Flash version for support of playback. Default: `10.0.0`.
      *
      * @returns {Promise}
      */
  }, {
    key: "addSource",
    value: function addSource(swfId, options) {
      var _this2 = this;
      var swfUrl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var minFlashVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      log_debug(red5pro_source_handler_rtmp_NAME, '[addsource]');
      this._swfId = swfId;
      this.holder = this._determineHolder(this.media);
      var soResponder = this._soResponder;
      var deferred = new DeferredPromise();
      var hasDefinedControls = options.controls;
      var isMuted = browser.hasAttributeDefined(this.media, 'muted');
      var usePlaybackControls = browser.hasAttributeDefined(this.media, 'controls') && browser.hasClassDefined(this.media, 'red5pro-media');
      options.swf = swfUrl || options.swf;
      options.minFlashVersion = minFlashVersion || options.minFlashVersion;
      this._setUpInitCallback(deferred);
      var classList = this.media.classList;
      embed_defineEmbedElement(this.media, this.holder).then(function (elementId) {
        var flashvars = {
          stream: options.streamName,
          app: options.context ? "".concat(options.app, "/").concat(options.context) : options.app,
          host: options.host,
          muted: browser.hasAttributeDefined(_this2.media, 'muted'),
          autoplay: browser.hasAttributeDefined(_this2.media, 'autoplay'),
          useAdaptiveBitrateController: options.useAdaptiveBitrateController
        };
        if (options.backgroundColor) {
          flashvars.backgroundColor = options.backgroundColor;
        }
        if (options.buffer && !isNaN(Number(options.buffer))) {
          flashvars.buffer = options.buffer;
        }
        if (options.width && !isNaN(options.width)) {
          flashvars.width = red5pro_source_handler_rtmp_toInt(options.width);
        }
        if (options.height && !isNaN(options.height)) {
          flashvars.height = red5pro_source_handler_rtmp_toInt(options.height);
        }
        if (options.embedWidth === '100%' || options.embedHeight === '100%') {
          flashvars.autosize = true;
        }
        _this2._swfId = swfId;
        if (typeof options.connectionParams !== 'undefined') {
          flashvars.connectionParams = encodeURIComponent(JSON.stringify(options.connectionParams));
        }
        if (typeof options.abrVariants !== 'undefined') {
          flashvars.abrVariants = encodeURIComponent(JSON.stringify(options.abrVariants));
        }
        if (typeof options.abrVariantUpgradeSettings !== 'undefined') {
          flashvars.abrVariantUpgradeSettings = encodeURIComponent(JSON.stringify(options.abrVariantUpgradeSettings));
        }
        return embed_embedSwfObject(swfId, options, flashvars, browser.getSwfObject(), elementId);
      }).then(function () {
        if (hasDefinedControls || usePlaybackControls) {
          if (hasDefinedControls) {
            _this2._controls = options.controls;
          } else {
            _this2._controls = new PlaybackControlsImpl(_this2, _this2.holder);
          }
          _this2.media.controls = false;
          _this2._controls.setAsVOD(isVODStreamName(options.streamName));
          _this2._controls.setMutedState(isMuted);
          var embedded = _this2.getEmbeddedView();
          var index = classList.length,
            clazz;
          while (--index > -1) {
            clazz = classList.item(index);
            embedded.classList.add(clazz);
          }
        }
        _this2._addPlaybackHandlers(_this2._playbackNotificationCenter);
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
          code: PlaybackState.AVAILABLE,
          state: PlaybackStateReadable[PlaybackState.AVAILABLE]
        }));
        return true;
      }).then(function () {
        soResponder.connect(swfId);
        return true;
      }).catch(function (e) {
        return deferred.reject(e);
      });
      return deferred.promise;
    }

    /**
     * Request to connect to stream.
     */
  }, {
    key: "connect",
    value: function connect() {
      log_debug(red5pro_source_handler_rtmp_NAME, '[connect]');
      try {
        this.getEmbeddedView().connect();
      } catch (e) {
        throw e;
      }
    }
  }, {
    key: "play",
    value: function play() {
      try {
        this.getEmbeddedView().play();
      } catch (e) {
        throw e;
      }
    }
  }, {
    key: "pause",
    value: function pause() {
      try {
        this.getEmbeddedView().pause();
      } catch (e) {
        throw e;
      }
    }
  }, {
    key: "resume",
    value: function resume() {
      try {
        this.getEmbeddedView().resume();
      } catch (e) {
        throw e;
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      try {
        this.getEmbeddedView().stop();
      } catch (e) {
        throw e;
      }
    }
  }, {
    key: "mute",
    value: function mute() {
      try {
        this.getEmbeddedView().mute();
      } catch (e) {
        throw e;
      }
    }
  }, {
    key: "unmute",
    value: function unmute() {
      try {
        this.getEmbeddedView().unmute();
      } catch (e) {
        throw e;
      }
    }
  }, {
    key: "setVolume",
    value: function setVolume(value) {
      try {
        this.getEmbeddedView().setVolume(value);
      } catch (e) {
        throw e;
      }
    }
  }, {
    key: "seekTo",
    value: function seekTo(value) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      try {
        this.getEmbeddedView().seekTo(value, duration);
      } catch (e) {
        throw e;
      }
    }
  }, {
    key: "toggleFullScreen",
    value: function toggleFullScreen() {
      try {
        browser.toggleFullScreen(this.holder);
      } catch (e) {
        throw e;
      }
    }

    /**
     * Notification of current stream being in an unpublished state.
     * The stream enters an unpublished state when the broadcaster stop the stream and the subscriber is still connected.
     */
  }, {
    key: "unpublish",
    value: function unpublish() {
      this.stop();
    }

    /**
     * Request to disconnect from the playback stream.
     */
  }, {
    key: "disconnect",
    value: function disconnect() {
      try {
        this.getEmbeddedView().disconnect();
        log_debug(red5pro_source_handler_rtmp_NAME, '[disconnect]');
      } catch (e) {
        // nada.
      }
      this._cleanUp();
      this._soResponder.disconnect();
    }

    /**
     * Assign response handler for SharedObject communication.
     *
     * @param {Object} handler
     *
     * @private
     */
  }, {
    key: "addSharedObjectResponseHandler",
    value: function addSharedObjectResponseHandler(handler) {
      this._soResponder.addResponseHandler(handler);
    }

    /**
     * Remove response handler from SharedObject communication.
     *
     * @param {Object} handler
     *
     * @private
     */
  }, {
    key: "removeSharedObjectResponseHandler",
    value: function removeSharedObjectResponseHandler(handler) {
      this._soResponder.removeResponseHandler(handler);
    }

    /**
     * Send message on SharedObject.
     *
     * @param {String} name
     *        The name of the SharedObject.
     * @param {String} callName
     *        The method name to invoke on the SharedObject.
     * @param {String} message
     *        The message to send along.
     *
     * @private
     */
  }, {
    key: "sendToSharedObject",
    value: function sendToSharedObject(name, callName, message) {
      this._soResponder.sendToSharedObject(name, callName, message);
    }

    /**
     * Send property update to SharedObject.
     *
     * @param {String} name
     *        The name of the SharedObject.
     * @param {String} key
     *        The property name to update.
     * @param {String} value
     *        The property value to set.
     *
     * @private
     */
  }, {
    key: "sendPropertyToSharedObject",
    value: function sendPropertyToSharedObject(name, key, value) {
      this._soResponder.sendPropertyToSharedObject(name, key, value);
    }

    /**
     * Request to get the remote SharedObject on the server by name.
     *
     * @param {String} sharedObjectName
     *
     * @private
     */
  }, {
    key: "getRemoteSharedObject",
    value: function getRemoteSharedObject(sharedObjectName) {
      this._soResponder.getRemoteSharedObject(sharedObjectName);
    }

    /**
     * Request to connect to SharedObject by name.
     *
     * @param {String} sharedObjectName
     *
     * @private
     */
  }, {
    key: "connectToSharedObject",
    value: function connectToSharedObject(sharedObjectName) {
      this._soResponder.connectToSharedObject(sharedObjectName);
    }

    /**
     * Request to close the SharedObject by name.
     *
     * @param {String} sharedObjectName
     *
     * @private
     */
  }, {
    key: "closeSharedObject",
    value: function closeSharedObject(sharedObjectName) {
      this._soResponder.closeSharedObject(sharedObjectName);
    }

    /*
     * Request to start the Adaptive Bitrate Controller to automatically downgrade and upgrade streams based on NetStatus and bandwidth.
     * The ABR is started automatically when providing the `useAdaptiveBitrateController` configuration property.
     *
     * NOTE: Adaptive Bitrate Controller API is only available when using Autoscale-Enabled Red5 Pro Server.
     */
  }, {
    key: "startABRController",
    value: function startABRController() {
      try {
        this.getEmbeddedView().startABRController();
      } catch (e) {
        log_debug(red5pro_source_handler_rtmp_NAME, "Could not start the Adaptive Bitrate Controller: ".concat(e.message));
      }
    }

    /*
     * Request to stop the Adaptive Bitrate Controller from automatically downgrading and upgrading streams based on NetStatus and bandwidth.
     *
     * NOTE: Adaptive Bitrate Controller API is only available when using Autoscale-Enabled Red5 Pro Server.
     */
  }, {
    key: "stopABRController",
    value: function stopABRController() {
      try {
        this.getEmbeddedView().stopABRController();
      } catch (e) {
        log_debug(red5pro_source_handler_rtmp_NAME, "Could not stop the Adaptive Bitrate Controller: ".concat(e.message));
      }
    }

    /**
     * Request to use the provide ABR Variants when performing Adaptive Bitrate Control.
     * Requires the `useAdaptiveBitrateController` intitialization configuration property to be `true`.
     * NOTE: Adaptive Bitrate Controller API is only available when using Autoscale-Enabled Red5 Pro Server.
     *
     * @param {Object} abrSettings
     *        TODO: Provide ABR Variant object schema expected.
     * @param {int} level
     *        The level to start out on for ABR.
     */
  }, {
    key: "setABRVariants",
    value: function setABRVariants(abrVariants, level) {
      try {
        var value = typeof abrVariants === 'string' ? encodeURIComponent(abrVariants) : encodeURIComponent(JSON.stringify(abrVariants));
        this.getEmbeddedView().setABRVariants(value, level || 1);
      } catch (e) {
        log_debug(red5pro_source_handler_rtmp_NAME, "Could not set ABR Variants: ".concat(e.message));
      }
    }

    /**
     * Request to set ABR level explicitly. The SDK attempts to properly choose the correct level based on bandwidth, but this API allows for the level to be set explicitly.
     *
     * NOTE: Adaptive Bitrate Controller API is only available when using Autoscale-Enabled Red5 Pro Server.
     *
     * @param {int} level
     *        The level to set the ABR based on the variants provided in `setABRVariants`.
     * @param {boolean} firm
     *        Flag to set level firmly, disabling the automatic switching of the Adaptive Bitrate Controller.
     */
  }, {
    key: "setABRLevel",
    value: function setABRLevel(level, firm) {
      try {
        this.getEmbeddedView().setABRLevel(level, !!firm);
      } catch (e) {
        log_debug(red5pro_source_handler_rtmp_NAME, "Could not set ABR level: ".concat(e.message));
      }
    }

    /**
     * Provides the upgrade settings to use by the Adaptive Bitrate Control in upgrading previously downgraded streams.
     *
     * NOTE: Adaptive Bitrate Controller API is only available when using Autoscale-Enabled Red5 Pro Server.
     *
     * @param {Object} abrVariantUpgrades
     *        A configuration object that defines the associated retry limits based on levels of the Provision Variants.
     * @example
     * {
     *  minimumDowngradePlaybackSpan: 2000,
     *  upgrade: [
     *    {
     *      level: 1,
     *      retryTimeout: 0
     *    },
     *    {
     *      level: 2,
     *      retryTimeout: 2000
     *    },
     *    {
     *      level: 3,
     *      retryTimeout: 4000
     *    }
     *  ]
     * }
     */
  }, {
    key: "setABRVariantUpgradeSettings",
    value: function setABRVariantUpgradeSettings(abrVariantUpgrades) {
      try {
        var value = typeof abrVariants === 'string' ? encodeURIComponent(abrVariantUpgrades) : encodeURIComponent(JSON.stringify(abrVariantUpgrades));
        this.getEmbeddedView().setABRVariantUpgradeSettings(value);
      } catch (e) {
        log_debug(red5pro_source_handler_rtmp_NAME, "Could not set ABR Variants: ".concat(e.message));
      }
    }

    /**
     * Returns the embedded Flash object if available.
     *
     * @returns {Element}
     */
  }, {
    key: "getEmbeddedView",
    value: function getEmbeddedView() {
      return browser.getEmbedObject(this._swfId);
    }

    /**
     * Returns playback controls if available.
     *
     * @returns {PlaybackControls}
     */
  }, {
    key: "getControls",
    value: function getControls() {
      return this._controls;
    }

    /**
     * Returns the subscriber type associated with this controller.
     *
     * @returns {String}
     */
  }, {
    key: "getType",
    value: function getType() {
      return this.playerType;
    }
  }]);
  return RTMPSourceHandler;
}(PlaybackController);
/* harmony default export */ var red5pro_source_handler_rtmp = (red5pro_source_handler_rtmp_RTMPSourceHandler);
// CONCATENATED MODULE: ./src/js/subscriber/red5pro-rtmp.js


function red5pro_rtmp_typeof(obj) { "@babel/helpers - typeof"; return red5pro_rtmp_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, red5pro_rtmp_typeof(obj); }
function red5pro_rtmp_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function red5pro_rtmp_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, red5pro_rtmp_toPropertyKey(descriptor.key), descriptor); } }
function red5pro_rtmp_createClass(Constructor, protoProps, staticProps) { if (protoProps) red5pro_rtmp_defineProperties(Constructor.prototype, protoProps); if (staticProps) red5pro_rtmp_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function red5pro_rtmp_toPropertyKey(arg) { var key = red5pro_rtmp_toPrimitive(arg, "string"); return red5pro_rtmp_typeof(key) === "symbol" ? key : String(key); }
function red5pro_rtmp_toPrimitive(input, hint) { if (red5pro_rtmp_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (red5pro_rtmp_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function red5pro_rtmp_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) red5pro_rtmp_setPrototypeOf(subClass, superClass); }
function red5pro_rtmp_setPrototypeOf(o, p) { red5pro_rtmp_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return red5pro_rtmp_setPrototypeOf(o, p); }
function red5pro_rtmp_createSuper(Derived) { var hasNativeReflectConstruct = red5pro_rtmp_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = red5pro_rtmp_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = red5pro_rtmp_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return red5pro_rtmp_possibleConstructorReturn(this, result); }; }
function red5pro_rtmp_possibleConstructorReturn(self, call) { if (call && (red5pro_rtmp_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return red5pro_rtmp_assertThisInitialized(self); }
function red5pro_rtmp_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function red5pro_rtmp_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function red5pro_rtmp_getPrototypeOf(o) { red5pro_rtmp_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return red5pro_rtmp_getPrototypeOf(o); }










var red5pro_rtmp_NAME = 'RTMPSubcriber';
var red5pro_rtmp_defaultOptions = {
  protocol: 'rtmp',
  port: 1935,
  width: 320,
  // media playback
  height: 240,
  // media playback
  embedWidth: '100%',
  // DOM display style
  embedHeight: '100%',
  // DOM display style
  minFlashVersion: '10.0.0',
  swf: 'lib/red5pro/red5pro-subscriber.swf',
  swfobjectURL: 'lib/swfobject/swfobject.js',
  productInstallURL: 'lib/swfobject/playerProductInstall.swf',
  mediaElementId: 'red5pro-subscriber',
  // with Autoscale enabled server only =>
  useAdaptiveBitrateController: false,
  abrVariants: undefined,
  abrVariantUpgradeSettings: {
    minimumDowngradePlaybackSpan: 10000,
    // Amount of time playback needs to exceed between playback and downgrade in order to be eligible for upgrade
    upgrade: [{
      level: 1,
      retryTimeout: 0
    }, {
      level: 2,
      retryTimeout: 10000 // If on level 2, in 10 seconds after playback, try and switch up.
    }, {
      level: 3,
      retryTimeout: 20000 // If on level 3, in 20 seconds after playback, try and switch up.
    }]
  }
};

/**
 * Main entry for Flash-based Subscriber over RTMP.
 *
 * @extends EventEmitter
 * @extends SubscriberPlaybackController
 */
var red5pro_rtmp_RTMPSubscriber = /*#__PURE__*/function (_PlaybackController) {
  red5pro_rtmp_inherits(RTMPSubscriber, _PlaybackController);
  var _super = red5pro_rtmp_createSuper(RTMPSubscriber);
  function RTMPSubscriber() {
    var _this;
    red5pro_rtmp_classCallCheck(this, RTMPSubscriber);
    _this = _super.call(this);
    _this._options = undefined;
    _this._view = undefined;
    _this._sourceHandler = undefined;
    _this._elementId = undefined;
    _this._embedPromise = undefined;
    _this._getEmbedPromise().then(function () {
      _this.onEmbedComplete();
    }).catch(function (err) {
      return _this.onEmbedFailure(err);
    });
    _this._viewResolver = new DeferredPromise();
    _this._subscriptionResolver = new DeferredPromise();
    _this._orientation = 0;
    _this._streamingMode = 'Video/Audio';
    return _this;
  }
  red5pro_rtmp_createClass(RTMPSubscriber, [{
    key: "_getViewResolverPromise",
    value: function _getViewResolverPromise() {
      return this._viewResolver.promise;
    }
  }, {
    key: "_getSubscriptionResolverPromise",
    value: function _getSubscriptionResolverPromise() {
      return this._subscriptionResolver.promise;
    }
  }, {
    key: "_getEmbedPromise",
    value: function _getEmbedPromise() {
      this._embedPromise = Future.createIfNotExist(this._embedPromise);
      return this._embedPromise.promise;
    }

    /**
     * Gloms the Playback Controls API onto this instance to provide ease in use.
     *
     * @param {Object} handler
     *        The method request handler to bind and forward calls on.
     *
     * @private
     */
  }, {
    key: "_glomSourceHandlerAPI",
    value: function _glomSourceHandlerAPI(handler) {
      var _this2 = this;
      /*
       * || Note ||
       * play() is not glommed as it needs to be handled differently.
       */

      this.pause = handler.pause.bind(handler);
      this.resume = handler.resume.bind(handler);
      this.stop = handler.stop.bind(handler);
      this.mute = handler.mute.bind(handler);
      this.unmute = handler.unmute.bind(handler);
      this.setVolume = handler.setVolume.bind(handler);
      this.seekTo = handler.seekTo.bind(handler);
      this.toggleFullScreen = handler.toggleFullScreen.bind(handler);

      // Adaptive Bitrate Controller - Autoscale enabled only.
      this.setABRLevel = handler.setABRLevel.bind(handler);
      this.setABRVariants = handler.setABRVariants.bind(handler);
      this.stopABRController = handler.stopABRController.bind(handler);
      this.startABRController = handler.startABRController.bind(handler);
      this.setABRVariantUpgradeSettings = handler.setABRVariantUpgradeSettings.bind(handler);
      handler.on('*', function (event) {
        _this2.trigger(new SubscriberEvent(event.type, _this2, event.data));
      });
    }

    /**
     * Still in use, but hold-over of previous 3.x SDK versions designed to pair views and subscribers. In 4.0.0 it has been internalized.
     * API deprecated.
     *
     * @private
     */
  }, {
    key: "_setViewIfNotExist",
    value: function _setViewIfNotExist(currentView) {
      var mediaElementId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      if (typeof currentView === 'undefined' && mediaElementId !== undefined) {
        var view = new playback(mediaElementId);
        view.attachSubscriber(this);
      }
    }

    /**
     * Define global function handlers for ExternalInterface to invoke for API communication.
     *
     * @private
     */
  }, {
    key: "_establishExtIntHandlers",
    value: function _establishExtIntHandlers(id) {
      var _this3 = this;
      log_debug(red5pro_rtmp_NAME, "Subscriber ID provided to client: (".concat(id, ")."));
      var invokeFn = function invokeFn(label) {
        return ['subscriber', label, id.split('-').join('_')].join('_');
      };
      window[invokeFn('r5proConnectClosed')] = function () {
        return _this3.trigger(new SubscriberEvent(SubscriberEventTypes.CONNECTION_CLOSED, _this3));
      };
      window[invokeFn('r5proConnectSuccess')] = function () {
        return _this3.trigger(new SubscriberEvent(SubscriberEventTypes.CONNECT_SUCCESS, _this3));
      };
      window[invokeFn('r5proConnectFailure')] = function () {
        _this3.trigger(new SubscriberEvent(SubscriberEventTypes.CONNECT_FAILURE, _this3));
      };
      window[invokeFn('r5proSubscribeStop')] = function () {
        return _this3.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_STOP, _this3));
      };
      window[invokeFn('r5proSubscribeMetadata')] = function (metadata) {
        var _JSON$parse = JSON.parse(metadata),
          orientation = _JSON$parse.orientation,
          streamingMode = _JSON$parse.streamingMode;
        var orientationInt = parseInt(orientation, 10);
        var previousStreamingMode = _this3._streamingMode;
        if (_this3._orientation !== orientationInt) {
          _this3._orientation = orientationInt;
          _this3.trigger(new SubscriberEvent(SubscriberEventTypes.ORIENTATION_CHANGE, _this3, {
            orientation: orientationInt
          }));
        }
        if (previousStreamingMode !== streamingMode) {
          _this3._streamingMode = streamingMode;
          _this3.trigger(new SubscriberEvent(SubscriberEventTypes.STREAMING_MODE_CHANGE, _this3, {
            streamingMode: streamingMode,
            previousStreamingMode: previousStreamingMode
          }));
        }
        _this3.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_METADATA, _this3, JSON.parse(metadata)));
      };
      window[invokeFn('r5proSubscribeUnpublish')] = function () {
        _this3.onUnpublish();
      };
      window[invokeFn('r5proSubscribePublisherCongestion')] = function (data) {
        return _this3.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_PUBLISHER_CONGESTION, _this3, JSON.parse(data)));
      };
      window[invokeFn('r5proSubscribePublisherRecovery')] = function (data) {
        return _this3.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_PUBLISHER_RECOVERY, _this3, JSON.parse(data)));
      };
      window[invokeFn('r5proSubscribeSendInvoke')] = function (payload) {
        _this3.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_SEND_INVOKE, _this3, typeof payload === 'string' ? JSON.parse(payload) : payload));
      };
      window[invokeFn('r5proSubscribePlayRequest')] = function () {
        _this3.play();
      };
      window[invokeFn('r5proSubscribeStart')] = function () {
        _this3._subscriptionResolver.resolve(_this3);
        _this3.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_START, _this3));
      };
      window[invokeFn('r5proSubscribeInvalidName')] = function () {
        _this3._subscriptionResolver.reject('NetStream.Play.StreamNotFound', _this3);
        _this3.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_INVALID_NAME, _this3));
      };
      window[invokeFn('r5proSubscribeFail')] = function () {
        _this3._subscriptionResolver.reject('NetStream.Failed', _this3);
        _this3.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_FAIL, _this3));
      };
      window[invokeFn('r5proSubscribeVolumeChange')] = function (payload) {
        _this3.trigger(new SubscriberEvent(SubscriberEventTypes.VOLUME_CHANGE, _this3, {
          volume: JSON.parse(payload).volume
        }));
      };
      window[invokeFn('r5proSubscribePlaybackStalled')] = function () {
        log_debug(red5pro_rtmp_NAME, 'playback has stalled...');
      };
      window[invokeFn('r5proSubscribePlaybackTimeChange')] = function (payload) {
        var data = JSON.parse(payload);
        _this3.trigger(new SubscriberEvent(SubscriberEventTypes.PLAYBACK_TIME_UPDATE, _this3, {
          time: data.value,
          duration: data.duration
        }));
      };
      window[invokeFn('r5proSubscribePlaybackStateChange')] = function (payload) {
        var code = JSON.parse(payload).code;
        _this3.trigger(new SubscriberEvent(SubscriberEventTypes.PLAYBACK_STATE_CHANGE, _this3, {
          code: code,
          state: PlaybackStateReadable[code]
        }));
      };
      window[invokeFn('r5proSubscribeABRLevelChange')] = function (payload) {
        var data = JSON.parse(payload);
        var level = data.level,
          stream = data.stream;
        var settings = JSON.parse(decodeURIComponent(stream));
        _this3.trigger(new SubscriberEvent(RTMPSubscriberEventTypes.ABR_LEVEL_CHANGE, _this3, {
          level: level,
          stream: settings
        }));
      };
    }

    /**
     * Request to initialize the HLS-based Subscriber based on configuration.
     * The returned `Promise` will either resolve with a reference to this instance or reject with an error `String` in failure.
     *
     * @param {Object} options
     *        The initialization configuration map.
     * @return {Promise}
     */
  }, {
    key: "init",
    value: function init(options) {
      var _this4 = this;
      var deferred = new DeferredPromise();
      var version = options.minFlashVersion || red5pro_rtmp_defaultOptions.minFlashVersion;
      if (!browser.supportsFlashVersion(version)) {
        log_warn(red5pro_rtmp_NAME, "Could not resolve RTMPSubscriber instance. Requires minimum Flash Player install of ".concat(version, "."));
        deferred.reject("Could not resolve RTMPSubscriber instance. Requires minimum Flash Player install of ".concat(version, "."));
      } else {
        this._options = Object.assign({}, red5pro_rtmp_defaultOptions, options);
        var establishSourceHandler = function establishSourceHandler() {
          _this4._getViewResolverPromise().then(function (view) {
            _this4._sourceHandler = new red5pro_source_handler_rtmp(_this4, view.view, _this4.getType());
            _this4._glomSourceHandlerAPI(_this4._sourceHandler);
            if (_this4._options) {
              var dfd = _this4._embedPromise;
              _this4._sourceHandler.addSource(_this4._elementId, _this4._options).then(function (subscriberId) {
                _this4._establishExtIntHandlers(subscriberId);
                dfd.resolve(_this4);
              }).catch(function (err) {
                return dfd.reject(err);
              });
            }
          });
        };
        try {
          browser.injectScript(this._options.swfobjectURL).then(function () {
            var embedDfd = _this4._embedPromise;
            log_debug(red5pro_rtmp_NAME, 'SWFObject embedded.');
            if (_this4._sourceHandler) {
              _this4._sourceHandler.addSource(_this4._elementId, _this4._options).then(function (subscriberId) {
                _this4._establishExtIntHandlers(subscriberId);
                embedDfd.resolve(_this4);
              }).catch(function (err) {
                embedDfd.reject(err);
              });
              return _this4._getEmbedPromise();
            }
            establishSourceHandler();
            return true;
          }).then(function () {
            _this4._setViewIfNotExist(_this4._view, _this4._options.mediaElementId);
            deferred.resolve(_this4);
          }).catch(function (err) {
            log_error(red5pro_rtmp_NAME, "Could not embed Flash-based RTMP Player. Reason: ".concat(err));
            if (_this4._sourceHandler) {
              _this4._sourceHandler.disconnect();
            }
            deferred.reject(err);
            _this4.trigger(new SubscriberEvent(RTMPSubscriberEventTypes.EMBED_FAILURE, _this4));
          });
        } catch (e) {
          deferred.reject("Could not inject Flash-based Player into the page. Reason: ".concat(e.message));
          this.trigger(new SubscriberEvent(RTMPSubscriberEventTypes.EMBED_FAILURE, this));
        }
      }
      return deferred.promise;
    }

    /**
     * Still in use for assigning document element view management to this instance.
     * API deprecated in 4.0.0.
     *
     * @private
     */
  }, {
    key: "setView",
    value: function setView(view, elementId) {
      this._view = view;
      this._elementId = elementId;
      this._viewResolver.resolve(this._view);
      return this;
    }

    /**
     * Request to begin subscribing to a stream.
     *
     * @return {Promise}
     *          The returned `Promise` will resolve or reject on successful start of playback.
     */
  }, {
    key: "subscribe",
    value: function subscribe() {
      return this._getSubscriptionResolverPromise();
    }

    /**
     * Request to stop a subscription.
     * The returned `Promise` will either resolve or reject on successful stop of subscription.
     *
     * @return {Promise}
     */
  }, {
    key: "unsubscribe",
    value: function unsubscribe() {
      var _this5 = this;
      log_debug(red5pro_rtmp_NAME, '[unsubscribe]');
      var cb = function cb(resolve, reject) {
        try {
          _this5._sourceHandler.disconnect();
          resolve();
        } catch (e) {
          reject(e.message);
        }
      };
      return new Promise(cb);
    }

    /**
     * Request to start playing the stream.
     */
  }, {
    key: "play",
    value: function play() {
      var _this6 = this;
      log_debug(red5pro_rtmp_NAME, '[play]');
      this._getEmbedPromise().then(function () {
        _this6._sourceHandler.play();
      });
    }

    /**
     * Event handler for completion of embedding Flash element into page.
     *
     * @private
     */
  }, {
    key: "onEmbedComplete",
    value: function onEmbedComplete() {
      log_debug(red5pro_rtmp_NAME, '[embed:complete]');
      this.trigger(new SubscriberEvent(RTMPSubscriberEventTypes.EMBED_SUCCESS, this));
    }

    /**
     * Event handler for failure in embedding Flash element into page.
     *
     * @private
     */
  }, {
    key: "onEmbedFailure",
    value: function onEmbedFailure(err) {
      log_debug(red5pro_rtmp_NAME, "[embed:failure] - ".concat(err));
      this.trigger(new SubscriberEvent(RTMPSubscriberEventTypes.EMBED_FAILURE, this));
    }

    /**
     * Event handler for `Unpublish` of stream subscribed to. Occurs when a broadcaster stops their stream while this subscription stream is open.
     *
     * @private
     */
  }, {
    key: "onUnpublish",
    value: function onUnpublish() {
      log_debug(red5pro_rtmp_NAME, '[onunpublish]');
      if (this._sourceHandler) {
        this._sourceHandler.unpublish();
      }
      this.trigger(new SubscriberEvent(SubscriberEventTypes.PLAY_UNPUBLISH, this));
      if (this._sourceHandler) {
        // This differs slightly from how the WebRTC subscriber works on Unpublish notification.
        // For WebRTC subscribers, there is an immediate disconection dispatched FROM THE SERVER as a notification.
        // In Flash, an unpublish is not a direct correlation to a disconnect for a subscriber, as a NetStream
        //    can stay open without stream data being delivered. In WebRTC, once a stream is stopped ("unpublished")
        //    that connection can not be pumped a new stream as it can on Flash's NetStream.
        // As such, to have the clients "behave" the same, we will request a disconnect on unpublish.
        this._sourceHandler.disconnect();
      }
    }

    /**
     * Returns connection handler for playback.
     * Used in SharedObject communication.
     *
     * @return {Object}
     *
     * @private
     */
  }, {
    key: "getConnection",
    value: function getConnection() {
      return this._sourceHandler;
    }

    /**
     * Returns reference to playback controls if available.
     *
     * @return {PlaybackControls}
     */
  }, {
    key: "getControls",
    value: function getControls() {
      return this._sourceHandler ? this._sourceHandler.getControls() : undefined;
    }

    /**
     * Returns the initialization configuration used in `init()`.
     *
     * @return {Object}
     */
  }, {
    key: "getOptions",
    value: function getOptions() {
      return this._options;
    }

    /**
     * Returns the target view Element.
     *
     * @return {Element}
     */
  }, {
    key: "getPlayer",
    value: function getPlayer() {
      return this._sourceHandler ? this._sourceHandler.getEmbeddedView() : undefined;
    }

    /**
     * Returns the type of implementation: `RTMP`.
     *
     * @return {String}
     */
  }, {
    key: "getType",
    value: function getType() {
      return PlaybackTypes.RTMP.toUpperCase();
    }
  }]);
  return RTMPSubscriber;
}(PlaybackController);
/* harmony default export */ var red5pro_rtmp = (red5pro_rtmp_RTMPSubscriber);
// CONCATENATED MODULE: ./src/js/subscriber/red5pro-source-handler-hls.js


function red5pro_source_handler_hls_typeof(obj) { "@babel/helpers - typeof"; return red5pro_source_handler_hls_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, red5pro_source_handler_hls_typeof(obj); }
function red5pro_source_handler_hls_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function red5pro_source_handler_hls_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, red5pro_source_handler_hls_toPropertyKey(descriptor.key), descriptor); } }
function red5pro_source_handler_hls_createClass(Constructor, protoProps, staticProps) { if (protoProps) red5pro_source_handler_hls_defineProperties(Constructor.prototype, protoProps); if (staticProps) red5pro_source_handler_hls_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function red5pro_source_handler_hls_toPropertyKey(arg) { var key = red5pro_source_handler_hls_toPrimitive(arg, "string"); return red5pro_source_handler_hls_typeof(key) === "symbol" ? key : String(key); }
function red5pro_source_handler_hls_toPrimitive(input, hint) { if (red5pro_source_handler_hls_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (red5pro_source_handler_hls_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function red5pro_source_handler_hls_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) red5pro_source_handler_hls_setPrototypeOf(subClass, superClass); }
function red5pro_source_handler_hls_setPrototypeOf(o, p) { red5pro_source_handler_hls_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return red5pro_source_handler_hls_setPrototypeOf(o, p); }
function red5pro_source_handler_hls_createSuper(Derived) { var hasNativeReflectConstruct = red5pro_source_handler_hls_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = red5pro_source_handler_hls_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = red5pro_source_handler_hls_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return red5pro_source_handler_hls_possibleConstructorReturn(this, result); }; }
function red5pro_source_handler_hls_possibleConstructorReturn(self, call) { if (call && (red5pro_source_handler_hls_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return red5pro_source_handler_hls_assertThisInitialized(self); }
function red5pro_source_handler_hls_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function red5pro_source_handler_hls_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function red5pro_source_handler_hls_getPrototypeOf(o) { red5pro_source_handler_hls_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return red5pro_source_handler_hls_getPrototypeOf(o); }








var red5pro_source_handler_hls_NAME = 'HLSSourceHandler';

/**
 * Source Handler for HLS-based Subscribers, which serves as a Presentation Controller between view and subscriber.
 *
 * @extends EventEmitter
 * @extends SubscriberPlaybackController
 *
 * @private
 */
var red5pro_source_handler_hls_HLSSourceHandler = /*#__PURE__*/function (_PlaybackController) {
  red5pro_source_handler_hls_inherits(HLSSourceHandler, _PlaybackController);
  var _super = red5pro_source_handler_hls_createSuper(HLSSourceHandler);
  function HLSSourceHandler(media, type) {
    var _this;
    red5pro_source_handler_hls_classCallCheck(this, HLSSourceHandler);
    _this = _super.call(this);
    _this.media = media;
    _this.clone = _this.media.cloneNode(true);
    _this.parent = _this.media.parentNode;
    _this.holder = _this._determineHolder(media);
    _this.playerType = type;
    _this._mediaSource = undefined;
    _this._isVOD = false;
    _this._controls = undefined;
    _this._orientation = 0;
    _this._streamingMode = 'Video/Audio';
    _this._autoLayoutOrientation = true;
    _this._playbackNotificationCenter = _this.media;
    _this._handleOrientationChange = _this._handleOrientationChange.bind(red5pro_source_handler_hls_assertThisInitialized(_this));
    _this._onOrientationMetadata = _this._onOrientationMetadata.bind(red5pro_source_handler_hls_assertThisInitialized(_this));
    _this._onStreamingModeMetadata = _this._onStreamingModeMetadata.bind(red5pro_source_handler_hls_assertThisInitialized(_this));
    browser.onFullScreenStateChange(_this._handleFullScreenChange.bind(red5pro_source_handler_hls_assertThisInitialized(_this)));
    return _this;
  }

  /**
   * Established DOM Element order for playback.
   *
   * @param {Element} media
   *        The target media element: e.g., `video` or `audio`.
   *
   * @private
   */
  red5pro_source_handler_hls_createClass(HLSSourceHandler, [{
    key: "_determineHolder",
    value: function _determineHolder(media) {
      if (media.parentNode.classList.contains('red5pro-media-container')) {
        return media.parentNode;
      } else {
        var parent = media.parentNode;
        var div = browser.createElement('div');
        div.classList.add('red5pro-media-container');
        parent.insertBefore(div, media);
        parent.removeChild(media);
        div.appendChild(media);
        return div;
      }
    }

    /**
     * Clean up of DOM Element order upon stop of playback.
     *
     * @private
     */
  }, {
    key: "_cleanUp",
    value: function _cleanUp() {
      // Return to prior DOM manipulation.
      var el = this.media;
      var src = this._mediaSource;
      var elParent = el.parentNode;
      var mediaHolder = this.holder;
      if (src) {
        el.removeChild(src);
      }
      if (elParent) {
        elParent.removeChild(el);
        // The object parent could be a wrapper child in the original parent element.
        if (elParent !== this.parent) {
          elParent.parentNode.removeChild(elParent);
          mediaHolder = this.parent;
        }
      } else {
        try {
          el.remove();
        } catch (e) {
          log_warn(red5pro_source_handler_hls_NAME, "Issue in DOM cleanup of HLS video object: ".concat(e.message));
        }
      }
      this.media = this.clone.cloneNode(true);
      mediaHolder.appendChild(this.media);
      if (this._controls) {
        this._controls.detach();
      }
      this.media.setAttribute('autoplay', true);
      this.clone = this.media.cloneNode(true);
      this.parent = this.media.parentNode;
      this.holder = this._determineHolder(this.media);
      this._orientation = 0;
      this.isVOD = false;
    }

    /**
     * Assigns and handlers event notificiations coming from the media notifier (e.g., `video` or `audio` element).
     *
     * @param {Object} notifier
     *
     * @private
     */
  }, {
    key: "_addPlaybackHandlers",
    value: function _addPlaybackHandlers(notifier) {
      var _this2 = this;
      var controls = this.getControls();
      var hasControls = typeof controls !== 'undefined';
      notifier.oncanplay = function () {
        if (controls) {
          controls.enable(true);
        }
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
          code: PlaybackState.AVAILABLE,
          state: PlaybackStateReadable[PlaybackState.AVAILABLE]
        }));
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.VOLUME_CHANGE, undefined, {
          volume: notifier.volume
        }));
      };
      notifier.ondurationchange = function (event) {
        // eslint-disable-line no-unused-vars
        if (!isNaN(notifier.duration) && Number.isFinite(notifier.duration)) {
          _this2.isVOD = true;
        }
        if (!_this2.isVOD && hasControls) {
          controls.setPlaybackDuration(1);
        } else if (hasControls) {
          controls.setPlaybackDuration(notifier.duration);
        }
      };
      notifier.onended = function () {
        log_debug(red5pro_source_handler_hls_NAME, '[videoelement:onended]');
        if (hasControls) {
          controls.setState(PlaybackState.IDLE);
        }
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
          code: PlaybackState.IDLE,
          state: PlaybackStateReadable[PlaybackState.IDLE]
        }));
      };
      notifier.ontimeupdate = function (event) {
        // eslint-disable-line no-unused-vars
        if (hasControls) {
          if (!self.isVOD) {
            controls.setSeekTime(1, 1);
          } else {
            controls.setSeekTime(notifier.currentTime, self.isVOD ? notifier.duration : undefined);
          }
        }
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.PLAYBACK_TIME_UPDATE, undefined, {
          time: notifier.currentTime,
          duration: notifier.duration
        }));
      };
      notifier.onseeked = function (event) {// eslint-disable-line no-unused-vars
        //      debug(NAME, 'Seeked.')
      };
      notifier.onseeking = function (event) {// eslint-disable-line no-unused-vars
        //      debug(NAME, 'Seeking.')
      };
      notifier.onplay = function () {
        if (hasControls) {
          controls.setState(PlaybackState.PLAYING);
        }
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
          code: PlaybackState.PLAYING,
          state: PlaybackStateReadable[PlaybackState.PLAYING]
        }));
      };
      notifier.onpause = function () {
        if (hasControls) {
          controls.setState(PlaybackState.PAUSED);
        }
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
          code: PlaybackState.PAUSED,
          state: PlaybackStateReadable[PlaybackState.PAUSED]
        }));
      };
      notifier.onvolumechange = function (event) {
        // eslint-disable-line no-unused-vars
        if (hasControls && controls.getVolume() !== _this2.media.volume) {
          controls.setVolume(_this2.media.volume);
        }
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.VOLUME_CHANGE, undefined, {
          volume: notifier.muted ? 0 : notifier.volume
        }));
      };
      // for debugging purposes.
      notifier.onencrypted = function () {
        log_debug(red5pro_source_handler_hls_NAME, '[videoelement:event] encrypted');
      };
      notifier.onemptied = function () {
        log_debug(red5pro_source_handler_hls_NAME, '[videoelement:event] emptied');
      };
      notifier.onloadeddata = function () {
        log_debug(red5pro_source_handler_hls_NAME, '[videoelement:event] loadeddata');
        /*
        this.trigger(new SubscriberEvent(SubscriberEventTypes.VIDEO_DIMENSIONS_CHANGE, undefined, {
          width: this.media.videoWidth,
          height: this.media.videoHeight
        }))
        */
      };

      notifier.onresize = function () {
        log_debug(red5pro_source_handler_hls_NAME, '[videoelement:event] resize');
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.VIDEO_DIMENSIONS_CHANGE, undefined, {
          width: _this2.media.videoWidth,
          height: _this2.media.videoHeight
        }));
      };
      notifier.onloadedmetadata = function () {
        log_debug(red5pro_source_handler_hls_NAME, '[videoelement:event] loadedmetadata');
        _this2.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_START, undefined, {}));
      };
      notifier.onloadstart = function () {
        log_debug(red5pro_source_handler_hls_NAME, '[videoelement:event] loadedstart');
      };
      notifier.onstalled = function () {
        log_debug(red5pro_source_handler_hls_NAME, '[videoelement:event] stalled');
      };
      notifier.onsuspend = function () {
        log_debug(red5pro_source_handler_hls_NAME, '[videoelement:event] suspend');
      };
      notifier.onwaiting = function () {
        log_debug(red5pro_source_handler_hls_NAME, '[videoelement:event] waiting');
      };
      //    notifier.onprogress = () => { debug(NAME, '[videoelement:event] progress. Played: ' + notifier.played.length + ', Buffered: ' + notifier.buffered.length + '.') }
    }

    /**
     * Event handler for change in fullscreen state.
     *
     * @param {Boolean} isFullScreen
     *
     * @private
     */
  }, {
    key: "_handleFullScreenChange",
    value: function _handleFullScreenChange(isFullScreen) {
      if (isFullScreen) {
        this.holder.classList.add('red5pro-media-container-full-screen');
        this.media.classList.add('red5pro-media-container-full-screen');
      } else {
        this.holder.classList.remove('red5pro-media-container-full-screen');
        this.media.classList.remove('red5pro-media-container-full-screen');
      }
      this.trigger(new SubscriberEvent(SubscriberEventTypes.FULL_SCREEN_STATE_CHANGE, undefined, isFullScreen));
    }

    /**
     * Define the source element on the HLS playback element.
     *
     * @param {String} url
     *        The playback endpoint URL.
     * @param {String} type
     *        The mime type of the playback stream.
     * @param {Object} options
     *        The initialization configuration map.
     *
     * @private
     */
  }, {
    key: "_embedMediaSource",
    value: function _embedMediaSource(url, type, options) {
      // eslint-disable-line no-unused-vars
      var deferred = new DeferredPromise();
      try {
        var source = browser.createElement('source');
        source.type = type;
        source.src = url;
        this.media.type = type;
        if (this.media.firstChild) {
          this.media.insertBefore(source, this.media.firstChild);
        } else {
          this.media.appendChild(source);
        }
        this._mediaSource = source;
        this._autoLayoutOrientation = options.autoLayoutOrientation;
        browser.onOrientationMetadata(this.media, this._onOrientationMetadata);
        browser.onStreamingModeMetadata(this.media, this._onStreamingModeMetadata);
        deferred.resolve();
      } catch (e) {
        deferred.reject(e.message);
      }
      return deferred.promise;
    }

    /**
     * Delegate responder to incoming changes of `orientation` metadata on HLS playback tracks.
     *
     * @param {Object} metdata
     *
     * @private
     */
  }, {
    key: "_onOrientationMetadata",
    value: function _onOrientationMetadata(metadata) {
      var orientation = metadata.orientation,
        resolution = metadata.resolution;
      var orientationInt = parseInt(orientation, 10);
      if (orientation && this._orientation !== orientationInt) {
        log_debug(red5pro_source_handler_hls_NAME, 'Metadata received: ' + JSON.stringify(metadata, null, 2));
        this._orientation = orientationInt;
        if (this._autoLayoutOrientation) {
          applyOrientation(this.media, this._orientation, metadataResolutionToObject(resolution));
          this._handleOrientationChange(this._orientation);
        }
        this.trigger(new SubscriberEvent(SubscriberEventTypes.ORIENTATION_CHANGE, undefined, {
          orientation: this._orientation,
          viewElement: this.media
        }));
        this.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_METADATA, undefined, metadata));
      }
    }

    /**
     * Delegate responder to incoming changes of `streamingMode` metadata on HLS playback tracks.
     *
     * @param {Object} metdata
     *
     * @private
     */
  }, {
    key: "_onStreamingModeMetadata",
    value: function _onStreamingModeMetadata(metadata) {
      var streamingMode = metadata.streamingMode;
      var previousStreamingMode = this._streamingMode;
      if (streamingMode && previousStreamingMode !== streamingMode) {
        log_debug(red5pro_source_handler_hls_NAME, 'Metadata received: ' + JSON.stringify(metadata, null, 2));
        this._streamingMode = streamingMode;
        this.trigger(new SubscriberEvent(SubscriberEventTypes.STREAMING_MODE_CHANGE, undefined, {
          streamingMode: this._streamingMode,
          previousStreamingMode: previousStreamingMode,
          viewElement: this.media
        }));
        this.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_METADATA, undefined, metadata));
      }
    }

    /**
     * Request to setup the presentation of a playback stream using HLS.
     *
     * @param {String} url
     *        The endpoint URL for playback.
     * @param {String} type
     *        The mime type for playback.
     * @param {Object} options
     *        The initialization configuration map.
     *
     * @returns {Promise}
     */
  }, {
    key: "addSource",
    value: function addSource(url, type, options) {
      var _this3 = this;
      log_debug(red5pro_source_handler_hls_NAME, '[addsource]');
      this.holder = this._determineHolder(this.media);
      var deferred = new DeferredPromise();
      var hasDefinedControls = options.controls;
      var isMuted = browser.hasAttributeDefined(this.media, 'muted');
      var isAutoplay = browser.hasAttributeDefined(this.media, 'autoplay');
      // Will handle autoplay explicitly to capture issues with browser restrictions and send notifications.
      if (!isMuted) {
        this.media.setAttribute('autoplay', false);
      }
      var usePlaybackControls = browser.hasAttributeDefined(this.media, 'controls') && browser.hasClassDefined(this.media, 'red5pro-media');
      this._embedMediaSource(url, type, options).then(function () {
        if (hasDefinedControls || usePlaybackControls) {
          if (hasDefinedControls) {
            _this3._controls = options.controls;
          } else {
            _this3._controls = new PlaybackControlsImpl(_this3, _this3.holder);
          }
          _this3.media.controls = false;
          _this3._controls.setAsVOD(_this3.isVOD);
          _this3._controls.setMutedState(isMuted);
        }
        _this3._addPlaybackHandlers(_this3._playbackNotificationCenter);
        if (isAutoplay) {
          _this3.attemptAutoplay(options.muteOnAutoplayRestriction);
        }
        deferred.resolve();
      }).catch(function (e) {
        return deferred.reject(e);
      });
      return deferred.promise;
    }

    /**
     * Request to connect to stream.
     */
  }, {
    key: "connect",
    value: function connect() {
      log_debug(red5pro_source_handler_hls_NAME, '[connect]');
    }
  }, {
    key: "attemptAutoplay",
    value: function attemptAutoplay() {
      var _this4 = this;
      var muteOnAutoplay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.play().catch(function (e) {
        if (muteOnAutoplay) {
          _this4.mute();
          _this4.play().then(function () {
            _this4.trigger(new SubscriberEvent(SubscriberEventTypes.AUTO_PLAYBACK_MUTED, undefined, {
              element: _this4.media
            }));
          }).catch(function (err) {
            _this4.trigger(new SubscriberEvent(SubscriberEventTypes.AUTO_PLAYBACK_FAILURE, undefined, {
              error: err.message ? err.message : err,
              element: _this4.media
            }));
          });
        } else {
          _this4.trigger(new SubscriberEvent(SubscriberEventTypes.AUTO_PLAYBACK_FAILURE, undefined, {
            error: e.message ? e.message : e,
            element: _this4.media
          }));
        }
      });
    }
  }, {
    key: "play",
    value: function play() {
      log_debug(red5pro_source_handler_hls_NAME, '[videoelement:action] play');
      var deferred = new DeferredPromise();
      try {
        var maybePromise = this.media.play();
        if (maybePromise) {
          maybePromise.then(function () {
            log_debug(red5pro_source_handler_hls_NAME, '[videoelement:action] play (START)');
            deferred.resolve();
          }).catch(deferred.reject);
        } else {
          log_debug(red5pro_source_handler_hls_NAME, '[videoelement:action] play (START)');
          deferred.resolve();
        }
      } catch (e) {
        log_error(red5pro_source_handler_hls_NAME, '[videoelement:action] play (FAULT) - ' + e.message);
        deferred.reject(e);
      }
      return deferred.promise;
    }
  }, {
    key: "pause",
    value: function pause() {
      log_debug(red5pro_source_handler_hls_NAME, '[videoelement:action] pause');
      try {
        this.media.pause();
      } catch (e) {
        log_debug(red5pro_source_handler_hls_NAME, '[videoelement:action] pause (FAULT) - ' + e.message);
      }
    }
  }, {
    key: "resume",
    value: function resume() {
      log_debug(red5pro_source_handler_hls_NAME, '[videoelement:action] resume');
      try {
        var maybePromise = this.media.play();
        if (maybePromise) {
          maybePromise.then(function () {
            return log_debug(red5pro_source_handler_hls_NAME, '[videoelement:action] play (START)');
          }).catch(function (err) {
            return log_error(red5pro_source_handler_hls_NAME, '[videoelement:action] play (FAULT) ' + (err.message ? err.message : err));
          });
        }
      } catch (e) {
        log_error(red5pro_source_handler_hls_NAME, '[videoelement:action] resume (FAULT) - ' + e.message);
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      try {
        this.media.stop();
      } catch (e) {
        // ok.
      }
    }
  }, {
    key: "mute",
    value: function mute() {
      this.media.muted = true;
      var controls = this.getControls();
      if (controls) {
        controls.setMutedState(true);
      }
    }
  }, {
    key: "unmute",
    value: function unmute() {
      this.media.muted = false;
      var controls = this.getControls();
      if (controls) {
        controls.setMutedState(false);
      }
    }
  }, {
    key: "setVolume",
    value: function setVolume(value) {
      this.unmute();
      this.media.volume = value;
    }
  }, {
    key: "seekTo",
    value: function seekTo(percentage) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      this.media.currentTime = duration ? percentage * duration : percentage;
    }
  }, {
    key: "toggleFullScreen",
    value: function toggleFullScreen() {
      try {
        browser.toggleFullScreen(this.holder);
      } catch (e) {
        throw e;
        // nada.
      }
    }

    /**
     * Notification of current stream being in an unpublished state.
     * The stream enters an unpublished state when the broadcaster stop the stream and the subscriber is still connected.
     */
  }, {
    key: "unpublish",
    value: function unpublish() {
      try {
        this.stop();
        this.media.onended.call(this.media);
      } catch (e) {
        // nada.
      }
    }

    /**
     * Request to disconnect playback.
     */
  }, {
    key: "disconnect",
    value: function disconnect() {
      this._cleanUp();
    }

    /**
     * Responder to change in orientation received through metadata.
     *
     * @param {Number} orientation
     *        The orientation value.
     *
     * @private
     */
  }, {
    key: "_handleOrientationChange",
    value: function _handleOrientationChange(orientation) {
      if (this._controls && orientation % 180 !== 0) {
        this.holder.classList.add('red5pro-media-background');
        this.media.classList.remove('red5pro-media-background');
      }
    }

    /*
     * || SHARED OBJECT INTEGRATION NOT AVAILABLE FOR HLS PLAYBACK ||
     */
    // eslint-disable-next-line no-unused-vars
  }, {
    key: "addSharedObjectResponseHandler",
    value: function addSharedObjectResponseHandler(handler) {}

    // eslint-disable-next-line no-unused-vars
  }, {
    key: "removeSharedObjectResponseHandler",
    value: function removeSharedObjectResponseHandler(handler) {}

    // eslint-disable-next-line no-unused-vars
  }, {
    key: "sendToSharedObject",
    value: function sendToSharedObject(name, callName, message) {}

    // eslint-disable-next-line no-unused-vars
  }, {
    key: "sendPropertyToSharedObject",
    value: function sendPropertyToSharedObject(name, key, value) {}

    // eslint-disable-next-line no-unused-vars
  }, {
    key: "getRemoteSharedObject",
    value: function getRemoteSharedObject(sharedObjectName) {}

    // eslint-disable-next-line no-unused-vars
  }, {
    key: "connectToSharedObject",
    value: function connectToSharedObject(sharedObjectName) {}

    // eslint-disable-next-line no-unused-vars
  }, {
    key: "closeSharedObject",
    value: function closeSharedObject(sharedObjectName) {}

    /**
     * Returns playback controls if available.
     *
     * @returns {PlaybackControls}
     */
  }, {
    key: "getControls",
    value: function getControls() {
      return this._controls;
    }

    /**
     * Returns the subscriber type associated with this controller.
     *
     * @returns {String}
     */
  }, {
    key: "getType",
    value: function getType() {
      return this.playerType;
    }

    /**
     * Returns flag of video being recognized as VOD (Video On Demand).
     *
     * @returns {Boolean}
     */
  }, {
    key: "isVOD",
    get: function get() {
      return this._isVOD;
    }

    /**
     * Sets flag of video being considered as VOD (Video On Demand).
     *
     * @param {Boolean} value
     */,
    set: function set(value) {
      this._isVOD = value;
      if (this._controls) {
        this._controls.setAsVOD(value);
      }
    }
  }]);
  return HLSSourceHandler;
}(PlaybackController);
/* harmony default export */ var red5pro_source_handler_hls = (red5pro_source_handler_hls_HLSSourceHandler);
// CONCATENATED MODULE: ./src/js/subscriber/red5pro-hls.js


function red5pro_hls_typeof(obj) { "@babel/helpers - typeof"; return red5pro_hls_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, red5pro_hls_typeof(obj); }
function red5pro_hls_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function red5pro_hls_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, red5pro_hls_toPropertyKey(descriptor.key), descriptor); } }
function red5pro_hls_createClass(Constructor, protoProps, staticProps) { if (protoProps) red5pro_hls_defineProperties(Constructor.prototype, protoProps); if (staticProps) red5pro_hls_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function red5pro_hls_toPropertyKey(arg) { var key = red5pro_hls_toPrimitive(arg, "string"); return red5pro_hls_typeof(key) === "symbol" ? key : String(key); }
function red5pro_hls_toPrimitive(input, hint) { if (red5pro_hls_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (red5pro_hls_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function red5pro_hls_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) red5pro_hls_setPrototypeOf(subClass, superClass); }
function red5pro_hls_setPrototypeOf(o, p) { red5pro_hls_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return red5pro_hls_setPrototypeOf(o, p); }
function red5pro_hls_createSuper(Derived) { var hasNativeReflectConstruct = red5pro_hls_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = red5pro_hls_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = red5pro_hls_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return red5pro_hls_possibleConstructorReturn(this, result); }; }
function red5pro_hls_possibleConstructorReturn(self, call) { if (call && (red5pro_hls_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return red5pro_hls_assertThisInitialized(self); }
function red5pro_hls_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function red5pro_hls_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function red5pro_hls_getPrototypeOf(o) { red5pro_hls_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return red5pro_hls_getPrototypeOf(o); }













var red5pro_hls_NAME = 'HLSSubscriber';

/**
 * Simple generation og unique subscriber id.
 *
 * @return {String}
 *
 * @private
 */
var red5pro_hls_generateSubscriptionId = function generateSubscriptionId() {
  var id = Math.floor(Math.random() * 0x10000).toString(16);
  return "subscriber-".concat(id);
};

// Default to secure settings.
var red5pro_hls_defaultOptions = {
  protocol: 'https',
  port: 443,
  app: 'live',
  mimeType: 'application/x-mpegURL',
  mediaElementId: 'red5pro-subscriber',
  autoLayoutOrientation: true,
  muteOnAutoplayRestriction: true,
  subscriptionId: red5pro_hls_generateSubscriptionId()
};
var urlRegex = /^http(|s).*\.m3u8/g;

/**
 * Main entry for HLS-based Subscriber.
 *
 * @extends EventEmitter
 * @extends SubscriberPlaybackController
 */
var red5pro_hls_HLSSubscriber = /*#__PURE__*/function (_PlaybackController) {
  red5pro_hls_inherits(HLSSubscriber, _PlaybackController);
  var _super = red5pro_hls_createSuper(HLSSubscriber);
  function HLSSubscriber() {
    var _this;
    red5pro_hls_classCallCheck(this, HLSSubscriber);
    _this = _super.call(this);
    _this._options = undefined;
    _this._view = undefined;
    _this._sourceHandler = undefined;
    _this._socketHelper = undefined;
    _this._viewResolver = new DeferredPromise();
    _this._subscriptionResolver = new DeferredPromise();
    _this._boundBubbleSubscriberEvents = _this.bubbleSubscriberEvents.bind(red5pro_hls_assertThisInitialized(_this));
    return _this;
  }
  red5pro_hls_createClass(HLSSubscriber, [{
    key: "_getViewResolverPromise",
    value: function _getViewResolverPromise() {
      return this._viewResolver.promise;
    }
  }, {
    key: "_getSubscriptionResolverPromise",
    value: function _getSubscriptionResolverPromise() {
      return this._subscriptionResolver.promise;
    }

    /**
     * Proxy event bubbler through handler instance.
     *
     * @private
     */
  }, {
    key: "bubbleSubscriberEvents",
    value: function bubbleSubscriberEvents(event) {
      if (event.type === SubscriberEventTypes.SUBSCRIBE_START) {
        this._subscriptionResolver.resolve(this);
      }
      this.trigger(new SubscriberEvent(event.type, this, event.data));
    }

    /**
     * Gloms the Playback Controls API onto this instance to provide ease in use.
     *
     * @param {Object} handler
     *        The method request handler to bind and forward calls on.
     *
     * @private
     */
  }, {
    key: "_glomSourceHandlerAPI",
    value: function _glomSourceHandlerAPI(handler) {
      var _this2 = this;
      this.play = handler.play.bind(handler);
      this.pause = handler.pause.bind(handler);
      this.resume = handler.resume.bind(handler);
      this.stop = handler.stop.bind(handler);
      this.mute = handler.mute.bind(handler);
      this.unmute = handler.unmute.bind(handler);
      this.setVolume = handler.setVolume.bind(handler);
      this.seekTo = handler.seekTo.bind(handler);
      this.toggleFullScreen = handler.toggleFullScreen.bind(handler);
      handler.on('*', function (event) {
        _this2.trigger(new SubscriberEvent(event.type, _this2, event.data));
      });
    }

    /**
     * Still in use, but hold-over of previous 3.x SDK versions designed to pair views and subscribers. In 4.0.0 it has been internalized.
     * API deprecated.
     *
     * @private
     */
  }, {
    key: "_setViewIfNotExist",
    value: function _setViewIfNotExist(currentView) {
      var mediaElementId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      if (typeof currentView === 'undefined' && mediaElementId !== undefined) {
        var view = new playback(mediaElementId);
        view.attachSubscriber(this);
      }
    }

    /**
     * Attempt to initialize the subscription handler for HLS.
     *
     * @param {Object} options
     *        The initialization configuration.
     * @param {Object} handler
     *        The handler instance that will manage view interaction and events.
     *
     * @private
     */
  }, {
    key: "_initHandler",
    value: function _initHandler(options) {
      var _this3 = this;
      var _this$_options = this._options,
        streamName = _this$_options.streamName,
        mimeType = _this$_options.mimeType;
      var url = streamName.match(urlRegex) ? streamName : optionsToHlsURL(this._options);
      this._sourceHandler.on('*', this._boundBubbleSubscriberEvents);
      this._sourceHandler.addSource(url, mimeType, options).then(function () {
        _this3.trigger(new SubscriberEvent(SubscriberEventTypes.CONNECT_SUCCESS));
        _this3._trackStreamingModeState(_this3._sourceHandler);
      }).catch(function (err) {
        log_error(red5pro_hls_NAME, 'Could not establish an HLS Subscriber: ' + err);
        _this3.trigger(new SubscriberEvent(SubscriberEventTypes.CONNECT_FAILURE));
      });
    }

    /**
     * Handles notification on change of streamingMode which relates to audio/video mute of broadcast-side.
     *
     * @param {EventEmitter} notifier
     *
     * @private
     */
  }, {
    key: "_trackStreamingModeState",
    value: function _trackStreamingModeState(notifier) {
      var _this4 = this;
      notifier.on(SubscriberEventTypes.STREAMING_MODE_CHANGE, function (event) {
        var _event$data = event.data,
          streamingMode = _event$data.streamingMode,
          previousStreamingMode = _event$data.previousStreamingMode;
        if (streamingMode !== 'Empty' && previousStreamingMode === 'Empty') {
          _this4._sourceHandler.disconnect();
          var _this4$_options = _this4._options,
            streamName = _this4$_options.streamName,
            mimeType = _this4$_options.mimeType;
          var url = streamName.match(urlRegex) ? streamName : optionsToHlsURL(_this4._options);
          _this4._sourceHandler.addSource(url, mimeType, _this4._options).then(function () {
            return _this4.subscribe();
          }).catch(function (error) {
            return error(red5pro_hls_NAME, error);
          });
        }
      });
    }

    /**
     * Request to initialize the HLS-based Subscriber based on configuration.
     * The returned `Promise` will either resolve with a reference to this instance or reject with an error `String` in failure.
     *
     * @param {Object} options
     *        The initialization configuration map.
     * @return {Promise}
     */
  }, {
    key: "init",
    value: function init(options) {
      var _this5 = this;
      var deferred = new DeferredPromise();
      if (!browser.supportsHLS()) {
        log_warn(red5pro_hls_NAME, "Could not resolve HLSSubscriber instance.");
        deferred.reject("Could not resolve HLSSubscriber instance.");
      } else if (options.connectionParams && !websocket_isSupported()) {
        // If `connectionParams` are provided in the init config,
        //  then a subsequent validation call is made on a WebSocket to 
        //  ensure that this client is allowed access.
        log_warn(red5pro_hls_NAME, "Could not resolve HLSSubscriber instance with connection params. WebSocket support is required.");
        deferred.reject(red5pro_hls_NAME, "Could not resolve HLSSubscriber instance with connection params. WebSocket support is required.");
      } else {
        this._options = Object.assign({}, red5pro_hls_defaultOptions, options);
        var socketPromise = new DeferredPromise();
        if (this._options.connectionParams) {
          try {
            this._socketHelper = new socket_helper(this, 'HLSSubscriptionSocket');
            var socketurl = hlsSocketEndpointFromOptions(this._options, {
              id: this._options.subscriptionId
            });
            this._socketHelper.setUp(socketurl, socketPromise);
          } catch (e) {
            log_error(red5pro_hls_NAME, e.message);
            deferred.reject(red5pro_hls_NAME, "Could not set up WebSocket for authentication with connectionParams: ".concat(e.message));
          }
        } else {
          socketPromise.resolve();
        }
        socketPromise.promise.then(function () {
          // Tear down socket helper if exists.
          // We only needed it to do validation with optional connectionParams.
          if (_this5._socketHelper) {
            _this5._socketHelper.tearDown();
            _this5._socketHelper = undefined;
          }
          _this5._setViewIfNotExist(_this5._view, _this5._options.mediaElementId);
          _this5._getViewResolverPromise().then(function (view) {
            _this5._sourceHandler = new red5pro_source_handler_hls(view.view, _this5.getType());
            _this5._glomSourceHandlerAPI(_this5._sourceHandler);
            if (_this5._options) {
              _this5._initHandler(_this5._options);
            }
          });
          deferred.resolve(_this5);
        }).catch(function (error) {
          deferred.reject(error);
          _this5.trigger(new SubscriberEvent(SubscriberEventTypes.CONNECT_FAILURE, _this5, error));
        });
      }
      return deferred.promise;
    }

    /**
     * Still in use for assigning document element view management to this instance.
     * API deprecated in 4.0.0.
     *
     * @private
     */
  }, {
    key: "setView",
    value: function setView(view) {
      this._view = view;
      this._viewResolver.resolve(view);
      return this;
    }

    /**
     * Request to begin subscribing to a stream.
     *
     * @return {Promise}
     *          The returned `Promise` will resolve or reject on successful start of playback.
     */
  }, {
    key: "subscribe",
    value: function subscribe() {
      return this._getSubscriptionResolverPromise();
    }

    /**
     * Request to stop a subscription.
     * The returned `Promise` will either resolve or reject on successful stop of subscription.
     *
     * @return {Promise}
     */
  }, {
    key: "unsubscribe",
    value: function unsubscribe() {
      log_debug(red5pro_hls_NAME, '[unscubscribe]');
      var deferred = new DeferredPromise();
      if (this._socketHelper) {
        this._socketHelper.tearDown();
      }
      try {
        this._sourceHandler.stop();
        this._sourceHandler.disconnect();
        deferred.resolve();
      } catch (e) {
        deferred.reject(e.message);
      }
      return deferred.promise;
    }

    /**
     * Returns connection handler for playback.
     *
     * @return {Object}
     */
  }, {
    key: "getConnection",
    value: function getConnection() {
      return this._sourceHandler;
    }

    /**
     * Returns reference to playback controls if available.
     *
     * @return {PlaybackControls}
     */
  }, {
    key: "getControls",
    value: function getControls() {
      return this._sourceHandler ? this._sourceHandler.getControls() : undefined;
    }

    /**
     * Returns the initialization configuration used in `init()`.
     *
     * @return {Object}
     */
  }, {
    key: "getOptions",
    value: function getOptions() {
      return this._options;
    }

    /**
     * Returns the target view Element.
     *
     * @return {Element}
     */
  }, {
    key: "getPlayer",
    value: function getPlayer() {
      return this._view.view;
    }

    /**
     * Returns the type of implementation: `RTC`.
     *
     * @return {String}
     */
  }, {
    key: "getType",
    value: function getType() {
      return PlaybackTypes.HLS.toUpperCase();
    }
  }]);
  return HLSSubscriber;
}(PlaybackController);
/* harmony default export */ var red5pro_hls = (red5pro_hls_HLSSubscriber);
// CONCATENATED MODULE: ./src/js/helper/whipwhep-signaling-helper.js
function whipwhep_signaling_helper_typeof(obj) { "@babel/helpers - typeof"; return whipwhep_signaling_helper_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, whipwhep_signaling_helper_typeof(obj); }
function whipwhep_signaling_helper_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ whipwhep_signaling_helper_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == whipwhep_signaling_helper_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function whipwhep_signaling_helper_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function whipwhep_signaling_helper_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, whipwhep_signaling_helper_toPropertyKey(descriptor.key), descriptor); } }
function whipwhep_signaling_helper_createClass(Constructor, protoProps, staticProps) { if (protoProps) whipwhep_signaling_helper_defineProperties(Constructor.prototype, protoProps); if (staticProps) whipwhep_signaling_helper_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function whipwhep_signaling_helper_toPropertyKey(arg) { var key = whipwhep_signaling_helper_toPrimitive(arg, "string"); return whipwhep_signaling_helper_typeof(key) === "symbol" ? key : String(key); }
function whipwhep_signaling_helper_toPrimitive(input, hint) { if (whipwhep_signaling_helper_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (whipwhep_signaling_helper_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

var whipwhep_signaling_helper_NAME = 'WhipWhepSignalingHelper';

/**
 * Converts a Link header into a Map of props for easier parsing.
 * @param {string} link
 * @returns Map
 *
 * @private
 */
var headerLinkToObject = function headerLinkToObject(link) {
  var atts = link.split(';').map(function (s) {
    return s.trim();
  });
  var props = atts.map(function (s) {
    if (s.charAt(0) === '<') {
      return ['url', s.substring(1, s.length - 1)];
    }
    return s.split('=');
  });
  return props.reduce(function (acc, curr) {
    return acc.set(curr[0], curr[1]);
  }, new Map());
};

/**
 * Parses link url into protocol and host for ease in assemble for credentialed links.
 * @param {string} url
 * @returns Object { protocol, host }
 *
 * @private
 */
var getHostAndProtocolFromLinkUrl = function getHostAndProtocolFromLinkUrl(url) {
  var parts = url.split(':');
  if (parts.length > 1) {
    return {
      protocol: parts[0],
      host: parts[1]
    };
  }
  return {
    protocol: undefined,
    host: url
  };
};
var whipwhep_signaling_helper_WhipWhepSignalingHelper = /*#__PURE__*/function () {
  function WhipWhepSignalingHelper(url) {
    whipwhep_signaling_helper_classCallCheck(this, WhipWhepSignalingHelper);
    this._url = url;
    // this._resource = url.replace(/\/endpoint\//, '/resource/')
    this._resource = undefined;
  }
  whipwhep_signaling_helper_createClass(WhipWhepSignalingHelper, [{
    key: "getOptions",
    value: function () {
      var _getOptions = _asyncToGenerator( /*#__PURE__*/whipwhep_signaling_helper_regeneratorRuntime().mark(function _callee() {
        var response, status, headers, headerReg, links;
        return whipwhep_signaling_helper_regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              log_debug(whipwhep_signaling_helper_NAME, "[whipwhep-options] ".concat(this._url));
              _context.prev = 1;
              _context.next = 4;
              return fetch(this._url, {
                method: 'OPTIONS',
                mode: 'cors'
              });
            case 4:
              response = _context.sent;
              status = response.status, headers = response.headers;
              if (!(status === 200 || status === 204)) {
                _context.next = 12;
                break;
              }
              headerReg = /^(L|l)ink/;
              links = [];
              headers.forEach(function (key, value) {
                if (headerReg.exec(value)) {
                  if (key.indexOf('rel="ice-server"') > -1) {
                    var link = headerLinkToObject(key);
                    var url = link.get('url');
                    var _getHostAndProtocolFr = getHostAndProtocolFromLinkUrl(url),
                      protocol = _getHostAndProtocolFr.protocol,
                      host = _getHostAndProtocolFr.host;
                    var username = link.get('username');
                    var password = link.get('credential');
                    if (protocol && host && username && password) {
                      links.push("".concat(protocol, "://").concat(username, ":").concat(password, "@").concat(host));
                    } else if (url) {
                      links.push(url);
                    }
                  }
                }
              });
              log_debug(whipwhep_signaling_helper_NAME, "[whipwhep-links]: ".concat(links));
              return _context.abrupt("return", {
                links: links.length > 0 ? [{
                  urls: links.length > 1 ? links : links[0]
                }] : undefined
              });
            case 12:
              _context.next = 18;
              break;
            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](1);
              log_error(whipwhep_signaling_helper_NAME, _context.t0.message);
              throw _context.t0;
            case 18:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[1, 14]]);
      }));
      function getOptions() {
        return _getOptions.apply(this, arguments);
      }
      return getOptions;
    }()
    /**
     * Posts offer to WHIP endpoint and resolves with answer SDP and location.
     *
     * @param {string} sdp
     * @returns {object} { sdp:(string), location:(string)}
     */
  }, {
    key: "postSDPOffer",
    value: function () {
      var _postSDPOffer = _asyncToGenerator( /*#__PURE__*/whipwhep_signaling_helper_regeneratorRuntime().mark(function _callee2(sdp) {
        var response, status, headers, answerSDP, location, parsed, errorMessage;
        return whipwhep_signaling_helper_regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              log_debug(whipwhep_signaling_helper_NAME, "[whipwhep-post] ".concat(this._url, ": ") + JSON.stringify(sdp, null, 2));
              _context2.prev = 1;
              _context2.next = 4;
              return fetch(this._url, {
                method: 'POST',
                mode: 'cors',
                headers: {
                  'content-type': 'application/sdp'
                },
                body: sdp
              });
            case 4:
              response = _context2.sent;
              status = response.status, headers = response.headers;
              if (!(status >= 200 && status < 300)) {
                _context2.next = 20;
                break;
              }
              _context2.next = 9;
              return response.text();
            case 9:
              answerSDP = _context2.sent;
              location = headers.get('Location');
              if (!location) {
                _context2.next = 17;
                break;
              }
              if (location.match(/^(http|https)/)) {
                this._resource = location;
              } else {
                parsed = new URL(this._url); // parsed.pathname = location
                this._resource = parsed.toString();
              }
              log_debug(whipwhep_signaling_helper_NAME, "[whipwhep-response] ".concat(this._resource, ": ").concat(answerSDP));
              return _context2.abrupt("return", {
                sdp: answerSDP,
                location: this._resource
              });
            case 17:
              throw new Error('Location not provided in header response to Offer.');
            case 18:
              _context2.next = 36;
              break;
            case 20:
              if (!(status === 405)) {
                _context2.next = 24;
                break;
              }
              throw new Error('Remember to update the URL passed into the WHIP or WHEP client.');
            case 24:
              if (!(status === 406)) {
                _context2.next = 28;
                break;
              }
              throw new Error('Stream may not be available to publish or subscribe to.');
            case 28:
              if (!(status === 409)) {
                _context2.next = 32;
                break;
              }
              throw new Error('Stream rejected.');
            case 32:
              _context2.next = 34;
              return response.text();
            case 34:
              errorMessage = _context2.sent;
              throw Error(errorMessage);
            case 36:
              _context2.next = 42;
              break;
            case 38:
              _context2.prev = 38;
              _context2.t0 = _context2["catch"](1);
              log_error(whipwhep_signaling_helper_NAME, _context2.t0.message);
              throw _context2.t0;
            case 42:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[1, 38]]);
      }));
      function postSDPOffer(_x) {
        return _postSDPOffer.apply(this, arguments);
      }
      return postSDPOffer;
    }()
  }, {
    key: "trickle",
    value: function () {
      var _trickle = _asyncToGenerator( /*#__PURE__*/whipwhep_signaling_helper_regeneratorRuntime().mark(function _callee3(sdp) {
        var response, status, headers, candidate, errorMessage;
        return whipwhep_signaling_helper_regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              log_debug(whipwhep_signaling_helper_NAME, "[whipwhep-trickle] ".concat(this._resource, ": ") + JSON.stringify(sdp, null, 2));
              _context3.prev = 1;
              _context3.next = 4;
              return fetch(this._resource, {
                method: 'PATCH',
                mode: 'cors',
                headers: {
                  'content-type': 'application/trickle-ice-sdpfrag'
                },
                body: sdp
              });
            case 4:
              response = _context3.sent;
              status = response.status, headers = response.headers;
              if (!(status >= 200 && status < 300)) {
                _context3.next = 14;
                break;
              }
              _context3.next = 9;
              return response.text();
            case 9:
              candidate = _context3.sent;
              log_debug(whipwhep_signaling_helper_NAME, "[whipwhep-response] ".concat(this._resource, ": ").concat(candidate));
              return _context3.abrupt("return", {
                candidate: candidate
              });
            case 14:
              if (!(status === 405)) {
                _context3.next = 19;
                break;
              }
              console.log('Remember to update the URL passed into the WHIP or WHEP client');
              throw new Error('Remember to update the URL passed into the WHIP or WHEP client');
            case 19:
              _context3.next = 21;
              return response.text();
            case 21:
              errorMessage = _context3.sent;
              throw Error(errorMessage);
            case 23:
              _context3.next = 29;
              break;
            case 25:
              _context3.prev = 25;
              _context3.t0 = _context3["catch"](1);
              console.error(_context3.t0);
              throw _context3.t0;
            case 29:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[1, 25]]);
      }));
      function trickle(_x2) {
        return _trickle.apply(this, arguments);
      }
      return trickle;
    }()
  }, {
    key: "tearDown",
    value: function () {
      var _tearDown = _asyncToGenerator( /*#__PURE__*/whipwhep_signaling_helper_regeneratorRuntime().mark(function _callee4() {
        return whipwhep_signaling_helper_regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (this._resource) {
                _context4.next = 2;
                break;
              }
              return _context4.abrupt("return");
            case 2:
              log_debug(whipwhep_signaling_helper_NAME, "[whipwhep-teardown]");
              _context4.next = 5;
              return fetch(this._resource, {
                method: 'DELETE',
                mode: 'cors'
              });
            case 5:
              this._url = undefined;
              this._resource = undefined;
            case 7:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function tearDown() {
        return _tearDown.apply(this, arguments);
      }
      return tearDown;
    }()
  }]);
  return WhipWhepSignalingHelper;
}();
/* harmony default export */ var whipwhep_signaling_helper = (whipwhep_signaling_helper_WhipWhepSignalingHelper);
// CONCATENATED MODULE: ./src/js/subscriber/red5pro-whep.js
function red5pro_whep_typeof(obj) { "@babel/helpers - typeof"; return red5pro_whep_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, red5pro_whep_typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = red5pro_whep_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function red5pro_whep_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ red5pro_whep_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == red5pro_whep_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function red5pro_whep_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function red5pro_whep_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { red5pro_whep_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { red5pro_whep_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function red5pro_whep_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function red5pro_whep_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, red5pro_whep_toPropertyKey(descriptor.key), descriptor); } }
function red5pro_whep_createClass(Constructor, protoProps, staticProps) { if (protoProps) red5pro_whep_defineProperties(Constructor.prototype, protoProps); if (staticProps) red5pro_whep_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function red5pro_whep_toPropertyKey(arg) { var key = red5pro_whep_toPrimitive(arg, "string"); return red5pro_whep_typeof(key) === "symbol" ? key : String(key); }
function red5pro_whep_toPrimitive(input, hint) { if (red5pro_whep_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (red5pro_whep_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function red5pro_whep_get() { if (typeof Reflect !== "undefined" && Reflect.get) { red5pro_whep_get = Reflect.get.bind(); } else { red5pro_whep_get = function _get(target, property, receiver) { var base = red5pro_whep_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return red5pro_whep_get.apply(this, arguments); }
function red5pro_whep_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = red5pro_whep_getPrototypeOf(object); if (object === null) break; } return object; }
function red5pro_whep_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) red5pro_whep_setPrototypeOf(subClass, superClass); }
function red5pro_whep_setPrototypeOf(o, p) { red5pro_whep_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return red5pro_whep_setPrototypeOf(o, p); }
function red5pro_whep_createSuper(Derived) { var hasNativeReflectConstruct = red5pro_whep_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = red5pro_whep_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = red5pro_whep_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return red5pro_whep_possibleConstructorReturn(this, result); }; }
function red5pro_whep_possibleConstructorReturn(self, call) { if (call && (red5pro_whep_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return red5pro_whep_assertThisInitialized(self); }
function red5pro_whep_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function red5pro_whep_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function red5pro_whep_getPrototypeOf(o) { red5pro_whep_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return red5pro_whep_getPrototypeOf(o); }











var red5pro_whep_NAME = 'WHEPClient';
var ICE_GATHER_TIMEOUT = 1000;

/**
 * Simple generation of unique subscriber id.
 *
 * @return {String}
 *
 * @private
 */
var red5pro_whep_generateSubscriptionId = function generateSubscriptionId() {
  var id = Math.floor(Math.random() * 0x10000).toString(16);
  return "subscriber-".concat(id);
};

// Default to secure settings.
var red5pro_whep_defaultOptions = {
  protocol: 'wss',
  port: 443,
  app: 'live',
  autoLayoutOrientation: true,
  mediaElementId: 'red5pro-subscriber',
  rtcConfiguration: {
    iceServers: [{
      urls: 'stun:stun2.l.google.com:19302'
    }],
    iceCandidatePoolSize: 2,
    bundlePolicy: 'max-bundle'
  },
  // Favored over iceServers.
  iceServers: undefined,
  // Deprecated. Preserved for backward-compatibility.
  iceTransport: IceTransportTypes.UDP,
  muteOnAutoplayRestriction: true,
  maintainConnectionOnSubscribeErrors: false,
  signalingSocketOnly: false,
  // No DC in SDP at the moment
  dataChannelConfiguration: undefined,
  socketSwitchDelay: 1000,
  bypassAvailable: false,
  maintainStreamVariant: false,
  enableLiveSeek: false,
  trickleIce: false // Flag to use trickle ice to send candidates
};
var red5pro_whep_WHEPClient = /*#__PURE__*/function (_RTCSubscriber) {
  red5pro_whep_inherits(WHEPClient, _RTCSubscriber);
  var _super = red5pro_whep_createSuper(WHEPClient);
  /**
   * Constructor. Providing arguments will automatically kick of connection sequence.
   * Leaving arguments unset allows for more control and follows same pattern of init -> subscribe as RTCSubscriber.
   * @param {string} url Optional endpoint for WHEP. Example: https://your-red5pro.com/live/whep/endpoint/stream1
   * @param {HTMLMediaElement} element Optional media element to play media in.
   * @param {boolean} trickleIce Optional request to trickle candidates. Preferred: false, send with SDP offer.
   */
  function WHEPClient(url, element) {
    var _this;
    var trickleIce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    red5pro_whep_classCallCheck(this, WHEPClient);
    _this = _super.call(this);
    var optionsFromUrl = url ? optionsFromWhipWhepUrl(url) : red5pro_whep_defaultOptions;
    optionsFromUrl.mediaElementId = element ? element.id : red5pro_whep_defaultOptions.mediaElementId;
    optionsFromUrl.trickleIce = trickleIce;
    _this._whipHelper = undefined;
    if (url) {
      _this._internalConnect(optionsFromUrl);
    }
    return _this;
  }

  /**
   * Internal connection sequence if used constructor with arguments.
   *
   * @param {Object} options
   *        The initialization configuration map.
   *
   * @private
   */
  red5pro_whep_createClass(WHEPClient, [{
    key: "_internalConnect",
    value: function () {
      var _internalConnect2 = red5pro_whep_asyncToGenerator( /*#__PURE__*/red5pro_whep_regeneratorRuntime().mark(function _callee(options) {
        return red5pro_whep_regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.init(options);
            case 2:
              _context.next = 4;
              return this.subscribe();
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _internalConnect(_x) {
        return _internalConnect2.apply(this, arguments);
      }
      return _internalConnect;
    }()
    /**
     * Ensures gathering state complete for ICE.
     *
     * @param {RTCPeerConnection} connection
     * @returns Promise
     *
     * @private
     */
  }, {
    key: "waitToGatherIce",
    value: function () {
      var _waitToGatherIce = red5pro_whep_asyncToGenerator( /*#__PURE__*/red5pro_whep_regeneratorRuntime().mark(function _callee2(connection) {
        var offer;
        return red5pro_whep_regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              connection.addTransceiver('video', {
                direction: 'recvonly'
              });
              connection.addTransceiver('audio', {
                direction: 'recvonly'
              });
              _context2.next = 4;
              return connection.createOffer();
            case 4:
              offer = _context2.sent;
              connection.setLocalDescription(offer);
              return _context2.abrupt("return", new Promise(function (resolve, reject) {
                if (connection.iceGatheringState === 'complete') {
                  resolve({
                    offer: offer,
                    local: connection.localDescription
                  });
                } else {
                  setTimeout(function () {
                    resolve({
                      offer: offer,
                      local: connection.localDescription
                    });
                  }, ICE_GATHER_TIMEOUT);
                  connection.onicegatheringstatechange = function () {
                    connection.iceGatheringState === 'complete' && resolve({
                      offer: offer,
                      local: connection.localDescription
                    });
                  };
                }
              }));
            case 7:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function waitToGatherIce(_x2) {
        return _waitToGatherIce.apply(this, arguments);
      }
      return waitToGatherIce;
    }()
    /**
     * Sends a candidate to the server over WHEP.
     *
     * @param {Object} candidate
     *        The peer candidate description.
     *
     * @private
     */
  }, {
    key: "_sendCandidate",
    value: function _sendCandidate(candidate) {
      log_debug(red5pro_whep_NAME, '[sendcandidate]');
      this.trigger(new SubscriberEvent(RTCSubscriberEventTypes.CANDIDATE_START, this, candidate));
    }

    /**
     * POSTs SDP to WHEP endpoint.
     *
     * @param {RTCSessionDescription} sessionDescription
     *
     * @returns { sdp, location }
     *
     * @private
     */
  }, {
    key: "_postOffer",
    value: function () {
      var _postOffer2 = red5pro_whep_asyncToGenerator( /*#__PURE__*/red5pro_whep_regeneratorRuntime().mark(function _callee3(sessionDescription) {
        return red5pro_whep_regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              _context3.next = 3;
              return this._whipHelper.postSDPOffer(sessionDescription.sdp);
            case 3:
              return _context3.abrupt("return", _context3.sent);
            case 6:
              _context3.prev = 6;
              _context3.t0 = _context3["catch"](0);
              log_error(red5pro_whep_NAME, _context3.t0.message || _context3.t0);
              this.onStreamUnavailable(_context3.t0);
              throw _context3.t0;
            case 11:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 6]]);
      }));
      function _postOffer(_x3) {
        return _postOffer2.apply(this, arguments);
      }
      return _postOffer;
    }()
    /**
     * Sends Candidates as PATCH to WHEP endpoint.
     * @param {string} sdp The SDP with candidates
     * @returns Promise
     *
     * @private
     */
  }, {
    key: "_postCandidateFragments",
    value: function () {
      var _postCandidateFragments2 = red5pro_whep_asyncToGenerator( /*#__PURE__*/red5pro_whep_regeneratorRuntime().mark(function _callee5(sdp) {
        var _this2 = this;
        var hostFrag, srflxFrag;
        return red5pro_whep_regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              hostFrag = generateSDPCandidateFrag(sdp, 'host');
              srflxFrag = generateSDPCandidateFrag(sdp, 'srflx', true);
              _context5.next = 4;
              return this._whipHelper.trickle(hostFrag);
            case 4:
              return _context5.abrupt("return", new Promise(function (resolve, reject) {
                var postSrflx = function postSrflx() {
                  setTimeout( /*#__PURE__*/red5pro_whep_asyncToGenerator( /*#__PURE__*/red5pro_whep_regeneratorRuntime().mark(function _callee4() {
                    return red5pro_whep_regeneratorRuntime().wrap(function _callee4$(_context4) {
                      while (1) switch (_context4.prev = _context4.next) {
                        case 0:
                          _context4.next = 2;
                          return _this2._whipHelper.trickle(srflxFrag);
                        case 2:
                          resolve();
                        case 3:
                        case "end":
                          return _context4.stop();
                      }
                    }, _callee4);
                  })), 150);
                };
                postSrflx();
              }));
            case 5:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function _postCandidateFragments(_x4) {
        return _postCandidateFragments2.apply(this, arguments);
      }
      return _postCandidateFragments;
    }()
    /**
     * Request offer over WHEP service.
     *
     * @private
     */
  }, {
    key: "_requestOffer",
    value: function () {
      var _requestOffer2 = red5pro_whep_asyncToGenerator( /*#__PURE__*/red5pro_whep_regeneratorRuntime().mark(function _callee6() {
        var trickleIce, connection, _yield$this$waitToGat, offer, local, _yield$this$_postOffe, sdp, _sdp;
        return red5pro_whep_regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              trickleIce = this._options.trickleIce;
              connection = this.getPeerConnection(); // offer: the origin offer SDP
              // local: the local description with all candidates
              _context6.next = 4;
              return this.waitToGatherIce(connection);
            case 4:
              _yield$this$waitToGat = _context6.sent;
              offer = _yield$this$waitToGat.offer;
              local = _yield$this$waitToGat.local;
              this.trigger(new SubscriberEvent(RTCSubscriberEventTypes.OFFER_START, this));
              _context6.next = 10;
              return this._postOffer(trickleIce ? offer : local);
            case 10:
              _yield$this$_postOffe = _context6.sent;
              sdp = _yield$this$_postOffe.sdp;
              this.trigger(new SubscriberEvent(RTCSubscriberEventTypes.OFFER_END, this));
              _context6.next = 15;
              return connection.setRemoteDescription(new RTCSessionDescription({
                type: 'answer',
                sdp: sdp
              }));
            case 15:
              if (!trickleIce) {
                _context6.next = 19;
                break;
              }
              _sdp = local.sdp;
              _context6.next = 19;
              return this._postCandidateFragments(_sdp);
            case 19:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function _requestOffer() {
        return _requestOffer2.apply(this, arguments);
      }
      return _requestOffer;
    }()
    /**
     * Disconnect and teardown after close of subscription.
     *
     * @private
     */
  }, {
    key: "_disconnect",
    value: function _disconnect() {
      if (this._whipHelper) {
        this._whipHelper.tearDown();
      }
      this._whipHelper = undefined;
      red5pro_whep_get(red5pro_whep_getPrototypeOf(WHEPClient.prototype), "_disconnect", this).call(this);
    }

    /**
     * Request to initialize the WebRTC-based Subscriber based on configuration.
     * The returned `Promise` will either resolve with a reference to this instance or reject with an error `String` in failure.
     *
     * @param {Object} options
     *        The initialization configuration map.
     * @return {Promise}
     */
  }, {
    key: "init",
    value: function () {
      var _init = red5pro_whep_asyncToGenerator( /*#__PURE__*/red5pro_whep_regeneratorRuntime().mark(function _callee7(options) {
        var _this$_options, protocol, host, port, app, streamName, subscriptionId, proto;
        return red5pro_whep_regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              if (webrtc_isSupported()) {
                _context7.next = 4;
                break;
              }
              throw new Error('Cannot create WebRTC playback instance. Your environment does not support WebRTC and/or WebSockets.');
            case 4:
              this._disconnect();
              this._options = _objectSpread(_objectSpread({}, red5pro_whep_defaultOptions), options);
              this._options.subscriptionId = this._options.subscriptionId || red5pro_whep_generateSubscriptionId();
              _this$_options = this._options, protocol = _this$_options.protocol, host = _this$_options.host, port = _this$_options.port, app = _this$_options.app, streamName = _this$_options.streamName, subscriptionId = _this$_options.subscriptionId;
              proto = protocol === 'ws' ? 'http' : 'https';
              this._whipUrl = "".concat(proto, "://").concat(host, ":").concat(port, "/").concat(app, "/whep/endpoint/").concat(streamName, "?requestId=").concat(subscriptionId);
              this._whipHelper = new whipwhep_signaling_helper(this._whipUrl);
              this._peerHelper = new webrtc_helper_sub(this);
              this._messageTransport = this._whipHelper;
              return _context7.abrupt("return", this);
            case 14:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function init(_x5) {
        return _init.apply(this, arguments);
      }
      return init;
    }()
    /**
     * Request to begin subscribing to a stream.
     *
     * @return {Promise}
     *          The returned `Promise` will resolve or reject on successful start of playback.
     *        There are several processes that occur in order to establish a WebRTC subscription that involve - but are not limited to - ICE communication and assigning of local and remote SDPs on peer connections.
     */
  }, {
    key: "subscribe",
    value: function () {
      var _subscribe = red5pro_whep_asyncToGenerator( /*#__PURE__*/red5pro_whep_regeneratorRuntime().mark(function _callee8() {
        var _this$_options2, streamName, mediaElementId, rtcConfiguration, enableLiveSeek, _this$_options3, signalingSocketOnly, dataChannelConfiguration, dataChannelAllowed, view, _yield$this$_whipHelp, links;
        return red5pro_whep_regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _this$_options2 = this._options, streamName = _this$_options2.streamName, mediaElementId = _this$_options2.mediaElementId, rtcConfiguration = _this$_options2.rtcConfiguration, enableLiveSeek = _this$_options2.enableLiveSeek;
              _this$_options3 = this._options, signalingSocketOnly = _this$_options3.signalingSocketOnly, dataChannelConfiguration = _this$_options3.dataChannelConfiguration; // Set default data channel configuration if not defined and severing socket on signal end.
              // TODO: Set this as more "private" with `red5pro-<streamname>`
              dataChannelAllowed = signalingSocketOnly && webrtc_supportsDataChannel();
              if (dataChannelAllowed && !dataChannelConfiguration) {
                dataChannelConfiguration = {
                  name: "red5pro"
                };
              }
              // this._options.signalingSocketOnly = dataChannelAllowed

              // TODO: DC turned off for now
              this._options.signalingSocketOnly = false;
              _context8.prev = 5;
              this._setViewIfNotExist(this._view, mediaElementId);
              _context8.next = 9;
              return this._getViewResolverPromise();
            case 9:
              view = _context8.sent;
              if (enableLiveSeek) {
                if (browser.supportsHLS() || browser.supportsNonNativeHLS()) {
                  this._sourceHandler = new red5pro_source_handler_rtc_seekable(view.view, this.getType());
                } else {
                  log_error(red5pro_whep_NAME, "Could not utilize the 'enableLiveSeek' request. This feature requires either native HLS playback or hls.js as a depenency.");
                  this._sourceHandler = new red5pro_source_handler_rtc(view.view, this.getType());
                }
              } else {
                this._sourceHandler = new red5pro_source_handler_rtc(view.view, this.getType());
              }
              this._glomSourceHandlerAPI(this._sourceHandler);
              this._initHandler(this._options, this._sourceHandler);
              this._getAvailabilityResolverPromise().catch(function () {
                /* passed up through overarching promise. */
              });
              _context8.next = 16;
              return this._whipHelper.getOptions();
            case 16:
              _yield$this$_whipHelp = _context8.sent;
              links = _yield$this$_whipHelp.links;
              if (links) {
                this._options.iceServers = links;
              }

              // TODO: DC turned off for now
              // this._connect(rtcConfiguration, dataChannelConfiguration, this._options.iceServers)
              this._connect(rtcConfiguration, undefined, this._options.iceServers);
              this._connectionClosed = false;
              return _context8.abrupt("return", this._getSubscriptionResolverPromise());
            case 24:
              _context8.prev = 24;
              _context8.t0 = _context8["catch"](5);
              this.trigger(new SubscriberEvent(SubscriberEventTypes.CONNECT_FAILURE), this, _context8.t0);
              throw _context8.t0;
            case 28:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this, [[5, 24]]);
      }));
      function subscribe() {
        return _subscribe.apply(this, arguments);
      }
      return subscribe;
    }()
    /**
     * Event handler for receipt of a `MediaStream`.
     *
     * @param {MediaStream} stream
     *        The stream returned on the Peer Connection.
     *
     * @private
     */
  }, {
    key: "onAnswerMediaStream",
    value: function () {
      var _onAnswerMediaStream = red5pro_whep_asyncToGenerator(function () {
        var _this3 = this;
        var stream = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
        return /*#__PURE__*/red5pro_whep_regeneratorRuntime().mark(function _callee9() {
          var view;
          return red5pro_whep_regeneratorRuntime().wrap(function _callee9$(_context9) {
            while (1) switch (_context9.prev = _context9.next) {
              case 0:
                // eslint-disable-line no-unused-vars
                _this3.trigger(new SubscriberEvent(RTCSubscriberEventTypes.ANSWER_END, _this3));
                _context9.next = 3;
                return _this3._getViewResolverPromise();
              case 3:
                view = _context9.sent;
                view.attachStream(stream);
                _this3._mediaStream = stream;
                _this3.trigger(new SubscriberEvent(RTCSubscriberEventTypes.ON_ADD_STREAM, _this3, _this3._mediaStream));
              case 7:
              case "end":
                return _context9.stop();
            }
          }, _callee9);
        })();
      });
      function onAnswerMediaStream() {
        return _onAnswerMediaStream.apply(this, arguments);
      }
      return onAnswerMediaStream;
    }()
    /**
     * Event handler for open of Peer Connection.
     *
     * @private
     */
  }, {
    key: "onPeerConnectionOpen",
    value: function onPeerConnectionOpen() {
      red5pro_whep_get(red5pro_whep_getPrototypeOf(WHEPClient.prototype), "onPeerConnectionOpen", this).call(this);
      this._subscriptionResolver.resolve(this);
      this.trigger(new SubscriberEvent(SubscriberEventTypes.SUBSCRIBE_START, this));
      this._playIfAutoplaySet(this._options, this._view);
      this._startSeekable(this._options, this._view);
    }

    /**
     * Returns the current WebSocket connection helper if established. Due to using WHEP, this does not exist.
     *
     * @return {SubscriptionSocketHelper}
     *
     * @private
     */
  }, {
    key: "getConnection",
    value: function getConnection() {
      return undefined;
    }
  }]);
  return WHEPClient;
}(red5pro_rtc);
/* harmony default export */ var red5pro_whep = (red5pro_whep_WHEPClient);
// CONCATENATED MODULE: ./src/js/subscriber/index.js


function subscriber_typeof(obj) { "@babel/helpers - typeof"; return subscriber_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, subscriber_typeof(obj); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || subscriber_unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function subscriber_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return subscriber_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return subscriber_arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return subscriber_arrayLikeToArray(arr); }
function subscriber_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function subscriber_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function subscriber_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, subscriber_toPropertyKey(descriptor.key), descriptor); } }
function subscriber_createClass(Constructor, protoProps, staticProps) { if (protoProps) subscriber_defineProperties(Constructor.prototype, protoProps); if (staticProps) subscriber_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function subscriber_toPropertyKey(arg) { var key = subscriber_toPrimitive(arg, "string"); return subscriber_typeof(key) === "symbol" ? key : String(key); }
function subscriber_toPrimitive(input, hint) { if (subscriber_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (subscriber_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function subscriber_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) subscriber_setPrototypeOf(subClass, superClass); }
function subscriber_setPrototypeOf(o, p) { subscriber_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return subscriber_setPrototypeOf(o, p); }
function subscriber_createSuper(Derived) { var hasNativeReflectConstruct = subscriber_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = subscriber_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = subscriber_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return subscriber_possibleConstructorReturn(this, result); }; }
function subscriber_possibleConstructorReturn(self, call) { if (call && (subscriber_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return subscriber_assertThisInitialized(self); }
function subscriber_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function subscriber_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function subscriber_getPrototypeOf(o) { subscriber_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return subscriber_getPrototypeOf(o); }









var subscriber_NAME = 'Red5ProSubscriber';
var playbackFactory = new impl_factory_order();
var playbackImpl = function () {
  var map = new Map();
  map.set(PlaybackTypes.RTC, red5pro_rtc);
  map.set(PlaybackTypes.RTMP, red5pro_rtmp);
  map.set(PlaybackTypes.HLS, red5pro_hls);
  return map;
}();

/**
 * Main entry for failover support of all subscriber implementations.
 *
 * @extends EventEmitter
 */
var subscriber_Red5ProSubscriber = /*#__PURE__*/function (_EventEmitter) {
  subscriber_inherits(Red5ProSubscriber, _EventEmitter);
  var _super = subscriber_createSuper(Red5ProSubscriber);
  function Red5ProSubscriber() {
    var _this;
    subscriber_classCallCheck(this, Red5ProSubscriber);
    _this = _super.call(this);
    _this._options = undefined;
    _this._order = [PlaybackTypes.RTC, PlaybackTypes.RTMP, PlaybackTypes.HLS];
    return _this;
  }

  /**
   * Utilizes Failover Publisher Factory to attempt in determining browser support for Publisher from defined order.
   *
   * @return {Promise}
   *
   * @private
   */
  subscriber_createClass(Red5ProSubscriber, [{
    key: "_getPlaybackFromOrder",
    value: function _getPlaybackFromOrder(order, options) {
      return playbackFactory.create(order, playbackImpl, options, 'init');
    }

    /**
     * Returns the specified order for auto-failover.
     *
     *  @return {Array}
     *          Default: `['rtc', 'rtmp', 'hls']`.
     */
  }, {
    key: "getPlaybackOrder",
    value: function getPlaybackOrder() {
      return this._order;
    }

    /**
     * Defines the desired auto-failover order.
     *
     *  @param {Array} order
     *          The desired order. e.g, `['rtc', 'rtmp', 'hls']`.
     */
  }, {
    key: "setPlaybackOrder",
    value: function setPlaybackOrder(order) {
      // Allow for string value to define single item in order.
      order = typeof order === 'string' ? [order] : order;

      // Filter out values not available in enumeration of playback types.
      var t = order.filter(function (entry) {
        var key;
        for (key in PlaybackTypes) {
          if (PlaybackTypes[key].toLowerCase() === entry.toLowerCase()) {
            return true;
          }
        }
        return false;
      }).map(function (entry) {
        return entry.toLowerCase();
      });

      // Define new order.
      this._order = _toConsumableArray(new Set(t));
      log_debug(subscriber_NAME, "[orderupdate]: ".concat(this._order));
      return this;
    }

    /**
     * Request to initialize and determine the proper Subscriber implementation based on configuration.
     *
     * The returned `Promise` will either resolve with the determined Subscriber instance or reject with an error String in failure to determine Subscriber type.
     *
     *  @param {Object} options
     *          The initialization configuration map for each desired failover tech.
     *  @return {Promise}
     */
  }, {
    key: "init",
    value: function init(options) {
      this._options = options;
      var deferred = new DeferredPromise();
      log_debug(subscriber_NAME, '[init]');
      this._getPlaybackFromOrder(this._order, this._options).then(function (subscriber) {
        log_debug(subscriber_NAME, "[init:success]: subscriber found ".concat(subscriber.getType()));
        deferred.resolve(subscriber);
      }).catch(function (err) {
        log_warn(subscriber_NAME, "[playerror]: Could not implement a subscriber: ".concat(err));
        deferred.reject(err);
      });
      return deferred.promise;
    }

    /**
     * Return enumerated value Subscriber types used in failover order.
     * @type {Object}
     */
  }, {
    key: "playbackTypes",
    get: function get() {
      return PlaybackTypes;
    }
  }]);
  return Red5ProSubscriber;
}(event_emitter);

// CONCATENATED MODULE: ./src/js/publisher/pub-source-handler.js


function pub_source_handler_typeof(obj) { "@babel/helpers - typeof"; return pub_source_handler_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, pub_source_handler_typeof(obj); }
function pub_source_handler_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function pub_source_handler_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, pub_source_handler_toPropertyKey(descriptor.key), descriptor); } }
function pub_source_handler_createClass(Constructor, protoProps, staticProps) { if (protoProps) pub_source_handler_defineProperties(Constructor.prototype, protoProps); if (staticProps) pub_source_handler_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function pub_source_handler_toPropertyKey(arg) { var key = pub_source_handler_toPrimitive(arg, "string"); return pub_source_handler_typeof(key) === "symbol" ? key : String(key); }
function pub_source_handler_toPrimitive(input, hint) { if (pub_source_handler_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (pub_source_handler_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }







var pub_source_handler_NAME = 'R5ProPublisherSourceHandler';

/**
 * Determine the video dimensions setting value based on possible definition using `MediaConstraint`.
 * @private
 */
var convertDimensionOptions = function convertDimensionOptions(vo) {
  return vo.exact || vo.ideal || vo.max || vo.min || vo;
};

/**
 * Define the audio and video settings for Flash.
 * The `width` and `height` attributes relate to video. The `audio` attribute is a boolean flag.
 * @private
 */
var pub_source_handler_mediaConstraintsToFlashvars = function mediaConstraintsToFlashvars(constraints, flashvars) {
  var fv = deepCopy(flashvars);
  if (typeof constraints.video === 'boolean') {
    fv.video = constraints.video;
  } else {
    var key;
    for (key in constraints.video) {
      fv[key] = convertDimensionOptions(constraints.video[key]);
    }
    fv.video = true;
  }
  fv.audio = typeof constraints.audio === 'boolean' ? constraints.audio : true;
  return fv;
};

/**
 * The internal Publish Source Handler for an RTMPPublisher.
 * @private
 */
var pub_source_handler_PublisherSourceHandler = /*#__PURE__*/function () {
  /**
   * @param {Element} video
   *        The video DOM Element.
   * @param {String} type
   *        The publisher type: most likely, `RTMP`.
   * @param {Object} soResponder
   *        Optional responder to SharedObject API. If not provided, will generate a `RTMPSharedObjectHandler` instance internally.
   * @private
   */
  function PublisherSourceHandler(video, type) {
    var soResponder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
    pub_source_handler_classCallCheck(this, PublisherSourceHandler);
    this.video = video;
    this.clone = this.video.cloneNode(true);
    this.holder = this.video.parentNode;
    this._publisherType = type;
    this._swfId = null;
    this._embedFuture = undefined;
    this._soResponder = soResponder || new sharedobject_helper_rtmp();
  }

  /**
   * Requested and used by RTMPPublisher instance in recognizing completion of embed.
   *
   * @return {Promise}
   * @private
   */
  pub_source_handler_createClass(PublisherSourceHandler, [{
    key: "getEmbedOperation",
    value: function getEmbedOperation() {
      this._embedFuture = Future.createIfNotExist(this._embedFuture);
      return this._embedFuture.promise;
    }

    /**
     * Clean up of references and modified display.
     * @private
     */
  }, {
    key: "cleanUp",
    value: function cleanUp() {
      // Return to prior DOM manipulation.
      this.video.remove();
      this.video = this.clone.cloneNode(true);
      this.holder.appendChild(this.video);
      this._embedFuture = undefined;
    }

    /**
     * Request to define the embedding options for a RTMPPublisher.
     *
     * @param {String} swfId
     *        The unique id to use in embedding element.
     * @param {Object} options
     *        The initialization configuration to determine flashvars from.
     * @param {String} swfUrl
     *        Optional location of the SWF file to embed. Default is relative path to `red5pro-subscriber.swf`.
     * @param {String} minFlashVersion
     *        Optional semver of minimum Flash version to determine support. Default is `10.0.0`.
     * @return {Promise}
     *        The `Promise` either resolves or rejects the success of embed on page using SWFObject.
     * @private
     */
  }, {
    key: "addSource",
    value: function addSource(swfId, options) {
      var swfUrl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var minFlashVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      log_debug(pub_source_handler_NAME, '[addsource]');
      var self = this;
      this._swfId = swfId;
      this._embedFuture = Future.createIfNotExist(this._embedFuture);
      var deferred = this._embedFuture;
      options.swf = swfUrl || options.swf;
      options.minFlashVersion = minFlashVersion || options.minFlashVersion;
      embed_defineEmbedElement(this.video, this.holder).then(function (elementId) {
        log_debug(pub_source_handler_NAME, '[element:complete]');
        var flashvars = {
          buffer: options.buffer != null ? options.buffer : 1,
          streamMode: options.streamMode,
          streamName: options.streamName,
          appName: options.app,
          host: options.host
        };
        if (options.backgroundColor) {
          flashvars.backgroundColor = options.backgroundColor;
        }
        if (options.context) {
          flashvars.roomName = options.context;
        }
        if (options.embedWidth === '100%' || options.embedHeight === '100%') {
          flashvars.autosize = true;
        }
        if (typeof options.connectionParams !== 'undefined') {
          flashvars.connectionParams = encodeURIComponent(JSON.stringify(options.connectionParams));
        }
        flashvars = pub_source_handler_mediaConstraintsToFlashvars(options.mediaConstraints, flashvars);
        return embed_embedSwfObject(swfId, options, flashvars, browser.getSwfObject(), elementId);
      }).then(function () {
        log_debug(pub_source_handler_NAME, '[embed:complete]');
        deferred.resolve(self);
      }).catch(function (err) {
        return deferred.reject(err);
      });
      return deferred.promise;
    }

    /**
     * Request to connect to server for a broadcast session.
     *
     * @param {Object} publishOptions
     * @private
     */
  }, {
    key: "connect",
    value: function connect(publishOptions) {
      log_debug(pub_source_handler_NAME, '[connect]');
      var el = browser.getEmbedObject(this._swfId);
      if (el) {
        el.connect(publishOptions);
        this._soResponder.connect(this._swfId);
      } else {
        log_warn(pub_source_handler_NAME, 'Could not determine embedded element with swf id: ' + this._swfId + '.');
      }
    }

    /**
     * Request to disconnect from server.
     *
     * @private
     */
  }, {
    key: "disconnect",
    value: function disconnect() {
      log_debug(pub_source_handler_NAME, '[disconnect]');
      try {
        var el = browser.getEmbedObject(this._swfId);
        if (el) {
          el.disconnect();
        }
      } catch (e) {
        // nada.
      }
      this.cleanUp();
      this._soResponder.disconnect();
    }

    /**
     * Request to send a message to all subscribers.
     *
     * @param {String} methodName
     *        The method name associated with the message to be accepted by all subscribers.
     * @param {Object} data
     *        The data object to send associated with the method name.
     * @private
     */
  }, {
    key: "send",
    value: function send(methodName, data) {
      var el = browser.getEmbedObject(this._swfId);
      if (el) {
        el.send(methodName, data);
      }
    }

    /**
     * Adds a response handler on SharedObject channel responder.
     * @private
     */
  }, {
    key: "addSharedObjectResponseHandler",
    value: function addSharedObjectResponseHandler(handler) {
      this._soResponder.addResponseHandler(handler);
    }

    /**
     * Removes a response handler on SharedObject channel responder.
     * @private
     */
  }, {
    key: "removeSharedObjectResponseHandler",
    value: function removeSharedObjectResponseHandler(handler) {
      this._soResponder.removeResponseHandler(handler);
    }

    /**
     * Sends message on SharedObject channel responder.
     *
     * @param {String} name
     *        The SharedObject name.
     * @param {String} callName
     *        The method name to be invoked.
     * @param {String} message
     *        The structured value to send.
     * @private
     */
  }, {
    key: "sendToSharedObject",
    value: function sendToSharedObject(name, callName, message) {
      this._soResponder.sendToSharedObject(name, callName, message);
    }

    /**
     * Sends property update on SharedObject channel responder.
     *
     * @param {String} name
     *        The SharedObject name.
     * @param {String} key
     *        The property name on the SharedObject.
     * @param {String} value
     *        The structured property value.
     * @private
     */
  }, {
    key: "sendPropertyToSharedObject",
    value: function sendPropertyToSharedObject(name, key, value) {
      this._soResponder.sendPropertyToSharedObject(name, key, value);
    }

    /**
     * Requests to get SharedObject instance from the SharedObject channel responder.
     * @private
     */
  }, {
    key: "getRemoteSharedObject",
    value: function getRemoteSharedObject(sharedObjectName) {
      this._soResponder.getRemoteSharedObject(sharedObjectName);
    }

    /**
     * Request to connect to a shared object.
     *
     * @param {String} sharedObjectName
     *        The name of the SharedObject.
     * @private
     */
  }, {
    key: "connectToSharedObject",
    value: function connectToSharedObject(sharedObjectName) {
      this._soResponder.connectToSharedObject(sharedObjectName);
    }

    /**
     * Request to close connection to a shared object.
     *
     * @param {String} sharedObjectName
     *        The name of the SharedObject.
     * @private
     */
  }, {
    key: "closeSharedObject",
    value: function closeSharedObject(sharedObjectName) {
      this._soResponder.closeSharedObject(sharedObjectName);
    }

    /**
     * Deprecated. Request to update broadcast dimensions before a broadcast.
     *
     * @param {Object} quality
     *        Expects object with following structur: `{video: {width:Int, heightInt}}
     * @private
     */
  }, {
    key: "setMediaQuality",
    value: function setMediaQuality(quality) {
      var el = browser.getEmbedObject(this._swfId);
      if (el) {
        if (quality.video && typeof quality.video !== 'boolean') {
          var w = !isNaN(quality.video.width) ? toInt(quality.video.width) : Number.isNaN;
          var h = !isNaN(quality.video.height) ? toInt(quality.video.height) : Number.isNaN;
          el.updateResolution(w, h);
        }
      }
    }

    /**
     * Returns the type of implementation: `RTMP`.
     *
     * @return {String}
     * @private
     */
  }, {
    key: "getType",
    value: function getType() {
      return this._publisherType;
    }
  }]);
  return PublisherSourceHandler;
}();
/* harmony default export */ var pub_source_handler = (pub_source_handler_PublisherSourceHandler);
// CONCATENATED MODULE: ./src/js/view/publish.js


function publish_typeof(obj) { "@babel/helpers - typeof"; return publish_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, publish_typeof(obj); }
function publish_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function publish_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, publish_toPropertyKey(descriptor.key), descriptor); } }
function publish_createClass(Constructor, protoProps, staticProps) { if (protoProps) publish_defineProperties(Constructor.prototype, protoProps); if (staticProps) publish_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function publish_toPropertyKey(arg) { var key = publish_toPrimitive(arg, "string"); return publish_typeof(key) === "symbol" ? key : String(key); }
function publish_toPrimitive(input, hint) { if (publish_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (publish_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }


var publish_NAME = 'R5ProPublishView';
var publisherId = 'red5pro-publisher';

/**
 * Bridge between DOM Element view and Publisher implementation.
 * Still used, but internalized as of 4.0.0. Up for deprecation, up for discussion.
 *
 * @private
 */
var publish_PublishView = /*#__PURE__*/function () {
  /**
   * @param {String} elementId
   *        The element `id` to use for playback display.
   * @private
   */
  function PublishView() {
    var elementId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : publisherId;
    publish_classCallCheck(this, PublishView);
    try {
      this._targetElement = browser.resolveElement(elementId);
    } catch (e) {
      log_error(publish_NAME, "Could not instantiate a new instance of Red5ProPublisher. Reason: ".concat(e.message));
      throw e;
    }
  }
  publish_createClass(PublishView, [{
    key: "attachPublisher",
    value: function attachPublisher(publisher) {
      log_debug(publish_NAME, '[attachpublisher]');
      publisher.setView(this, browser.getElementId(this._targetElement));
    }
  }, {
    key: "preview",
    value: function preview(mediaStream) {
      var autoplay = this.isAutoplay;
      log_debug(publish_NAME, "[preview]: autoplay(".concat(autoplay, ")"));
      browser.setVideoSource(this._targetElement, mediaStream, autoplay);
    }
  }, {
    key: "unpreview",
    value: function unpreview() {
      browser.setVideoSource(this._targetElement, null, this.isAutoplay);
    }
  }, {
    key: "isAutoplay",
    get: function get() {
      return browser.hasAttributeDefined(this._targetElement, 'autoplay');
    }
  }, {
    key: "view",
    get: function get() {
      return this._targetElement;
    }
  }]);
  return PublishView;
}();
/* harmony default export */ var view_publish = (publish_PublishView);
// CONCATENATED MODULE: ./src/js/enum/publish.js


var PublishTypes = Object.freeze({
  RTMP: 'rtmp',
  RTC: 'rtc'
});
var PublishModeTypes = Object.freeze({
  LIVE: 'live',
  RECORD: 'record',
  APPEND: 'append'
});
// CONCATENATED MODULE: ./src/js/publisher/constraint/index.js


/**
 * Easy decorator for setting a mutable, iteratable property on an object.
 *
 * @private
 */
function constraint_typeof(obj) { "@babel/helpers - typeof"; return constraint_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, constraint_typeof(obj); }
function constraint_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, constraint_toPropertyKey(descriptor.key), descriptor); } }
function constraint_createClass(Constructor, protoProps, staticProps) { if (protoProps) constraint_defineProperties(Constructor.prototype, protoProps); if (staticProps) constraint_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function constraint_toPropertyKey(arg) { var key = constraint_toPrimitive(arg, "string"); return constraint_typeof(key) === "symbol" ? key : String(key); }
function constraint_toPrimitive(input, hint) { if (constraint_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (constraint_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function constraint_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
var inflate = function inflate(obj, prop, value) {
  Object.defineProperty(obj, prop, {
    value: value,
    writable: true,
    enumerable: true
  });
};

/**
 * Default `exact` setting for `video` on `MediaConstraint` for WebRTC broadcast.
 *
 * @private
 */
var RTCMediaVideoConstraint = /*#__PURE__*/constraint_createClass(function RTCMediaVideoConstraint() {
  constraint_classCallCheck(this, RTCMediaVideoConstraint);
  inflate(this, 'width', {
    exact: 640
  });
  inflate(this, 'height', {
    exact: 480
  });
});
/**
 * Default RTMP video settings for braodcast.
 *
 * @private
 */
var RTMPMediaVideoConstraint = /*#__PURE__*/constraint_createClass(function RTMPMediaVideoConstraint() {
  constraint_classCallCheck(this, RTMPMediaVideoConstraint);
  inflate(this, 'width', 640);
  inflate(this, 'height', 480);
  inflate(this, 'force', false);
  inflate(this, 'framerate', 15);
  inflate(this, 'bandwidth', 50000);
  inflate(this, 'quality', 80);
  inflate(this, 'profile', 'baseline');
  inflate(this, 'level', 3.1);
});
/**
 * Default WebRTC media settings for broadcast.
 *
 * @private
 */
var RTCMediaConstraint = /*#__PURE__*/constraint_createClass(function RTCMediaConstraint() {
  var audio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var video = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  constraint_classCallCheck(this, RTCMediaConstraint);
  inflate(this, 'audio', audio);
  inflate(this, 'video', video || new RTCMediaVideoConstraint());
});
/**
 * Default RTMP media settings for broadcast.
 *
 * @private
 */
var RTMPMediaConstraint = /*#__PURE__*/constraint_createClass(function RTMPMediaConstraint() {
  var audio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var video = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  constraint_classCallCheck(this, RTMPMediaConstraint);
  inflate(this, 'audio', audio);
  inflate(this, 'video', video || new RTMPMediaVideoConstraint());
});

// CONCATENATED MODULE: ./src/js/publisher/red5pro-rtmp.js


function publisher_red5pro_rtmp_typeof(obj) { "@babel/helpers - typeof"; return publisher_red5pro_rtmp_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, publisher_red5pro_rtmp_typeof(obj); }
function publisher_red5pro_rtmp_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function publisher_red5pro_rtmp_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, publisher_red5pro_rtmp_toPropertyKey(descriptor.key), descriptor); } }
function publisher_red5pro_rtmp_createClass(Constructor, protoProps, staticProps) { if (protoProps) publisher_red5pro_rtmp_defineProperties(Constructor.prototype, protoProps); if (staticProps) publisher_red5pro_rtmp_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function publisher_red5pro_rtmp_toPropertyKey(arg) { var key = publisher_red5pro_rtmp_toPrimitive(arg, "string"); return publisher_red5pro_rtmp_typeof(key) === "symbol" ? key : String(key); }
function publisher_red5pro_rtmp_toPrimitive(input, hint) { if (publisher_red5pro_rtmp_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (publisher_red5pro_rtmp_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function publisher_red5pro_rtmp_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) publisher_red5pro_rtmp_setPrototypeOf(subClass, superClass); }
function publisher_red5pro_rtmp_setPrototypeOf(o, p) { publisher_red5pro_rtmp_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return publisher_red5pro_rtmp_setPrototypeOf(o, p); }
function publisher_red5pro_rtmp_createSuper(Derived) { var hasNativeReflectConstruct = publisher_red5pro_rtmp_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = publisher_red5pro_rtmp_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = publisher_red5pro_rtmp_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return publisher_red5pro_rtmp_possibleConstructorReturn(this, result); }; }
function publisher_red5pro_rtmp_possibleConstructorReturn(self, call) { if (call && (publisher_red5pro_rtmp_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return publisher_red5pro_rtmp_assertThisInitialized(self); }
function publisher_red5pro_rtmp_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function publisher_red5pro_rtmp_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function publisher_red5pro_rtmp_getPrototypeOf(o) { publisher_red5pro_rtmp_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return publisher_red5pro_rtmp_getPrototypeOf(o); }










var publisher_red5pro_rtmp_NAME = 'RTMPPublisher';
var publisher_red5pro_rtmp_defaultOptions = {
  protocol: 'rtmp',
  port: 1935,
  streamMode: 'live',
  mediaElementId: 'red5pro-publisher',
  embedWidth: '100%',
  // DOM display style
  embedHeight: '100%',
  // DOM display style
  minFlashVersion: '10.0.0',
  swf: 'lib/red5pro/red5pro-publisher.swf',
  swfobjectURL: 'lib/swfobject/swfobject.js',
  productInstallURL: 'lib/swfobject/playerProductInstall.swf',
  mediaConstraints: new RTMPMediaConstraint()
};

/**
 * Main entry for Flash-based Publisher.
 *
 * @extends EventEmitter
 */
var red5pro_rtmp_RTMPPublisher = /*#__PURE__*/function (_EventEmitter) {
  publisher_red5pro_rtmp_inherits(RTMPPublisher, _EventEmitter);
  var _super = publisher_red5pro_rtmp_createSuper(RTMPPublisher);
  function RTMPPublisher() {
    var _this;
    publisher_red5pro_rtmp_classCallCheck(this, RTMPPublisher);
    _this = _super.call(this);
    _this._options = undefined;
    _this._view = undefined;
    _this._sourceHandler = undefined;
    _this._elementId = undefined;
    _this._connectFuture = undefined;
    return _this;
  }

  /**
   * Still in use for assigning document element view management to this instance.
   *
   * @private
   */
  publisher_red5pro_rtmp_createClass(RTMPPublisher, [{
    key: "_setViewIfNotExist",
    value: function _setViewIfNotExist(currentView) {
      var mediaElementId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      if (typeof currentView === 'undefined' && mediaElementId !== undefined) {
        var view = new view_publish(mediaElementId);
        view.attachPublisher(this);
      }
    }

    /**
     * Still in use for assigning document element view management to this instance.
     * API deprecated in 4.0.0.
     *
     * @private
     */
  }, {
    key: "setView",
    value: function setView(view, elementId) {
      var _this2 = this;
      this._view = view;
      this._elementId = elementId;
      if (this._sourceHandler !== undefined) {
        this._sourceHandler.disconnect();
        this._sourceHandler = undefined;
      }
      if (this._view) {
        this._sourceHandler = new pub_source_handler(this._view.view, this.getType());
      }
      if (this._options && this._sourceHandler) {
        this._sourceHandler.addSource(this._elementId, this._options).catch(function (err) {
          log_error(publisher_red5pro_rtmp_NAME, "Could not establish proper RTMP publisher: ".concat(err));
          _this2.trigger(new PublisherEvent(RTMPPublisherEventTypes.EMBED_FAILURE, _this2));
        });
      }
      return this;
    }

    /**
     * Define a window global callback used by Flash publisher to recognize embed complete.
     *
     * @private
     */
  }, {
    key: "_setUpConnectCallback",
    value: function _setUpConnectCallback(promise) {
      var _this3 = this;
      window.setActiveId = function (successId) {
        // successId === _options.streamName
        log_debug(publisher_red5pro_rtmp_NAME, "Embed and connect() complete for publisher swf. successId(".concat(successId, ")."));
        promise.resolve(_this3);
        _this3.trigger(new PublisherEvent(RTMPPublisherEventTypes.EMBED_SUCCESS, _this3));
        _this3._tearDownConnectCallback();
      };
      // TODO: Setup timeout to reject?
    }

    /**
     * Tear down global callback used in Flash publisher recognize of embed.
     *
     * @private
     */
  }, {
    key: "_tearDownConnectCallback",
    value: function _tearDownConnectCallback() {
      window.setActiveId = undefined;
    }

    /**
     * Define global function handlers for ExternalInterface to invoke for API communication.
     *
     * @private
     */
  }, {
    key: "_establishExtIntHandlers",
    value: function _establishExtIntHandlers() {
      var _this4 = this;
      var id = this._options.streamName;
      var invokeFn = function invokeFn(label) {
        return ['publisher', label, id.split('-').join('_')].join('_');
      };
      window[invokeFn('r5proConnectClosed')] = function () {
        _this4.trigger(new PublisherEvent(PublisherEventTypes.CONNECTION_CLOSED, _this4));
      };
      window[invokeFn('r5proConnectSuccess')] = function () {
        return _this4.trigger(new PublisherEvent(PublisherEventTypes.CONNECT_SUCCESS, _this4));
      };
      window[invokeFn('r5proUnpublishSuccess')] = function () {
        return _this4.trigger(new PublisherEvent(PublisherEventTypes.UNPUBLISH_SUCCESS, _this4));
      };
      window[invokeFn('r5proPublishStart')] = function () {
        _this4._connectFuture.resolve(_this4);
        _this4.trigger(new PublisherEvent(PublisherEventTypes.PUBLISH_START, _this4));
      };
      window[invokeFn('r5proPublishMetadata')] = function (metadata) {
        return _this4.trigger(new PublisherEvent(PublisherEventTypes.PUBLISH_METADATA, _this4, metadata));
      };
      window[invokeFn('r5proPublishInsufficientBW')] = function (data) {
        return _this4.trigger(new PublisherEvent(PublisherEventTypes.PUBLISH_INSUFFICIENT_BANDWIDTH, _this4, data));
      };
      window[invokeFn('r5proPublishSufficientBW')] = function (data) {
        return _this4.trigger(new PublisherEvent(PublisherEventTypes.PUBLISH_SUFFICIENT_BANDWIDTH, _this4, data));
      };
      window[invokeFn('r5proPublishRecoveringBW')] = function (data) {
        return _this4.trigger(new PublisherEvent(PublisherEventTypes.PUBLISH_RECOVERING_BANDWIDTH, _this4, data));
      };
      window[invokeFn('r5proConnectFailure')] = function () {
        _this4._connectFuture.reject(PublisherEventTypes.CONNECT_FAILURE);
        _this4.trigger(new PublisherEvent(PublisherEventTypes.CONNECT_FAILURE, _this4));
      };
      window[invokeFn('r5proPublishFail')] = function () {
        _this4._connectFuture.reject(PublisherEventTypes.PUBLISH_FAIL);
        _this4.trigger(new PublisherEvent(PublisherEventTypes.PUBLISH_FAIL, _this4));
      };
      window[invokeFn('r5proPublishInvalidName')] = function () {
        _this4._connectFuture.reject(PublisherEventTypes.PUBLISH_INVALID_NAME);
        _this4.trigger(new PublisherEvent(PublisherEventTypes.PUBLISH_INVALID_NAME, _this4));
      };
    }

    /**
     * Request to initialize the Flash-based Publisher based on configuration.
     * The returned `Promise` will either resolve with a reference to this instance or reject with an error `String` in failure.
     *
     * @param {Object} options
     *        The initialization configuration map.
     * @return {Promise}
     */
  }, {
    key: "init",
    value: function init(options) {
      var self = this;
      var deferred = new DeferredPromise();
      var version = options.minFlashVersion || publisher_red5pro_rtmp_defaultOptions.minFlashVersion;
      if (!browser.supportsFlashVersion(version)) {
        deferred.reject("Could not resolve RTMPPublisher instance. Requires minimum Flash Player install of ".concat(version));
      } else {
        this._options = Object.assign({}, publisher_red5pro_rtmp_defaultOptions, options);
        try {
          browser.injectScript(this._options.swfobjectURL).then(function () {
            log_debug(publisher_red5pro_rtmp_NAME, 'SWFObject embedded.');
            if (self._sourceHandler) {
              log_debug(publisher_red5pro_rtmp_NAME, 'Publish handler established.');
              return self._sourceHandler.addSource(self._elementId, self._options);
            } else {
              log_debug(publisher_red5pro_rtmp_NAME, 'Publish handler not established.');
              return true;
            }
          }).then(function () {
            self._setViewIfNotExist(self._view, self._options.mediaElementId);
            deferred.resolve(self);
          }).catch(function (err) {
            log_error(publisher_red5pro_rtmp_NAME, "Could not embed Flash-based RTMP Publisher. Reason: ".concat(err));
            if (self._sourceHandler) {
              self._sourceHandler.disconnect();
            }
            deferred.reject(err);
            self.trigger(new PublisherEvent(RTMPPublisherEventTypes.EMBED_FAILURE, self));
          });
        } catch (e) {
          deferred.reject("Could not inject Flash-based Publisher into the page. Reason: ".concat(e.message));
          self.trigger(new PublisherEvent(RTMPPublisherEventTypes.EMBED_FAILURE, self));
        }
      }
      return deferred.promise;
    }

    /**
     * Request to being a broadcast session after initilization has occured.
     *
     * @param {String} streamName
     *        Optional stream name to broadcast on, otherwise defaulting to the `streamName` provided in `init()` configuration.
     * @param {Promise} promise
     *        Optional `Promise` object to resolve/reject on based on sequence of events in establishing a broadcast, otherwise defaulting to `Promise` created internally and returned.
     * @return {Promise}
     *        The returned `Promise` will resolve or reject on successful start of a broadcast.<br>
     *        There are several processes that occur in order to establish a Flash-based broadcast that involve - but are not limited to - proper embed of Flash object on page with flashvars used in establishing RTMP-based NetConnection.
     */
  }, {
    key: "publish",
    value: function publish() {
      var _this5 = this;
      var streamName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      var promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      // eslint-disable-line no-unused-vars
      var dfd = promise || new DeferredPromise();
      this._setUpConnectCallback(dfd);
      this._options.streamName = streamName || this._options.streamName;
      var publishOptions = this._options;
      try {
        var srcHandler = this._sourceHandler;
        this._sourceHandler.getEmbedOperation().then(function () {
          log_debug(publisher_red5pro_rtmp_NAME, '[handler:embed:complete]');
          var el = browser.getEmbedObject(_this5._elementId);
          if (el) {
            _this5._establishExtIntHandlers();
          }
          var count = 0;
          var limit = 100;
          var tryConnect = function tryConnect() {
            var timeout;
            timeout = setTimeout(function () {
              try {
                clearTimeout(timeout);
                srcHandler.connect(JSON.stringify(publishOptions));
              } catch (e) {
                if (count++ > limit) {
                  throw e;
                } else {
                  tryConnect();
                }
              }
            }, 300);
          };
          tryConnect();
        }).catch(function (err) {
          dfd.reject(err);
          _this5.trigger(new PublisherEvent(PublisherEventTypes.CONNECT_FAILURE, _this5));
        });
      } catch (e) {
        log_error(publisher_red5pro_rtmp_NAME, '[handler:embed:error]');
        dfd.reject("Could not initiate connection sequence. Reason: ".concat(e.message));
        this.trigger(new PublisherEvent(PublisherEventTypes.CONNECT_FAILURE, this));
        this._tearDownConnectCallback();
      }
      this._connectFuture = dfd;
      return dfd.promise;
    }

    /**
     * Request to stop a broadcast.
     * The returned `Promise` will either resolve or reject on successful stop of broadcast.
     *
     * @return {Promise}
     */
  }, {
    key: "unpublish",
    value: function unpublish() {
      var deferred = new DeferredPromise();
      try {
        browser.getEmbedObject(this._elementId).unpublish();
        deferred.resolve();
      } catch (e) {
        log_error(publisher_red5pro_rtmp_NAME, "Could not initiate publish sequence. Reason: ".concat(e.message));
        deferred.reject(e.message);
      }
      this._connectFuture = undefined;
      return deferred.promise;
    }

    /**
     * Request to send a message to all subscribers.
     *
     * @param {String} methodName
     *        The method name associated with the message to be accepted by all subscribers.
     * @param {Object} data
     *        The data object to send associated with the method name.
     */
  }, {
    key: "send",
    value: function send(methodName, data) {
      this._sourceHandler.send(methodName, typeof data === 'string' ? data : JSON.stringify(data));
    }

    /**
     * Deprecated. Request to update broadcast dimensions before a broadcast.
     *
     * @param {Object} quality
     *        Expects object with following structur: `{video: {width:Int, heightInt}}
     *
     * @private
     */
  }, {
    key: "setMediaQuality",
    value: function setMediaQuality(quality) {
      if (this._sourceHandler) {
        this._sourceHandler.setMediaQuality(quality);
      }
    }

    /**
     * Helper method to overlay options over current configuration.
     *
     * @param {Object} newOptions
     *        The options to overlay.
     *
     * @private
     */
  }, {
    key: "overlayOptions",
    value: function overlayOptions(newOptions) {
      this._options = Object.assign(this._options, newOptions);
    }

    /**
     * Returns the current Flash/RTMP connection helper if established.
     * Used in SharedObject communication.
     *
     * @return {PublisherSourceHandler}
     *
     * @private
     */
  }, {
    key: "getConnection",
    value: function getConnection() {
      return this._sourceHandler;
    }

    /**
     * Returns the initialization configuration used in `init()`.
     *
     * @return {Object}
     */
  }, {
    key: "getOptions",
    value: function getOptions() {
      return this._options;
    }

    /**
     * Returns the type of implementation: `RTMP`.
     *
     * @return {String}
     */
  }, {
    key: "getType",
    value: function getType() {
      return PublishTypes.RTMP.toUpperCase();
    }
  }]);
  return RTMPPublisher;
}(event_emitter);
/* harmony default export */ var publisher_red5pro_rtmp = (red5pro_rtmp_RTMPPublisher);
// CONCATENATED MODULE: ./src/js/helper/socket-helper-pub.js


function socket_helper_pub_typeof(obj) { "@babel/helpers - typeof"; return socket_helper_pub_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, socket_helper_pub_typeof(obj); }
function socket_helper_pub_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function socket_helper_pub_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, socket_helper_pub_toPropertyKey(descriptor.key), descriptor); } }
function socket_helper_pub_createClass(Constructor, protoProps, staticProps) { if (protoProps) socket_helper_pub_defineProperties(Constructor.prototype, protoProps); if (staticProps) socket_helper_pub_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function socket_helper_pub_toPropertyKey(arg) { var key = socket_helper_pub_toPrimitive(arg, "string"); return socket_helper_pub_typeof(key) === "symbol" ? key : String(key); }
function socket_helper_pub_toPrimitive(input, hint) { if (socket_helper_pub_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (socket_helper_pub_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function socket_helper_pub_get() { if (typeof Reflect !== "undefined" && Reflect.get) { socket_helper_pub_get = Reflect.get.bind(); } else { socket_helper_pub_get = function _get(target, property, receiver) { var base = socket_helper_pub_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return socket_helper_pub_get.apply(this, arguments); }
function socket_helper_pub_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = socket_helper_pub_getPrototypeOf(object); if (object === null) break; } return object; }
function socket_helper_pub_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) socket_helper_pub_setPrototypeOf(subClass, superClass); }
function socket_helper_pub_setPrototypeOf(o, p) { socket_helper_pub_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return socket_helper_pub_setPrototypeOf(o, p); }
function socket_helper_pub_createSuper(Derived) { var hasNativeReflectConstruct = socket_helper_pub_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = socket_helper_pub_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = socket_helper_pub_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return socket_helper_pub_possibleConstructorReturn(this, result); }; }
function socket_helper_pub_possibleConstructorReturn(self, call) { if (call && (socket_helper_pub_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return socket_helper_pub_assertThisInitialized(self); }
function socket_helper_pub_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function socket_helper_pub_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function socket_helper_pub_getPrototypeOf(o) { socket_helper_pub_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return socket_helper_pub_getPrototypeOf(o); }



var socket_helper_pub_NAME = 'R5ProPublisherSocket';

/**
 * Publisher-based extension of `SocketHelper`.
 *
 * @extends {SocketHelper}
 *
 * @private
 */
var socket_helper_pub_PublisherSocketHelper = /*#__PURE__*/function (_SocketHelper) {
  socket_helper_pub_inherits(PublisherSocketHelper, _SocketHelper);
  var _super = socket_helper_pub_createSuper(PublisherSocketHelper);
  function PublisherSocketHelper(responder) {
    socket_helper_pub_classCallCheck(this, PublisherSocketHelper);
    return _super.call(this, responder, socket_helper_pub_NAME);
  }

  /**
   * Override to respond to messages coming over WebSocket.
   */
  socket_helper_pub_createClass(PublisherSocketHelper, [{
    key: "respond",
    value: function respond(message) {
      if (message.data) {
        var json = this.getJsonFromSocketMessage(message);
        if (!socket_helper_pub_get(socket_helper_pub_getPrototypeOf(PublisherSocketHelper.prototype), "respond", this).call(this, message)) {
          if (json.data !== undefined) {
            if (json.data.sdp !== undefined) {
              if (json.data.sdp.type === 'answer') {
                this._responder.onSDPAnswer(json.data);
                return true;
              }
            }
            if (json.data.candidate !== undefined) {
              if (isObjectEmpty(json.data.candidate)) {
                this._responder.onEmptyCandidate();
                return true;
              } else {
                this._responder.onAddIceCandidate(json.data.candidate);
                return true;
              }
            }
            if (json.data.type === 'status') {
              if (json.data.code === 'NetConnection.ICE.TricleCompleted' || json.data.code === 'NetConnection.ICE.TrickleCompleted') {
                this._responder.onSocketIceCandidateEnd();
              } else if (json.data.code === 'NetConnection.Publish.InsufficientBW') {
                this._responder.onInsufficientBandwidth(json.data);
              } else if (json.data.code === 'NetConnection.Publish.SufficientBW') {
                this._responder.onSufficientBandwidth(json.data);
              } else if (json.data.code === 'NetConnection.Publish.RecoveringBW') {
                this._responder.onRecoveringBandwidth(json.data);
              } else {
                this._responder.onPublisherStatus(json.data);
                return true;
              }
            }
            if (json.type !== undefined && json.type.toLowerCase() === 'metadata') {
              // It is a `send` API invocation.
              if (json.method !== undefined) {
                this._responder.onSendReceived(json.method, json.data);
                return true;
              } else {
                this._responder.onMetaData(json.data);
                return true;
              }
            }
          }
          this._responder.onSocketMessage(this, message);
        }
      } else {
        log_warn(socket_helper_pub_NAME, '[ws.onmessage] - No Message Data.');
      }
    }

    /**
     * Posts an unpublish request.
     *
     * @param {String}
     *        The stream name to unpublish.
     */
  }, {
    key: "postUnpublish",
    value: function postUnpublish(streamName) {
      if (this._websocket === undefined || this._openState !== 1) {
        return false;
      }
      this.post({
        unpublish: streamName
      });
      return true;
    }

    /**
     * Request to leave group from conference participant.
     *
     * @param {String} group
     *        The group name to leave.
     */
  }, {
    key: "postUnjoin",
    value: function postUnjoin(group, streamName) {
      if (this._websocket === undefined || this._openState !== 1) {
        return false;
      }
      log_debug(socket_helper_pub_NAME, "[peerconnection:leavegroup]");
      return this.post({
        leaveGroup: group,
        streamName: streamName
      });
    }
  }]);
  return PublisherSocketHelper;
}(socket_helper);
/* harmony default export */ var socket_helper_pub = (socket_helper_pub_PublisherSocketHelper);
// CONCATENATED MODULE: ./src/js/helper/webrtc-helper-pub.js


function webrtc_helper_pub_typeof(obj) { "@babel/helpers - typeof"; return webrtc_helper_pub_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, webrtc_helper_pub_typeof(obj); }
function webrtc_helper_pub_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ webrtc_helper_pub_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == webrtc_helper_pub_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function webrtc_helper_pub_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function webrtc_helper_pub_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { webrtc_helper_pub_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { webrtc_helper_pub_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function webrtc_helper_pub_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function webrtc_helper_pub_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, webrtc_helper_pub_toPropertyKey(descriptor.key), descriptor); } }
function webrtc_helper_pub_createClass(Constructor, protoProps, staticProps) { if (protoProps) webrtc_helper_pub_defineProperties(Constructor.prototype, protoProps); if (staticProps) webrtc_helper_pub_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function webrtc_helper_pub_toPropertyKey(arg) { var key = webrtc_helper_pub_toPrimitive(arg, "string"); return webrtc_helper_pub_typeof(key) === "symbol" ? key : String(key); }
function webrtc_helper_pub_toPrimitive(input, hint) { if (webrtc_helper_pub_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (webrtc_helper_pub_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function webrtc_helper_pub_get() { if (typeof Reflect !== "undefined" && Reflect.get) { webrtc_helper_pub_get = Reflect.get.bind(); } else { webrtc_helper_pub_get = function _get(target, property, receiver) { var base = webrtc_helper_pub_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return webrtc_helper_pub_get.apply(this, arguments); }
function webrtc_helper_pub_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = webrtc_helper_pub_getPrototypeOf(object); if (object === null) break; } return object; }
function webrtc_helper_pub_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) webrtc_helper_pub_setPrototypeOf(subClass, superClass); }
function webrtc_helper_pub_setPrototypeOf(o, p) { webrtc_helper_pub_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return webrtc_helper_pub_setPrototypeOf(o, p); }
function webrtc_helper_pub_createSuper(Derived) { var hasNativeReflectConstruct = webrtc_helper_pub_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = webrtc_helper_pub_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = webrtc_helper_pub_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return webrtc_helper_pub_possibleConstructorReturn(this, result); }; }
function webrtc_helper_pub_possibleConstructorReturn(self, call) { if (call && (webrtc_helper_pub_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return webrtc_helper_pub_assertThisInitialized(self); }
function webrtc_helper_pub_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function webrtc_helper_pub_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function webrtc_helper_pub_getPrototypeOf(o) { webrtc_helper_pub_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return webrtc_helper_pub_getPrototypeOf(o); }





var webrtc_helper_pub_NAME = 'R5ProPublishPeer';

/**
 * Proxy to Peer Connection for Publishers.
 *
 * @private
 */
var webrtc_helper_pub_PublisherPeerHelper = /*#__PURE__*/function (_WebRTCPeerHelper) {
  webrtc_helper_pub_inherits(PublisherPeerHelper, _WebRTCPeerHelper);
  var _super = webrtc_helper_pub_createSuper(PublisherPeerHelper);
  function PublisherPeerHelper(responder) {
    webrtc_helper_pub_classCallCheck(this, PublisherPeerHelper);
    return _super.call(this, responder, webrtc_helper_pub_NAME);
  }

  /**
   * Removes handlers assigned to the peer connection instance.
   *
   * @param {RTCPeerConnection} connection
   *
   * @private
   */
  webrtc_helper_pub_createClass(PublisherPeerHelper, [{
    key: "_removeConnectionHandlers",
    value: function _removeConnectionHandlers(connection) {
      connection.onconnectionstatechange = undefined;
      connection.oniceconnectionstatechange = undefined;
      connection.onicecandidate = undefined;
      connection.ontrack = undefined;
    }

    /**
     * Assigns handlers to events on the peer connection instance.
     *
     * @param {RTCPeerConnection} connection
     * @param {Promise} promise
     *        The `Promise` to resolve or reject on success of connection.
     */
  }, {
    key: "_addConnectionHandlers",
    value: function _addConnectionHandlers(connection, promise) {
      var _this = this;
      var reconnectTimeout;
      var timeoutLimit = 5000;
      connection.ontrack = function (event) {
        log_debug(webrtc_helper_pub_NAME, "[peer:ontrack]");
        console.log(event);
        _this._responder.onPeerConnectionTrackAdd(event.track);
      };
      connection.onconnectionstatechange = function () {
        log_debug(webrtc_helper_pub_NAME, "[peer.onconnectionstatechange] - State: ".concat(connection.connectionState));
        if (connection.connectionState === 'connected') {
          log_debug(webrtc_helper_pub_NAME, '[peerconnection:open]');
          if (promise) {
            promise.resolve(_this);
          } else {
            _this._responder.onPeerConnectionOpen();
          }
        } else if (connection.connectionState === 'failed' || connection.connectionState === 'disconnected') {
          log_warn(webrtc_helper_pub_NAME, '[peerconnection:error]');
          if (promise) {
            promise.reject();
          }
          if (connection.connectionState === 'failed') {
            _this._responder.onPeerConnectionFail();
          }
        }
      };
      connection.onicecandidate = function (event) {
        log_debug(webrtc_helper_pub_NAME, "[peer.onicecandidate] - Peer Candidate: ".concat(event.candidate));
        if (event.candidate) {
          _this._responder.onIceCandidate(event.candidate);
        } else if (event.candidate === null) {
          // null means they have finished sending candidates back and forth?
          // this._responder.onIceCandidateTrickleEnd()
        }
      };
      connection.oniceconnectionstatechange = function (event) {
        var state = connection.iceConnectionState;
        log_debug(webrtc_helper_pub_NAME, "[peer.oniceconnectionstatechange] - State: ".concat(state));
        if (state === 'connected' && browser.getIsEdge()) {
          // Support for ORTC order of candidates.
          // Typically this will be invoked from a `onicegatheringstatechange` event on the Connection.
          // Edge doesn't notify on that event.
          log_debug(webrtc_helper_pub_NAME, '[edge/ortc:notify complete]');
          _this._responder.onPeerGatheringComplete();
        } else if (state === 'failed') {
          if (reconnectTimeout) {
            clearTimeout(reconnectTimeout);
          }
          _this._responder.onPeerConnectionClose(event);
        } else if (state === 'disconnected') {
          // may receive a disconnect temporarily that will then return to a connection.
          reconnectTimeout = setTimeout(function () {
            log_debug(webrtc_helper_pub_NAME, "[peer.oniceconnectionstatechange] - Reconnect timeout reached. Closing PeerConnection.");
            clearTimeout(reconnectTimeout);
            _this._responder.onPeerConnectionClose(event);
          }, timeoutLimit);
        } else {
          if (reconnectTimeout) {
            log_debug(webrtc_helper_pub_NAME, "[peer.oniceconnectionstatechange] - Clearing timeout for reconnect.");
            clearTimeout(reconnectTimeout);
          }
        }
      };
      connection.onsignalingstatechange = function (event) {
        // eslint-disable-line no-unused-vars
        var state = connection.signalingState;
        log_debug(webrtc_helper_pub_NAME, "[peer.onsignalingstatechange] - State: ".concat(state));
      };
      connection.onicegatheringstatechange = function () {
        var state = connection.iceGatheringState;
        log_debug(webrtc_helper_pub_NAME, "[peer.onicegatheringstatechange] - State: ".concat(state));
        if (state === 'complete') {
          _this._responder.onPeerGatheringComplete();
        }
      };
      connection.onremovestream = function () {
        log_debug(webrtc_helper_pub_NAME, "[peer.onremovestream]");
      };
    }

    /**
     * Message event listener on RTCDataChannel
     *
     * @param {Event} event
     *
     * @private
     */
  }, {
    key: "_onDataChannelMessage",
    value: function _onDataChannelMessage(event) {
      var message = event;
      if (webrtc_helper_pub_get(webrtc_helper_pub_getPrototypeOf(PublisherPeerHelper.prototype), "_onDataChannelMessage", this).call(this, event)) {
        return true;
      }
      var json = this.getJsonFromSocketMessage(message);
      if (json === null) {
        log_warn(this._name, 'Determined websocket response not in correct format. Aborting message handle.');
        return true;
      }
      log_debug(this._name, '[datachannel-response]: ' + JSON.stringify(json, null, 2));
      var data = json.data;
      if (data && data.type === 'status') {
        if (data.code === 'NetStream.Play.UnpublishNotify') {
          this._responder.onUnpublish();
          return true;
        }
        log_debug(webrtc_helper_pub_NAME, "[datachannel.message] status :: ".concat(data.code));
        this._responder.onPublisherStatus(data);
        return true;
      }
      this._responder.onDataChannelMessage(this._dataChannel, message);
      return false;
    }

    /**
     * Request to `getUserMedia` on browser.
     *
     * @param {Object} contraints
     *        The `MediaConstraints` object.
     * @param {Function} rejectionCB
     *        Callback for rejections on getUserMedia as the SDK determines possible nearest neighbor.
     * @return {Promise}
     */
  }, {
    key: "getUserMedia",
    value: function getUserMedia(constraints, rejectionCB) {
      return webrtc_getUserMedia(constraints, rejectionCB);
    }

    /**
     * Request to force `getUserMedia` request using the provided constraints.
     *
     * @param {Object} constraints
     *        The `MediaConstraints` to force in request on `getUserMedia`.
     * @return {Promise}
     */
  }, {
    key: "forceUserMedia",
    value: function forceUserMedia(constraints) {
      return webrtc_forceUserMedia(constraints);
    }

    /**
     * Request to create an Offer through the Peer Connection.
     *
     * @param {Object} bandwidth
     *        The optional bandwidth configuration to use in munging SDP before sending offer.
     * @param {Boolean} forceVP8
     *        The optional flag to force VP8 encoding.
     * @param {Boolean} forceSDPStripe
     *        The optional flag to force stripping of SDP in order to keep under char limit in Message. Used by ConferenceParticipant.
     * @param {Promise} promise
     *        The `Promise` to resolve or reject on success of sending offer on Peer Connection.
     * @return {Promise}
     */
  }, {
    key: "createOffer",
    value: function createOffer() {
      var _this2 = this;
      var bandwidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var forceVP8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var forceSDPStrip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var offerPromise = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      log_debug(webrtc_helper_pub_NAME, '[createoffer]');
      var p = offerPromise || new DeferredPromise();
      this._peerConnection.createOffer().then(function (sessionDescription) {
        _this2.setLocalDescription(sessionDescription, bandwidth).then(function () {
          var sdp = sessionDescription.sdp;
          if (bandwidth) {
            sdp = updateBandwidth(bandwidth, sdp);
          }
          // Strips SDP to just use Opus & H264. Cuts SDP size down.
          if (forceSDPStrip) {
            sdp = stripRTPMaps(sdp);
            sdp = stripNonH264FromVideo(sdp);
            sdp = flipRecvOnlyOnExtraAudio(sdp);
            sdp = flipRecvOnlyOnExtraVideo(sdp);
          }
          if (forceVP8) {
            sdp = sdp.replaceAll('H264', 'H265');
            log_debug(webrtc_helper_pub_NAME, '[createoffer] FORCING VP8');
          }
          sessionDescription.sdp = sdp;
          _this2._responder.onSDPSuccess();
          p.resolve(sessionDescription);
        }).catch(function (err) {
          _this2._responder.onSDPError(err);
          p.reject(err);
        });
      }).catch(function (err) {
        log_debug(webrtc_helper_pub_NAME, '[createoffer:error]');
        p.reject(err);
      });
      return p.hasOwnProperty('promise') ? p.promise : p;
    }

    /**
     * Request to create an Offer through the Peer Connection without immediately setting as local description.
     *
     * @param {Object} bandwidth
     *        The optional bandwidth configuration to use in munging SDP before sending offer.
     * @param {Boolean} forceVP8
     *        The optional flag to force VP8 encoding.
     * @param {Boolean} forceSDPStripe
     *        The optional flag to force stripping of SDP in order to keep under char limit in Message. Used by ConferenceParticipant.
     * @return {Promise}
     */
  }, {
    key: "createOfferWithoutSetLocal",
    value: function () {
      var _createOfferWithoutSetLocal = webrtc_helper_pub_asyncToGenerator(function () {
        var _this3 = this;
        var bandwidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var forceVP8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var forceSDPStrip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        return /*#__PURE__*/webrtc_helper_pub_regeneratorRuntime().mark(function _callee() {
          var sessionDescription, sdp;
          return webrtc_helper_pub_regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                log_debug(webrtc_helper_pub_NAME, '[createoffer:withoutlocal]');
                _context.prev = 1;
                _context.next = 4;
                return _this3._peerConnection.createOffer();
              case 4:
                sessionDescription = _context.sent;
                sdp = sessionDescription.sdp;
                if (bandwidth) {
                  sdp = updateBandwidth(bandwidth, sdp);
                }
                // Strips SDP to just use Opus & H264. Cuts SDP size down.
                if (forceSDPStrip) {
                  sdp = stripRTPMaps(sdp);
                  sdp = stripNonH264FromVideo(sdp);
                  sdp = flipRecvOnlyOnExtraAudio(sdp);
                  sdp = flipRecvOnlyOnExtraVideo(sdp);
                }
                if (forceVP8) {
                  sdp = sdp.replaceAll('H264', 'H265');
                  log_debug(webrtc_helper_pub_NAME, '[createoffer] FORCING VP8');
                }
                sessionDescription.sdp = sdp;
                _this3._responder.onSDPSuccess();
                return _context.abrupt("return", sessionDescription);
              case 14:
                _context.prev = 14;
                _context.t0 = _context["catch"](1);
                log_debug(webrtc_helper_pub_NAME, '[createoffer:error]');
                _this3._responder.onSDPError(_context.t0);
                throw _context.t0;
              case 19:
              case "end":
                return _context.stop();
            }
          }, _callee, null, [[1, 14]]);
        })();
      });
      function createOfferWithoutSetLocal() {
        return _createOfferWithoutSetLocal.apply(this, arguments);
      }
      return createOfferWithoutSetLocal;
    }()
    /**
     * Posts an unpublish request.
     *
     * @param {String}
     *        The stream name to unpublish.
     */
  }, {
    key: "postUnpublish",
    value: function postUnpublish(streamName) {
      // else
      var complete = this.post({
        unpublish: streamName
      });
      log_debug(webrtc_helper_pub_NAME, "[peerconnection:unpublish] complete: ".concat(complete));
      return complete;
    }

    /**
     * Request to leave group from conference participant.
     *
     * @param {String} group
     *        The group name to leave.
     */
  }, {
    key: "postUnjoin",
    value: function postUnjoin(group, streamName) {
      log_debug(webrtc_helper_pub_NAME, "[peerconnection:leavegroup]");
      return this.post({
        leaveGroup: group,
        streamName: streamName
      });
    }
  }]);
  return PublisherPeerHelper;
}(webrtc_helper);
/* harmony default export */ var webrtc_helper_pub = (webrtc_helper_pub_PublisherPeerHelper);
// CONCATENATED MODULE: ./src/js/publisher/red5pro-rtc.js


function publisher_red5pro_rtc_typeof(obj) { "@babel/helpers - typeof"; return publisher_red5pro_rtc_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, publisher_red5pro_rtc_typeof(obj); }
function publisher_red5pro_rtc_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function publisher_red5pro_rtc_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, publisher_red5pro_rtc_toPropertyKey(descriptor.key), descriptor); } }
function publisher_red5pro_rtc_createClass(Constructor, protoProps, staticProps) { if (protoProps) publisher_red5pro_rtc_defineProperties(Constructor.prototype, protoProps); if (staticProps) publisher_red5pro_rtc_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function publisher_red5pro_rtc_toPropertyKey(arg) { var key = publisher_red5pro_rtc_toPrimitive(arg, "string"); return publisher_red5pro_rtc_typeof(key) === "symbol" ? key : String(key); }
function publisher_red5pro_rtc_toPrimitive(input, hint) { if (publisher_red5pro_rtc_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (publisher_red5pro_rtc_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function publisher_red5pro_rtc_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) publisher_red5pro_rtc_setPrototypeOf(subClass, superClass); }
function publisher_red5pro_rtc_setPrototypeOf(o, p) { publisher_red5pro_rtc_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return publisher_red5pro_rtc_setPrototypeOf(o, p); }
function publisher_red5pro_rtc_createSuper(Derived) { var hasNativeReflectConstruct = publisher_red5pro_rtc_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = publisher_red5pro_rtc_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = publisher_red5pro_rtc_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return publisher_red5pro_rtc_possibleConstructorReturn(this, result); }; }
function publisher_red5pro_rtc_possibleConstructorReturn(self, call) { if (call && (publisher_red5pro_rtc_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return publisher_red5pro_rtc_assertThisInitialized(self); }
function publisher_red5pro_rtc_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function publisher_red5pro_rtc_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function publisher_red5pro_rtc_getPrototypeOf(o) { publisher_red5pro_rtc_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return publisher_red5pro_rtc_getPrototypeOf(o); }




















var pubStartRegex = /(.*) starting/i;
var pubStopRegex = /(.*) stopping/i;
var publisher_red5pro_rtc_NAME = 'RTCPublisher';
var red5pro_rtc_debug = function debug(message) {
  log_debug(publisher_red5pro_rtc_NAME, message);
};
var red5pro_rtc_warn = function warn(message) {
  log_warn(publisher_red5pro_rtc_NAME, message);
};
var red5pro_rtc_error = function error(message) {
  log_error(publisher_red5pro_rtc_NAME, message);
};

// Default to secure settings.
var red5pro_rtc_defaultOptions = {
  protocol: 'wss',
  port: 443,
  app: 'live',
  streamMode: PublishModeTypes.LIVE,
  keyFramerate: 3000,
  mediaElementId: 'red5pro-publisher',
  rtcConfiguration: {
    iceServers: [{
      urls: 'stun:stun2.l.google.com:19302'
    }],
    iceCandidatePoolSize: 2,
    bundlePolicy: 'max-bundle'
  },
  // Favored over iceServers.
  iceServers: undefined,
  // Deprecated. Preserved for backward-compatibility.
  iceTransport: IceTransportTypes.UDP,
  bandwidth: {
    audio: 56,
    video: 512
  },
  clearMediaOnUnpublish: false,
  mediaConstraints: new RTCMediaConstraint(),
  onGetUserMedia: undefined,
  signalingSocketOnly: true,
  dataChannelConfiguration: undefined,
  forceVP8: false,
  socketSwitchDelay: 1000,
  bypassAvailable: false
};
var getConstraintsFromMediaStream = function getConstraintsFromMediaStream(stream) {
  var constraints = {
    audio: false,
    video: false
  };
  var settings = {
    audio: false,
    video: false
  };
  stream.getTracks().forEach(function (track) {
    if (track.kind === 'video') {
      settings.video = track.getSettings();
      constraints.video = track.getConstraints();
    } else if (track.kind === 'audio') {
      settings.audio = track.getSettings();
      constraints.audio = track.getConstraints();
    }
  });
  return {
    requested: constraints,
    accepted: settings
  };
};

/**
 * Main entry for WebRTC-based Publisher.
 *
 * @extends EventEmitter
 */
var red5pro_rtc_RTCPublisher = /*#__PURE__*/function (_EventEmitter) {
  publisher_red5pro_rtc_inherits(RTCPublisher, _EventEmitter);
  var _super = publisher_red5pro_rtc_createSuper(RTCPublisher);
  function RTCPublisher() {
    var _this;
    publisher_red5pro_rtc_classCallCheck(this, RTCPublisher);
    _this = _super.call(this);
    _this._options = undefined;
    _this._view = undefined;
    _this._peerHelper = undefined;
    _this._socketHelper = undefined;
    _this._messageTransport = undefined;
    _this._mediaStream = undefined;
    _this._switchChannelRequest = undefined;
    _this._streamFuture = undefined;
    _this._availableFuture = undefined;
    _this._peerFuture = undefined;
    _this._offerFuture = undefined;
    _this._sendOfferFuture = undefined;
    _this._trickleEndFuture = undefined;
    _this._publishFuture = undefined;
    _this._unpublishFuture = undefined;
    _this._onOrientationChange = _this._onOrientationChange.bind(publisher_red5pro_rtc_assertThisInitialized(_this));
    _this._gUMRejectionHandler = _this._onGUMRejection.bind(publisher_red5pro_rtc_assertThisInitialized(_this));
    return _this;
  }
  publisher_red5pro_rtc_createClass(RTCPublisher, [{
    key: "_getMediaStream",
    value: function _getMediaStream() {
      this._streamFuture = Future.createIfNotExist(this._streamFuture);
      return this._streamFuture.promise;
    }
  }, {
    key: "_getTrickleEnd",
    value: function _getTrickleEnd() {
      return Future.createIfNotExist(this._trickleEndFuture);
    }

    /**
     * Runs internal `getUserMedia` logic to determine broadcast constraints.
     *
     * @param {Object} options
     *        The initialization options provided in `init()`.
     *
     * @private
     */
  }, {
    key: "_gum",
    value: function _gum(options) {
      var _this2 = this;
      // Safari issue in which, if the MediaStream track listing starts with `video`, broadcasting will fail.
      var _isMediaStreamTrackListingMunged = function _isMediaStreamTrackListingMunged(mediaStream) {
        if (!mediaStream) return false;
        var tracks = mediaStream.getTracks();
        // Ensure that there are 2 tracks (one video and one audio), otherwise, it is OK to broadcast video only.
        if (tracks && tracks.length > 1) {
          return tracks[0].kind === 'video';
        }
        return false;
      };
      if (options.onGetUserMedia !== undefined) {
        red5pro_rtc_debug('Requesting gUM from user-defined configuration:onGetUserMedia.');
        options.onGetUserMedia().then(function (media) {
          if (_isMediaStreamTrackListingMunged(media)) {
            red5pro_rtc_debug('We received a MediaStream with mismatching track listing. Trying again...');
            _this2._gum(options);
            return;
          }
          _this2.trigger(new PublisherEvent(RTCPublisherEventTypes.CONSTRAINTS_ACCEPTED, _this2, getConstraintsFromMediaStream(media)));
          _this2._streamFuture.resolve(media);
        }).catch(function (err) {
          red5pro_rtc_error("Could not resolve MediaStream from provided gUM. Error - ".concat(err));
          _this2.trigger(new PublisherEvent(RTCPublisherEventTypes.CONSTRAINTS_REJECTED, _this2, {
            constraints: options.mediaConstraints
          }));
          _this2._streamFuture.reject(err);
        });
      } else {
        red5pro_rtc_debug("Requesting gUM using mediaConstraints: ".concat(JSON.stringify(options.mediaConstraints, null, 2)));
        this._peerHelper.getUserMedia(options.mediaConstraints, this._gUMRejectionHandler).then(function (res) {
          if (_isMediaStreamTrackListingMunged(res.media)) {
            red5pro_rtc_debug('We received a MediaStream with mismatching track listing. Trying again...');
            _this2._gum(options);
            return;
          }
          red5pro_rtc_debug("Found valid constraints: ".concat(JSON.stringify(res.constraints, null, 2)));
          _this2.trigger(new PublisherEvent(RTCPublisherEventTypes.CONSTRAINTS_ACCEPTED, _this2, getConstraintsFromMediaStream(res.media)));
          _this2.trigger(new PublisherEvent(PublisherEventTypes.DIMENSION_CHANGE, _this2, res.constraints));
          _this2._streamFuture.resolve(res.media);
        }).catch(function (rej) {
          red5pro_rtc_debug("Could not find valid constraint resolutions from: ".concat(JSON.stringify(rej.constraints, null, 2)));
          red5pro_rtc_error("Could not resolve MediaStream from provided mediaConstraints. Error - ".concat(rej.error));
          red5pro_rtc_debug("Attempting to find resolutions from original provided constraints: ".concat(JSON.stringify(rej.constraints, null, 2)));
          _this2.trigger(new PublisherEvent(RTCPublisherEventTypes.CONSTRAINTS_REJECTED, _this2, {
            constraints: rej.constraints
          }));
          // allowing to try original constraint requested.
          options.onGetUserMedia = function () {
            return _this2._peerHelper.forceUserMedia(rej.constraints);
          };
          _this2._gum(options);
        });
      }
    }

    /**
     * Callback for rejection on constraints from RTC Peer Helper and getUserMedia requests.
     *
     * @param {MediaConstraints} rejectedConstraints
     *        The MediaConstraints that were rejected from the `getUserMedia` call.
     *
     * @private
     */
  }, {
    key: "_onGUMRejection",
    value: function _onGUMRejection(rejectedConstraints) {
      this.trigger(new PublisherEvent(RTCPublisherEventTypes.CONSTRAINTS_REJECTED, this, {
        constraints: rejectedConstraints
      }));
    }

    /**
     * Invoked upon `onorientationchange` of the browser. Mobile browsers only.
     *
     * @param {int} orientation
     *        The orientation value of the device browser.
     *
     * @private
     */
  }, {
    key: "_onOrientationChange",
    value: function _onOrientationChange(orientation) {
      if (this.getMessageTransport()) {
        this.getMessageTransport().post({
          send: {
            method: 'onMetaData',
            data: {
              deviceOrientation: orientation
            }
          }
        });
      }
    }

    /**
     * Invoked upon receipt from `_gum` with MediaStream instance returned from browser.
     *
     * @param {MediaStream} mediaStream
     *        The `MediaStream` object.
     *
     * @private
     */
  }, {
    key: "_onMediaStreamReceived",
    value: function _onMediaStreamReceived(mediaStream) {
      this._mediaStream = mediaStream;
      this.trigger(new PublisherEvent(RTCPublisherEventTypes.MEDIA_STREAM_AVAILABLE, this, mediaStream));
      if (this._view) {
        this._view.preview(this._mediaStream);
      }
    }

    /**
     * Still in use, but hold-over of previous 3.x SDK versions designed to pair views and publishers. In 4.0.0 it has been internalized.
     * API deprecated.
     *
     * @private
     */
  }, {
    key: "_setViewIfNotExist",
    value: function _setViewIfNotExist(currentView) {
      var mediaElementId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      if (typeof currentView === 'undefined' && mediaElementId !== undefined) {
        var view = new view_publish(mediaElementId);
        view.attachPublisher(this);
      }
    }

    /**
     * Request availability based on unique `streamName`.
     * The return from the WebSocket request will either invoke `onStreamAvailable` or `onStreamUnavailable`.
     *
     * @param {String} streamName
     *        The unique stream name to check if it is _unavailable_ - meaning free to publish against.
     * @return {Promise}
     *        The promise will resolve/reject the `_availableFuture`.
     *
     * @private
     */
  }, {
    key: "_requestAvailability",
    value: function _requestAvailability(streamName) {
      red5pro_rtc_debug('[requestavailability]');
      //this._availableFuture = undefined
      this._availableFuture = Future.createIfNotExist(this._availableFuture);
      if (this._options.bypassAvailable) {
        this._availableFuture.resolve(true);
      } else {
        this._socketHelper.post({
          isAvailable: streamName,
          bundle: true
        });
      }
      return this._availableFuture.promise;
    }

    /**
     * Request to setup RTCPeerConnection instance for exchange of SDP locally and remotely.
     *
     * @param {RTCConfiguration} rtcConfiguration
     *        A custom RTCConfiguration
     * @param {Object} dataChannelConfiguration
     *        Optional configuration for data channel communicaton.
     * @param {Array} iceServers
     *        List of ICE servers
     * @return {Promise}
     *        The promise will resolve/reject the `_peerFuture`.
     *
     * @note For backward compatibility, keeping arguments as optional, with at least one being fulfilled. The `configuration` param will be favored after 5.4.0, `iceServers` is up for deprecation.
     *
     * @private
     */
  }, {
    key: "_createPeerConnection",
    value: function _createPeerConnection(configuration) {
      var dataChannelConfiguration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var iceServers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      red5pro_rtc_debug('[createpeeer]');
      this._peerFuture = undefined;
      this._peerFuture = Future.createIfNotExist(this._peerFuture);
      if (iceServers && configuration) {
        red5pro_rtc_warn('The iceServers configuration property is considered deprecated. Please use the rtcConfiguration configuration property upon which you can assign iceServers. Reference: https://www.red5pro.com/docs/streaming/migrationguide.html');
        configuration.iceServers = iceServers;
      }
      var p;
      if (configuration !== undefined) {
        p = this._peerHelper.setUpWithPeerConfiguration(configuration, dataChannelConfiguration, this._peerFuture);
      } else {
        p = this._peerHelper.setUp(iceServers, this._peerFuture, this._options.rtcpMuxPolicy);
      }
      return p;
    }

    /**
     * Request to generate offer on Peer Connection instance.
     *
     * @param {Object} bandwidth
     *        Optional bandwidth configuration object to munge SDP.
     * @return {Promise}
     *        The promise will resolve/reject a success in creation of the offer through the Peer Connection.
     *
     * @private
     */
  }, {
    key: "_createOffer",
    value: function _createOffer() {
      var bandwidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var forceVP8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      red5pro_rtc_debug('[createoffer]');
      this._offerFuture = undefined;
      this._offerFuture = Future.createIfNotExist(this._offerFuture);
      this._peerHelper.createOffer(bandwidth, forceVP8, false, this._offerFuture);
      return this._offerFuture.promise;
    }

    /**
     * Request to set a remote description on Peer Connection instance.
     *
     * @param {Object} sdp
     *        Object describing the Session Description.
     * @return {Promise}
     *        The promise will resolve/reject in a success in setting the remote SDP on the Peer Connection.
     *
     * @private
     */
  }, {
    key: "_setRemoteDescription",
    value: function _setRemoteDescription(sdp) {
      red5pro_rtc_debug('[setremotedescription]');
      return this._peerHelper.setRemoteDescription(sdp);
    }

    /**
     * Request to send offer on WebSocket instance.
     *
     * @param {Object} sdp
     *        Object describing the Session Description.
     * @param {string} streamName
     *        The unique stream name of the broadcast.
     * @param {String} transport
     *        The transport type.
     * @return {Promise}
     *        The promise will resolve/reject on the success of delivering an offer over the WebSocket.
     *
     * @private
     */
  }, {
    key: "_sendOffer",
    value: function _sendOffer(sdp, streamName, transport) {
      red5pro_rtc_debug('[sendoffer]');
      this._sendOfferFuture = undefined;
      this._sendOfferFuture = Future.createIfNotExist(this._sendOffFuture);
      this._socketHelper.post({
        handleOffer: streamName,
        transport: transport,
        data: {
          sdp: sdp
        }
      });
      return this._sendOfferFuture.promise;
    }

    /**
     * Request to send ICE candidate over the WebSocket.
     * This can happen several times in the ICE negotiation process.
     *
     * @param {Object} candidate
     *        The Candidate to send.
     * @param {string} streamName
     *        The associated unique stream name of the broadcast.
     *
     * @private
     */
  }, {
    key: "_sendCandidate",
    value: function _sendCandidate(candidate, streamName) {
      red5pro_rtc_debug('[sendcandidate]');
      this._socketHelper.post({
        handleCandidate: streamName,
        data: {
          candidate: candidate
        }
      });
    }

    /**
     * Request on WebSocket to begin publishing.
     *
     * @param {string} streamName
     *        The unique stream name of the broadcast.
     * @param {string} mode
     *        The broadcast mode: `live`, `record` or `append`.
     * @param {int} framerate
     *        The key framerate to broadcast at.
     * @return {Promise}
     *        The promise will resolve/reject in the request to being a broadcast.
     *
     * @private
     */
  }, {
    key: "_requestPublish",
    value: function _requestPublish(streamName, streamMode, framerate) {
      red5pro_rtc_debug('[requestpublish]');
      this._publishFuture = undefined;
      this._publishFuture = Future.createIfNotExist(this._publishFuture);
      this._socketHelper.post({
        publish: streamName,
        mode: streamMode,
        keyFramerate: framerate
      });
      return this._publishFuture.promise;
    }

    /**
     * Request to stop a current broadcast.
     *
     * @param {String} streamName
     *        The unique stream name being broadcast on.
     * @return {Promise}
     *        The promise will resolve/reject on success of properly stopping a broadcast.
     *
     * @private
     */
  }, {
    key: "_requestUnpublish",
    value: function _requestUnpublish(streamName) {
      this._unpublishFuture = undefined;
      this._unpublishFuture = Future.createIfNotExist(this._unpublishFuture);
      // If we get a false response from trying to send a close POST,
      //  it means that the socket has already been closed by another impetus -
      //  most likley loss of network or server failure.
      if (!this.getMessageTransport().postUnpublish(streamName)) {
        this._unpublishFuture.resolve();
      }
      return this._unpublishFuture.promise;
    }

    /**
     * Request to initialize the WebRTC-based Publisher based on configuration.
     * The returned `Promise` will either resolve with a reference to this instance or reject with an error `String` in failure.
     *
     * @param {Object} options
     *        The initialization configuration map.
     * @return {Promise}
     */
  }, {
    key: "init",
    value: function init(options) {
      this._streamFuture = undefined;
      var deferred = new DeferredPromise();
      if (!webrtc_isSupported() || !websocket_isSupported()) {
        deferred.reject('Cannot create WebRTC playback instance. Your environment does not support WebRTC and/or WebSockets.');
      } else {
        this._options = Object.assign({}, red5pro_rtc_defaultOptions, options);
        this._peerHelper = new webrtc_helper_pub(this);
        this._socketHelper = new socket_helper_pub(this);
        this._messageTransport = this._messageTransport || this._socketHelper;
        this._getMediaStream().then(this._onMediaStreamReceived.bind(this)).catch(function (error) {
          red5pro_rtc_warn("[gum]: ".concat(error));
        });
        this._gum(this._options);
        // auto preview.
        this._setViewIfNotExist(this._view, this._options.mediaElementId);
        deferred.resolve(this);
      }
      return deferred.promise;
    }

    /**
     * Request to initialize the WebRTC-based Publisher based on configuration and previously established MediaStream.
     * USE WITH CAUTION. It is assumed you know what you are doing in accessing a MediaStream outside of the API available from the SDK.
     * The returned `Promise` will either resolve with a reference to this instance or reject with an error `String` in failure.
     *
     * @param {Object} options
     *        The initialization configuration map.
     * @param {MediaStream} mediaStream
     *        A previously established MediaStream, most likely receieved through getUserMedia() outside of SDK use.
     *
     * @return {Promise}
     */
  }, {
    key: "initWithStream",
    value: function initWithStream(options, mediaStream) {
      red5pro_rtc_debug('[initWithStream]');
      this._streamFuture = undefined;
      var deferred = new DeferredPromise();
      if (!webrtc_isSupported() || !websocket_isSupported()) {
        deferred.reject('Cannot create WebRTC playback instance. Your environment does not support WebRTC and/or WebSockets.');
      } else {
        this._options = Object.assign({}, red5pro_rtc_defaultOptions, options);
        this._peerHelper = new webrtc_helper_pub(this);
        this._socketHelper = new socket_helper_pub(this);
        this._messageTransport = this._messageTransport || this._socketHelper;
        // auto preview.
        this._setViewIfNotExist(this._view, this._options.mediaElementId);
        var mediaPromise = this._getMediaStream();
        mediaPromise.then(this._onMediaStreamReceived.bind(this)).catch(function (error) {
          red5pro_rtc_warn("[gum]: ".concat(error));
        });
        this._streamFuture.resolve(mediaStream);
        deferred.resolve(this);
      }
      return deferred.promise;
    }

    /**
     * Still in use for assigning document element view management to this instance.
     * API deprecated in 4.0.0.
     *
     * @private
     */
  }, {
    key: "setView",
    value: function setView(view) {
      this._view = view;
      if (this._mediaStream && this._view) {
        this._view.preview(this._mediaStream);
      }
      return this;
    }

    /**
     * Request to preview the generate MediaStream in the target view prior to publishing.
     * Automatically called when invoking `publish()`.
     *
     * @return {Promise}
     * @see #publish
     */
  }, {
    key: "preview",
    value: function preview() {
      var _this3 = this;
      red5pro_rtc_debug('[preview]');
      var p = new Promise(function (res) {
        res(_this3);
      });
      this._setViewIfNotExist(this._view, this._options.mediaElementId);
      return p;
    }

    /**
     * Clears the MediaStream from the target view and releases the camera from the browser.
     * If `clearMediaOnUnpublish` is set in the initialization configuration, this will be invoked internally when `unpublish` is called.
     *
     * @see #preview
     */
  }, {
    key: "unpreview",
    value: function unpreview() {
      red5pro_rtc_debug('[unpreview]');
      if (this._mediaStream) {
        this._mediaStream.getTracks().forEach(function (track) {
          track.stop();
        });
      }
      if (this._view) {
        this._view.unpreview();
      }
    }

    /**
     * Request to begin a broadcast session after initialization has occured.
     *
     * @param {String} streamName
     *        Optional stream name to broadcast on, otherwise defaulting to the `streamName` provided in `init()` configuration.
     * @param {Promise} promise
     *        Optional `Promise` object to resolve/reject on based on sequence of events in establishing a broadcast, otherwise defaulting to `Promise` created internally and returned.
     * @return {Promise}
     *        The returned `Promise` will resolve or reject on successful start of a broadcast.<br>
     *        There are several processes that occur in order to establish a WebRTC broadcast that involve - but are not limited to - ICE communication and assigning of local and remote SDPs on peer connections.
     */
  }, {
    key: "publish",
    value: function publish() {
      var _this4 = this;
      var streamName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      red5pro_rtc_debug('[publish]');
      this._options.streamName = streamName || this._options.streamName;
      var p = promise || new DeferredPromise();
      var socketPromise = new DeferredPromise();
      var socketurl = rtcSocketEndpointFromOptions(this._options, {
        id: this._options.streamName
      });
      this._trickleEndFuture = this._getTrickleEnd();
      if (!this._peerHelper) {
        this._peerHelper = new webrtc_helper_pub(this);
      }
      if (this._socketHelper) {
        this._socketHelper.clearRetry();
      } else {
        this._socketHelper = new socket_helper_pub(this);
        this._messageTransport = this._socketHelper;
      }
      this._socketHelper.setUp(socketurl, socketPromise);
      var _this$_options = this._options,
        rtcConfiguration = _this$_options.rtcConfiguration,
        signalingSocketOnly = _this$_options.signalingSocketOnly,
        dataChannelConfiguration = _this$_options.dataChannelConfiguration;
      // Set default data channel configuration if not defined and severing socket on signal end.
      // TODO: Set this as more "private" with `red5pro-<streamname>`
      var dataChannelAllowed = signalingSocketOnly && webrtc_supportsDataChannel();
      if (dataChannelAllowed && !dataChannelConfiguration) {
        dataChannelConfiguration = {
          name: "red5pro"
        };
      }
      this._options.signalingSocketOnly = dataChannelAllowed;

      // Moved this out in order to handle socket errors within any step of process.
      this._publishFuture = Future.createIfNotExist(this._publishFuture);
      this._publishFuture.promise.catch(function (error) {
        browser.removeOrientationChangeHandler(_this4._onOrientationChange);
        p.reject(error);
        _this4.trigger(new PublisherEvent(PublisherEventTypes.CONNECT_FAILURE, _this4, error));
      });

      // 0. Establish socket connection.
      socketPromise.promise
      // 1. Wait for stream attach
      .then(function () {
        _this4.trigger(new PublisherEvent(PublisherEventTypes.CONNECT_SUCCESS, _this4));
        return _this4._getMediaStream();
      })
      // 2. Request available stream to publish on
      .then(function () {
        return _this4._requestAvailability(_this4._options.streamName, _this4._options.streamType);
      })
      // 3. Create Peer Connection
      .then(function () {
        return _this4._createPeerConnection(rtcConfiguration, dataChannelConfiguration, _this4._options.iceServers);
      })
      // 4. Make Offer on Peer Connection
      .then(function (connection) {
        _this4.trigger(new PublisherEvent(RTCPublisherEventTypes.PEER_CONNECTION_AVAILABLE, _this4, connection));
        _this4._mediaStream.getTracks().forEach(function (track) {
          connection.addTrack(track, _this4._mediaStream);
        });
        // Deprecated.
        //        connection.addStream(this._mediaStream)
        return _this4._createOffer(_this4._options.bandwidth, _this4._options.forceVP8);
      })
      // 5. Send Offer
      .then(function (sessionDescription) {
        _this4.trigger(new PublisherEvent(RTCPublisherEventTypes.OFFER_START, _this4, sessionDescription));
        return _this4._sendOffer(sessionDescription, _this4._options.streamName, _this4._options.iceTransport);
      })
      // 6. Set the session description remotely
      .then(function (sdp) {
        return _this4._setRemoteDescription(sdp.sdp);
      })
      // 7. Wait until ice trickle end
      .then(function (sdp) {
        _this4.trigger(new PublisherEvent(RTCPublisherEventTypes.OFFER_END, _this4, sdp));
        return _this4._getTrickleEnd().promise;
      })
      // 8. Request to publish stream
      .then(function () {
        _this4.trigger(new PublisherEvent(RTCPublisherEventTypes.ICE_TRICKLE_COMPLETE, _this4));
        return _this4._requestPublish(_this4._options.streamName, _this4._options.streamMode, _this4._options.keyFramerate);
      })
      // 9. Results in socket message of publish (see :onPublishStatus)
      .then(function () {
        browser.addOrientationChangeHandler(_this4._onOrientationChange);
        p.resolve(_this4);
        _this4.trigger(new PublisherEvent(PublisherEventTypes.PUBLISH_START, _this4));
      }).catch(function (error) {
        browser.removeOrientationChangeHandler(_this4._onOrientationChange);
        p.reject(error);
        _this4.trigger(new PublisherEvent(PublisherEventTypes.CONNECT_FAILURE, _this4, error));
      });
      return p.hasOwnProperty('promise') ? p.promise : p;
    }

    /**
     * Request to begin a broadcast session after initialization has occured and with a previously established WebSocket instance.
     * USE WITH CAUTION. It is assumed you know what you are doing by providing a previously established WebSocket instance.
     *
     * @param {WebSocket} socket
     *        The previous established WebSocket to use in broadcast session signalling.
     * @param {String} streamName
     *        Optional stream name to broadcast on, otherwise defaulting to the `streamName` provided in `init()` configuration.
     * @param {Promise} promise
     *        Optional `Promise` object to resolve/reject on based on sequence of events in establishing a broadcast, otherwise defaulting to `Promise` created internally and returned.
     *
     * @return {Promise}
     *        The returned `Promise` will resolve or reject on successful start of a broadcast.<br>
     *        There are several processes that occur in order to establish a WebRTC broadcast that involve - but are not limited to - ICE communication and assigning of local and remote SDPs on peer connections.
     *
     * @private
     */
  }, {
    key: "publishWithSocket",
    value: function publishWithSocket(socket) {
      var _this5 = this;
      var streamName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var promise = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      red5pro_rtc_debug('[publishWithSocket]');
      this._options.streamName = streamName || this._options.streamName;
      var p = promise || new DeferredPromise();
      var socketPromise = new DeferredPromise();
      this._socketHelper = new socket_helper_pub(this);
      this._socketHelper.setUpWithSocket(socket, socketPromise);

      // 1. Establish a socket handler instance with previous WebSocket instance.
      socketPromise.promise
      // 2. Request to publish stream
      .then(function () {
        return _this5._requestPublish(_this5._options.streamName, _this5._options.streamMode, _this5._options.keyFramerate);
      })
      // 3. Results in socket message of publish (see :onPublishStatus)
      .then(function () {
        browser.addOrientationChangeHandler(_this5._onOrientationChange);
        p.resolve(_this5);
        _this5.trigger(new PublisherEvent(PublisherEventTypes.PUBLISH_START, _this5));
      }).catch(function (error) {
        browser.removeOrientationChangeHandler(_this5._onOrientationChange);
        p.reject(error);
        _this5.trigger(new PublisherEvent(PublisherEventTypes.CONNECT_FAILURE, _this5, error));
      });
      return p.hasOwnProperty('promise') ? p.promise : p;
    }

    /**
     * Request to stop a broadcast.
     * The returned `Promise` will either resolve or reject on successful stop of broadcast.
     *
     * @param {Boolean} andRemove
     *        Flag to additionally remove the preview.
     *
     * @return {Promise}
     */
  }, {
    key: "unpublish",
    value: function unpublish() {
      var _this6 = this;
      var andRemove = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      red5pro_rtc_debug('[unpublish]');
      var clearHelpers = function clearHelpers() {
        if (_this6._socketHelper) {
          red5pro_rtc_debug('[unpublish:teardown]');
          _this6._socketHelper.tearDown();
        }
        if (_this6._peerHelper) {
          _this6._peerHelper.tearDown();
        }
        _this6._socketHelper = undefined;
        _this6._peerHelper = undefined;
        _this6._messageTransport = undefined;
      };
      if (this._options.clearMediaOnUnpublish || andRemove) {
        this.unpreview();
      }
      this._availableFuture = undefined;
      this._peerFuture = undefined;
      this._offerFuture = undefined;
      this._sendOfferFuture = undefined;
      this._trickleEndFuture = undefined;
      this._publishFuture = undefined;
      var f = this._requestUnpublish(this._options.streamName, this._options.groupName);
      f.then(function () {
        _this6._unpublishFuture = undefined;
        //      this._mediaStream = undefined
        clearHelpers();
        _this6.trigger(new PublisherEvent(PublisherEventTypes.UNPUBLISH_SUCCESS, _this6));
      });
      browser.removeOrientationChangeHandler(this._onOrientationChange);
      return f;
    }

    /**
     * Deprecated. Use `muteAudio`.
     *
     * @private
     */
  }, {
    key: "mute",
    value: function mute() {
      // backward comatibility - to be deprecated.
      this.muteAudio();
    }

    /**
     * Deprecated. Use `unmuteAudio`.
     *
     * @private
     */
  }, {
    key: "unmute",
    value: function unmute() {
      // backward comatibility - to be deprecated.
      this.unmuteAudio();
    }

    /**
     * Request to mute the audio of the broadcast.
     * Can only be called once the broadcast has begun.
     */
  }, {
    key: "muteAudio",
    value: function muteAudio() {
      this.getMessageTransport().post({
        mute: {
          muteAudio: true
        }
      });
    }

    /**
     * Request to unmute the audio of a broadcast that has been previously muted.
     */
  }, {
    key: "unmuteAudio",
    value: function unmuteAudio() {
      this.getMessageTransport().post({
        mute: {
          muteAudio: false
        }
      });
    }

    /** Request to mute (not send) the video of the broadcast.
     * Can only be called once the broadcast has begun.
     */
  }, {
    key: "muteVideo",
    value: function muteVideo() {
      this.getMessageTransport().post({
        mute: {
          muteVideo: true
        }
      });
    }

    /**
     * Request to unmute (resume sending) the video of a previously video-muted broadcast.
     */
  }, {
    key: "unmuteVideo",
    value: function unmuteVideo() {
      this.getMessageTransport().post({
        mute: {
          muteVideo: false
        }
      });
    }

    /**
     * Request to send a message to all subscribers.
     *
     * @param {String} methodName
     *        The method name associated with the message to be accepted by all subscribers.
     * @param {Object} data
     *        The data object to send associated with the method name.
     */
  }, {
    key: "send",
    value: function send(methodName, data) {
      this.getMessageTransport().post({
        send: {
          method: methodName,
          data: typeof data === 'string' ? JSON.parse(data) : data
        }
      });
    }

    /**
     * Request to invoke a method on the Application Adapter related to the `app` config setting.
     *
     * @param {String} methodName
     *        The name of the method to invoke on thw Application Adapter
     * @param {Array} args
     *        The ordered list of arguments to invoke on the method. Do not provide anything if the method takes no arguments.
     * @return {Promise}
     */
  }, {
    key: "callServer",
    value: function callServer(methodName, args) {
      return this.getMessageTransport().postAsync({
        callAdapter: {
          method: methodName,
          arguments: args
        }
      });
    }

    /**
     * Sends an RPC log to the server which will be printed out in server logs.
     *
     * @param {String} level
     *        Valid values: TRACE, INFO, DEBUG, WARN or ERROR
     * @param {Object} message
     *        Either a String or a JSON-serializable Object. This param will be converted to a string to be sent to the server.
     */
  }, {
    key: "sendLog",
    value: function sendLog(level, message) {
      try {
        var theLevel = Object.keys(LEVELS).find(function (l) {
          return l.toLowerCase() === level.toLowerCase();
        }) ? level : LEVELS.DEBUG;
        var theMessage = typeof message === 'string' ? message : JSON.stringify(message);
        this.getMessageTransport().post({
          log: theLevel.toUpperCase(),
          message: theMessage
        });
      } catch (e) {
        var _message = e.message || e;
        red5pro_rtc_error(publisher_red5pro_rtc_NAME, "Could not send log to server. Message parameter expected to be String or JSON-serializable object.");
        red5pro_rtc_error(publisher_red5pro_rtc_NAME, _message);
      }
    }

    /**
     * Event handler for availability of stream on request over the socket.
     *
     * @private
     */
  }, {
    key: "onStreamAvailable",
    value: function onStreamAvailable(receipt) {
      red5pro_rtc_debug('[onstreamavailable]: ' + JSON.stringify(receipt, null, 2));
      this._availableFuture = Future.createIfNotExist(this._availableFuture);
      this._availableFuture.reject("Stream with name ".concat(this._options.streamName, " already has a broadcast session."));
      this.trigger(new PublisherEvent(PublisherEventTypes.PUBLISH_INVALID_NAME, this));
    }

    /**
     * Event handler for unavailability of stream on request over the socket.
     *
     * @private
     */
  }, {
    key: "onStreamUnavailable",
    value: function onStreamUnavailable(receipt) {
      // Being unavailable, is a good thing for allowing to publish using `options.streamName`
      red5pro_rtc_debug("Stream ".concat(this._options.streamName, " does not exist."));
      red5pro_rtc_debug('[onstreamunavailable]: ' + JSON.stringify(receipt, null, 2));
      this._availableFuture = Future.createIfNotExist(this._availableFuture);
      this._availableFuture.resolve(true);
    }

    /**
     * General event handler for all messages.
     *
     * @private
     */
  }, {
    key: "onSocketMessage",
    value: function onSocketMessage(socket, message) {
      this.trigger(new PublisherEvent(RTCPublisherEventTypes.SOCKET_MESSAGE, this, {
        socket: socket,
        message: message
      }));
    }

    /**
     * Event handler for WebSocket errors.
     *
     * @private
     */
  }, {
    key: "onSocketMessageError",
    value: function onSocketMessageError(message) {
      var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      red5pro_rtc_error("Error in stream publish: ".concat(message, ".\n[Optional detail]: ").concat(detail));
      if (this._publishFuture) {
        this.trigger(new PublisherEvent(PublisherEventTypes.PUBLISH_FAIL, this));
        this._publishFuture.reject(message);
        this.unpublish();
      }
    }

    /**
     * Event handler for close of WebSocket.
     *
     * @private
     */
  }, {
    key: "onSocketClose",
    value: function onSocketClose(closeEvent) {
      red5pro_rtc_debug('[onsocketclose]');
      if (this._peerHelper) {
        this._peerHelper.tearDown();
      }
      this.trigger(new PublisherEvent(PublisherEventTypes.CONNECTION_CLOSED, this, closeEvent));
    }

    /**
     * Event handler for fail in Peer Connection.
     *
     * @private
     */
  }, {
    key: "onPeerConnectionFail",
    value: function onPeerConnectionFail() {
      red5pro_rtc_debug('[onpeerconnectionfail]');
      this.trigger(new PublisherEvent(PublisherEventTypes.PUBLISH_FAIL, this));
      this._publishFuture.reject('Peer Connection Failed.');
    }

    /**
     * Event handler for close of Peer Connection.
     *
     * @private
     */
  }, {
    key: "onPeerConnectionClose",
    value: function onPeerConnectionClose(event) {
      red5pro_rtc_debug('[onpeerconnectionclose]');
      if (this._socketHelper) {
        red5pro_rtc_debug('[onpeerconnectionclose:teardown]');
        this._socketHelper.tearDown();
      }
      this.onSocketClose(event);
    }

    /**
     * Event handler for open of Peer Connection.
     *
     * @private
     */
  }, {
    key: "onPeerConnectionOpen",
    value: function onPeerConnectionOpen() {
      red5pro_rtc_debug('[onpeerconnection::open]');
      this.trigger(new PublisherEvent(RTCPublisherEventTypes.PEER_CONNECTION_OPEN), this, this.getPeerConnection());
    }

    /**
     * Event handler for track add on PeerConnection.
     *
     * @private
     */
  }, {
    key: "onPeerConnectionTrackAdd",
    value: function onPeerConnectionTrackAdd(track) {
      red5pro_rtc_debug('[onpeerconnection::track]');
      this.trigger(new PublisherEvent(RTCPublisherEventTypes.TRACK_ADDED, this, {
        track: track
      }));
    }

    /**
     * Event handler for success of SDP offer over WebSocket.
     *
     * @private
     */
  }, {
    key: "onSDPSuccess",
    value: function onSDPSuccess(receipt) {
      var info = receipt ? ': ' + JSON.stringify(receipt, null, 2) : '';
      red5pro_rtc_debug("[onsdpsuccess]".concat(info));
    }

    /**
     * Event handler for error in SDP offer over WebSocket.
     *
     * @private
     */
  }, {
    key: "onSDPError",
    value: function onSDPError(receipt) {
      this.trigger(new PublisherEvent(PublisherEventTypes.PUBLISH_FAIL, this));
      var errorMsg = receipt ? ': ' + JSON.stringify(receipt, null, 2) : '';
      red5pro_rtc_error("[onsdperror]".concat(errorMsg));
    }

    /**
     * Event handler for success in SDP answer over WebSocket.
     *
     * @private
     */
  }, {
    key: "onSDPAnswer",
    value: function onSDPAnswer(sdp) {
      red5pro_rtc_debug('[sdpanswer]:: ' + JSON.stringify(sdp, null, 2));
      this._sendOfferFuture = Future.createIfNotExist(this._sendOfferFuture);
      this._sendOfferFuture.resolve(sdp);
    }

    /**
     * Event handler for request to add ICE candidate on Peer Connection instance.
     *
     * @private
     */
  }, {
    key: "onAddIceCandidate",
    value: function onAddIceCandidate(candidate) {
      red5pro_rtc_debug('[addicecandidate]');
      this._peerHelper.addIceCandidate(candidate).then(function () {
        red5pro_rtc_debug('[addicecandidate:success]');
      }).catch(function (err) {
        red5pro_rtc_warn("[addicecandidate:error] - ".concat(err));
      });
    }

    /**
     * Event handler for receipt and request to send ICE candidate.
     *
     * @private
     */
  }, {
    key: "onIceCandidate",
    value: function onIceCandidate(candidate) {
      red5pro_rtc_debug('[icecandidatetrickle]');
      this._sendCandidate(candidate, this._options.streamName);
    }

    /**
     * Event handler for end of ICE trickle negotiation.
     *
     * @private
     */
  }, {
    key: "onIceCandidateTrickleEnd",
    value: function onIceCandidateTrickleEnd() {
      red5pro_rtc_debug('[icecandidatetrickle:end]');
    }

    /**
     * Event handler for receipt of empty candidate during ICE negotiation.
     *
     * @private
     */
  }, {
    key: "onEmptyCandidate",
    value: function onEmptyCandidate() {
      red5pro_rtc_debug('[icecandidatetrickle:empty]');
      this.trigger(new PublisherEvent(RTCPublisherEventTypes.PEER_CANDIDATE_END));
    }

    /**
     * Event handler for completion of peer ice candidate gathering.
     *
     * @private
     */
  }, {
    key: "onPeerGatheringComplete",
    value: function onPeerGatheringComplete() {
      red5pro_rtc_debug('[icecandidategathering:end]');
      if (this._socketHelper) {
        this._socketHelper.postEndOfCandidates(this._options.streamName);
      }
    }

    /**
     * Event handler for end of ICE candidate notification over WebSocket.
     *
     * @private
     */
  }, {
    key: "onSocketIceCandidateEnd",
    value: function onSocketIceCandidateEnd() {
      red5pro_rtc_debug('[socketicecandidate:end]');
      this._getTrickleEnd().resolve();
      // this._trickleEndFuture = undefined
    }

    /**
     * Publisher status event handler for start and stop of this Publisher instance.
     *
     * @private
     */
  }, {
    key: "onPublisherStatus",
    value: function onPublisherStatus(status) {
      red5pro_rtc_debug('[publisherstatus] - ' + JSON.stringify(status, null, 2));
      var stopResult = pubStopRegex.exec(status.message);
      var startResult = pubStartRegex.exec(status.message);
      if (stopResult && stopResult[1] === this._options.streamName) {
        this._unpublishFuture.resolve();
      } else if (startResult && startResult[1] === this._options.streamName) {
        this._publishFuture.resolve();
      } else if (status.code && status.code === 'NetStream.Publish.IsAvailable') {
        this.trigger(new PublisherEvent(PublisherEventTypes.PUBLISH_AVAILABLE, this.status));
      } else {
        this.trigger(new PublisherEvent(PublisherEventTypes.PUBLISH_STATUS, this, status));
      }
    }

    /**
     * Notification from server on insufficient bandwidth for current broadcast.
     *
     * @param {Object} data
     *        Provides information regarding current bandwidth conditions.
     *
     * @private
     */
  }, {
    key: "onInsufficientBandwidth",
    value: function onInsufficientBandwidth(data) {
      this.trigger(new PublisherEvent(PublisherEventTypes.PUBLISH_INSUFFICIENT_BANDWIDTH, this, data));
    }

    /**
     * Notification from server on recovered sufficient bandwidth for current broadcast.
     *
     * @param {Object} data
     *        Provides information regarding current bandwidth conditions.
     *
     * @private
     */
  }, {
    key: "onSufficientBandwidth",
    value: function onSufficientBandwidth(data) {
      this.trigger(new PublisherEvent(PublisherEventTypes.PUBLISH_SUFFICIENT_BANDWIDTH, this, data));
    }

    /**
     * Notification from server on bandwidth recovery data for current broadcast.
     *
     * @param {Object} data
     *        Provides information regarding current bandwidth conditions.
     *
     * @private
     */
  }, {
    key: "onRecoveringBandwidth",
    value: function onRecoveringBandwidth(data) {
      this.trigger(new PublisherEvent(PublisherEventTypes.PUBLISH_RECOVERING_BANDWIDTH, this, data));
    }

    /**
     * Notification from server on send method data.
     *
     * @private
     */
  }, {
    key: "onSendReceived",
    value: function onSendReceived(methodName, data) {
      if (methodName === 'onMetaData') {
        this.onMetaData(data);
      } else {
        // environment.invoke(methodName, data)
        this.trigger(new PublisherEvent(PublisherEventTypes.PUBLISH_SEND_INVOKE, this, {
          methodName: methodName,
          data: data
        }));
      }
    }

    /**
     * Event listener for Data Channel being open on server to switch signaling.
     *
     * @private
     */
  }, {
    key: "onDataChannelAvailable",
    value: function onDataChannelAvailable(channelName) {
      var _this7 = this;
      red5pro_rtc_debug('[ondatachannel::available]');
      this._switchChannelRequest = {
        switchChannel: channelName || 'red5pro'
      };
      if (this._options.signalingSocketOnly) {
        var t = setTimeout(function () {
          clearTimeout(t);
          if (_this7._socketHelper) {
            _this7._socketHelper.sever(_this7._switchChannelRequest);
          }
          _this7._messageTransport = _this7._peerHelper;
          _this7.trigger(new MessageTransportStateEvent(MessageTransportStateEventTypes.CHANGE, _this7, {
            controller: _this7,
            transport: _this7._messageTransport
          }));
        }, this._socketHelper ? this._options.socketSwitchDelay : 100);
      }
      this.trigger(new PublisherEvent(RTCPublisherEventTypes.DATA_CHANNEL_AVAILABLE, this, {
        name: channelName,
        dataChannel: this.getDataChannel()
      }));
    }

    /**
     * Event handler for notifications of error on optional data channel.
     *
     * @param {RTCDataChannel} dataChannel
     * @param {String} error
     *
     * @private
     */
  }, {
    key: "onDataChannelError",
    value: function onDataChannelError(dataChannel, error) {
      this.trigger(new PublisherEvent(RTCPublisherEventTypes.DATA_CHANNEL_ERROR, this, {
        dataChannel: dataChannel,
        error: error
      }));
    }

    /**
     * Event handler for notifications of message on optional data channel.
     *
     * @param {RTCDataChannel} dataChannel
     * @param {Object} message
     *
     * @private
     */
  }, {
    key: "onDataChannelMessage",
    value: function onDataChannelMessage(dataChannel, messageData) {
      this.trigger(new PublisherEvent(RTCPublisherEventTypes.DATA_CHANNEL_MESSAGE, this, {
        dataChannel: dataChannel,
        message: messageData
      }));
    }

    /**
     * Notification from optionally opened RTCDataChannel.
     *
     * @private
     */
  }, {
    key: "onDataChannelOpen",
    value: function onDataChannelOpen(dataChannel) {
      this.trigger(new PublisherEvent(RTCPublisherEventTypes.DATA_CHANNEL_OPEN, this, {
        dataChannel: dataChannel
      }));
    }

    /**
     * Notification from optionally opened RTCDataChannel on closure.
     *
     * @private
     */
  }, {
    key: "onDataChannelClose",
    value: function onDataChannelClose(dataChannel) {
      this.trigger(new PublisherEvent(RTCPublisherEventTypes.DATA_CHANNEL_CLOSE, this, {
        dataChannel: dataChannel
      }));
    }

    /**
     * Notification from server on metadata.
     *
     * @private
     */
  }, {
    key: "onMetaData",
    value: function onMetaData(data) {
      // eslint-disable-line no-unused-vars
      this.trigger(new PublisherEvent(PublisherEventTypes.PUBLISH_METADATA, this, data));
    }

    /**
     * Helper method to overlay options over current configuration.
     *
     * @private
     */
  }, {
    key: "overlayOptions",
    value: function overlayOptions(newOptions) {
      this._options = Object.assign(this._options, newOptions);
    }

    /**
     * Returns the Message Transport instance that posts requests to the server.
     *
     *  @return {Object}
     *          Either the socker proxy or the peer connection proxy
     *
     * @private
     */
  }, {
    key: "getMessageTransport",
    value: function getMessageTransport() {
      return this._messageTransport;
    }

    /**
     * Returns the current WebSocket connection helper if established.
     * Used in SharedObject communication.
     *
     * @return {PublisherSocketHelper}
     *
     * @private
     */
  }, {
    key: "getConnection",
    value: function getConnection() {
      return this._socketHelper;
    }

    /**
     * Returns the current RTCPeerConnection helper if established.
     *
     * @return {RTCPeerConnection}
     */
  }, {
    key: "getPeerConnection",
    value: function getPeerConnection() {
      return this._peerHelper ? this._peerHelper.connection : undefined;
    }

    /**
     * Returns the current RTCDataChannel is available.
     *
     * @return {RTCDataChannel}
     */
  }, {
    key: "getDataChannel",
    value: function getDataChannel() {
      return this._peerHelper ? this._peerHelper.dataChannel : undefined;
    }

    /**
     * Returns the `MediaStream` instance if generated through `getUserMedia` and exists for broadcast.
     *
     * @return {MediaStream}
     */
  }, {
    key: "getMediaStream",
    value: function getMediaStream() {
      return this._mediaStream;
    }

    /**
     * Returns the initialization configuration used in `init()`.
     *
     * @return {Object}
     */
  }, {
    key: "getOptions",
    value: function getOptions() {
      return this._options;
    }

    /**
     * Returns the type of implementation: `RTC`.
     *
     * @return {String}
     */
  }, {
    key: "getType",
    value: function getType() {
      return PublishTypes.RTC.toUpperCase();
    }
  }]);
  return RTCPublisher;
}(event_emitter);
/* harmony default export */ var publisher_red5pro_rtc = (red5pro_rtc_RTCPublisher);
// CONCATENATED MODULE: ./src/js/publisher/red5pro-whip.js
function red5pro_whip_typeof(obj) { "@babel/helpers - typeof"; return red5pro_whip_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, red5pro_whip_typeof(obj); }
function red5pro_whip_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function red5pro_whip_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? red5pro_whip_ownKeys(Object(source), !0).forEach(function (key) { red5pro_whip_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : red5pro_whip_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function red5pro_whip_defineProperty(obj, key, value) { key = red5pro_whip_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function red5pro_whip_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ red5pro_whip_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == red5pro_whip_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function red5pro_whip_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function red5pro_whip_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { red5pro_whip_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { red5pro_whip_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function red5pro_whip_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function red5pro_whip_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, red5pro_whip_toPropertyKey(descriptor.key), descriptor); } }
function red5pro_whip_createClass(Constructor, protoProps, staticProps) { if (protoProps) red5pro_whip_defineProperties(Constructor.prototype, protoProps); if (staticProps) red5pro_whip_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function red5pro_whip_toPropertyKey(arg) { var key = red5pro_whip_toPrimitive(arg, "string"); return red5pro_whip_typeof(key) === "symbol" ? key : String(key); }
function red5pro_whip_toPrimitive(input, hint) { if (red5pro_whip_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (red5pro_whip_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function red5pro_whip_get() { if (typeof Reflect !== "undefined" && Reflect.get) { red5pro_whip_get = Reflect.get.bind(); } else { red5pro_whip_get = function _get(target, property, receiver) { var base = red5pro_whip_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return red5pro_whip_get.apply(this, arguments); }
function red5pro_whip_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = red5pro_whip_getPrototypeOf(object); if (object === null) break; } return object; }
function red5pro_whip_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) red5pro_whip_setPrototypeOf(subClass, superClass); }
function red5pro_whip_setPrototypeOf(o, p) { red5pro_whip_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return red5pro_whip_setPrototypeOf(o, p); }
function red5pro_whip_createSuper(Derived) { var hasNativeReflectConstruct = red5pro_whip_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = red5pro_whip_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = red5pro_whip_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return red5pro_whip_possibleConstructorReturn(this, result); }; }
function red5pro_whip_possibleConstructorReturn(self, call) { if (call && (red5pro_whip_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return red5pro_whip_assertThisInitialized(self); }
function red5pro_whip_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function red5pro_whip_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function red5pro_whip_getPrototypeOf(o) { red5pro_whip_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return red5pro_whip_getPrototypeOf(o); }












var red5pro_whip_NAME = 'WHIPClient';
var red5pro_whip_ICE_GATHER_TIMEOUT = 1000;
var red5pro_whip_debug = function debug(message) {
  log_debug(red5pro_whip_NAME, message);
};
var red5pro_whip_warn = function warn(message) {
  log_warn(red5pro_whip_NAME, message);
};
var red5pro_whip_error = function error(message) {
  log_error(red5pro_whip_NAME, message);
};

// Default to secure settings.
var red5pro_whip_defaultOptions = {
  protocol: 'https',
  port: 443,
  app: 'live',
  streamMode: PublishModeTypes.LIVE,
  keyFramerate: 3000,
  mediaElementId: 'red5pro-publisher',
  rtcConfiguration: {
    iceServers: [{
      urls: 'stun:stun2.l.google.com:19302'
    }],
    iceCandidatePoolSize: 2,
    bundlePolicy: 'max-bundle'
  },
  // Favored over iceServers.
  iceServers: undefined,
  // Deprecated. Preserved for backward-compatibility.
  iceTransport: IceTransportTypes.UDP,
  bandwidth: {
    audio: 56,
    video: 750
  },
  clearMediaOnUnpublish: false,
  mediaConstraints: new RTCMediaConstraint(),
  onGetUserMedia: undefined,
  dataChannelConfiguration: undefined,
  forceVP8: false,
  bypassAvailable: false,
  signalingSocketOnly: false,
  // No DC in SDP at the moment
  trickleIce: false // Flag to use trickle ice to send candidates
};
var red5pro_whip_WHIPClient = /*#__PURE__*/function (_RTCPublisher) {
  red5pro_whip_inherits(WHIPClient, _RTCPublisher);
  var _super = red5pro_whip_createSuper(WHIPClient);
  /**
   * Constructor. Providing arguments will automatically kick of connection sequence.
   * Leaving arguments unset allows for more control and follows same pattern of init -> publish as RTCPublisher.
   * @param {string} url Optional endpoint for WHIP. Example: https://your-red5pro.com/live/whip/endpoint/stream1
   * @param {HTMLMediaElement} element Optional media element to play media in.
   * @param {boolean} trickleIce Optional request to trickle candidates. Preferred: false, send with SDP offer.
   */
  function WHIPClient(url, element) {
    var _this;
    var trickleIce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    red5pro_whip_classCallCheck(this, WHIPClient);
    _this = _super.call(this);
    var optionsFromUrl = url ? optionsFromWhipWhepUrl(url) : red5pro_whip_defaultOptions;
    optionsFromUrl.mediaElementId = element ? element.id : red5pro_whip_defaultOptions.mediaElementId;
    optionsFromUrl.trickleIce = trickleIce;
    _this._whipHelper = undefined;
    if (url) {
      _this._internalConnect(optionsFromUrl);
    }
    return _this;
  }

  /**
   * Internal connection sequence if used constructor with arguments.
   *
   * @param {Object} options
   *        The initialization configuration map.
   *
   * @private
   */
  red5pro_whip_createClass(WHIPClient, [{
    key: "_internalConnect",
    value: function () {
      var _internalConnect2 = red5pro_whip_asyncToGenerator( /*#__PURE__*/red5pro_whip_regeneratorRuntime().mark(function _callee(options) {
        return red5pro_whip_regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.init(options);
            case 2:
              _context.next = 4;
              return this.publish();
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _internalConnect(_x) {
        return _internalConnect2.apply(this, arguments);
      }
      return _internalConnect;
    }()
    /**
     * Ensures gathering state complete for ICE.
     *
     * @param {RTCPeerConnection} connection
     * @returns Promise
     *
     * @private
     */
  }, {
    key: "waitToGatherIce",
    value: function () {
      var _waitToGatherIce = red5pro_whip_asyncToGenerator( /*#__PURE__*/red5pro_whip_regeneratorRuntime().mark(function _callee2(connection) {
        return red5pro_whip_regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", new Promise(function (resolve, reject) {
                if (connection.iceGatheringState === 'complete') {
                  resolve(connection.localDescription);
                } else {
                  setTimeout(function () {
                    resolve(connection.localDescription);
                  }, red5pro_whip_ICE_GATHER_TIMEOUT);
                  connection.onicegatheringstatechange = function () {
                    connection.iceGatheringState === 'complete' && resolve(connection.localDescription);
                  };
                }
              }));
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function waitToGatherIce(_x2) {
        return _waitToGatherIce.apply(this, arguments);
      }
      return waitToGatherIce;
    }()
    /**
     * POSTs SDP to WHEP endpoint.
     *
     * @param {RTCSessionDescription} sessionDescription
     *
     * @returns { sdp, location }
     *
     * @private
     */
  }, {
    key: "_postOffer",
    value: function () {
      var _postOffer2 = red5pro_whip_asyncToGenerator( /*#__PURE__*/red5pro_whip_regeneratorRuntime().mark(function _callee3(sessionDescription) {
        var sdp, cleaned;
        return red5pro_whip_regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              sdp = sessionDescription.sdp;
              cleaned = cleanWhipSDP(sdp);
              _context3.next = 5;
              return this._whipHelper.postSDPOffer(cleaned);
            case 5:
              return _context3.abrupt("return", _context3.sent);
            case 8:
              _context3.prev = 8;
              _context3.t0 = _context3["catch"](0);
              red5pro_whip_error(_context3.t0.message || _context3.t0);
              // It was most likely rejected because stream already exists...
              this.onStreamAvailable(_context3.t0);
              throw _context3.t0;
            case 13:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 8]]);
      }));
      function _postOffer(_x3) {
        return _postOffer2.apply(this, arguments);
      }
      return _postOffer;
    }()
    /**
     * Sends Candidates as PATCH to WHEP endpoint.
     * @param {string} sdp The SDP with candidates
     * @returns Promise
     *
     * @private
     */
  }, {
    key: "_postCandidateFragments",
    value: function () {
      var _postCandidateFragments2 = red5pro_whip_asyncToGenerator( /*#__PURE__*/red5pro_whip_regeneratorRuntime().mark(function _callee5(sdp) {
        var _this2 = this;
        var hostFrag, srflxFrag;
        return red5pro_whip_regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              hostFrag = generateSDPCandidateFrag(sdp, 'host');
              srflxFrag = generateSDPCandidateFrag(sdp, 'srflx', true);
              _context5.next = 4;
              return this._whipHelper.trickle(hostFrag);
            case 4:
              return _context5.abrupt("return", new Promise(function (resolve, reject) {
                var postSrflx = function postSrflx() {
                  setTimeout( /*#__PURE__*/red5pro_whip_asyncToGenerator( /*#__PURE__*/red5pro_whip_regeneratorRuntime().mark(function _callee4() {
                    return red5pro_whip_regeneratorRuntime().wrap(function _callee4$(_context4) {
                      while (1) switch (_context4.prev = _context4.next) {
                        case 0:
                          _context4.next = 2;
                          return _this2._whipHelper.trickle(srflxFrag);
                        case 2:
                          resolve();
                        case 3:
                        case "end":
                          return _context4.stop();
                      }
                    }, _callee4);
                  })), 150);
                };
                postSrflx();
              }));
            case 5:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function _postCandidateFragments(_x4) {
        return _postCandidateFragments2.apply(this, arguments);
      }
      return _postCandidateFragments;
    }()
    /**
     * Override request to send ICE candidate over the WebSocket. We're WHIPping.
     * This can happen several times in the ICE negotiation process.
     *
     * @param {Object} candidate
     *        The Candidate to send.
     * @param {string} streamName
     *        The associated unique stream name of the broadcast.
     *
     * @private
     */
  }, {
    key: "_sendCandidate",
    value: function _sendCandidate(candidate, streamName) {
      red5pro_whip_debug(JSON.stringify(candidate, null, 2));
    }

    /**
     * Request to initialize the WebRTC-based Publisher based on configuration.
     * The returned `Promise` will either resolve with a reference to this instance or reject with an error `String` in failure.
     *
     * @param {Object} options
     *        The initialization configuration map.
     * @return {Promise}
     */
  }, {
    key: "init",
    value: function () {
      var _init = red5pro_whip_asyncToGenerator( /*#__PURE__*/red5pro_whip_regeneratorRuntime().mark(function _callee6(options) {
        var _this$_options, protocol, host, port, app, streamName, proto;
        return red5pro_whip_regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              this._options = red5pro_whip_objectSpread(red5pro_whip_objectSpread({}, red5pro_whip_defaultOptions), options);
              _this$_options = this._options, protocol = _this$_options.protocol, host = _this$_options.host, port = _this$_options.port, app = _this$_options.app, streamName = _this$_options.streamName;
              proto = protocol === 'ws' ? 'http' : 'https';
              this._whipUrl = "".concat(proto, "://").concat(host, ":").concat(port, "/").concat(app, "/whip/endpoint/").concat(streamName);
              this._whipHelper = new whipwhep_signaling_helper(this._whipUrl);
              this._messageTransport = this._whipHelper;
              return _context6.abrupt("return", red5pro_whip_get(red5pro_whip_getPrototypeOf(WHIPClient.prototype), "init", this).call(this, options));
            case 7:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function init(_x5) {
        return _init.apply(this, arguments);
      }
      return init;
    }()
    /**
     * Request to initialize the WebRTC-based Publisher based on configuration and previously established MediaStream.
     * USE WITH CAUTION. It is assumed you know what you are doing in accessing a MediaStream outside of the API available from the SDK.
     * The returned `Promise` will either resolve with a reference to this instance or reject with an error `String` in failure.
     *
     * @param {Object} options
     *        The initialization configuration map.
     * @param {MediaStream} mediaStream
     *        A previously established MediaStream, most likely receieved through getUserMedia() outside of SDK use.
     *
     * @return {Promise}
     */
  }, {
    key: "initWithStream",
    value: function () {
      var _initWithStream = red5pro_whip_asyncToGenerator( /*#__PURE__*/red5pro_whip_regeneratorRuntime().mark(function _callee7(options, mediaStream) {
        var _this$_options2, protocol, host, port, app, streamName;
        return red5pro_whip_regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _this$_options2 = this._options, protocol = _this$_options2.protocol, host = _this$_options2.host, port = _this$_options2.port, app = _this$_options2.app, streamName = _this$_options2.streamName;
              this._whipUrl = "".concat(protocol, "://").concat(host, ":").concat(port, "/").concat(app, "/whip/endpoint/").concat(streamName);
              this._whipHelper = new whipwhep_signaling_helper(this._whipUrl);
              this._messageTransport = this._whipHelper;
              return _context7.abrupt("return", red5pro_whip_get(red5pro_whip_getPrototypeOf(WHIPClient.prototype), "initWithStream", this).call(this, options, mediaStream));
            case 5:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function initWithStream(_x6, _x7) {
        return _initWithStream.apply(this, arguments);
      }
      return initWithStream;
    }()
    /**
     * Request to begin a broadcast session after initialization has occured.
     *
     * @param {String} streamName
     *        Optional stream name to broadcast on, otherwise defaulting to the `streamName` provided in `init()` configuration.
     * @param {Promise} promise
     *        Optional `Promise` object to resolve/reject on based on sequence of events in establishing a broadcast, otherwise defaulting to `Promise` created internally and returned.
     * @return {Promise}
     *        The returned `Promise` will resolve or reject on successful start of a broadcast.<br>
     *        There are several processes that occur in order to establish a WebRTC broadcast that involve - but are not limited to - ICE communication and assigning of local and remote SDPs on peer connections.
     */
  }, {
    key: "publish",
    value: function () {
      var _publish = red5pro_whip_asyncToGenerator(function () {
        var _this3 = this;
        var streamName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        return /*#__PURE__*/red5pro_whip_regeneratorRuntime().mark(function _callee8() {
          var _this3$_options, bandwidth, forceVP8, rtcConfiguration, signalingSocketOnly, dataChannelConfiguration, trickleIce, dataChannelAllowed, _yield$_this3$_whipHe, links, connection, mediaStream, offer, localDescription, _yield$_this3$_postOf, sdp, _sdp;
          return red5pro_whip_regeneratorRuntime().wrap(function _callee8$(_context8) {
            while (1) switch (_context8.prev = _context8.next) {
              case 0:
                _this3$_options = _this3._options, bandwidth = _this3$_options.bandwidth, forceVP8 = _this3$_options.forceVP8, rtcConfiguration = _this3$_options.rtcConfiguration, signalingSocketOnly = _this3$_options.signalingSocketOnly, dataChannelConfiguration = _this3$_options.dataChannelConfiguration, trickleIce = _this3$_options.trickleIce; // Set default data channel configuration if not defined and severing socket on signal end.
                // TODO: Set this as more "private" with `red5pro-<streamname>`
                dataChannelAllowed = signalingSocketOnly && webrtc_supportsDataChannel();
                if (dataChannelAllowed && !dataChannelConfiguration) {
                  dataChannelConfiguration = {
                    name: "red5pro"
                  };
                }
                _this3._options.signalingSocketOnly = dataChannelAllowed;
                _context8.prev = 4;
                if (streamName) {
                  _this3._options.streamName = streamName;
                }
                _context8.next = 8;
                return _this3._whipHelper.getOptions();
              case 8:
                _yield$_this3$_whipHe = _context8.sent;
                links = _yield$_this3$_whipHe.links;
                if (links) {
                  _this3._options.iceServers = links;
                }
                // TODO: No DC support at this time.
                //      const connection = await this._createPeerConnection(rtcConfiguration, dataChannelConfiguration, links || this._options.iceServers)
                _context8.next = 13;
                return _this3._createPeerConnection(rtcConfiguration, undefined, links || _this3._options.iceServers);
              case 13:
                connection = _context8.sent;
                _this3.trigger(new PublisherEvent(RTCPublisherEventTypes.PEER_CONNECTION_AVAILABLE, _this3, connection));
                _context8.next = 17;
                return _this3._getMediaStream();
              case 17:
                mediaStream = _context8.sent;
                // WHIP
                mediaStream.getTracks().forEach(function (track) {
                  var transceiver = connection.addTransceiver(track, {
                    direction: 'sendonly'
                  });
                });
                // WAS
                // mediaStream.getTracks().forEach((track) => {
                //   connection.addTrack(track, this._mediaStream)
                // })
                _context8.next = 21;
                return _this3._peerHelper.createOfferWithoutSetLocal(bandwidth, forceVP8);
              case 21:
                offer = _context8.sent;
                _context8.next = 24;
                return _this3._peerHelper.setLocalDescription(offer);
              case 24:
                _context8.next = 26;
                return _this3.waitToGatherIce(connection);
              case 26:
                localDescription = _context8.sent;
                _this3.trigger(new PublisherEvent(RTCPublisherEventTypes.OFFER_START, _this3, localDescription));
                _context8.next = 30;
                return _this3._postOffer(trickleIce ? offer : localDescription);
              case 30:
                _yield$_this3$_postOf = _context8.sent;
                sdp = _yield$_this3$_postOf.sdp;
                _context8.next = 34;
                return _this3._setRemoteDescription({
                  type: 'answer',
                  sdp: stripExtMaps(sdp)
                });
              case 34:
                _this3.trigger(new PublisherEvent(RTCPublisherEventTypes.OFFER_END, _this3, sdp));
                if (!trickleIce) {
                  _context8.next = 39;
                  break;
                }
                _sdp = localDescription.sdp;
                _context8.next = 39;
                return _this3._postCandidateFragments(_sdp);
              case 39:
                _this3.trigger(new PublisherEvent(RTCPublisherEventTypes.ICE_TRICKLE_COMPLETE, _this3));
                browser.addOrientationChangeHandler(_this3._onOrientationChange);
                _this3.trigger(new PublisherEvent(PublisherEventTypes.PUBLISH_START, _this3));
                if (promise) {
                  promise.resolve(_this3);
                }
                return _context8.abrupt("return", _this3);
              case 46:
                _context8.prev = 46;
                _context8.t0 = _context8["catch"](4);
                red5pro_whip_error(_context8.t0);
                browser.removeOrientationChangeHandler(_this3._onOrientationChange);
                _this3.trigger(new PublisherEvent(PublisherEventTypes.CONNECT_FAILURE, _this3, _context8.t0));
                if (promise) {
                  promise.reject(_context8.t0);
                }
                throw _context8.t0;
              case 53:
              case "end":
                return _context8.stop();
            }
          }, _callee8, null, [[4, 46]]);
        })();
      });
      function publish() {
        return _publish.apply(this, arguments);
      }
      return publish;
    }()
    /**
     * Request to stop a broadcast.
     * The returned `Promise` will either resolve or reject on successful stop of broadcast.
     *
     * @param {Boolean} andRemove
     *        Flag to additionally remove the preview.
     *
     * @return {Promise}
     */
  }, {
    key: "unpublish",
    value: function () {
      var _unpublish = red5pro_whip_asyncToGenerator(function () {
        var _this4 = this;
        var andRemove = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        return /*#__PURE__*/red5pro_whip_regeneratorRuntime().mark(function _callee9() {
          return red5pro_whip_regeneratorRuntime().wrap(function _callee9$(_context9) {
            while (1) switch (_context9.prev = _context9.next) {
              case 0:
                red5pro_whip_debug('[unpublish:teardown]');
                if (_this4._whipHelper) {
                  _this4._whipHelper.tearDown();
                }
                if (_this4._peerHelper) {
                  _this4._peerHelper.tearDown();
                }
                _this4._whipHelper = undefined;
                _this4._peerHelper = undefined;
                _this4._messageTransport = undefined;
                if (_this4._options.clearMediaOnUnpublish || andRemove) {
                  _this4.unpreview();
                }
                _this4.trigger(new PublisherEvent(PublisherEventTypes.UNPUBLISH_SUCCESS, _this4));
                browser.removeOrientationChangeHandler(_this4._onOrientationChange);
                return _context9.abrupt("return", _this4);
              case 10:
              case "end":
                return _context9.stop();
            }
          }, _callee9);
        })();
      });
      function unpublish() {
        return _unpublish.apply(this, arguments);
      }
      return unpublish;
    }()
    /**
     * Returns the current WebSocket connection helper if established. Due to using WHIP, this does not exist.
     *
     * @return {PublisherSocketHelper}
     *
     * @private
     */
  }, {
    key: "getConnection",
    value: function getConnection() {
      return undefined;
    }
  }]);
  return WHIPClient;
}(publisher_red5pro_rtc);
/* harmony default export */ var red5pro_whip = (red5pro_whip_WHIPClient);
// CONCATENATED MODULE: ./src/js/publisher/index.js


function publisher_typeof(obj) { "@babel/helpers - typeof"; return publisher_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, publisher_typeof(obj); }
function publisher_toConsumableArray(arr) { return publisher_arrayWithoutHoles(arr) || publisher_iterableToArray(arr) || publisher_unsupportedIterableToArray(arr) || publisher_nonIterableSpread(); }
function publisher_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function publisher_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return publisher_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return publisher_arrayLikeToArray(o, minLen); }
function publisher_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function publisher_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return publisher_arrayLikeToArray(arr); }
function publisher_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function publisher_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function publisher_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, publisher_toPropertyKey(descriptor.key), descriptor); } }
function publisher_createClass(Constructor, protoProps, staticProps) { if (protoProps) publisher_defineProperties(Constructor.prototype, protoProps); if (staticProps) publisher_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function publisher_toPropertyKey(arg) { var key = publisher_toPrimitive(arg, "string"); return publisher_typeof(key) === "symbol" ? key : String(key); }
function publisher_toPrimitive(input, hint) { if (publisher_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (publisher_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function publisher_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) publisher_setPrototypeOf(subClass, superClass); }
function publisher_setPrototypeOf(o, p) { publisher_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return publisher_setPrototypeOf(o, p); }
function publisher_createSuper(Derived) { var hasNativeReflectConstruct = publisher_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = publisher_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = publisher_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return publisher_possibleConstructorReturn(this, result); }; }
function publisher_possibleConstructorReturn(self, call) { if (call && (publisher_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return publisher_assertThisInitialized(self); }
function publisher_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function publisher_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function publisher_getPrototypeOf(o) { publisher_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return publisher_getPrototypeOf(o); }








var publisher_NAME = 'Red5ProPublisher';
var publishFactory = new impl_factory_order();
var publisherImpl = function () {
  var map = new Map();
  map.set(PublishTypes.RTC, publisher_red5pro_rtc);
  map.set(PublishTypes.RTMP, publisher_red5pro_rtmp);
  return map;
}();

/**
 * Main entry for failover support of all publisher implementations.
 *
 * @extends EventEmitter
 */
var publisher_Red5ProPublisher = /*#__PURE__*/function (_EventEmitter) {
  publisher_inherits(Red5ProPublisher, _EventEmitter);
  var _super = publisher_createSuper(Red5ProPublisher);
  function Red5ProPublisher() {
    var _this;
    publisher_classCallCheck(this, Red5ProPublisher);
    _this = _super.call(this);
    _this._options = undefined;
    _this._order = [PublishTypes.RTC, PublishTypes.RTMP];
    return _this;
  }

  /**
   * Utilizes Failover Publisher Factory to attempt in determining browser support for Publisher from defined order.
   *
   * @return {Promise}
   *
   * @private
   */
  publisher_createClass(Red5ProPublisher, [{
    key: "_getPublisherFromOrder",
    value: function _getPublisherFromOrder(order, options) {
      return publishFactory.create(order, publisherImpl, options, 'init');
    }

    /**
     * Returns the specified order for auto-failover.
     *
     *  @return {Array}
     *          Default: `['rtc', 'rtmp']`.
     */
  }, {
    key: "getPublishOrder",
    value: function getPublishOrder() {
      return this._order;
    }

    /**
     * Defines the desired auto-failover order.
     *
     *  @param {Array} order
     *          The desired order. e.g, `['rtc', 'rtmp']`.
     *
     *  @return {Red5ProPublisher}
     *          This instance.
     */
  }, {
    key: "setPublishOrder",
    value: function setPublishOrder(order) {
      // Allow for string value to define single item in order.
      order = typeof order === 'string' ? [order] : order;

      // Filter out values not available in enumeration of playback types.
      var t = order.filter(function (entry) {
        var key;
        for (key in PublishTypes) {
          if (PublishTypes[key].toLowerCase() === entry.toLowerCase()) {
            return true;
          }
        }
        return false;
      }).map(function (entry) {
        return entry.toLowerCase();
      });

      // Define new order.
      this._order = publisher_toConsumableArray(new Set(t));
      log_debug(publisher_NAME, "[orderupdate]: ".concat(this._order));
      return this;
    }

    /**
     * Request to initialize and determine the proper Publisher implementation based on configuration.
     * The returned `Promise` will either resolve with the determined Publisher instance or reject with an error String in failure to determine Publisher type.
     *
     *  @param {Object} options
     *          The initialization configuration map for each desired failover tech.
     *  @return {Promise}
     */
  }, {
    key: "init",
    value: function init(options) {
      var deferred = new DeferredPromise();
      log_debug(publisher_NAME, '[publish]');
      this._options = options;
      this._getPublisherFromOrder(this._order, this._options).then(function (publisher) {
        deferred.resolve(publisher);
      }).catch(function (err) {
        log_warn(publisher_NAME, "[publisherror]: Could not implement a publisher: ".concat(err));
        deferred.reject(err);
      });
      return deferred.promise;
    }

    /**
     * Return enumerated value Publisher types used in failover order.
     * @type {Object}
     */
  }, {
    key: "publishTypes",
    get: function get() {
      return PublishTypes;
    }
  }]);
  return Red5ProPublisher;
}(event_emitter);

// CONCATENATED MODULE: ./src/js/sharedobject/sharedobject.js
function sharedobject_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) sharedobject_setPrototypeOf(subClass, superClass); }
function sharedobject_setPrototypeOf(o, p) { sharedobject_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return sharedobject_setPrototypeOf(o, p); }
function sharedobject_createSuper(Derived) { var hasNativeReflectConstruct = sharedobject_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = sharedobject_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = sharedobject_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return sharedobject_possibleConstructorReturn(this, result); }; }
function sharedobject_possibleConstructorReturn(self, call) { if (call && (sharedobject_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return sharedobject_assertThisInitialized(self); }
function sharedobject_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function sharedobject_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function sharedobject_getPrototypeOf(o) { sharedobject_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return sharedobject_getPrototypeOf(o); }
function sharedobject_typeof(obj) { "@babel/helpers - typeof"; return sharedobject_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, sharedobject_typeof(obj); }
function sharedobject_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function sharedobject_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, sharedobject_toPropertyKey(descriptor.key), descriptor); } }
function sharedobject_createClass(Constructor, protoProps, staticProps) { if (protoProps) sharedobject_defineProperties(Constructor.prototype, protoProps); if (staticProps) sharedobject_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function sharedobject_toPropertyKey(arg) { var key = sharedobject_toPrimitive(arg, "string"); return sharedobject_typeof(key) === "symbol" ? key : String(key); }
function sharedobject_toPrimitive(input, hint) { if (sharedobject_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (sharedobject_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }






var sharedobject_NAME = 'Red5ProSharedObject';
var SO_SUBTYPE_PROPERTY = 4;
var SO_SUBTYPE_METHOD = 6;
var SO_SUBTYPE_REMOVE = 9;
var sharedobject_debug = function debug(soName, message) {
  log_debug([sharedobject_NAME, soName].join(':'), message);
};
var sharedobject_warn = function warn(soName, message) {
  log_warn([sharedobject_NAME, soName].join(':'), message);
};
var sharedobject_error = function error(soName, message) {
  log_error([sharedobject_NAME, soName].join(':'), message);
};
var decodeMessageIfJSONString = function decodeMessageIfJSONString(message) {
  return typeof message === 'string' ? JSON.parse(message) : message;
};

/**
 * Defines the structure of a Property Data notification object.
 *
 * @private
 */
var PropertyData = /*#__PURE__*/function () {
  function PropertyData(key, value) {
    sharedobject_classCallCheck(this, PropertyData);
    this.key = key;
    this.value = value;
  }
  sharedobject_createClass(PropertyData, [{
    key: "toObject",
    value: function toObject() {
      var obj = {};
      obj[this.key] = this.value;
      return obj;
    }
  }]);
  return PropertyData;
}();
/**
 * Defines the structure of a Method Data notification object.
 *
 * @private
 */
var MethodData = /*#__PURE__*/function () {
  function MethodData(methodName, message) {
    sharedobject_classCallCheck(this, MethodData);
    this.methodName = methodName;
    var messageList;
    if (Object.prototype.toString.call(message) === '[object Array]') {
      var i;
      var msg;
      var length = message.length;
      messageList = [];
      for (i = 0; i < length; i++) {
        msg = decodeMessageIfJSONString(message[i]);
        if (Object.prototype.toString.call(message) === '[object Array]') {
          messageList = messageList.concat(msg);
        } else {
          messageList.push(msg);
        }
      }
    } else {
      messageList = [decodeMessageIfJSONString(message)];
    }
    this.message = messageList.length === 1 ? messageList[0] : messageList;
  }
  sharedobject_createClass(MethodData, [{
    key: "toObject",
    value: function toObject() {
      return {
        methodName: this.methodName,
        message: this.message
      };
    }
  }]);
  return MethodData;
}();
/**
 * Main entry for Shared Object associated with Publishers and Subscribers.
 *
 * @extends EventEmitter
 */
var sharedobject_Red5ProSharedObject = /*#__PURE__*/function (_EventEmitter) {
  sharedobject_inherits(Red5ProSharedObject, _EventEmitter);
  var _super = sharedobject_createSuper(Red5ProSharedObject);
  /**
   * The API on this object is limited as it communicates along with message channel connection which you provide in the constuctor. This connection can either be a previously established Publisher, Subscriber or Red5ProSharedObjectSocket.
   *
   * Event handlers should be assigned to new `Red5ProSharedObject` instances in order to handle notifications over the communication channel.
   *
   * @param {String} name
   *        The name of the Shared Object to connect to.
   * @param {Object} connection
   *        The connection delegate to send and receive Shared Object notifications on.
   *        This will either be a previously established Publisher or Subscriber instance.
   */
  function Red5ProSharedObject(name, connection) {
    var _this;
    sharedobject_classCallCheck(this, Red5ProSharedObject);
    _this = _super.call(this);
    _this._name = name;
    _this._transport = undefined;
    _this._transportController = undefined;
    _this._onclose = _this.close.bind(sharedobject_assertThisInitialized(_this));
    _this._handleTransportStateEvents = _this._handleTransportStateEvents.bind(sharedobject_assertThisInitialized(_this));
    _this._handleMessageTransportChange = _this._handleMessageTransportChange.bind(sharedobject_assertThisInitialized(_this));
    _this.setMessageTransportController(connection);
    return _this;
  }

  /**
   * Established communication and connection to Shared Object through message transport layer.
   *
   * @param {Object} transport
   *        The Message Transport instance.
   *
   * @private
   */
  sharedobject_createClass(Red5ProSharedObject, [{
    key: "_establishTransport",
    value: function _establishTransport(transport) {
      transport.addSharedObjectResponseHandler(this);
      try {
        sharedobject_debug(this._name, '[sharedobject:connect:attempt]');
        // Immediately invoke request on shared object through the `getMessageTransport()`
        //  instance of a Publisher or Subscriber (whomever invoked this constructor).
        transport.on('*', this._handleSocketStateEvents);
        transport.getRemoteSharedObject(this._name);
        browser.addCloseHandler(this._onclose, 0);
      } catch (e) {
        sharedobject_error(this._name, '[sharedobject:connect:error]: ' + e.message);
        this._transport = undefined;
        this._transportController = undefined;
      }
    }

    /**
     * Event listener for transport change on target Message Transport Controller instance.
     *
     * @private
     */
  }, {
    key: "_handleMessageTransportChange",
    value: function _handleMessageTransportChange(event) {
      var _this2 = this;
      var controller = event.data.controller;
      var t = setTimeout(function () {
        clearTimeout(t);
        _this2.setMessageTransportController(controller);
      }, 1000);
    }

    /**
     * General state event handler from underlying socket connection.
     *
     * @private
     */
  }, {
    key: "_handleTransportStateEvents",
    value: function _handleTransportStateEvents(event) {
      sharedobject_debug(this._name, "".concat(event.name, ": ").concat(event.type));
      if (event.type === MessageTransportStateEventTypes.CLOSE) {
        this.trigger(new SharedObjectEvent(SharedObjectEventTypes.CONNECTION_CLOSED, this._name));
        this.close();
      }
    }

    /**
     * Attempt to parse message into a Object.
     *
     * @param {Object} message
     *        Either a JSON string or object.
     *
     * @private
     */
  }, {
    key: "_getJsonFromSocketMessage",
    value: function _getJsonFromSocketMessage(message) {
      try {
        return typeof message.data === 'string' ? JSON.parse(message.data) : message.data;
      } catch (e) {
        sharedobject_warn(this._name, 'Could not parse message as JSON. Message= ' + message.data + '. Error= ' + e.message);
      }
      return null;
    }

    /**
     * Dispatch of PROPERTY_UPDATE with information.
     *
     * @param {Object} valueObject
     *        Optional value object to send in notification.
     *
     * @private
     */
  }, {
    key: "_notifyOfPropertyValues",
    value: function _notifyOfPropertyValues(valueObject) {
      if (Object.keys(valueObject).length === 0) {
        this.trigger(new SharedObjectEvent(SharedObjectEventTypes.PROPERTY_UPDATE, this._name, {}));
      } else {
        var key;
        for (key in valueObject) {
          this.trigger(new SharedObjectEvent(SharedObjectEventTypes.PROPERTY_UPDATE, this._name, new PropertyData(key, valueObject[key]).toObject()));
        }
      }
    }

    /**
     * Dispatch of PROPERTY_UPDATE or METHOD_UPDATE based on event(s).
     *
     * @param {Array} events
     *        A list of events to iterate through and dispatch notifications from.
     *
     * @private
     */
  }, {
    key: "_notifyOfEvents",
    value: function _notifyOfEvents(events) {
      var i, event;
      var handled = false;
      var length = events.length;
      for (i = 0; i < length; i++) {
        event = events[i];
        switch (event.subtype) {
          case SO_SUBTYPE_REMOVE:
            this.trigger(new SharedObjectEvent(SharedObjectEventTypes.PROPERTY_REMOVE, this._name, {
              attribute: event.attribute
            }));
            handled = true;
            break;
          case SO_SUBTYPE_PROPERTY:
            if (event.attributes) {
              // We have an initial payload of attribute values.
              this._notifyOfPropertyValues(event.attributes);
            } else {
              this.trigger(new SharedObjectEvent(SharedObjectEventTypes.PROPERTY_UPDATE, this._name, new PropertyData(event.attribute, event.value).toObject()));
            }
            handled = true;
            break;
          case SO_SUBTYPE_METHOD:
            this.trigger(new SharedObjectEvent(SharedObjectEventTypes.METHOD_UPDATE, this._name, new MethodData(event.method, event.value).toObject()));
            handled = true;
            break;
        }
      }
      return handled;
    }

    /**
     * Invoked by connection channel to handle message and dispatch appropriate notifications.
     *
     * @private
     */
  }, {
    key: "respond",
    value: function respond(message) {
      if (message.data) {
        var json = this._getJsonFromSocketMessage(message);
        if (json === null) {
          sharedobject_warn(this._name, 'Determined message response not in correct format. Aborting message handle.');
          return true;
        }
        if (json.data !== undefined) {
          if (json.data.name === this._name) {
            sharedobject_debug(this._name, '[sharedobject-response]: ' + JSON.stringify(json, null, 2));
            if (json.data.status === 'SharedObject.Status.GetRemote' && json.data.message === 'Success') {
              this._transport.connectToSharedObject(this._name);
              return true;
            } else if (json.data.status === 'SharedObject.Status.GetRemote' && json.data.message === 'Fail') {
              this.trigger(new SharedObjectEvent(SharedObjectEventTypes.CONNECT_FAILURE, this._name));
              return true;
            } else if (json.data.status === 'SharedObject.Status.Connect' && json.data.message === 'Success') {
              this.trigger(new SharedObjectEvent(SharedObjectEventTypes.CONNECT_SUCCESS, this._name));
              return true;
            } else if (json.data.status === 'SharedObject.Status.Connect' && json.data.message === 'Fail') {
              this.trigger(new SharedObjectEvent(SharedObjectEventTypes.CONNECT_FAILURE, this._name));
              return true;
            } else if (json.data.status === 'SharedObject.Status.Disconnect') {
              this.trigger(new SharedObjectEvent(SharedObjectEventTypes.CONNECTION_CLOSED, this._name));
              return true;
            } else if (json.data.type === 'sharedobject') {
              if (json.data.hasOwnProperty('events')) {
                return this._notifyOfEvents(json.data.events);
              } else if (json.data.hasOwnProperty('value')) {
                return this._notifyOfPropertyValues(json.data.value);
              }
            }
          } else {
            sharedobject_debug(this._name, 'Unhandled Message exchange: ' + JSON.stringify(json, null, 2));
          }
        }
      }
      return false;
    }

    /**
     * Request to send notification to other connected clients using a target method name and object data.
     *
     * @param {String} methodName
     *        The name of the method to attempt to invoke on receiving clients.
     * @param {Object} data
     *        A data object to send along as the parameter of the target method.
     */
  }, {
    key: "send",
    value: function send(methodName, data) {
      var transport = this._transport;
      if (transport) {
        transport.sendToSharedObject(this._name, methodName, data);
      } else {
        sharedobject_warn(this._name, 'No WebSocket connection available!');
      }
    }

    /**
     * Request to update a specific property on the connected Shared Object.
     *
     * @param {String} key
     *        The property name to update.
     * @param {Object} value
     *        The value object to update the property to.
     */
  }, {
    key: "setProperty",
    value: function setProperty(key, value) {
      this._transport.sendPropertyToSharedObject(this._name, key, value);
    }

    /**
     * Request to close the established Shared Object connection. This does not close the underlying WebSocket connection.
     */
  }, {
    key: "close",
    value: function close() {
      var transport = this._transport;
      if (transport) {
        try {
          transport.closeSharedObject(this._name);
        } catch (e) {
          // nada.
        }
        transport.removeSharedObjectResponseHandler(this);
        transport.off('*', this._handleTransportStateEvents);
      }
      this._transport = undefined;
      this._transportController = undefined;
      browser.removeCloseHandler(this._onclose);
    }

    /**
     * Returns the Message Transport Controller instance
     *
     * @see #setMessageTransportController
     */
  }, {
    key: "getMessageTransportController",
    value: function getMessageTransportController() {
      return this._transportController;
    }

    /**
     * Assigns the Message Transport Controller which exposes the message transport layer on which all communication to and from the Shared Object is handled.
     *
     * @param {Object} controller
     *        The Controller for the Message Transport Layer. Exposes the method `getMessageTransport` which returns the current message transport layer.
     *
     */
  }, {
    key: "setMessageTransportController",
    value: function setMessageTransportController(controller) {
      if (this._transport) {
        this._transport.removeSharedObjectResponseHandler(this);
        this._transport.off('*', this._handleTransportStateEvents);
        browser.removeCloseHandler(this._onclose);
        this._transport = undefined;
        this._transportController = undefined;
      }
      this._transportController = controller;
      this._transport = this._transportController.getMessageTransport();
      if (this._transportController && this._transport) {
        this._transportController.on(MessageTransportStateEventTypes.CHANGE, this._handleMessageTransportChange);
        this._establishTransport(this._transport);
      }
    }

    /**
     * Return the name of the Shared Object connected to.
     *
     * @return {String}
     */
  }, {
    key: "getName",
    value: function getName() {
      return this._name;
    }
  }]);
  return Red5ProSharedObject;
}(event_emitter);
/* harmony default export */ var sharedobject = (sharedobject_Red5ProSharedObject);
// CONCATENATED MODULE: ./src/js/sharedobject/socket.js
function socket_typeof(obj) { "@babel/helpers - typeof"; return socket_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, socket_typeof(obj); }
function socket_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function socket_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, socket_toPropertyKey(descriptor.key), descriptor); } }
function socket_createClass(Constructor, protoProps, staticProps) { if (protoProps) socket_defineProperties(Constructor.prototype, protoProps); if (staticProps) socket_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function socket_toPropertyKey(arg) { var key = socket_toPrimitive(arg, "string"); return socket_typeof(key) === "symbol" ? key : String(key); }
function socket_toPrimitive(input, hint) { if (socket_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (socket_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function socket_get() { if (typeof Reflect !== "undefined" && Reflect.get) { socket_get = Reflect.get.bind(); } else { socket_get = function _get(target, property, receiver) { var base = socket_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return socket_get.apply(this, arguments); }
function socket_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = socket_getPrototypeOf(object); if (object === null) break; } return object; }
function socket_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) socket_setPrototypeOf(subClass, superClass); }
function socket_setPrototypeOf(o, p) { socket_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return socket_setPrototypeOf(o, p); }
function socket_createSuper(Derived) { var hasNativeReflectConstruct = socket_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = socket_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = socket_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return socket_possibleConstructorReturn(this, result); }; }
function socket_possibleConstructorReturn(self, call) { if (call && (socket_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return socket_assertThisInitialized(self); }
function socket_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function socket_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function socket_getPrototypeOf(o) { socket_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return socket_getPrototypeOf(o); }



// import { info, debug, warn } from '../log'

/**
 * A bare-bones Proxy for WebSocket connection to be used by Red5ProSharedObjects.
 */
var socket_Red5ProSharedObjectSocket = /*#__PURE__*/function (_SocketHelper) {
  socket_inherits(Red5ProSharedObjectSocket, _SocketHelper);
  var _super = socket_createSuper(Red5ProSharedObjectSocket);
  function Red5ProSharedObjectSocket() {
    var _this;
    var responder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
    socket_classCallCheck(this, Red5ProSharedObjectSocket);
    var uuid = Math.floor(Math.random() * 0x10000).toString(16);
    var name = "sharedobject-".concat(uuid);
    _this = _super.call(this, responder, name);
    _this.id = name;
    _this._sharedObjectName = undefined;
    return _this;
  }

  /**
   * Hijacking this to track SharedObject name for event notification.
   *
   * @private
   */
  socket_createClass(Red5ProSharedObjectSocket, [{
    key: "getRemoteSharedObject",
    value: function getRemoteSharedObject(name) {
      socket_get(socket_getPrototypeOf(Red5ProSharedObjectSocket.prototype), "getRemoteSharedObject", this).call(this, name);
      this._sharedObjectName = name;
    }

    /**
     * Initialize the WebSocket connection based on configuration properties.
     *
     * @param {Object} configuration
     *                  Configuration object used in construction WebSocket endpoint URL based on properties.
     * @param {String} id
     *                  Optional identifier for the shared object connection instance. Needs to be unique. Autogenerated if left undefined.
     * @param {Integer} capability
     *                  Optional capability enum for connection. 2 = Shared Object + WebSocket. 4 = Shared Object + RTC.
     * @return {Promise}
     */
  }, {
    key: "init",
    value: function init(configuration) {
      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var capability = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
      var socketPromise = new DeferredPromise();
      this.id = id || this.id;
      this._name = this.id;
      // capabilities is the int to notify that there is no associated rtc connection.
      var url = rtcSocketEndpointFromOptions(configuration, {
        id: this.id,
        capabilities: capability
      });
      this.setUp(url, socketPromise);
      return socketPromise.promise;
    }

    /**
     * Responds to messages coming over the WebSocket connection.
     *
     * @param {Object} message
     *
     * @private
     */
  }, {
    key: "respond",
    value: function respond(message) {
      // eslint-disable-line no-unused-vars
      if (!socket_get(socket_getPrototypeOf(Red5ProSharedObjectSocket.prototype), "respond", this).call(this, message)) {
        if (message.data) {
          var json = this.getJsonFromSocketMessage(message);
          if (json && json.data) {
            var data = json.data;
            if (data.type === 'status') {
              if (data.code === 'NetConnection.Connect.Closed') {
                // Trick into responding to disconnect through SharedObject responder.
                this.respond({
                  data: {
                    data: {
                      status: 'SharedObject.Status.Disconnect',
                      message: data.code,
                      name: this._sharedObjectName
                    }
                  }
                });
                this._sharedObjectName = undefined;
              } else if (data.code === 'NetConnection.ICE.TrickleCompleted' && this._responder) {
                this._responder.onIceTrickleComplete();
              } else if (data.code === 'NetConnection.DataChannel.Available' && this._responder) {
                this._responder.onDataChannelAvailable(data.description);
              } else if (this._responder) {
                this._responder.onSocketStatus(data);
              }
            } else if (data.sdp) {
              var sdp = data.sdp;
              if (sdp.type === 'answer' && this._responder) {
                this._responder.onSDPAnswer(sdp);
              }
            } else if (data.candidate && this._responder) {
              var candidate = data.candidate;
              this._responder.onAddIceCandidate(candidate);
            }
          }
        }
      }
    }

    /**
     * Request to close down the WebSocket connection.
     */
  }, {
    key: "close",
    value: function close() {
      this._sharedObjectName = undefined;
      this.tearDown();
    }

    /**
     * Returns reference to this instance. This is used internally to access the underlying communication channel by the SharedObject implementation.
     *
     * @private
     */
  }, {
    key: "getMessageTransport",
    value: function getMessageTransport() {
      return this;
    }

    /**
     * Returns reference to this instance. This is used internally to access the underlying communication channel by the SharedObject implementation.
     *
     * @private
     */
  }, {
    key: "getConnection",
    value: function getConnection() {
      return this;
    }
  }]);
  return Red5ProSharedObjectSocket;
}(socket_helper);
/* harmony default export */ var sharedobject_socket = (socket_Red5ProSharedObjectSocket);
// CONCATENATED MODULE: ./src/js/sharedobject/peer.js
function peer_typeof(obj) { "@babel/helpers - typeof"; return peer_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, peer_typeof(obj); }
function peer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function peer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, peer_toPropertyKey(descriptor.key), descriptor); } }
function peer_createClass(Constructor, protoProps, staticProps) { if (protoProps) peer_defineProperties(Constructor.prototype, protoProps); if (staticProps) peer_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function peer_toPropertyKey(arg) { var key = peer_toPrimitive(arg, "string"); return peer_typeof(key) === "symbol" ? key : String(key); }
function peer_toPrimitive(input, hint) { if (peer_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (peer_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function peer_get() { if (typeof Reflect !== "undefined" && Reflect.get) { peer_get = Reflect.get.bind(); } else { peer_get = function _get(target, property, receiver) { var base = peer_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return peer_get.apply(this, arguments); }
function peer_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = peer_getPrototypeOf(object); if (object === null) break; } return object; }
function peer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) peer_setPrototypeOf(subClass, superClass); }
function peer_setPrototypeOf(o, p) { peer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return peer_setPrototypeOf(o, p); }
function peer_createSuper(Derived) { var hasNativeReflectConstruct = peer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = peer_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = peer_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return peer_possibleConstructorReturn(this, result); }; }
function peer_possibleConstructorReturn(self, call) { if (call && (peer_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return peer_assertThisInitialized(self); }
function peer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function peer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function peer_getPrototypeOf(o) { peer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return peer_getPrototypeOf(o); }








var soStartRegex = /(.*) starting/i;

/**
 * A bare-bones Proxy for RTCPeerConnection to be used by Red5ProSharedObjects.
 */
var peer_Red5ProSharedObjectPeerConnection = /*#__PURE__*/function (_WebRTCPeerHelper) {
  peer_inherits(Red5ProSharedObjectPeerConnection, _WebRTCPeerHelper);
  var _super = peer_createSuper(Red5ProSharedObjectPeerConnection);
  function Red5ProSharedObjectPeerConnection() {
    var _this;
    var responder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
    peer_classCallCheck(this, Red5ProSharedObjectPeerConnection);
    var uuid = Math.floor(Math.random() * 0x10000).toString(16);
    var name = "sharedobject-".concat(uuid);
    _this = _super.call(this, responder, name);
    _this.id = name;
    _this._options = undefined;
    _this._socket = undefined;
    _this._sharedObjectName = undefined;
    _this._connectionPromise = undefined;
    return _this;
  }

  /**
   * Removes handlers assigned to the peer connection instance.
   *
   * @param {RTCPeerConnection} connection
   */
  // eslint-disable-next-line no-unused-vars
  peer_createClass(Red5ProSharedObjectPeerConnection, [{
    key: "_removeConnectionHandlers",
    value: function _removeConnectionHandlers(connection) {
      connection.onconnectionstatechange = undefined;
      connection.oniceconnectionstatechange = undefined;
      connection.onicecandidate = undefined;
      connection.ontrack = undefined;
      connection.ondatachannel = undefined;
    }

    /**
     * Assigns handlers to events on the peer connection instance.
     *
     * @param {RTCPeerConnection} connection
     * @param {Promise} promise
     *        The `Promise` to resolve or reject on success of connection.
     */
    // eslint-disable-next-line no-unused-vars
  }, {
    key: "_addConnectionHandlers",
    value: function _addConnectionHandlers(connection, promise) {
      var _this2 = this;
      var reconnectTimeout;
      var timeoutLimit = 5000;
      promise = promise || this._connectionPromise;
      connection.onconnectionstatechange = function () {
        log_debug(_this2._name, "[peer.onconnectionstatechange] - State: ".concat(connection.connectionState));
        if (connection.connectionState === 'connected') {
          log_debug(_this2._name, '[peerconnection:open]');
          // TODO: This may need to move.
          _this2.trigger(new MessageTransportStateEvent(MessageTransportStateEventTypes.OPEN, _this2._name, {
            peerConnection: _this2
          }));
        } else if (connection.connectionState === 'failed' || connection.connectionState === 'disconnected') {
          log_warn(_this2._name, '[peerconnection:error]');
          if (connection.connectionState === 'failed') {
            _this2.trigger(new MessageTransportStateEvent(MessageTransportStateEventTypes.ERROR, _this2._name, {
              peerConnection: _this2,
              error: 'Connection Failed.'
            }));
          }
          if (promise) {
            promise.reject('Connection Failed.');
          }
        }
      };
      connection.onicecandidate = function (event) {
        log_debug(_this2._name, "[peer.onicecandidate] - Peer Candidate: ".concat(event.candidate));
        if (event.candidate) {
          _this2._socket.post({
            handleCandidate: _this2._name,
            data: {
              candidate: event.candidate
            }
          });
        } else if (event.candidate === null) {
          log_debug(_this2._name, '[icecandidatetrickle:end]');
          if (promise) {
            // promise.resolve(this)
          }
        }
      };
      connection.oniceconnectionstatechange = function (event) {
        var state = connection.iceConnectionState;
        log_debug(_this2._name, "[peer.oniceconnectionstatechange] - State: ".concat(state));
        if (state === 'connected' && browser.getIsEdge()) {
          // Support for ORTC order of candidates.
          // Typically this will be invoked from a `onicegatheringstatechange` event on the Connection.
          // Edge doesn't notify on that event.
          log_debug(_this2._name, '[edge/ortc:notify complete]');
          log_debug(_this2._name, '[icecandidategathering:end]');
          _this2._socket.postEndOfCandidates(_this2._name);
        } else if (state === 'failed') {
          if (reconnectTimeout) {
            clearTimeout(reconnectTimeout);
          }
          _this2.trigger(new MessageTransportStateEvent(MessageTransportStateEventTypes.ERROR, _this2._name, {
            peerConnection: _this2,
            error: 'Connection Failed.'
          }));
          _this2.trigger(new MessageTransportStateEvent(MessageTransportStateEventTypes.CLOSE, _this2._name, {
            peerConnection: _this2,
            event: event
          }));
          if (promise) {
            promise.reject('Connection Failed.');
          }
        } else if (state === 'disconnected') {
          // may receive a disconnect temporarily that will then return to a connection.
          reconnectTimeout = setTimeout(function () {
            log_debug(_this2._name, "[peer.oniceconnectionstatechange] - Reconnect timeout reached. Closing PeerConnection.");
            clearTimeout(reconnectTimeout);
            _this2.trigger(new MessageTransportStateEvent(MessageTransportStateEventTypes.CLOSE, _this2._name, {
              peerConnection: _this2,
              event: event
            }));
          }, timeoutLimit);
        } else {
          if (reconnectTimeout) {
            log_debug(_this2._name, "[peer.oniceconnectionstatechange] - Clearing timeout for reconnect.");
            clearTimeout(reconnectTimeout);
          }
        }
      };
      connection.onicegatheringstatechange = function () {
        var state = connection.iceGatheringState;
        log_debug(_this2._name, "[peer.onicegatheringstatechange] - State: ".concat(state));
        if (state === 'complete') {
          log_debug(_this2._name, '[icecandidategathering:end]');
          _this2._socket.postEndOfCandidates(_this2._name);
        }
      };
    }
  }, {
    key: "_createOffer",
    value: function _createOffer() {
      var _this3 = this;
      var promise = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      log_debug(this._name, "[peer.createoffer]");
      this._peerConnection.createOffer().then(function (sdp) {
        log_debug(_this3._name, "[peer:offer] ".concat(sdp.sdp));
        _this3._peerConnection.setLocalDescription(sdp).then(function () {
          _this3._socket.post({
            handleOffer: _this3._name,
            transport: 'udp',
            data: {
              sdp: sdp
            }
          });
        }).catch(function (error) {
          if (promise) {
            promise.reject(error);
          }
        });
      });
    }

    /**
     * Hijacking this to track SharedObject name for event notification.
     *
     * @private
     */
  }, {
    key: "getRemoteSharedObject",
    value: function getRemoteSharedObject(name) {
      peer_get(peer_getPrototypeOf(Red5ProSharedObjectPeerConnection.prototype), "getRemoteSharedObject", this).call(this, name);
      this._sharedObjectName = name;
    }

    /**
     * Initialize the WebSocket connection based on configuration properties.
     *
     * @param {Object} configuration
     *                  Configuration object used in construction of RTCPeerConnection.
     * @param {String} id
     *                  Optional identifier for the shared object connection instance. Needs to be unique. Autogenerated if left undefined.
     * @return {Promise}
     */
  }, {
    key: "init",
    value: function init(configuration) {
      var _this4 = this;
      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var peerPromise = new DeferredPromise();
      this.id = id || this.id;
      this._name = this.id;
      this._options = configuration;
      this._socket = new sharedobject_socket(this);
      this._socket.on('MessageTransport.Open', function (event) {
        log_debug(_this4._name, "[socket:event] - ".concat(event.type));
        _this4._connectionPromise = peerPromise;
        _this4.setUpWithPeerConfiguration(configuration.rtcConfiguration, _this4.getDataChannelConfiguration(configuration)).then(function () {
          _this4._createOffer(peerPromise);
        }).catch(function (error) {
          _this4.trigger(new MessageTransportStateEvent(MessageTransportStateEventTypes.ERROR, _this4._name, {
            peerConnection: _this4,
            error: error
          }));
          peerPromise.reject(error);
        });
      });
      // Capability = 4 for RTC Connection only.
      this._socket.init(configuration, this.id, 4).catch(function (error) {
        _this4.trigger(new MessageTransportStateEvent(MessageTransportStateEventTypes.ERROR, _this4._name, {
          peerConnection: _this4,
          error: error
        }));
        peerPromise.reject(error);
      });
      return peerPromise.promise;
    }

    /**
     * Returns reference to this instance. This is used internally to access the underlying communication channel by the SharedObject implementation.
     *
     * @private
     */
  }, {
    key: "getMessageTransport",
    value: function getMessageTransport() {
      return this._socket || this;
    }

    /**
     * Returns provided or default configuration for the RTCDataChannel.
     *
     *  @param {Object} configuration
     *          The base configuration provided in `init` to check for DataChannel configuration property on.
     *
     * @private
     */
  }, {
    key: "getDataChannelConfiguration",
    value: function getDataChannelConfiguration(configuration) {
      return configuration.dataChannelConfiguration || {
        name: 'red5pro'
      };
    }

    /**
     * Returns the provided or default channel name for the RTCDataChannel.
     *
     * @param {Object} configuration
     *        The base configuration provided in `init` to check for data channel name.
     *
     * @private
     */
  }, {
    key: "getDataChannelName",
    value: function getDataChannelName(configuration) {
      var dataChannelConfiguration = configuration.dataChannelConfiguration;
      if (dataChannelConfiguration && dataChannelConfiguration.name) {
        return dataChannelConfiguration.name;
      }
      return 'red5pro';
    }

    // >> Responder Delegate Handlers.
  }, {
    key: "onIceTrickleComplete",
    value: function onIceTrickleComplete() {
      log_debug(this._name, "[peer:icetricklecomplete]");
      this._socket.post({
        startChannel: this.getDataChannelName(this._options)
      });
    }
  }, {
    key: "onAddIceCandidate",
    value: function onAddIceCandidate(candidate) {
      log_debug(this._name, "[peer:addicecandidate]");
      if (!isObjectEmpty(candidate.candidate)) {
        this._peerConnection.addIceCandidate(candidate);
      } else {
        log_debug(this._name, "[peer:onemptycandidate]");
      }
    }
  }, {
    key: "onSDPAnswer",
    value: function onSDPAnswer(sdp) {
      var _this5 = this;
      log_debug(this._name, "[peer:handleanswer]");
      this._peerConnection.setRemoteDescription(new RTCSessionDescription(sdp)).then(function () {
        //
      }).catch(function (error) {
        _this5.trigger(new MessageTransportStateEvent(MessageTransportStateEventTypes.ERROR, _this5._name, {
          peerConnection: _this5,
          error: error
        }));
        _this5._connectionPromise.reject(error);
      });
    }
  }, {
    key: "onDataChannelAvailable",
    value: function onDataChannelAvailable(channelName) {
      this._socket.sever({
        switchChannel: channelName || 'red5pro'
      });
      this._socket = undefined;
      this._connectionPromise.resolve(this);
    }
  }, {
    key: "onSocketStatus",
    value: function onSocketStatus(statusData) {
      if (statusData.message) {
        var startResult = soStartRegex.exec(statusData.message);
        log_debug(this._name, "[peer:status] ".concat(statusData.message));
        if (startResult && startResult.length > 1) {
          //        const name = startResult[1] 
          //        const isPeerName = name === this._name
          //        const isDCName = name === this.getDataChannelName(this._options)
          //        this._connectionPromise.resolve(this)
        }
      }
    }
    // << Responder Delegate Handlers.
  }]);
  return Red5ProSharedObjectPeerConnection;
}(webrtc_helper);
/* harmony default export */ var sharedobject_peer = (peer_Red5ProSharedObjectPeerConnection);
// CONCATENATED MODULE: ./src/js/sharedobject/index.js




// CONCATENATED MODULE: ./src/js/conference/participant.js
function participant_typeof(obj) { "@babel/helpers - typeof"; return participant_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, participant_typeof(obj); }
function participant_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function participant_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, participant_toPropertyKey(descriptor.key), descriptor); } }
function participant_createClass(Constructor, protoProps, staticProps) { if (protoProps) participant_defineProperties(Constructor.prototype, protoProps); if (staticProps) participant_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function participant_toPropertyKey(arg) { var key = participant_toPrimitive(arg, "string"); return participant_typeof(key) === "symbol" ? key : String(key); }
function participant_toPrimitive(input, hint) { if (participant_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (participant_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function participant_get() { if (typeof Reflect !== "undefined" && Reflect.get) { participant_get = Reflect.get.bind(); } else { participant_get = function _get(target, property, receiver) { var base = participant_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return participant_get.apply(this, arguments); }
function participant_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = participant_getPrototypeOf(object); if (object === null) break; } return object; }
function participant_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) participant_setPrototypeOf(subClass, superClass); }
function participant_setPrototypeOf(o, p) { participant_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return participant_setPrototypeOf(o, p); }
function participant_createSuper(Derived) { var hasNativeReflectConstruct = participant_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = participant_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = participant_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return participant_possibleConstructorReturn(this, result); }; }
function participant_possibleConstructorReturn(self, call) { if (call && (participant_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return participant_assertThisInitialized(self); }
function participant_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function participant_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function participant_getPrototypeOf(o) { participant_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return participant_getPrototypeOf(o); }




var participant_pubStartRegex = /participant (.*) starting (.*)/i;
// const pubStopRegex = /participant (.*) stopping (.*)/i
var participant_pubStopRegex = /Leaving group (.*)/i;
var participant_NAME = 'RTCConferenceParticipant';
var DEFAULT_GROUP_NAME = 'group01';
var GROUP_TRACK_COUNT = 3;

// Builds off the default configuration for RTCPublisher
var defaultConfiguration = {
  groupName: DEFAULT_GROUP_NAME,
  autoGenerateMediaStream: true,
  mixAudioDown: false
};
var participant_RTCConferenceParticipant = /*#__PURE__*/function (_RTCPublisher) {
  participant_inherits(RTCConferenceParticipant, _RTCPublisher);
  var _super = participant_createSuper(RTCConferenceParticipant);
  function RTCConferenceParticipant() {
    var _this;
    participant_classCallCheck(this, RTCConferenceParticipant);
    _this = _super.call(this);
    _this._name = participant_NAME;
    _this._audioTracks = [];
    _this._videoTracks = [];
    _this._conferenceStream = undefined;
    //    this._audioStream = undefined
    //    this._audioElement = undefined
    return _this;
  }

  /**
   * Creates an `audio`DOM  element.
   *
   * @private
   */
  participant_createClass(RTCConferenceParticipant, [{
    key: "_createAudioElement",
    value: function _createAudioElement() {
      var audioElement = document.createElement('audio');
      //        audioElement.style.display = 'none'
      audioElement.id = 'red5pro-audio';
      audioElement.controls = 'controls';
      audioElement.autoplay = 'autoplay';
      audioElement.playsinline = 'playsinline';
      return audioElement;
    }

    /**
     * Stuff the media stream with additional audio tracks for SDP negotiation.
     *
     * @param {MediaStream} stream
     * @param {Number} amount
     *
     * @private
     */
  }, {
    key: "_packStreamWithAudio",
    value: function _packStreamWithAudio(stream, amount) {
      var v = stream.getVideoTracks()[0].clone();
      stream.addTrack(v);
      while (--amount > -1) {
        var context = new AudioContext();
        var dest = context.createMediaStreamDestination();
        context.createMediaStreamSource(stream).connect(dest);
        stream.addTrack(dest.stream.getAudioTracks()[0]);
      }
    }

    /**
     * Request to generate offer on Peer Connection instance.
     * Override to support SDP stripping.
     *
     * @param {Object} bandwidth
     *        Optional bandwidth configuration object to munge SDP.
     * @return {Promise}
     *        The promise will resolve/reject a success in creation of the offer through the Peer Connection.
     *
     * @private
     */
  }, {
    key: "_createOffer",
    value: function _createOffer() {
      var bandwidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var forceVP8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      log_debug('[createoffer]');
      this._offerFuture = undefined;
      this._offerFuture = Future.createIfNotExist(this._offerFuture);
      this._peerHelper.createOffer(bandwidth, forceVP8, true, this._offerFuture);
      return this._offerFuture.promise;
    }

    /**
     * Request to send offer on WebSocket instance.
     * Override to request join.
     *
     * @param {Object} sdp
     *        Object describing the Session Description.
     * @param {string} streamName
     *        The unique stream name of the broadcast.
     * @param {String} transport
     *        The transport type.
     * @return {Promise}
     *        The promise will resolve/reject on the success of delivering an offer over the WebSocket.
     *
     * @private
     */
  }, {
    key: "_sendOffer",
    value: function _sendOffer(sdp, streamName, transport) {
      var groupName = this._options.groupName;
      this._sendOfferFuture = undefined;
      this._sendOfferFuture = Future.createIfNotExist(this._sendOffFuture);
      this._socketHelper.post({
        joinGroup: groupName,
        streamName: streamName,
        transport: transport,
        data: {
          sdp: sdp
        }
      });
      return this._sendOfferFuture.promise;
    }

    /**
     * Request on WebSocket to begin publishing.
     * Override to bypass publish POST.
     *
     * @param {string} streamName
     *        The unique stream name of the broadcast.
     * @param {string} mode
     *        The broadcast mode: `live`, `record` or `append`.
     * @param {int} framerate
     *        The key framerate to broadcast at.
     * @return {Promise}
     *        The promise will resolve/reject in the request to being a broadcast.
     *
     * @private
     */
    // eslint-disable-next-line no-unused-vars
  }, {
    key: "_requestPublish",
    value: function _requestPublish(streamName, streamMode, keyFramerate) {
      var autoGenerateMediaStream = this._options.autoGenerateMediaStream;
      // A Conference Participant does not request to start a broadcast stream.
      this._publishFuture = undefined;
      this._publishFuture = Future.createIfNotExist(this._publishFuture);
      this._publishFuture.resolve();
      if (autoGenerateMediaStream) {
        this._conferenceStream = this._startReceivers();
        this.trigger(new RTCConferenceParticipantEvent(RTCConferenceParticipantEventTypes.MEDIA_STREAM, this, {
          stream: this._conferenceStream
        }));
      }
      return this._publishFuture.promise;
    }

    /**
     * Request to stop a broadcast.
     * The returned `Promise` will either resolve or reject on successful stop of broadcast.
     * Override to stop conference stream
     *
     * @return {Promise}
     */
  }, {
    key: "unpublish",
    value: function unpublish() {
      if (this._conferenceStream) {
        this._conferenceStream.getTracks().forEach(function (t) {
          return t.stop();
        });
      }
      return participant_get(participant_getPrototypeOf(RTCConferenceParticipant.prototype), "unpublish", this).call(this);
    }

    /**
     * Request to stop a current broadcast.
     * Override to request unjoin.
     *
     * @param {String} streamName
     *        The unique stream name being broadcast on.
     * @return {Promise}
     *        The promise will resolve/reject on success of properly stopping a broadcast.
     *
     * @private
     */
    // eslint-disable-next-line no-unused-vars
  }, {
    key: "_requestUnpublish",
    value: function _requestUnpublish(streamName) {
      var groupName = this._options.groupName;
      this._unpublishFuture = undefined;
      this._unpublishFuture = Future.createIfNotExist(this._unpublishFuture);
      // If we get a false response from trying to send a close POST,
      //  it means that the socket has already been closed by another impetus -
      //  most likley loss of network or server failure.
      if (!this.getMessageTransport().postUnjoin(groupName, streamName)) {
        this._unpublishFuture.resolve();
      }
      return this._unpublishFuture.promise;
    }

    /**
     * Starts moving stored tracks to single MediaStream out.
     *
     * @return {MediaStream}
     * @private
     */
  }, {
    key: "_startReceivers",
    value: function _startReceivers() {
      var receiverTracks = this.getPeerConnection().getTransceivers().map(function (t) {
        if (t.currentDirection === 'recvonly') {
          return t.receiver.track;
        }
        return undefined;
      }).filter(function (t) {
        return t;
      });
      var mixAudioDown = this._options.mixAudioDown;
      var stream;
      var mediaStream = this._conferenceStream || new MediaStream();
      if (!mixAudioDown) {
        // OPTION a - Add each track as singular track to one MediaStream
        receiverTracks.forEach(function (t) {
          return mediaStream.addTrack(t);
        });
      } else {
        // OPTION A - Mix all tracks into a single MediaStream + single AudioTrack
        var ac = new AudioContext();
        // WebAudio MediaStream sources only use the first track.
        var sources = receiverTracks.map(function (t) {
          if (t.kind === 'audio') {
            return ac.createMediaStreamSource(new MediaStream([t]));
          }
          return undefined;
        }).filter(function (t) {
          return t;
        });
        // The destination will output one track of mixed audio.
        var dest = ac.createMediaStreamDestination();
        // Mixing
        sources.forEach(function (s) {
          return s.connect(dest);
        });
        stream = dest.stream;
        stream.getTracks().forEach(function (t) {
          return mediaStream.addTrack(t);
        });
      }
      receiverTracks.forEach(function (t) {
        if (t.kind === 'video') {
          mediaStream.addTrack(t);
        }
      });
      return mediaStream;
    }

    /**
     * Request to initialize the WebRTC-based Publisher based on configuration.
     * The returned `Promise` will either resolve with a reference to this instance or reject with an error `String` in failure.
     * Override to assign groupName if not set.
     *
     * @param {Object} options
     *        The initialization configuration map.
     * @return {Promise}
     */
  }, {
    key: "init",
    value: function init(options) {
      return participant_get(participant_getPrototypeOf(RTCConferenceParticipant.prototype), "init", this).call(this, Object.assign(defaultConfiguration, options));
    }

    /**
     * Request to initialize the WebRTC-based Publisher based on configuration and MediaStream.
     * The returned `Promise` will either resolve with a reference to this instance or reject with an error `String` in failure.
     * Override to assign groupName if not set.
     *
     * @param {Object} options
     *        The initialization configuration map.
     * @param {MediaStream} stream
     *        The already established MediaStream.
     * @return {Promise}
     */
  }, {
    key: "initWithStream",
    value: function initWithStream(options, stream) {
      return participant_get(participant_getPrototypeOf(RTCConferenceParticipant.prototype), "initWithStream", this).call(this, Object.assign(defaultConfiguration, options), stream);
    }

    /**
     * Event handler for track add on PeerConnection.
     *
     * @private
     */
  }, {
    key: "onPeerConnectionTrackAdd",
    value: function onPeerConnectionTrackAdd(track) {
      var autoGenerateMediaStream = this._options.autoGenerateMediaStream;
      if (autoGenerateMediaStream && track.kind === 'audio') {
        this._audioTracks.push(track);
      } else if (autoGenerateMediaStream && track.kind === 'video') {
        this._videoTracks.push(track);
      }
      participant_get(participant_getPrototypeOf(RTCConferenceParticipant.prototype), "onPeerConnectionTrackAdd", this).call(this, track);
    }

    /**
     * Receipt of MediaStream from gUM.
     * Override to pack with conference audio tracks on SDP.
     *
     * @private
     */
  }, {
    key: "_onMediaStreamReceived",
    value: function _onMediaStreamReceived(mediaStream) {
      this._packStreamWithAudio(mediaStream, GROUP_TRACK_COUNT);
      participant_get(participant_getPrototypeOf(RTCConferenceParticipant.prototype), "_onMediaStreamReceived", this).call(this, mediaStream);
    }

    /**
     * Event handler for success in SDP answer over WebSocket.
     * Override to re-assign participant.
     *
     * @private
     */
  }, {
    key: "onSDPAnswer",
    value: function onSDPAnswer(sdp) {
      var streamName = this._options.streamName;
      // Flip streamName to participant id for further ICE negotiation.
      this.overlayOptions({
        streamName: sdp.participantId,
        participantId: sdp.participantId,
        publisherName: streamName
      });
      this._sendOfferFuture = Future.createIfNotExist(this._sendOfferFuture);
      this._sendOfferFuture.resolve(sdp);
    }

    /**
     * Publisher status event handler for start and stop of this Publisher instance.
     * Override for regex on messaging.
     *
     * @private
     */
  }, {
    key: "onPublisherStatus",
    value: function onPublisherStatus(status) {
      log_debug(this._name, '[publisherstatus] - ' + JSON.stringify(status, null, 2));
      var stopResult = participant_pubStopRegex.exec(status.message);
      var startResult = participant_pubStartRegex.exec(status.message);
      if (stopResult && stopResult[1] === this._options.groupName) {
        this._unpublishFuture.resolve();
      } else if (startResult && startResult[1] === this._options.streamName) {
        this._publishFuture.resolve();
      } else {
        log_warn(this._name, 'Publisher status received, but could not handle.');
      }
    }
  }]);
  return RTCConferenceParticipant;
}(publisher_red5pro_rtc);
/* harmony default export */ var participant = (participant_RTCConferenceParticipant);
// CONCATENATED MODULE: ./src/js/index.js
/**
 * Main entry of SDK, accessible on the `window` global at `red5prosdk`.
 *
 * @file red5pro.min.js
 * @module red5prosdk
 *
 *
 */

// SDK_VERSION, LOG_LEVEL injected from webpack build.
















/**
 * A Conference Participant is an RTCPublisher that can consume multiple audio tracks.
 */


/* ----------------------------  */
/* Subscription related references. */
/* ----------------------------  */

/**
 * The fail-over enabled Subscriber Factory.
 * @see Red5ProSubscriber
 */
var js_Red5ProSubscriber = subscriber_Red5ProSubscriber;
/**
 * The WebRTC based Subscriber.
 *
 * An instance of `RTCSubscriber` can be created explicitly using this class, or by the `Red5ProSubscriber` fail-over factory.
 * @see RTCSubscriber
 */
var js_RTCSubscriber = red5pro_rtc;
/**
 * The WebRTC based Subscriber supporting WHEP signaling.
 * @see WHEPClient
 */
var js_WHEPClient = red5pro_whep;
/**
 * The Flash (utilizing RTMP protocol) based Subscriber.
 *
 * An instance of `RTMPSubscriber` can be created explicitly using this class, or by the `Red5ProSubscriber` fail-over factory.
 * @see RTMPSubscriber
 */
var js_RTMPSubscriber = red5pro_rtmp;
/**
 * The HLS (HTTP Live Stream) based Subscriber.
 *
 * An instance of `HLSSubscriber` can be created explicitly using this class, or by the `Red5ProSubscriber` fail-over factory.
 * @see HLSSubscriber
 */
var js_HLSSubscriber = red5pro_hls;
/**
 * Still used, but API-deprecated View instance for playback. Has default setup in version 4.0.0.
 * @private
 */


/* ----------------------------  */
/* Broadcast related references. */
/* ----------------------------  */

/**
 * The fail-over enabled Publisher Factory.
 * @see Red5ProPublisher
 */
var js_Red5ProPublisher = publisher_Red5ProPublisher;
/**
 * The WebRTC based Publisher.<br>An instance of `RTCPublisher` can be created explicitly using this class, or by the `Red5ProPublisher` fail-over factory.
 * @see RTCPublisher
 */
var js_RTCPublisher = publisher_red5pro_rtc;
/**
 * The WebRTC based Publisher supporting WHIP signaling.
 * @see WHIPClient
 */
var js_WHIPClient = red5pro_whip;
/**
 * The Flash (utilizing RTMP protocol) based Publisher.
 *
 * An instance of `RTMPPublisher` can be created explicitly using this class, or by the `Red5ProPublisher` fail-over factory.
 * @see RTMPPublisher
 */
var js_RTMPPublisher = publisher_red5pro_rtmp;
/**
 * Still used, but API-deprecated View instance for broadcast/preview. Has default setup in version 4.0.0.
 * @private
 */


/* Playback controls interface. */


/* Shared Object references. */
/**
 * The ShardObject class.
 * @see Red5ProSharedObject
 */
var js_Red5ProSharedObject = sharedobject;

/**
 * The SharedObject Socket Proxy class.
 * @see Red5ProSharedObjectSocket
 */
var js_Red5ProSharedObjectSocket = sharedobject_socket;

/**
 * The SharedObject PeerConnection Proxy class.
 * @see Red5ProSharedObjectPeerConnection
 */
var js_Red5ProSharedObjectPeerConnection = sharedobject_peer;

/* Events */
/**
 * Enumeration of common Publisher Events.
 */
var js_PublisherEventTypes = PublisherEventTypes;
/**
 * Enueration of events specific to WebRTC-based Publishers.
 */
var js_RTCPublisherEventTypes = RTCPublisherEventTypes;
/**
 * Enumeration of events specific to fail-over Publisher factory.
 */
var js_FailoverPublisherEventTypes = FailoverPublisherEventTypes;
/**
 * Enumeraiton of common Subscriber Events.
 */
var js_SubscriberEventTypes = SubscriberEventTypes;
/**
 * Enumeration of events specific to WebRTC-based Subscribers.
 */
var js_RTCSubscriberEventTypes = RTCSubscriberEventTypes;
/**
 * Enumeration of events specific to RTMP-based Subscribers.
 */
var js_RTMPSubscriberEventTypes = RTMPSubscriberEventTypes;
/**
 * Enumeration of events specific to fail-over Subscriber factory.
 */
var js_FailoverSubscriberEventTypes = FailoverSubscriberEventTypes;
/**
 * Enumeration of events for Shared Objects.
 */
var js_SharedObjectEventTypes = SharedObjectEventTypes;
/**
 * Enumeration of events for WebSocket state.
*/
var js_MessageTransportStateEventTypes = MessageTransportStateEventTypes;
/**
 * Enumeration of events for RTCConferenceParticipant.
 */
var RTCConferenceParticipantEventType = RTCConferenceParticipantEventTypes;

/* Enums */
/**
 * Enumerate Audio Encoder options for Subscribers.
 *  * `OPUS`
 *  * `PCMU`
 *  * `PCMA`
 *  * `SPEEX`
 *  * `NONE`
 */
var js_PlaybackAudioEncoder = PlaybackAudioEncoder;
/**
 * Enumerated Video Encoder options for Subscribers.
 *  * `VP8`
 *  * `H264`
 *  * `NONE`
 */
var js_PlaybackVideoEncoder = PlaybackVideoEncoder;

/**
 * Enumerate ICE Transport options for Publishers and Subscribers.
 * * `UDP`
 * * `TCP`
 */
var js_IceTransportTypes = IceTransportTypes;
log_establishLogger("".concat("debug") || false); // eslint-disable-line no-undef

/**
 * Sets the log level for logs from the SDK
 * @param {string} level
 *    The specified log level.
 * @param {Boolean} record
 *    Flag to store all for access.
 * @see LOG_LEVELS
 */
var js_setLogLevel = function setLogLevel(level) {
  var record = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (LEVELS.hasOwnProperty(level.toUpperCase())) {
    log_establishLogger(level, record);
    if (console) {
      console.log("Red5 Pro SDK Version ".concat("10.10.0")); // eslint-disable-line no-undef,no-console
    }
  }
};

/**
 * Access of stored logs if specified `record` parameter of `setLogLevel`
 *
 * @return {Array}
 * @see setLogLevel
 */


/**
 * The enumerated log level Strings.
 *    * `TRACE`
 *    * `INFO`
 *    * `DEBUG`
 *    * `WARN`
 *    * `ERROR`
 *    * `FATAL`
 */
var LOG_LEVELS = LEVELS;
/**
 * Retrieves the Logger instance used by the SDK.
 *
 * @returns {Logger}
 *          The logger.
 */
var js_getLogger = getLogger;

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWQ1cHJvc2RrL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9yZWQ1cHJvc2RrL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9ub2RlX21vZHVsZXMvYnJvd3Nlci1idW55YW4vbGliL2J1bnlhbi5qcyIsIndlYnBhY2s6Ly9yZWQ1cHJvc2RrLy4vc3JjL2pzL2xvZy9idW55YW4td3JpdGVyLmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvbG9nL2luZGV4LmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvdXRpbC9wcm9taXNlLmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvdXRpbC9pbXBsLWZhY3Rvcnktb3JkZXIuanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9jb3JlL2V2ZW50LWVtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9leGNlcHRpb24vZXJyb3JzLmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvZW52L21ldGFkYXRhLXV0aWwuanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9lbnYvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9yZWQ1cHJvc2RrLy4vc3JjL2pzL2Vudi90cmFuc2xhdGlvbi11dGlsLmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvdXRpbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZWQ1cHJvc2RrLy4vc3JjL2pzL3V0aWwvb2JqZWN0LmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvYWRhcHRlci93ZWJydGMuanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9hZGFwdGVyL3dlYnNvY2tldC5qcyIsIndlYnBhY2s6Ly9yZWQ1cHJvc2RrLy4vc3JjL2pzL2V2ZW50L3B1Ymxpc2hlci1ldmVudC5qcyIsIndlYnBhY2s6Ly9yZWQ1cHJvc2RrLy4vc3JjL2pzL2V2ZW50L3N1YnNjcmliZXItZXZlbnQuanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9ldmVudC9zaGFyZWRvYmplY3QtZXZlbnQuanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9ldmVudC9tZXNzYWdlLXRyYW5zcG9ydC1ldmVudC5qcyIsIndlYnBhY2s6Ly9yZWQ1cHJvc2RrLy4vc3JjL2pzL2V2ZW50L3BhcnRpY2lwYW50LWV2ZW50LmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvZXZlbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9zdWJzY3JpYmVyL2NvbnRyb2xzL2V2ZW50LmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvc3Vic2NyaWJlci9jb250cm9scy9zbGlkZXIuanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9zdWJzY3JpYmVyL2NvbnRyb2xzL3N0YXRlLmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvc3Vic2NyaWJlci9jb250cm9scy9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZWQ1cHJvc2RrLy4vc3JjL2pzL3N1YnNjcmliZXIvcmVkNXByby1zb3VyY2UtaGFuZGxlci1ydGMuanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8tc291cmNlLWhhbmRsZXItcnRjLXNlZWthYmxlLmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvaGVscGVyL21lc3NhZ2UtdHJhbnNwb3J0LmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvaGVscGVyL3NvY2tldC1oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9oZWxwZXIvc29ja2V0LWhlbHBlci1zdWIuanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9oZWxwZXIvd2VicnRjLWhlbHBlci5qcyIsIndlYnBhY2s6Ly9yZWQ1cHJvc2RrLy4vc3JjL2pzL2hlbHBlci93ZWJydGMtaGVscGVyLXN1Yi5qcyIsIndlYnBhY2s6Ly9yZWQ1cHJvc2RrLy4vc3JjL2pzL3ZpZXcvcGxheWJhY2suanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy91dGlsL3VybC1lbmRwb2ludC5qcyIsIndlYnBhY2s6Ly9yZWQ1cHJvc2RrLy4vc3JjL2pzL2VudW0vcGxheWJhY2suanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9lbnVtL3dlYnJ0Yy5qcyIsIndlYnBhY2s6Ly9yZWQ1cHJvc2RrLy4vc3JjL2pzL3N1YnNjcmliZXIvcmVkNXByby1ydGMuanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9lbnYvZW1iZWQuanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9oZWxwZXIvc2hhcmVkb2JqZWN0LWhlbHBlci1ydG1wLmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvc3Vic2NyaWJlci9yZWQ1cHJvLXNvdXJjZS1oYW5kbGVyLXJ0bXAuanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8tcnRtcC5qcyIsIndlYnBhY2s6Ly9yZWQ1cHJvc2RrLy4vc3JjL2pzL3N1YnNjcmliZXIvcmVkNXByby1zb3VyY2UtaGFuZGxlci1obHMuanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8taGxzLmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvaGVscGVyL3doaXB3aGVwLXNpZ25hbGluZy1oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8td2hlcC5qcyIsIndlYnBhY2s6Ly9yZWQ1cHJvc2RrLy4vc3JjL2pzL3N1YnNjcmliZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9wdWJsaXNoZXIvcHViLXNvdXJjZS1oYW5kbGVyLmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvdmlldy9wdWJsaXNoLmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvZW51bS9wdWJsaXNoLmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvcHVibGlzaGVyL2NvbnN0cmFpbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9wdWJsaXNoZXIvcmVkNXByby1ydG1wLmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvaGVscGVyL3NvY2tldC1oZWxwZXItcHViLmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvaGVscGVyL3dlYnJ0Yy1oZWxwZXItcHViLmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvcHVibGlzaGVyL3JlZDVwcm8tcnRjLmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvcHVibGlzaGVyL3JlZDVwcm8td2hpcC5qcyIsIndlYnBhY2s6Ly9yZWQ1cHJvc2RrLy4vc3JjL2pzL3B1Ymxpc2hlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZWQ1cHJvc2RrLy4vc3JjL2pzL3NoYXJlZG9iamVjdC9zaGFyZWRvYmplY3QuanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9zaGFyZWRvYmplY3Qvc29ja2V0LmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvc2hhcmVkb2JqZWN0L3BlZXIuanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9zaGFyZWRvYmplY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmVkNXByb3Nkay8uL3NyYy9qcy9jb25mZXJlbmNlL3BhcnRpY2lwYW50LmpzIiwid2VicGFjazovL3JlZDVwcm9zZGsvLi9zcmMvanMvaW5kZXguanMiXSwibmFtZXMiOlsiUmF3U3RyZWFtIiwicmVjIiwiY29uc29sZSIsImxvZyIsInRpbWUiLCJ0b0lTT1N0cmluZyIsIm5hbWUiLCJuYW1lRnJvbUxldmVsIiwibGV2ZWwiLCJtc2ciLCJsb2dnZXIiLCJzdG9yZSIsImZvcm1hdE1lc3NhZ2UiLCJkaXNwYXRjaGVyIiwibWVzc2FnZSIsImRlY29yYXRlIiwic291cmNlIiwiTEVWRUxTIiwiVFJBQ0UiLCJJTkZPIiwiREVCVUciLCJXQVJOIiwiRVJST1IiLCJGQVRBTCIsImVzdGFibGlzaExvZ2dlciIsInJlY29yZCIsInN0cmVhbUxpc3QiLCJ1bmRlZmluZWQiLCJzdHJlYW1zIiwicHVzaCIsInN0cmVhbSIsInR5cGUiLCJsaXN0IiwibWFwIiwiaXRlbSIsImNvbmNhdCIsIndyaXRlIiwiY3JlYXRlTG9nZ2VyIiwiZ2V0TG9nZ2VyIiwiZ2V0UmVjb3JkZWRMb2dzIiwidHJhY2UiLCJpbmZvIiwiZGVidWciLCJ3YXJuIiwiZXJyb3IiLCJmYXRhbCIsIl9EZWZlcnJlZFByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicHJvbWlzZSIsIlByb21pc2UiLCJfRnV0dXJlIiwiY3JlYXRlSWZOb3RFeGlzdCIsImRlZmVycmVkSWZFeGlzdCIsImYiLCJEZWZlcnJlZFByb21pc2UiLCJGdXR1cmUiLCJXZWFrTWFwIiwicHZ0IiwiY3R4IiwiaGFzIiwic2V0IiwiZ2V0IiwiSW1wbEZhY3RvcnlPcmRlciIsImxpc3RvcmRlciIsImxlbmd0aCIsInNoaWZ0IiwiZmluZCIsIml0ZXJhdG9yIiwib3B0aW9ucyIsImluaXRGbiIsImxhc3RFcnJvciIsIm5leHQiLCJJbXBsIiwicCIsInNyYyIsInRoZW4iLCJjb25jcmV0ZSIsImNhdGNoIiwib3JkZXIiLCJrZXkiLCJkb25lIiwidmFsdWUiLCJzbGljZSIsIldJTERDQVJEIiwiV0lMRENBUkRfS0VZIiwiRXZlbnRFbWl0dGVyIiwiX2NhbGxiYWNrcyIsImNhbGxiYWNrcyIsImV2ZW50IiwiaSIsImZuIiwiaW5kZXhPZiIsImluZGV4Iiwic3BsaWNlIiwiX25vdGlmeSIsIk5vRWxlbWVudEZvdW5kRXJyb3IiLCJOb1N1cHBvcnRlZENhbWVyYVJlc29sdXRpb25zRXJyb3IiLCJqc29uQXR0ciIsImpzb25WYWwiLCJtZXRhZGF0YU1hcCIsInJlYWRVVEYiLCJkYXRhIiwic3RhcnQiLCJsZW4iLCJyZXN1bHQiLCJvZmZzZXQiLCJlbmQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJwYXJzZUpTT05Gb3JQcm9wZXJ0eSIsInRleHQiLCJwcm9wZXJ0eSIsIkpTT04iLCJwYXJzZSIsImUiLCJtYXRjaCIsImV4ZWMiLCJtYXRjaDIiLCJwYXJzZUpTT05Gb3JPcmllbnRhdGlvbiIsIm9yaWVudGF0aW9uIiwicGFyc2VJbnQiLCJwYXJzZUpTT05Gb3JTdHJlYW1pbmdNb2RlIiwic3RyZWFtaW5nTW9kZSIsImdldE1ldGFkYXRhTWFwRm9yUGxheWVyIiwicGxheWVyIiwiZW5hYmxlTWV0YWRhdGFNb25pdG9yIiwidGV4dFRyYWNrcyIsImFkZFRleHRUcmFjayIsImFkZEV2ZW50TGlzdGVuZXIiLCJhZGRUcmFja0V2ZW50IiwidHJhY2siLCJtb2RlIiwiY3VlQ2hhbmdlRXZlbnQiLCJjdWVzIiwiY3VycmVudFRhcmdldCIsImFjdGl2ZUN1ZXMiLCJzaXplIiwiZm9yRWFjaCIsIm9uT3JpZW50YXRpb25NZXRhZGF0YSIsImNhbGxiYWNrIiwiaGFzT3duUHJvcGVydHkiLCJvblN0cmVhbWluZ01vZGVNZXRhZGF0YSIsInJlbW92ZVBsYXllckRlbGVnYXRlcyIsImRlbGV0ZSIsInJ0bXBTdWJzY3JpYmVyQXNzaWdubWVudHMiLCJmdWxsc2NyZWVuSGFuZGxlcnMiLCJzY3JlZW5mdWxsSGFuZGxlckFzc2lnbmVkIiwiZW5hYmxlU2NyZWVuZnVsbEhhbmRsZXIiLCJ3aW5kb3ciLCJzY3JlZW5mdWxsIiwiZW5hYmxlZCIsIm9uY2hhbmdlIiwiaXNGdWxsc2NyZWVuIiwib3JpZW50YXRpb25IYW5kbGVycyIsIm9ub3JpZW50YXRpb25jaGFuZ2UiLCJzY3JlZW5PcmllbnRhdGlvbiIsInNjcmVlbiIsImFuZ2xlIiwib3JpZW50YXRpb25WYWx1ZSIsIm1hdGNoTWVkaWEiLCJtYXRjaGVzIiwiY2xvc2VIYW5kbGVycyIsImhhc09uV2luZG93Q2xvc2UiLCJvbndpbmRvd2Nsb3NlIiwiZmxhc2hWZXJzaW9uIiwidmVyc2lvbiIsIkFjdGl2ZVhPYmplY3QiLCJHZXRWYXJpYWJsZSIsInJlcGxhY2UiLCJuYXZpZ2F0b3IiLCJtaW1lVHlwZXMiLCJlbmFibGVkUGx1Z2luIiwicGx1Z2lucyIsImRlc2NyaXB0aW9uIiwiZXJyIiwic3BsaXQiLCJyZXF1ZXN0RnJhbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsInNldFRpbWVvdXQiLCJoYXNBZGFwdGVyU2hpbSIsImFkYXB0ZXIiLCJpc01veiIsIm1vekdldFVzZXJNZWRpYSIsImlzSUUiLCJkb2N1bWVudCIsImRvY3VtZW50TW9kZSIsImlzRWRnZSIsImJyb3dzZXJEZXRhaWxzIiwiYnJvd3NlciIsInRvTG93ZXJDYXNlIiwiU3R5bGVNZWRpYSIsImlzVG91Y2hFbmFibGVkIiwiRG9jdW1lbnRUb3VjaCIsImdldFVzZXJNZWRpYSIsIm1lZGlhRGV2aWNlcyIsIndlYmtpdEdldFVzZXJNZWRpYSIsIm1zR2V0VXNlck1lZGlhIiwiZ2V0SXNNb3oiLCJnZXRJc0VkZ2UiLCJzdXBwb3J0c1dlYlNvY2tldCIsIldlYlNvY2tldCIsInN1cHBvcnRzSExTIiwiZWwiLCJjcmVhdGVFbGVtZW50IiwiY2FuUGxheVR5cGUiLCJzdXBwb3J0c05vbk5hdGl2ZUhMUyIsIkhscyIsImlzU3VwcG9ydGVkIiwiY3JlYXRlSExTQ2xpZW50Iiwib3B0IiwiZ2V0SExTQ2xpZW50RXZlbnRFbnVtIiwiRXZlbnRzIiwic3VwcG9ydHNGbGFzaFZlcnNpb24iLCJkZWxpbWl0ZXIiLCJyZXNvbHZlRWxlbWVudCIsImlkIiwiZ2V0RWxlbWVudEJ5SWQiLCJjcmVhdGVXZWJTb2NrZXQiLCJ1cmwiLCJzZXRWaWRlb1NvdXJjZSIsInZpZGVvRWxlbWVudCIsIm1lZGlhU3RyZWFtIiwiYXV0b3BsYXkiLCJzcmNPYmplY3QiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJtYXliZVByb21pc2UiLCJwbGF5Iiwic2V0QXR0cmlidXRlIiwicGF1c2UiLCJpbmplY3RTY3JpcHQiLCJkZmQiLCJzY3JpcHQiLCJvbmxvYWQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJhcHBlbmRDaGlsZCIsImdVTSIsImNvbnN0cmFpbnRzIiwic2V0R2xvYmFsIiwicHJvcCIsImdldFN3Zk9iamVjdCIsInN3Zm9iamVjdCIsImdldEVtYmVkT2JqZWN0IiwiZ2V0RWxlbWVudElkIiwiZ2V0QXR0cmlidXRlIiwiYWRkT3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyIiwiaGFuZGxlciIsImFuZENhbGwiLCJzdXBwb3J0c09yaWVudGF0aW9uQ2hhbmdlIiwicmVtb3ZlT3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZENsb3NlSGFuZGxlciIsImluc2VydFZhbHVlIiwicmVtb3ZlQ2xvc2VIYW5kbGVyIiwiaW52b2tlIiwibWV0aG9kTmFtZSIsImNhbGwiLCJ0b2dnbGVGdWxsU2NyZWVuIiwiZWxlbWVudCIsInRvZ2dsZSIsIm9uRnVsbFNjcmVlblN0YXRlQ2hhbmdlIiwiY2IiLCJoYXNBdHRyaWJ1dGVEZWZpbmVkIiwiZWxlbSIsImF0dHJpYnV0ZSIsImF0dCIsImhhc0NsYXNzRGVmaW5lZCIsImNsYXNzTmFtZSIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwidGFnTmFtZSIsIm9wdHMiLCJjcmVhdGVUZXh0Tm9kZSIsInRvU3RyaW5nIiwiYWRkU3Vic2NyaXB0aW9uQXNzaWdubWVudEhhbmRsZXIiLCJzZXRTdWJzY3JpYmVySWQiLCJnZXRNb3VzZVhGcm9tRXZlbnQiLCJwYWdlWCIsImNsaWVudFgiLCJib2R5Iiwic2Nyb2xsTGVmdCIsImRvY3VtZW50RWxlbWVudCIsImdldFNjcm9sbFgiLCJwYWdlWE9mZnNldCIsInBhcmVudE5vZGUiLCJjcmVhdGVFdmVudCIsIkV2ZW50VHlwZSIsImdldEdsb2JhbCIsImVudmlyb25tZW50Iiwib3JpZ2luIiwic3R5bGVzIiwidHJhbnNpdGlvbiIsInJvdGF0aW9uVHJhbnNsYXRpb25zIiwidHJhbnNmb3JtIiwidHJhY2tSZXNpemUiLCJyYWYiLCJpc1JvdGF0ZWQiLCJwYXJlbnQiLCJwd2lkdGgiLCJjbGllbnRXaWR0aCIsInBoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzdHlsZSIsIndpZHRoIiwiZXdpZHRoIiwiZWhlaWdodCIsIm1hcmdpbiIsInBvc2l0aW9uIiwibGVmdCIsImFwcGx5T3JpZW50YXRpb24iLCJyZXNvbHV0aW9uIiwiaGVpZ2h0IiwidHJhbnNsYXRpb25zIiwiYXR0YWNoRXZlbnQiLCJjdXJyeSIsImZ4IiwiYXJpdHkiLCJmMSIsImFyZ3MiLCJBcnJheSIsInByb3RvdHlwZSIsImFyZ3VtZW50cyIsImFwcGx5IiwiZjIiLCJhcmdzMiIsImZpbHRlciIsImlkeCIsInRvSW50IiwiTWF0aCIsInJvdW5kIiwiZ2V0T3JFbHNlIiwiZGVmYXVsdFZhbHVlIiwiZ2V0SW50T3JFbHNlIiwiaXNOYU4iLCJkZWVwRGVmaW5lIiwib2JqZWN0IiwicGF0aHMiLCJ0YWlsIiwicG9wIiwicGF0aCIsImRlZXBDb3B5Iiwib2JqIiwic3RyIiwic3RyaW5naWZ5IiwibWV0YWRhdGFSZXNvbHV0aW9uVG9PYmplY3QiLCJkaW1zIiwiaXNPYmplY3RFbXB0eSIsIk9iamVjdCIsImtleXMiLCJjb25zdHJ1Y3RvciIsImZvcm1hdHMiLCJsYWJlbCIsImhhc1Jlc29sdXRpb25zRGVmaW5lZCIsInZpZGVvIiwiZ2V0VmFsdWVGcm9tQ29uc3RyYWludEF0dHJpYnV0ZSIsImV4YWN0IiwiaWRlYWwiLCJtYXgiLCJtaW4iLCJpc0V4YWN0IiwiZm9ybWF0IiwidyIsImgiLCJjb25maXJtZWQiLCJpc0xvd2VyIiwiZGVzaXJlZCIsImRpbWVuc2lvbnMiLCJoYXNNYXRjaGluZ0Zvcm1hdCIsImZvcm1hdHNMaXN0IiwiZmlsdGVyZWQiLCJmaW5kTG93ZXJSZXNvbHV0aW9ucyIsInJlc0lzTG93ZXIiLCJhbGxvd0Jyb3dzZXJUb0RlZmluZVJlc29sdXRpb24iLCJtZWRpYSIsImpvaW4iLCJmaW5kTmV4dFNlbGVjdGlvbiIsInNlbGVjdGlvbnMiLCJzZWxlY3Rpb24iLCJxdWlja1Jlc29sdXRpb25TdXBwb3J0IiwiZGV0ZXJtaW5lU3VwcG9ydGVkUmVzb2x1dGlvbiIsImRlZmVycmVkIiwiX1JUQ1BlZXJDb25uZWN0aW9uIiwiX1JUQ0ljZUNhbmRpZGF0ZSIsIl9SVENTZXNzaW9uRGVzY3JpcHRpb24iLCJzdXBwb3J0c0RhdGFDaGFubmVsIiwicGMiLCJkYyIsImNyZWF0ZURhdGFDaGFubmVsIiwiY2xvc2UiLCJyZWplY3Rpb25DQiIsImlzQXZhaWxhYmxlSW5Gb3JtYXRzIiwiZmFpbG92ZXIiLCJyZXMiLCJhdmFpbGFibGUiLCJmb3JjZVVzZXJNZWRpYSIsImNsZWFuV2hpcFNEUCIsInNkcCIsIm9mZmVuc2l2ZSIsInMiLCJzdHJpcEV4dE1hcHMiLCJleHRSZWciLCJydHBtYXBzIiwicmVneCIsImxpbmUiLCJSZWdFeHAiLCJzdHJpcFJUUE1hcHMiLCJqIiwicngiLCJmb3JtYXRTdHIiLCJsYXN0SW5kZXgiLCJzdHJpcE5vbkgyNjQiLCJtYXBzIiwiaDI2NCIsInR5cGVzIiwic3RyaXBOb25IMjY0RnJvbVZpZGVvIiwiciIsInZpZGVvcyIsIm91dCIsImVudHJ5Iiwic3NyYyIsImZsaXBSZWN2T25seSIsIm1saW5lIiwiZmxpcFJlY3ZPbmx5T25FeHRyYUF1ZGlvIiwiZmxpcFJlY3ZPbmx5T25FeHRyYVZpZGVvIiwidXBkYXRlQmFuZHdpZHRoIiwiYV9pbmRleCIsInZfaW5kZXgiLCJsX2luZGV4IiwiZnJvbnQiLCJiYWNrIiwiYXVkaW8iLCJmb3JjZVN0ZXJlb09uTG9jYWxBbnN3ZXIiLCJpbmNsdWRlcyIsImdlbmVyYXRlU0RQQ2FuZGlkYXRlRnJhZyIsImlzRW5kIiwiY2FuZGlkYXRlUmVnIiwiZnJhZ1JlZyIsInB3ZFJlZyIsIm1SZWciLCJsaW5lcyIsImljZUZyYWciLCJpY2VQd2QiLCJtTGluZSIsImNhbmRpZGF0ZXMiLCJsIiwiZnJhZ0xpc3QiLCJSVENQZWVyQ29ubmVjdGlvbiIsIm1velJUQ1BlZXJDb25uZWN0aW9uIiwid2Via2l0UlRDUGVlckNvbm5lY3Rpb24iLCJSVENJY2VDYW5kaWRhdGUiLCJtb3pSVENJY2VDYW5kaWRhdGUiLCJ3ZWJraXRSVENJY2VDYW5kaWRhdGUiLCJSVENTZXNzaW9uRGVzY3JpcHRpb24iLCJtb3pSVENTZXNzaW9uRGVzY3JpcHRpb24iLCJ3ZWJraXRSVENTZXNzaW9uRGVzY3JpcHRpb24iLCJjcmVhdGUiLCJQdWJsaXNoZXJFdmVudFR5cGVzIiwiZnJlZXplIiwiQ09OTkVDVF9TVUNDRVNTIiwiQ09OTkVDVF9GQUlMVVJFIiwiUFVCTElTSF9TVEFSVCIsIlBVQkxJU0hfRkFJTCIsIlBVQkxJU0hfSU5WQUxJRF9OQU1FIiwiVU5QVUJMSVNIX1NVQ0NFU1MiLCJQVUJMSVNIX01FVEFEQVRBIiwiUFVCTElTSF9TVEFUVVMiLCJQVUJMSVNIX0FWQUlMQUJMRSIsIlBVQkxJU0hfSU5TVUZGSUNJRU5UX0JBTkRXSURUSCIsIlBVQkxJU0hfU1VGRklDSUVOVF9CQU5EV0lEVEgiLCJQVUJMSVNIX1JFQ09WRVJJTkdfQkFORFdJRFRIIiwiUFVCTElTSF9TRU5EX0lOVk9LRSIsIkNPTk5FQ1RJT05fQ0xPU0VEIiwiRElNRU5TSU9OX0NIQU5HRSIsIkZhaWxvdmVyUHVibGlzaGVyRXZlbnRUeXBlcyIsIlBVQkxJU0hFUl9SRUpFQ1QiLCJQVUJMSVNIRVJfQUNDRVBUIiwiUlRDUHVibGlzaGVyRXZlbnRUeXBlcyIsIkNPTlNUUkFJTlRTX0FDQ0VQVEVEIiwiQ09OU1RSQUlOVFNfUkVKRUNURUQiLCJNRURJQV9TVFJFQU1fQVZBSUxBQkxFIiwiUEVFUl9DT05ORUNUSU9OX0FWQUlMQUJMRSIsIk9GRkVSX1NUQVJUIiwiT0ZGRVJfRU5EIiwiUEVFUl9DQU5ESURBVEVfRU5EIiwiSUNFX1RSSUNLTEVfQ09NUExFVEUiLCJTT0NLRVRfTUVTU0FHRSIsIkRBVEFfQ0hBTk5FTF9PUEVOIiwiREFUQV9DSEFOTkVMX0FWQUlMQUJMRSIsIkRBVEFfQ0hBTk5FTF9DTE9TRSIsIkRBVEFfQ0hBTk5FTF9NRVNTQUdFIiwiREFUQV9DSEFOTkVMX0VSUk9SIiwiUEVFUl9DT05ORUNUSU9OX09QRU4iLCJUUkFDS19BRERFRCIsIlJUTVBQdWJsaXNoZXJFdmVudFR5cGVzIiwiRU1CRURfU1VDQ0VTUyIsIkVNQkVEX0ZBSUxVUkUiLCJTdWJzY3JpYmVyRXZlbnRUeXBlcyIsIlNVQlNDUklCRV9TVEFSVCIsIlNVQlNDUklCRV9TVE9QIiwiU1VCU0NSSUJFX0ZBSUwiLCJTVUJTQ1JJQkVfSU5WQUxJRF9OQU1FIiwiU1VCU0NSSUJFX01FVEFEQVRBIiwiU1VCU0NSSUJFX1NUQVRVUyIsIlNVQlNDUklCRV9TRU5EX0lOVk9LRSIsIlNVQlNDUklCRV9QVUJMSVNIRVJfQ09OR0VTVElPTiIsIlNVQlNDUklCRV9QVUJMSVNIRVJfUkVDT1ZFUlkiLCJQTEFZX1VOUFVCTElTSCIsIk9SSUVOVEFUSU9OX0NIQU5HRSIsIlNUUkVBTUlOR19NT0RFX0NIQU5HRSIsIlZJREVPX0RJTUVOU0lPTlNfQ0hBTkdFIiwiVk9MVU1FX0NIQU5HRSIsIlNFRUtfQ0hBTkdFIiwiUExBWUJBQ0tfVElNRV9VUERBVEUiLCJQTEFZQkFDS19TVEFURV9DSEFOR0UiLCJGVUxMX1NDUkVFTl9TVEFURV9DSEFOR0UiLCJBVVRPX1BMQVlCQUNLX0ZBSUxVUkUiLCJBVVRPX1BMQVlCQUNLX01VVEVEIiwiRmFpbG92ZXJTdWJzY3JpYmVyRXZlbnRUeXBlcyIsIlNVQlNDUklCRVJfUkVKRUNUIiwiU1VCU0NSSUJFUl9BQ0NFUFQiLCJSVENTdWJzY3JpYmVyRXZlbnRUeXBlcyIsIkFOU1dFUl9TVEFSVCIsIkFOU1dFUl9FTkQiLCJDQU5ESURBVEVfU1RBUlQiLCJDQU5ESURBVEVfRU5EIiwiT05fQUREX1NUUkVBTSIsIkxJVkVfU0VFS19FUlJPUiIsIkxJVkVfU0VFS19FTkFCTEVEIiwiTElWRV9TRUVLX0RJU0FCTEVEIiwiTElWRV9TRUVLX0xPQURJTkciLCJMSVZFX1NFRUtfTE9BREVEIiwiUlRNUFN1YnNjcmliZXJFdmVudFR5cGVzIiwiQUJSX0xFVkVMX0NIQU5HRSIsIlNoYXJlZE9iamVjdEV2ZW50VHlwZXMiLCJQUk9QRVJUWV9VUERBVEUiLCJQUk9QRVJUWV9SRU1PVkUiLCJNRVRIT0RfVVBEQVRFIiwiTWVzc2FnZVRyYW5zcG9ydFN0YXRlRXZlbnRUeXBlcyIsIk9QRU4iLCJDTE9TRSIsIkNIQU5HRSIsIlJUQ0NvbmZlcmVuY2VQYXJ0aWNpcGFudEV2ZW50VHlwZXMiLCJBVURJT19TVFJFQU0iLCJWSURFT19TVFJFQU0iLCJNRURJQV9TVFJFQU0iLCJFdmVudCIsIl90eXBlIiwiX2RhdGEiLCJQdWJsaXNoZXJFdmVudCIsInB1Ymxpc2hlciIsIl9wdWJsaXNoZXIiLCJTdWJzY3JpYmVyRXZlbnQiLCJzdWJzY3JpYmVyIiwiX3N1YnNjcmliZXIiLCJTaGFyZWRPYmplY3RFdmVudCIsInNoYXJlZE9iamVjdE5hbWUiLCJfbmFtZSIsIk1lc3NhZ2VUcmFuc3BvcnRTdGF0ZUV2ZW50IiwiUlRDQ29uZmVyZW5jZVBhcnRpY2lwYW50RXZlbnQiLCJwYXJ0aWNpcGFudCIsIl9wYXJ0aWNpcGFudCIsIlNsaWRlckV2ZW50IiwiY29udHJvbCIsIl9jb250cm9sIiwiU2xpZGVyRXZlbnRUeXBlcyIsIkNIQU5HRV9TVEFSVCIsIkNIQU5HRV9DT01QTEVURSIsIlNlZWtFdmVudFR5cGVzIiwiU0VFS19TVEFSVCIsIlNFRUtfRU5EIiwiTkFNRSIsIkNvbnRyb2xTbGlkZXIiLCJfY29udGFpbmVyIiwiX2J1dHRvbiIsImNyZWF0ZUJ1dHRvbiIsIl90cmFjayIsImNyZWF0ZVRyYWNrIiwiX3Byb2dyZXNzQmFyIiwiY3JlYXRlUHJvZ3Jlc3NCYXIiLCJfdmFsdWUiLCJfZGlzYWJsZWQiLCJfZXZlbnRTdGFydFBvc2l0aW9uIiwiX2xheW91dCIsIl9tb3VzZXVwSGFuZGxlciIsIl9tb3VzZXVwIiwiYmluZCIsIl9tb3VzZWRvd25IYW5kbGVyIiwiX21vdXNlZG93biIsIl9tb3VzZW1vdmVIYW5kbGVyIiwiX21vdXNlbW92ZSIsIl90b3VjaHVwSGFuZGxlciIsIl90b3VjaHByb3h5IiwiX3RvdWNoZG93bkhhbmRsZXIiLCJfdG91Y2htb3ZlSGFuZGxlciIsIl91cGRhdGVIYW5kbGVycyIsInByZXZlbnREZWZhdWx0IiwidG91Y2hlcyIsImV2dCIsInRvdWNoIiwidCIsIm9yaWdpbmFsVGFyZ2V0IiwidGFyZ2V0IiwiY2hhbmdlZFRvdWNoZXMiLCJpbml0TW91c2VFdmVudCIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsInNjcmVlblgiLCJzY3JlZW5ZIiwiY2xpZW50WSIsImN0cmxLZXkiLCJhbHRLZXkiLCJzaGlmdEtleSIsIm1ldGFLZXkiLCJkaXNwYXRjaEV2ZW50IiwidHJpZ2dlciIsInBvc2l0aW9uT2Zmc2V0IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInBlcmNlbnRhZ2UiLCJpc0Rpc2FibGVkIiwiYWRkIiwicmVtb3ZlIiwic3BhbiIsInBlcmNlbnRWYWx1ZSIsImJvb2wiLCJQbGF5YmFja1N0YXRlIiwiVU5BVkFJTEFCTEUiLCJBVkFJTEFCTEUiLCJJRExFIiwiUExBWUlORyIsIlBBVVNFRCIsIlBsYXliYWNrU3RhdGVSZWFkYWJsZSIsIlN1YnNjcmliZXJQbGF5YmFja0NvbnRyb2xsZXIiLCJkdXJhdGlvbiIsIlN1YnNjcmliZXJQbGF5YmFja0NvbnRyb2xzIiwic3RhdGUiLCJTdWJzY3JpYmVyUGxheWJhY2tDb250cm9sc0ltcGwiLCJjb250YWluZXIiLCJfY29udHJvbGJhciIsIl9wbGF5UGF1c2VCdXR0b24iLCJfbXV0ZUJ1dHRvbiIsIl92b2x1bWVGaWVsZCIsIl9zZWVrVGltZUZpZWxkIiwiX3RpbWVGaWVsZCIsIl9mdWxsU2NyZWVuQnV0dG9uIiwiX3N0YXRlIiwiX211dGVkU3RhdGUiLCJfcmVzdW1lQWZ0ZXJTZWVrIiwiX3BsYXliYWNrRHVyYXRpb24iLCJfdm9sdW1lVmFsdWUiLCJfb25QbGF5UGF1c2VDbGlja0JvdW5kIiwiX29uUGxheVBhdXNlQ2xpY2siLCJjb250cm9sYmFyIiwiX2NyZWF0ZVBsYXlQYXVzZUJ1dHRvbiIsIl9jcmVhdGVNdXRlQnV0dG9uIiwiX2NyZWF0ZVZvbHVtZUNvbnRyb2wiLCJfY3JlYXRlU2Vla0NvbnRyb2wiLCJfY3JlYXRlUGxheWJhY2tUaW1lIiwiX2NyZWF0ZUZ1bGxTY3JlZW5Ub2dnbGUiLCJ2aWV3IiwiY29udHJvbEJhck9mZiIsImRlbGF5Q29udHJvbEJhck9mZiIsImNsZWFyVGltZW91dCIsInNldFN0YXRlIiwib25GdWxsU2NyZWVuQ2hhbmdlIiwic2V0U2Vla1RpbWUiLCJlbmFibGUiLCJnZXRTdGF0ZSIsInJlc3VtZSIsImJ1dHRvbiIsInNlbGYiLCJnZXRNdXRlZFN0YXRlIiwidW5tdXRlIiwic2V0TXV0ZWRTdGF0ZSIsIm11dGUiLCJzbGlkZXIiLCJvbiIsIk51bWJlciIsInNldFZvbHVtZSIsInNlZWtUbyIsImhycyIsIm1pbnMiLCJzZWNzIiwiZm9ybWF0dGVkQXJyIiwiaW5uZXJUZXh0IiwiZm9ybWF0VGltZSIsImZsb29yIiwib25TdGF0ZUNoYW5nZSIsIm11dGVkIiwib25NdXRlZFN0YXRlQ2hhbmdlIiwiaXNGdWxsU2NyZWVuIiwiaXNWT0QiLCJkaXNhYmxlZCIsInJlbW92ZUNoaWxkIiwiUGxheWJhY2tDb250cm9sbGVyIiwiUGxheWJhY2tDb250cm9scyIsIlBsYXliYWNrQ29udHJvbHNJbXBsIiwiUlRDU291cmNlSGFuZGxlciIsInVzZVBsYXliYWNrQ29udHJvbHMiLCJjbG9uZSIsImNsb25lTm9kZSIsImhvbGRlciIsIl9kZXRlcm1pbmVIb2xkZXIiLCJwbGF5ZXJUeXBlIiwiX2lzVk9EIiwiX2NvbnRyb2xzIiwiX3BsYXliYWNrTm90aWZpY2F0aW9uQ2VudGVyIiwiX2hhbmRsZUZ1bGxTY3JlZW5DaGFuZ2UiLCJkaXYiLCJpbnNlcnRCZWZvcmUiLCJlbFBhcmVudCIsIm1lZGlhSG9sZGVyIiwiZGV0YWNoIiwibm90aWZpZXIiLCJjb250cm9scyIsImdldENvbnRyb2xzIiwiaGFzQ29udHJvbHMiLCJvbmNhbnBsYXkiLCJjb2RlIiwidm9sdW1lIiwib25kdXJhdGlvbmNoYW5nZSIsImlzRmluaXRlIiwic2V0UGxheWJhY2tEdXJhdGlvbiIsIm9uZW5kZWQiLCJvbnRpbWV1cGRhdGUiLCJjdXJyZW50VGltZSIsIm9uc2Vla2VkIiwib25zZWVraW5nIiwib25wbGF5Iiwib25wYXVzZSIsIm9udm9sdW1lY2hhbmdlIiwiZ2V0Vm9sdW1lIiwib25lbmNyeXB0ZWQiLCJvbmVtcHRpZWQiLCJvbmxvYWRlZGRhdGEiLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJvbnJlc2l6ZSIsIm9ubG9hZGVkbWV0YWRhdGEiLCJvbmxvYWRzdGFydCIsIm9uc3RhbGxlZCIsIm9uc3VzcGVuZCIsIm9ud2FpdGluZyIsImhhc0RlZmluZWRDb250cm9scyIsImlzTXV0ZWQiLCJzZXRBc1ZPRCIsIl9hZGRQbGF5YmFja0hhbmRsZXJzIiwibXV0ZU9uQXV0b3BsYXkiLCJzdG9wIiwiX2NsZWFuVXAiLCJjYWxsTmFtZSIsIk1BWF9UUyIsIlJUQ1NlZWthYmxlU291cmNlSGFuZGxlciIsIl9pc1NlZWthYmxlIiwiX2lzSExTUGxheWJhY2tBY3RpdmUiLCJfaXNGcmFnTG9hZGluZyIsIl9obHNSZWNvdmVyRmxvcCIsIl9obHNSZWNvdmVyQXR0ZW1wdHMiLCJfbGFzdER1cmF0aW9uVXBkYXRlIiwiX3Jlc2l6ZU9ic2VydmVyIiwiaGxzIiwiaGxzRWxlbWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJwbGF5c2lubGluZSIsImRpc3BsYXkiLCJmbGFnIiwiaGxzTWVkaWEiLCJwYXVzZWQiLCJfcmVtb3ZlUGxheWJhY2tIYW5kbGVycyIsImRldGFjaE1lZGlhIiwiX3JlbW92ZVNlZWthYmxlSGFuZGxlcnMiLCJ1bm9ic2VydmUiLCJfb25SVENFbmRlZCIsIl9vblJUQ0R1cmF0aW9uQ2hhbmdlIiwiX29uUlRDVGltZVVwZGF0ZSIsIl9vblJUQ1BsYXkiLCJfb25SVENQYXVzZSIsImRldGFpbHMiLCJobHNDb250cm9sIiwiaXNTZWVrYWJsZSIsImRlc3Ryb3kiLCJlbmFibGVMaXZlU2VlayIsInN3YXBBdWRpb0NvZGVjIiwicmVjb3Zlck1lZGlhRXJyb3IiLCJzdGFydExvYWQiLCJNQU5JRkVTVF9QQVJTRUQiLCJGUkFHX0xPQURfUFJPR1JFU1MiLCJzdGF0cyIsImxvYWRlZCIsInRvdGFsIiwicHJvZ3Jlc3MiLCJpc0hMU1BsYXliYWNrQWN0aXZlIiwiRlJBR19MT0FERUQiLCJlbmREVFMiLCJmcmFnIiwiX29uSExTRHVyYXRpb25DaGFuZ2UiLCJfb25ITFNUaW1lVXBkYXRlIiwiX29uSExTUGxheSIsIl9vbkhMU1BhdXNlIiwiaGxzRHVyYXRpb24iLCJnZXRQbGF5YmFja0R1cmF0aW9uIiwiX3Nob3dITFNMaXZlUGxheWJhY2siLCJobHNVUkwiLCJoYXNOYXRpdmVTdXBwb3J0IiwiX2dlbmVyYXRlSExTTGl2ZVBsYXliYWNrIiwiYmFja0J1ZmZlckxlbmd0aCIsIl9hZGRTZWVrYWJsZUhhbmRsZXJzIiwiYXR0YWNoTWVkaWEiLCJNRURJQV9BVFRBQ0hFRCIsImxvYWRTb3VyY2UiLCJyNXByb19obHNfY29udHJvbCIsImZyb21Db250cm9scyIsImZyb21BY3Rpb25TZWVrIiwic2VlayIsIk1lc3NhZ2VUcmFuc3BvcnQiLCJfcmVzcG9uc2VIYW5kbGVycyIsIl9hc3luY1RpY2tldHMiLCJyZXF1ZXN0Iiwic2VuZFJlcXVlc3QiLCJyYW5kb20iLCJhc3luYyIsInBvc3QiLCJySGFuZGxlciIsInJlc3BvbmQiLCJzaGFyZWRPYmplY3RHZXRSZW1vdGUiLCJzaGFyZWRPYmplY3RDb25uZWN0Iiwic2hhcmVkT2JqZWN0U2VuZCIsIm1ldGhvZCIsInNoYXJlZE9iamVjdFNldFByb3BlcnR5Iiwic2hhcmVkT2JqZWN0Q2xvc2UiLCJTb2NrZXRIZWxwZXIiLCJyZXNwb25kZXIiLCJfcmVzcG9uZGVyIiwiX3BlbmRpbmdQb3N0UmVxdWVzdHMiLCJfd2Vic29ja2V0IiwiX2Nvbm5lY3Rpb25Qcm9taXNlIiwiX2lzVGVybWluYXRlZCIsIl9yZXRyeUNvdW50IiwiX3JldHJ5TGltaXQiLCJfcmVhZHlDaGVja0NvdW50IiwiX3JlYWR5Q2hlY2tMaW1pdCIsIl9vcGVuU3RhdGUiLCJfb25jbG9zZSIsInRlYXJEb3duIiwiX29ub3BlblRpbWVvdXQiLCJ3cyIsInRpbWVvdXQiLCJvblNvY2tldE9wZW4iLCJzb2NrZXQiLCJjbGVhclJldHJ5IiwiX3Jlc2V0T25vcGVuVGltZW91dCIsIm9ub3BlbiIsIm9ubWVzc2FnZSIsIm9uZXJyb3IiLCJvbmNsb3NlIiwib25Tb2NrZXRDbG9zZSIsIl9yZW1vdmVTb2NrZXRIYW5kbGVycyIsImRldGFpbCIsInNldHVwUHJvbWlzZSIsImZvcmNlUmVjb25uZWN0Iiwid2Vic29ja2V0IiwiX2FkZFNvY2tldEhhbmRsZXJzIiwic2V0VXAiLCJzdHJlYW1OYW1lIiwiaGFuZGxlQ2FuZGlkYXRlIiwiY2FuZGlkYXRlIiwic2VuZCIsImhhbmRsZWQiLCJoYW5kbGVNZXNzYWdlUmVzcG9uc2UiLCJqc29uIiwiZ2V0SnNvbkZyb21Tb2NrZXRNZXNzYWdlIiwiaXNBdmFpbGFibGUiLCJvblN0cmVhbUF2YWlsYWJsZSIsIm9uU3RyZWFtVW5hdmFpbGFibGUiLCJ0aWNrZXQiLCJvblNvY2tldE1lc3NhZ2VFcnJvciIsIl9vblVuZXhwZWN0ZWRTb2NrZXRFcnJvciIsIm9uRGF0YUNoYW5uZWxBdmFpbGFibGUiLCJTdWJzY3JpcHRpb25Tb2NrZXRIZWxwZXIiLCJvblNEUE9mZmVyIiwib25FbXB0eUNhbmRpZGF0ZSIsIm9uQWRkSWNlQ2FuZGlkYXRlIiwib25Tb2NrZXRJY2VDYW5kaWRhdGVFbmQiLCJvblVucHVibGlzaCIsIm9uQ29ubmVjdGlvbkNsb3NlZCIsIm9uU3Vic2NyaWJlclN0YXR1cyIsInN0YXR1cyIsIm9uU2VuZFJlY2VpdmVkIiwib25NZXRhRGF0YSIsIm1ldGFkYXRhIiwib25Tb2NrZXRNZXNzYWdlIiwiV2ViUlRDUGVlckhlbHBlciIsIl9kYXRhQ2hhbm5lbCIsIl9wZWVyQ29ubmVjdGlvbiIsIl9vbkRhdGFDaGFubmVsTWVzc2FnZSIsImRhdGFDaGFubmVsIiwib25EYXRhQ2hhbm5lbEVycm9yIiwib25EYXRhQ2hhbm5lbE9wZW4iLCJvbkRhdGFDaGFubmVsQ2xvc2UiLCJjb25uZWN0aW9uIiwiaWNlU2VydmVycyIsInNldFVwUHJvbWlzZSIsInJ0Y3BNdXhQb2xpY3kiLCJwZWVyQ29uZmlnIiwiaWNlQ2FuZGlkYXRlUG9vbFNpemUiLCJidW5kbGVQb2xpY3kiLCJwZWVyIiwid2VicnRjIiwib3B0aW9uYWwiLCJSdHBEYXRhQ2hhbm5lbHMiLCJnb29nQ3B1T3ZlcnVzZURldGVjdGlvbiIsIl9hZGRDb25uZWN0aW9uSGFuZGxlcnMiLCJjb25maWd1cmF0aW9uIiwiZGF0YUNoYW5uZWxDb25maWd1cmF0aW9uIiwib3JkZXJlZCIsIl9hZGREYXRhQ2hhbm5lbEhhbmRsZXJzIiwiX3JlbW92ZURhdGFDaGFubmVsSGFuZGxlcnMiLCJfcmVtb3ZlQ29ubmVjdGlvbkhhbmRsZXJzIiwic2Vzc2lvbkRlc2NyaXB0aW9uIiwic2V0TG9jYWxEZXNjcmlwdGlvbiIsInNldFJlbW90ZURlc2NyaXB0aW9uIiwiYWRkSWNlQ2FuZGlkYXRlIiwiaXNFbXB0eUNhbmRpZGF0ZSIsIlN1YnNjcmlwdGlvblBlZXJIZWxwZXIiLCJvbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSIsIm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlIiwib25pY2VjYW5kaWRhdGUiLCJvbnRyYWNrIiwib25kYXRhY2hhbm5lbCIsInJlY29ubmVjdFRpbWVvdXQiLCJ0aW1lb3V0TGltaXQiLCJjb25uZWN0aW9uU3RhdGUiLCJvblBlZXJDb25uZWN0aW9uT3BlbiIsIm9uSWNlQ2FuZGlkYXRlIiwiX3BlbmRpbmdNZWRpYVN0cmVhbSIsIm9uSWNlQ2FuZGlkYXRlVHJpY2tsZUVuZCIsIm9uQW5zd2VyTWVkaWFTdHJlYW0iLCJpY2VDb25uZWN0aW9uU3RhdGUiLCJvblBlZXJHYXRoZXJpbmdDb21wbGV0ZSIsIm9uUGVlckNvbm5lY3Rpb25GYWlsIiwib25QZWVyQ29ubmVjdGlvbkNsb3NlIiwib25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSIsImljZUdhdGhlcmluZ1N0YXRlIiwib25yZW1vdmVzdHJlYW0iLCJvbkRhdGFDaGFubmVsTWVzc2FnZSIsIm9uU0RQU3VjY2VzcyIsIm9uU0RQRXJyb3IiLCJjcmVhdGVBbnN3ZXIiLCJpY2VDYW5kaWRhdGUiLCJzZHBNTGluZUluZGV4IiwicGxheWJhY2tJZCIsIlBsYXliYWNrVmlldyIsImVsZW1lbnRJZCIsIl90YXJnZXRFbGVtZW50Iiwic2V0VmlldyIsImlzQXV0b3BsYXkiLCJnZXRCYWNrZ3JvdW5kQ29tcGF0V2ViU29ja2V0UG9ydCIsInBvcnQiLCJlbmNvZGVLZXlWYWx1ZXMiLCJ2YWx1ZU9iamVjdCIsImVuY29kZWQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJydGNTb2NrZXRFbmRwb2ludEZyb21PcHRpb25zIiwicGFyYW1zIiwicHJvdG9jb2wiLCJ3c3Byb3RvY29sIiwid3Nwb3J0IiwiYXBwRW5kcG9pbnQiLCJjb250ZXh0IiwiYXBwIiwiZW5kcG9pbnQiLCJob3N0IiwiY29ubmVjdGlvblBhcmFtcyIsImVuY29kZWRQYXJhbXMiLCJhc3NpZ24iLCJrdiIsImhsc1NvY2tldEVuZHBvaW50RnJvbU9wdGlvbnMiLCJzb2NrZXRQYXJhbXMiLCJvcHRpb25zVG9IbHNVUkwiLCJobHNwcm90b2NvbCIsImhsc3BvcnQiLCJhcGlWZXJzaW9uIiwidGhlSG9zdCIsInRoZVByb3RvY29sIiwidGhlUG9ydCIsInRoZVZlcnNpb24iLCJvcHRpb25zRnJvbVdoaXBXaGVwVXJsIiwicGF0dGVybiIsInBhdGhuYW1lIiwiaG9zdG5hbWUiLCJQbGF5YmFja1R5cGVzIiwiUlRDIiwiUlRNUCIsIkhMUyIsIlBsYXliYWNrQXVkaW9FbmNvZGVyIiwiT1BVUyIsIlBDTVUiLCJQQ01BIiwiU1BFRVgiLCJOT05FIiwiUGxheWJhY2tWaWRlb0VuY29kZXIiLCJWUDgiLCJIMjY0IiwiSWNlVHJhbnNwb3J0VHlwZXMiLCJVRFAiLCJUQ1AiLCJzdWJTdGFydFJlZ2V4IiwiZ2VuZXJhdGVTdWJzY3JpcHRpb25JZCIsImRlZmF1bHRPcHRpb25zIiwiYXV0b0xheW91dE9yaWVudGF0aW9uIiwibWVkaWFFbGVtZW50SWQiLCJydGNDb25maWd1cmF0aW9uIiwidXJscyIsImljZVRyYW5zcG9ydCIsIm11dGVPbkF1dG9wbGF5UmVzdHJpY3Rpb24iLCJtYWludGFpbkNvbm5lY3Rpb25PblN1YnNjcmliZUVycm9ycyIsInNpZ25hbGluZ1NvY2tldE9ubHkiLCJzb2NrZXRTd2l0Y2hEZWxheSIsImJ5cGFzc0F2YWlsYWJsZSIsIm1haW50YWluU3RyZWFtVmFyaWFudCIsIlJUQ1N1YnNjcmliZXIiLCJfdmlldyIsIl9vcHRpb25zIiwiX3BlZXJIZWxwZXIiLCJfc29ja2V0SGVscGVyIiwiX21lc3NhZ2VUcmFuc3BvcnQiLCJfY29ubmVjdGlvbkNsb3NlZCIsIl9zb3VyY2VIYW5kbGVyIiwiX21lZGlhU3RyZWFtIiwiX3ZpZXdSZXNvbHZlciIsIl9hdmFpbGFiaWxpdHlSZXNvbHZlciIsIl9zdWJzY3JpcHRpb25SZXNvbHZlciIsIl9vcmllbnRhdGlvbiIsIl9zdHJlYW1pbmdNb2RlIiwiX3N3aXRjaENoYW5uZWxSZXF1ZXN0IiwiY3VycmVudFZpZXciLCJhdHRhY2hTdWJzY3JpYmVyIiwiX2JvdW5kQnViYmxlU3Vic2NyaWJlckV2ZW50cyIsImFkZFNvdXJjZSIsInN1YnNjcmlwdGlvbklkIiwidHJhbnNwb3J0IiwidXNlRGF0YUNoYW5uZWwiLCJtYWludGFpblZhcmlhbnQiLCJ2RW5jb2RpbmciLCJhRW5jb2RpbmciLCJvZmZlciIsInJlcXVlc3RPZmZlciIsInJlcXVlc3RJZCIsImRhdGFjaGFubmVsIiwiZG9Ob3RTd2l0Y2giLCJ2aWRlb0VuY29kaW5nIiwiYXVkaW9FbmNvZGluZyIsIl9zZW5kQW5zd2VyIiwiaGFuZGxlQW5zd2VyIiwic2V0VXBXaXRoUGVlckNvbmZpZ3VyYXRpb24iLCJfcmVxdWVzdE9mZmVyIiwiZGV0YWNoU3RyZWFtIiwiZGlzY29ubmVjdCIsImF0dGVtcHRBdXRvcGxheSIsIkVycm9yIiwic3Vic2NyaWJlIiwiX2Rpc2Nvbm5lY3QiLCJzb2NrZXRQcm9taXNlIiwic29ja2V0dXJsIiwiZW5kcG9pbnRGcm9tT3B0aW9ucyIsImRhdGFDaGFubmVsQWxsb3dlZCIsIl9nZXRWaWV3UmVzb2x2ZXJQcm9taXNlIiwiZ2V0VHlwZSIsIl9nbG9tU291cmNlSGFuZGxlckFQSSIsIl9pbml0SGFuZGxlciIsIl9nZXRBdmFpbGFiaWxpdHlSZXNvbHZlclByb21pc2UiLCJfY29ubmVjdCIsIl9zZXRWaWV3SWZOb3RFeGlzdCIsIl9yZXF1ZXN0QXZhaWxhYmlsaXR5IiwiX2dldFN1YnNjcmlwdGlvblJlc29sdmVyUHJvbWlzZSIsInJlY2VpcHQiLCJfcmVxdWVzdEFuc3dlciIsIl9zZW5kQ2FuZGlkYXRlIiwiYXR0YWNoU3RyZWFtIiwicG9zdEVuZE9mQ2FuZGlkYXRlcyIsIl9zZW5kU3Vic2NyaWJlIiwiY2xvc2VFdmVudCIsImdldFBlZXJDb25uZWN0aW9uIiwidW5wdWJsaXNoIiwidW5zdWJzY3JpYmUiLCJvblB1Ymxpc2hlck5ldHdvcmtDb25nZXN0aW9uIiwib25QdWJsaXNoZXJOZXR3b3JrUmVjb3ZlcnkiLCJzdGFydFJlc3VsdCIsIl9wbGF5SWZBdXRvcGxheVNldCIsIl9zdGFydFNlZWthYmxlIiwiY2hhbm5lbE5hbWUiLCJzd2l0Y2hDaGFubmVsIiwic2V2ZXIiLCJjb250cm9sbGVyIiwiZ2V0RGF0YUNoYW5uZWwiLCJtZXNzYWdlRGF0YSIsInByZXZpb3VzU3RyZWFtaW5nTW9kZSIsImhhbmRsZU9yaWVudGF0aW9uQ2hhbmdlIiwidmlld0VsZW1lbnQiLCJnZXRNZXNzYWdlVHJhbnNwb3J0IiwicG9zdEFzeW5jIiwiY2FsbEFkYXB0ZXIiLCJ0aGVMZXZlbCIsInRoZU1lc3NhZ2UiLCJ0b1VwcGVyQ2FzZSIsIm11dGVBdWRpbyIsIm11dGVWaWRlbyIsImRlZmluZUVtYmVkRWxlbWVudCIsInRhcmdldEVsZW1lbnQiLCJ0YXJnZXRQYXJlbnQiLCJub2RlTmFtZSIsInBhcmVudEVsZW1lbnQiLCJlbWJlZFN3Zk9iamVjdCIsImlkTmFtZSIsImZsYXNodmFycyIsInF1YWxpdHkiLCJ3bW9kZSIsImJnY29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJhbGxvd3NjcmlwdGFjY2VzcyIsImFsbG93ZnVsbHNjcmVlbiIsImFsbG93bmV0d29ya2luZyIsImF0dHJpYnV0ZXMiLCJhbGlnbiIsImhhc0ZsYXNoUGxheWVyVmVyc2lvbiIsIm1pbkZsYXNoVmVyc2lvbiIsImVtYmVkU1dGIiwic3dmIiwiZW1iZWRXaWR0aCIsImVtYmVkSGVpZ2h0IiwicHJvZHVjdEluc3RhbGxVUkwiLCJzdWNjZXNzIiwiUlRNUFNoYXJlZE9iamVjdEhhbmRsZXIiLCJfZWxlbWVudCIsIl9oYW5kbGVTaGFyZWRPYmplY3RFdmVudCIsImhhbmRsZVNoYXJlZE9iamVjdEV2ZW50IiwiZWxJZCIsImhhbmRsZXJOYW1lIiwic2V0U2hhcmVkT2JqZWN0UmVzcG9uZGVyIiwic3dmSWQiLCJzaGFyZWRPYmplY3RTZW5kUHJvcGVydHkiLCJhc3NpZ25TaGFyZWRPYmplY3RSZXNwb25kZXIiLCJnZXRSZW1vdGVTaGFyZWRPYmplY3QiLCJjb25uZWN0VG9TaGFyZWRPYmplY3QiLCJkaXNjb25uZWN0RnJvbVNoYXJlZE9iamVjdCIsImlzVk9EU3RyZWFtTmFtZSIsInRlc3QiLCJSVE1QU291cmNlSGFuZGxlciIsIm5vdGlmaWNhdGlvbkNlbnRlciIsInNvUmVzcG9uZGVyIiwiX3N3ZklkIiwiX3NvUmVzcG9uZGVyIiwiZ2V0RW1iZWRkZWRWaWV3Iiwic3VjY2Vzc0lkIiwiX3RlYXJEb3duSW5pdENhbGxiYWNrIiwic3dmVXJsIiwiX3NldFVwSW5pdENhbGxiYWNrIiwiZW1iZWQiLCJ1c2VBZGFwdGl2ZUJpdHJhdGVDb250cm9sbGVyIiwiYnVmZmVyIiwiYXV0b3NpemUiLCJhYnJWYXJpYW50cyIsImFiclZhcmlhbnRVcGdyYWRlU2V0dGluZ3MiLCJlbWJlZGRlZCIsImNsYXp6IiwiY29ubmVjdCIsImFkZFJlc3BvbnNlSGFuZGxlciIsInJlbW92ZVJlc3BvbnNlSGFuZGxlciIsInNlbmRUb1NoYXJlZE9iamVjdCIsInNlbmRQcm9wZXJ0eVRvU2hhcmVkT2JqZWN0IiwiY2xvc2VTaGFyZWRPYmplY3QiLCJzdGFydEFCUkNvbnRyb2xsZXIiLCJzdG9wQUJSQ29udHJvbGxlciIsInNldEFCUlZhcmlhbnRzIiwiZmlybSIsInNldEFCUkxldmVsIiwiYWJyVmFyaWFudFVwZ3JhZGVzIiwic2V0QUJSVmFyaWFudFVwZ3JhZGVTZXR0aW5ncyIsInN3Zm9iamVjdFVSTCIsIm1pbmltdW1Eb3duZ3JhZGVQbGF5YmFja1NwYW4iLCJ1cGdyYWRlIiwicmV0cnlUaW1lb3V0IiwiUlRNUFN1YnNjcmliZXIiLCJfZWxlbWVudElkIiwiX2VtYmVkUHJvbWlzZSIsIl9nZXRFbWJlZFByb21pc2UiLCJvbkVtYmVkQ29tcGxldGUiLCJvbkVtYmVkRmFpbHVyZSIsImludm9rZUZuIiwib3JpZW50YXRpb25JbnQiLCJwYXlsb2FkIiwic2V0dGluZ3MiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlc3RhYmxpc2hTb3VyY2VIYW5kbGVyIiwic3Vic2NyaWJlcklkIiwiX2VzdGFibGlzaEV4dEludEhhbmRsZXJzIiwiZW1iZWREZmQiLCJITFNTb3VyY2VIYW5kbGVyIiwiX21lZGlhU291cmNlIiwiX2F1dG9MYXlvdXRPcmllbnRhdGlvbiIsIl9oYW5kbGVPcmllbnRhdGlvbkNoYW5nZSIsIl9vbk9yaWVudGF0aW9uTWV0YWRhdGEiLCJfb25TdHJlYW1pbmdNb2RlTWV0YWRhdGEiLCJmaXJzdENoaWxkIiwiX2VtYmVkTWVkaWFTb3VyY2UiLCJtaW1lVHlwZSIsInVybFJlZ2V4IiwiSExTU3Vic2NyaWJlciIsImJ1YmJsZVN1YnNjcmliZXJFdmVudHMiLCJfdHJhY2tTdHJlYW1pbmdNb2RlU3RhdGUiLCJoZWFkZXJMaW5rVG9PYmplY3QiLCJsaW5rIiwiYXR0cyIsInRyaW0iLCJwcm9wcyIsImNoYXJBdCIsInN1YnN0cmluZyIsInJlZHVjZSIsImFjYyIsImN1cnIiLCJNYXAiLCJnZXRIb3N0QW5kUHJvdG9jb2xGcm9tTGlua1VybCIsInBhcnRzIiwiV2hpcFdoZXBTaWduYWxpbmdIZWxwZXIiLCJfdXJsIiwiX3Jlc291cmNlIiwiZmV0Y2giLCJyZXNwb25zZSIsImhlYWRlcnMiLCJoZWFkZXJSZWciLCJsaW5rcyIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJhbnN3ZXJTRFAiLCJsb2NhdGlvbiIsInBhcnNlZCIsImVycm9yTWVzc2FnZSIsIklDRV9HQVRIRVJfVElNRU9VVCIsInRyaWNrbGVJY2UiLCJXSEVQQ2xpZW50Iiwib3B0aW9uc0Zyb21VcmwiLCJfd2hpcEhlbHBlciIsIl9pbnRlcm5hbENvbm5lY3QiLCJpbml0IiwiYWRkVHJhbnNjZWl2ZXIiLCJkaXJlY3Rpb24iLCJjcmVhdGVPZmZlciIsImxvY2FsIiwibG9jYWxEZXNjcmlwdGlvbiIsInBvc3RTRFBPZmZlciIsImhvc3RGcmFnIiwic3JmbHhGcmFnIiwidHJpY2tsZSIsInBvc3RTcmZseCIsIndhaXRUb0dhdGhlckljZSIsIl9wb3N0T2ZmZXIiLCJfcG9zdENhbmRpZGF0ZUZyYWdtZW50cyIsInByb3RvIiwiX3doaXBVcmwiLCJnZXRPcHRpb25zIiwicGxheWJhY2tGYWN0b3J5IiwicGxheWJhY2tJbXBsIiwiUmVkNVByb1N1YnNjcmliZXIiLCJfb3JkZXIiLCJTZXQiLCJfZ2V0UGxheWJhY2tGcm9tT3JkZXIiLCJjb252ZXJ0RGltZW5zaW9uT3B0aW9ucyIsInZvIiwibWVkaWFDb25zdHJhaW50c1RvRmxhc2h2YXJzIiwiZnYiLCJQdWJsaXNoZXJTb3VyY2VIYW5kbGVyIiwiX3B1Ymxpc2hlclR5cGUiLCJfZW1iZWRGdXR1cmUiLCJzdHJlYW1Nb2RlIiwiYXBwTmFtZSIsInJvb21OYW1lIiwibWVkaWFDb25zdHJhaW50cyIsInB1Ymxpc2hPcHRpb25zIiwiY2xlYW5VcCIsInVwZGF0ZVJlc29sdXRpb24iLCJwdWJsaXNoZXJJZCIsIlB1Ymxpc2hWaWV3IiwiUHVibGlzaFR5cGVzIiwiUHVibGlzaE1vZGVUeXBlcyIsIkxJVkUiLCJSRUNPUkQiLCJBUFBFTkQiLCJpbmZsYXRlIiwiZGVmaW5lUHJvcGVydHkiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJSVENNZWRpYVZpZGVvQ29uc3RyYWludCIsIlJUTVBNZWRpYVZpZGVvQ29uc3RyYWludCIsIlJUQ01lZGlhQ29uc3RyYWludCIsIlJUTVBNZWRpYUNvbnN0cmFpbnQiLCJSVE1QUHVibGlzaGVyIiwiX2Nvbm5lY3RGdXR1cmUiLCJhdHRhY2hQdWJsaXNoZXIiLCJzZXRBY3RpdmVJZCIsIl90ZWFyRG93bkNvbm5lY3RDYWxsYmFjayIsIl9zZXRVcENvbm5lY3RDYWxsYmFjayIsInNyY0hhbmRsZXIiLCJnZXRFbWJlZE9wZXJhdGlvbiIsImNvdW50IiwibGltaXQiLCJ0cnlDb25uZWN0Iiwic2V0TWVkaWFRdWFsaXR5IiwibmV3T3B0aW9ucyIsIlB1Ymxpc2hlclNvY2tldEhlbHBlciIsIm9uU0RQQW5zd2VyIiwib25JbnN1ZmZpY2llbnRCYW5kd2lkdGgiLCJvblN1ZmZpY2llbnRCYW5kd2lkdGgiLCJvblJlY292ZXJpbmdCYW5kd2lkdGgiLCJvblB1Ymxpc2hlclN0YXR1cyIsImdyb3VwIiwibGVhdmVHcm91cCIsIlB1Ymxpc2hlclBlZXJIZWxwZXIiLCJvblBlZXJDb25uZWN0aW9uVHJhY2tBZGQiLCJvbnNpZ25hbGluZ3N0YXRlY2hhbmdlIiwic2lnbmFsaW5nU3RhdGUiLCJiYW5kd2lkdGgiLCJmb3JjZVZQOCIsImZvcmNlU0RQU3RyaXAiLCJvZmZlclByb21pc2UiLCJyZXBsYWNlQWxsIiwiY29tcGxldGUiLCJwdWJTdGFydFJlZ2V4IiwicHViU3RvcFJlZ2V4IiwiZGVidWdMb2ciLCJ3YXJuTG9nIiwiZXJyb3JMb2ciLCJrZXlGcmFtZXJhdGUiLCJjbGVhck1lZGlhT25VbnB1Ymxpc2giLCJvbkdldFVzZXJNZWRpYSIsImdldENvbnN0cmFpbnRzRnJvbU1lZGlhU3RyZWFtIiwiZ2V0VHJhY2tzIiwia2luZCIsImdldFNldHRpbmdzIiwiZ2V0Q29uc3RyYWludHMiLCJyZXF1ZXN0ZWQiLCJhY2NlcHRlZCIsIlJUQ1B1Ymxpc2hlciIsIl9zdHJlYW1GdXR1cmUiLCJfYXZhaWxhYmxlRnV0dXJlIiwiX3BlZXJGdXR1cmUiLCJfb2ZmZXJGdXR1cmUiLCJfc2VuZE9mZmVyRnV0dXJlIiwiX3RyaWNrbGVFbmRGdXR1cmUiLCJfcHVibGlzaEZ1dHVyZSIsIl91bnB1Ymxpc2hGdXR1cmUiLCJfb25PcmllbnRhdGlvbkNoYW5nZSIsIl9nVU1SZWplY3Rpb25IYW5kbGVyIiwiX29uR1VNUmVqZWN0aW9uIiwiX2lzTWVkaWFTdHJlYW1UcmFja0xpc3RpbmdNdW5nZWQiLCJ0cmFja3MiLCJfZ3VtIiwicmVqIiwicmVqZWN0ZWRDb25zdHJhaW50cyIsImRldmljZU9yaWVudGF0aW9uIiwicHJldmlldyIsImJ1bmRsZSIsIl9zZW5kT2ZmRnV0dXJlIiwiaGFuZGxlT2ZmZXIiLCJmcmFtZXJhdGUiLCJwdWJsaXNoIiwicG9zdFVucHVibGlzaCIsIl9nZXRNZWRpYVN0cmVhbSIsIl9vbk1lZGlhU3RyZWFtUmVjZWl2ZWQiLCJtZWRpYVByb21pc2UiLCJ1bnByZXZpZXciLCJfZ2V0VHJpY2tsZUVuZCIsInN0cmVhbVR5cGUiLCJfY3JlYXRlUGVlckNvbm5lY3Rpb24iLCJhZGRUcmFjayIsIl9jcmVhdGVPZmZlciIsIl9zZW5kT2ZmZXIiLCJfc2V0UmVtb3RlRGVzY3JpcHRpb24iLCJfcmVxdWVzdFB1Ymxpc2giLCJzZXRVcFdpdGhTb2NrZXQiLCJhbmRSZW1vdmUiLCJjbGVhckhlbHBlcnMiLCJfcmVxdWVzdFVucHVibGlzaCIsImdyb3VwTmFtZSIsInVubXV0ZUF1ZGlvIiwiZXJyb3JNc2ciLCJzdG9wUmVzdWx0IiwiV0hJUENsaWVudCIsImNsZWFuZWQiLCJ0cmFuc2NlaXZlciIsImNyZWF0ZU9mZmVyV2l0aG91dFNldExvY2FsIiwicHVibGlzaEZhY3RvcnkiLCJwdWJsaXNoZXJJbXBsIiwiUmVkNVByb1B1Ymxpc2hlciIsIl9nZXRQdWJsaXNoZXJGcm9tT3JkZXIiLCJTT19TVUJUWVBFX1BST1BFUlRZIiwiU09fU1VCVFlQRV9NRVRIT0QiLCJTT19TVUJUWVBFX1JFTU9WRSIsInNvTmFtZSIsImRlY29kZU1lc3NhZ2VJZkpTT05TdHJpbmciLCJQcm9wZXJ0eURhdGEiLCJNZXRob2REYXRhIiwibWVzc2FnZUxpc3QiLCJSZWQ1UHJvU2hhcmVkT2JqZWN0IiwiX3RyYW5zcG9ydCIsIl90cmFuc3BvcnRDb250cm9sbGVyIiwiX2hhbmRsZVRyYW5zcG9ydFN0YXRlRXZlbnRzIiwiX2hhbmRsZU1lc3NhZ2VUcmFuc3BvcnRDaGFuZ2UiLCJzZXRNZXNzYWdlVHJhbnNwb3J0Q29udHJvbGxlciIsImFkZFNoYXJlZE9iamVjdFJlc3BvbnNlSGFuZGxlciIsIl9oYW5kbGVTb2NrZXRTdGF0ZUV2ZW50cyIsInRvT2JqZWN0IiwiZXZlbnRzIiwic3VidHlwZSIsIl9ub3RpZnlPZlByb3BlcnR5VmFsdWVzIiwiX2dldEpzb25Gcm9tU29ja2V0TWVzc2FnZSIsIl9ub3RpZnlPZkV2ZW50cyIsInJlbW92ZVNoYXJlZE9iamVjdFJlc3BvbnNlSGFuZGxlciIsIm9mZiIsIl9lc3RhYmxpc2hUcmFuc3BvcnQiLCJSZWQ1UHJvU2hhcmVkT2JqZWN0U29ja2V0IiwidXVpZCIsIl9zaGFyZWRPYmplY3ROYW1lIiwiY2FwYWJpbGl0eSIsImNhcGFiaWxpdGllcyIsIm9uSWNlVHJpY2tsZUNvbXBsZXRlIiwib25Tb2NrZXRTdGF0dXMiLCJzb1N0YXJ0UmVnZXgiLCJSZWQ1UHJvU2hhcmVkT2JqZWN0UGVlckNvbm5lY3Rpb24iLCJfc29ja2V0IiwicGVlckNvbm5lY3Rpb24iLCJwZWVyUHJvbWlzZSIsImdldERhdGFDaGFubmVsQ29uZmlndXJhdGlvbiIsInN0YXJ0Q2hhbm5lbCIsImdldERhdGFDaGFubmVsTmFtZSIsInN0YXR1c0RhdGEiLCJERUZBVUxUX0dST1VQX05BTUUiLCJHUk9VUF9UUkFDS19DT1VOVCIsImRlZmF1bHRDb25maWd1cmF0aW9uIiwiYXV0b0dlbmVyYXRlTWVkaWFTdHJlYW0iLCJtaXhBdWRpb0Rvd24iLCJSVENDb25mZXJlbmNlUGFydGljaXBhbnQiLCJfYXVkaW9UcmFja3MiLCJfdmlkZW9UcmFja3MiLCJfY29uZmVyZW5jZVN0cmVhbSIsImF1ZGlvRWxlbWVudCIsImFtb3VudCIsInYiLCJnZXRWaWRlb1RyYWNrcyIsIkF1ZGlvQ29udGV4dCIsImRlc3QiLCJjcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uIiwiY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UiLCJnZXRBdWRpb1RyYWNrcyIsImpvaW5Hcm91cCIsIl9zdGFydFJlY2VpdmVycyIsInBvc3RVbmpvaW4iLCJyZWNlaXZlclRyYWNrcyIsImdldFRyYW5zY2VpdmVycyIsImN1cnJlbnREaXJlY3Rpb24iLCJyZWNlaXZlciIsIk1lZGlhU3RyZWFtIiwiYWMiLCJzb3VyY2VzIiwiX3BhY2tTdHJlYW1XaXRoQXVkaW8iLCJvdmVybGF5T3B0aW9ucyIsInBhcnRpY2lwYW50SWQiLCJwdWJsaXNoZXJOYW1lIiwic3Vic2NyaWJlckxpYiIsInB1Ymxpc2hlckxpYiIsInNoYXJlZE9iamVjdExpYiIsInB1Ymxpc2hlckV2ZW50Iiwic3Vic2NyaWJlckV2ZW50Iiwic2hhcmVkb2JqZWN0RXZlbnQiLCJtZXNzYWdlVHJhbnNwb3J0U3RhdGVFdmVudCIsIlJUQ0NvbmZlcmVuY2VQYXJ0aWNpcGFudEV2ZW50VHlwZSIsInBhcnRpY2lwYW50U3RhdGVFdmVudCIsInBsYXliYWNrRW51bSIsIndlYnJ0Y0VudW0iLCJMT0dfTEVWRUwiLCJzZXRMb2dMZXZlbCIsIlNES19WRVJTSU9OIiwiTE9HX0xFVkVMUyIsIl9nZXRMb2dnZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87UUNWQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0JBQW9CO0FBQ3JELCtCQUErQixvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUIsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtQ0FBbUM7QUFDNUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3o1Qlk7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRWtDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTUEsdUJBQVM7RUFBQTtJQUFBO0VBQUE7RUFBQTtJQUFBO0lBQUEsT0FDcEIsZUFBT0MsR0FBRyxFQUFFO01BQ1ZDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLGtCQUFrQjtNQUFFO01BQzlCRixHQUFHLENBQUNHLElBQUksQ0FBQ0MsV0FBVyxFQUFFLEVBQ3RCSixHQUFHLENBQUNLLElBQUksRUFDUkMsdUJBQWEsQ0FBQ04sR0FBRyxDQUFDTyxLQUFLLENBQUMsRUFDeEJQLEdBQUcsQ0FBQ1EsR0FBRyxDQUNSO0lBQ0g7RUFBQztFQUFBO0FBQUEsSTs7QUNqQlM7O0FBRWdEO0FBQ2pCO0FBRTNDLElBQUlDLE1BQU07QUFDVixJQUFJQyxLQUFLO0FBRVQsSUFBTUMsYUFBYSxHQUFHLFNBQWhCQSxhQUFhLENBQUlDLFVBQVUsRUFBSztFQUNwQyxPQUFPLFVBQUFDLE9BQU8sRUFBSTtJQUNoQixrQkFBV0QsVUFBVSxlQUFLQyxPQUFPO0VBQ25DLENBQUM7QUFDSCxDQUFDO0FBRUQsSUFBTUMsWUFBUSxHQUFHLFNBQVhBLFFBQVEsQ0FBSVAsS0FBSyxFQUFLO0VBQzFCLE9BQU8sVUFBQ1EsTUFBTSxFQUFFRixPQUFPLEVBQUs7SUFDMUJKLE1BQU0sQ0FBQ0YsS0FBSyxDQUFDLENBQUNJLGFBQWEsQ0FBQ0ksTUFBTSxDQUFDLENBQUNGLE9BQU8sQ0FBQyxDQUFDO0VBQy9DLENBQUM7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNPLElBQU1HLE1BQU0sR0FBRztFQUNwQkMsS0FBSyxFQUFFLE9BQU87RUFDZEMsSUFBSSxFQUFFLE1BQU07RUFDWkMsS0FBSyxFQUFFLE9BQU87RUFDZEMsSUFBSSxFQUFFLE1BQU07RUFDWkMsS0FBSyxFQUFFLE9BQU87RUFDZEMsS0FBSyxFQUFFO0FBQ1QsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU1DLG1CQUFlLEdBQUcsU0FBbEJBLGVBQWUsQ0FBSWhCLEtBQUssRUFBNkM7RUFBQSxJQUEzQ2lCLE1BQU0sdUVBQUcsS0FBSztFQUFBLElBQUVDLFVBQVUsdUVBQUdDLFNBQVM7RUFDM0UsSUFBSUMsT0FBTyxHQUFHLEVBQUU7RUFDaEJBLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDO0lBQ1hyQixLQUFLLEVBQUVBLEtBQUs7SUFDWnNCLE1BQU0sRUFBRSxJQUFJOUIsdUJBQVMsRUFBRTtJQUN2QitCLElBQUksRUFBRTtFQUNSLENBQUMsQ0FBQztFQUNGLElBQUlMLFVBQVUsRUFBRTtJQUNkLElBQU1NLElBQUksR0FBR04sVUFBVSxDQUFDTyxHQUFHLENBQUMsVUFBQUMsSUFBSSxFQUFJO01BQ2xDQSxJQUFJLENBQUMxQixLQUFLLEdBQUdBLEtBQUs7SUFDcEIsQ0FBQyxDQUFDO0lBQ0ZvQixPQUFPLEdBQUdBLE9BQU8sQ0FBQ08sTUFBTSxDQUFDSCxJQUFJLENBQUM7RUFDaEM7RUFDQSxJQUFJUCxNQUFNLEVBQUU7SUFDVmQsS0FBSyxHQUFHLEVBQUU7SUFDVmlCLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDO01BQ1hyQixLQUFLLEVBQUVBLEtBQUs7TUFDWnNCLE1BQU0sRUFBRTtRQUNOTSxLQUFLLEVBQUUsZUFBQW5DLEdBQUcsRUFBSTtVQUNaLElBQU1FLEdBQUcsY0FBT0YsR0FBRyxDQUFDRyxJQUFJLENBQUNDLFdBQVcsRUFBRSxlQUFLRSx1QkFBYSxDQUFDTixHQUFHLENBQUNPLEtBQUssQ0FBQyxlQUFLUCxHQUFHLENBQUNRLEdBQUcsQ0FBRTtVQUNqRkUsS0FBSyxDQUFDa0IsSUFBSSxDQUFDMUIsR0FBRyxDQUFDO1FBQ2pCO01BQ0Y7SUFDRixDQUFDLENBQUM7RUFDSjtFQUNBTyxNQUFNLEdBQUcyQiw4QkFBWSxDQUFDO0lBQ3BCN0IsS0FBSyxFQUFFQSxLQUFLO0lBQ1pGLElBQUksRUFBRSxhQUFhO0lBQ25Cc0IsT0FBTyxFQUFFQTtFQUNYLENBQUMsQ0FBQztBQUNKLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFNVSxTQUFTLEdBQUcsU0FBWkEsU0FBUyxHQUFTO0VBQzdCLE9BQU81QixNQUFNO0FBQ2YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTTZCLGVBQWUsR0FBRyxTQUFsQkEsZUFBZSxHQUFTO0VBQ25DLE9BQU81QixLQUFLO0FBQ2QsQ0FBQzs7QUFFRDtBQUNPLElBQU02QixLQUFLLEdBQUd6QixZQUFRLENBQUNFLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDO0FBQ3BDLElBQU11QixJQUFJLEdBQUcxQixZQUFRLENBQUNFLE1BQU0sQ0FBQ0UsSUFBSSxDQUFDO0FBQ2xDLElBQU11QixTQUFLLEdBQUczQixZQUFRLENBQUNFLE1BQU0sQ0FBQ0csS0FBSyxDQUFDO0FBQ3BDLElBQU11QixRQUFJLEdBQUc1QixZQUFRLENBQUNFLE1BQU0sQ0FBQ0ksSUFBSSxDQUFDO0FBQ2xDLElBQU11QixTQUFLLEdBQUc3QixZQUFRLENBQUNFLE1BQU0sQ0FBQ0ssS0FBSyxDQUFDO0FBQ3BDLElBQU11QixTQUFLLEdBQUc5QixZQUFRLENBQUNFLE1BQU0sQ0FBQ00sS0FBSyxDQUFDLEM7O0FDcEcvQjs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFLTXVCLGdCQUFnQixvQ0FDcEIsNEJBQWU7RUFBQTtFQUFBO0VBQ2IsSUFBSSxDQUFDQyxPQUFPLEdBQUdwQixTQUFTO0VBQ3hCLElBQUksQ0FBQ3FCLE1BQU0sR0FBR3JCLFNBQVM7RUFDdkIsSUFBSSxDQUFDc0IsT0FBTyxHQUFHLElBQUlDLE9BQU8sQ0FBQyxVQUFDSCxPQUFPLEVBQUVDLE1BQU0sRUFBSztJQUM5QyxLQUFJLENBQUNELE9BQU8sR0FBR0EsT0FBTztJQUN0QixLQUFJLENBQUNDLE1BQU0sR0FBR0EsTUFBTTtFQUN0QixDQUFDLENBQUM7QUFDSixDQUFDO0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTUcsT0FBTyxHQUFHO0VBQ2RDLGdCQUFnQixFQUFFLDBCQUFDQyxlQUFlLEVBQUs7SUFDckMsSUFBSUMsQ0FBQyxHQUFHRCxlQUFlO0lBQ3ZCLElBQUksQ0FBQ0MsQ0FBQyxFQUFFO01BQ05BLENBQUMsR0FBRyxJQUFJUixnQkFBZ0IsRUFBRTtJQUM1QjtJQUNBLE9BQU9RLENBQUM7RUFDVjtBQUNGLENBQUM7QUFFTSxJQUFNQyxlQUFlLEdBQUdULGdCQUFnQjtBQUN4QyxJQUFNVSxNQUFNLEdBQUdMLE9BQU8sQzs7QUN0Q2pCOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsK0NBQ1o7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQzJDO0FBRTNDLElBQU1sQixzQkFBRyxHQUFHLElBQUl3QixPQUFPLEVBQUU7QUFFekIsSUFBTUMsR0FBRyxHQUFHLFNBQU5BLEdBQUcsQ0FBSUMsR0FBRyxFQUFLO0VBQ25CLElBQUksQ0FBQzFCLHNCQUFHLENBQUMyQixHQUFHLENBQUNELEdBQUcsQ0FBQyxFQUFFO0lBQ2pCMUIsc0JBQUcsQ0FBQzRCLEdBQUcsQ0FBQ0YsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO0VBQ2xCO0VBRUEsT0FBTzFCLHNCQUFHLENBQUM2QixHQUFHLENBQUNILEdBQUcsQ0FBQztBQUNyQixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTUksbUNBQWdCO0VBRTNCLDRCQUFlO0lBQUE7SUFBQTtJQUNiLElBQUksQ0FBQ0MsU0FBUyxHQUFJLFlBQVk7TUFDNUIsK0NBQU8sU0FBV0EsU0FBUyxDQUFFaEMsSUFBSTtRQUFBO1VBQUE7WUFBQTtjQUFBLE1BQ3hCQSxJQUFJLENBQUNpQyxNQUFNLEdBQUcsQ0FBQztnQkFBQTtnQkFBQTtjQUFBO2NBQUE7Y0FDcEIsT0FBTWpDLElBQUksQ0FBQ2tDLEtBQUssRUFBRTtZQUFBO2NBQUE7Y0FBQTtZQUFBO1lBQUE7Y0FBQTtVQUFBO1FBQUEsR0FGSkYsU0FBUztNQUFBLENBSTFCO0lBQ0gsQ0FBQyxFQUFHOztJQUVKO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtJQUNJTixHQUFHLENBQUMsSUFBSSxDQUFDLENBQUNTLElBQUksR0FBRyxVQUFDQyxRQUFRLEVBQUVuQyxHQUFHLEVBQUVvQyxPQUFPLEVBQUVwQixPQUFPLEVBQXNDO01BQUEsSUFBcENxQixNQUFNLHVFQUFHLElBQUk7TUFBQSxJQUFFQyxTQUFTLHVFQUFHLElBQUk7TUFDaEYsZ0JBQXFCYixHQUFHLENBQUMsS0FBSSxDQUFDLENBQUNjLElBQUksQ0FBQ0osUUFBUSxFQUFFbkMsR0FBRyxDQUFDO1FBQUE7UUFBM0NGLElBQUk7UUFBRTBDLElBQUk7TUFDakIsSUFBSSxDQUFDQSxJQUFJLEVBQUU7UUFDVHhCLE9BQU8sQ0FBQ0QsTUFBTSxDQUFDdUIsU0FBUyxDQUFDO01BQzNCLENBQUMsTUFBTTtRQUNMLElBQUlHLENBQUM7UUFDTCxJQUFJQyxHQUFHLEdBQUdOLE9BQU8sQ0FBQ3RDLElBQUksQ0FBQztRQUN2QjRDLEdBQUcsR0FBR0EsR0FBRyxJQUFJTixPQUFPO1FBQ3BCLElBQUlDLE1BQU0sRUFBRTtVQUNWSSxDQUFDLEdBQUcsSUFBSUQsSUFBSSxFQUFFLENBQUNILE1BQU0sQ0FBQyxDQUFDSyxHQUFHLENBQUM7UUFDN0IsQ0FBQyxNQUFNO1VBQ0xELENBQUMsR0FBRyxJQUFJRCxJQUFJLENBQUNFLEdBQUcsQ0FBQztRQUNuQjtRQUNBRCxDQUFDLENBQUNFLElBQUksQ0FBQyxVQUFDQyxRQUFRLEVBQUs7VUFDbkI1QixPQUFPLENBQUNGLE9BQU8sQ0FBQzhCLFFBQVEsQ0FBQztRQUMzQixDQUFDLENBQUMsQ0FDREMsS0FBSyxDQUFDLFVBQUFsQyxLQUFLLEVBQUk7VUFBRTtVQUNoQjJCLFNBQVMsR0FBRzNCLEtBQUs7VUFDakJjLEdBQUcsQ0FBQyxLQUFJLENBQUMsQ0FBQ1MsSUFBSSxDQUFDQyxRQUFRLEVBQUVuQyxHQUFHLEVBQUVvQyxPQUFPLEVBQUVwQixPQUFPLEVBQUVxQixNQUFNLEVBQUVDLFNBQVMsQ0FBQztRQUNwRSxDQUFDLENBQUM7TUFDSjtJQUNGLENBQUM7O0lBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtJQUNJYixHQUFHLENBQUMsSUFBSSxDQUFDLENBQUNjLElBQUksR0FBRyxVQUFDTyxLQUFLLEVBQUU5QyxHQUFHLEVBQUs7TUFDL0IsSUFBSXdDLElBQUk7TUFDUixJQUFJTyxHQUFHO01BQ1AsSUFBTVIsSUFBSSxHQUFHTyxLQUFLLENBQUNQLElBQUksRUFBRTtNQUN6QixJQUFJLENBQUNBLElBQUksQ0FBQ1MsSUFBSSxFQUFFO1FBQ2RELEdBQUcsR0FBR1IsSUFBSSxDQUFDVSxLQUFLO1FBQ2hCVCxJQUFJLEdBQUd4QyxHQUFHLENBQUM2QixHQUFHLENBQUNrQixHQUFHLENBQUM7TUFDckI7TUFDQSxPQUFPLENBQUNBLEdBQUcsRUFBRVAsSUFBSSxDQUFDO0lBQ3BCLENBQUM7RUFDSDs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVpFO0lBQUE7SUFBQSxPQWFBLGdCQUFRTSxLQUFLLEVBQUU5QyxHQUFHLEVBQUVvQyxPQUFPLEVBQWlCO01BQUEsSUFBZkMsTUFBTSx1RUFBRyxJQUFJO01BQ3hDLElBQU1yQixPQUFPLEdBQUcsSUFBSU0sZUFBZSxFQUFFO01BQ3JDRyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUNTLElBQUksQ0FBQyxJQUFJLENBQUNILFNBQVMsQ0FBQ2UsS0FBSyxDQUFDSSxLQUFLLEVBQUUsQ0FBQyxFQUFFbEQsR0FBRyxFQUFFb0MsT0FBTyxFQUFFcEIsT0FBTyxFQUFFcUIsTUFBTSxDQUFDO01BQzVFLE9BQU9yQixPQUFPLENBQUNBLE9BQU87SUFDeEI7RUFBQztFQUFBO0FBQUE7QUFJWWMsMEZBQWdCLEU7Ozs7Ozs7O0FDL0cvQixJQUFNcUIsUUFBUSxHQUFHLEdBQUc7QUFDcEIsSUFBTUMsWUFBWSxHQUFHLFNBQVM7O0FBRTlCO0FBQ0E7QUFDQTtBQUZBLElBR01DLFlBQVk7RUFFaEIsd0JBQWU7SUFBQTtJQUNiLElBQUksQ0FBQ0MsVUFBVSxHQUFHLENBQUMsQ0FBQztJQUNwQixJQUFJLENBQUNBLFVBQVUsQ0FBQ0YsWUFBWSxDQUFDLEdBQUcsRUFBRTtFQUNwQzs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEsaUJBQVNHLFNBQVMsRUFBRUMsS0FBSyxFQUFFO01BQ3ZCLElBQUlDLENBQUM7UUFBRXpCLE1BQU0sR0FBR3VCLFNBQVMsQ0FBQ3ZCLE1BQU07TUFDaEMsS0FBSXlCLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR3pCLE1BQU0sRUFBRXlCLENBQUMsRUFBRSxFQUFFO1FBQzFCRixTQUFTLENBQUNFLENBQUMsQ0FBQyxDQUFDRCxLQUFLLENBQUM7TUFDckI7SUFDSjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFMRTtJQUFBO0lBQUEsT0FNQSxZQUFJMUQsSUFBSSxFQUFFNEQsRUFBRSxFQUFFO01BQ1osSUFBSSxPQUFPQSxFQUFFLEtBQUssVUFBVSxFQUFFO1FBQzVCO01BQ0Y7TUFFQSxJQUFJNUQsSUFBSSxLQUFLcUQsUUFBUSxFQUFFO1FBQ3JCLElBQUksQ0FBQ0csVUFBVSxDQUFDRixZQUFZLENBQUMsQ0FBQ3hELElBQUksQ0FBQzhELEVBQUUsQ0FBQztRQUN0QztNQUNGO01BRUEsSUFBSSxJQUFJLENBQUNKLFVBQVUsQ0FBQ3hELElBQUksQ0FBQyxLQUFLSixTQUFTLEVBQUU7UUFDdkMsSUFBSSxDQUFDNEQsVUFBVSxDQUFDeEQsSUFBSSxDQUFDLEdBQUcsRUFBRTtNQUM1QjtNQUVBLElBQUksSUFBSSxDQUFDd0QsVUFBVSxDQUFDeEQsSUFBSSxDQUFDLENBQUM2RCxPQUFPLENBQUNELEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO1FBQzVDLElBQUksQ0FBQ0osVUFBVSxDQUFDeEQsSUFBSSxDQUFDLENBQUNGLElBQUksQ0FBQzhELEVBQUUsQ0FBQztNQUNoQztJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUxFO0lBQUE7SUFBQSxPQU1BLGFBQUs1RCxJQUFJLEVBQUU0RCxFQUFFLEVBQUU7TUFDYixJQUFJMUQsR0FBRyxHQUFHLElBQUksQ0FBQ3NELFVBQVUsQ0FBQ3hELElBQUksQ0FBQztNQUMvQixJQUFJQSxJQUFJLEtBQUtxRCxRQUFRLEVBQUU7UUFDckJuRCxHQUFHLEdBQUcsSUFBSSxDQUFDc0QsVUFBVSxDQUFDRixZQUFZLENBQUM7TUFDckM7TUFDQSxJQUFJcEQsR0FBRyxFQUFFO1FBQ1AsSUFBTTRELEtBQUssR0FBRzVELEdBQUcsQ0FBQzJELE9BQU8sQ0FBQ0QsRUFBRSxDQUFDO1FBQzdCLElBQUlFLEtBQUssS0FBSyxDQUFDLENBQUMsRUFBRTtVQUNoQjVELEdBQUcsQ0FBQzZELE1BQU0sQ0FBQ0QsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUN0QjtNQUNGO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLGlCQUFTSixLQUFLLEVBQUU7TUFDZCxJQUFNMUQsSUFBSSxHQUFHMEQsS0FBSyxDQUFDMUQsSUFBSTtNQUN2QixJQUFJLElBQUksQ0FBQ3dELFVBQVUsQ0FBQ3hELElBQUksQ0FBQyxFQUFFO1FBQ3pCLElBQUksQ0FBQ2dFLE9BQU8sQ0FBQyxJQUFJLENBQUNSLFVBQVUsQ0FBQ3hELElBQUksQ0FBQyxFQUFFMEQsS0FBSyxDQUFDO01BQzVDO01BQ0EsSUFBSSxDQUFDTSxPQUFPLENBQUMsSUFBSSxDQUFDUixVQUFVLENBQUNGLFlBQVksQ0FBQyxFQUFFSSxLQUFLLENBQUM7SUFDcEQ7RUFBQztFQUFBO0FBQUE7QUFJWUgsOERBQVksRTs7QUN2RmY7O0FBRVo7QUFDQTtBQUNBO0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR08sSUFBTVUsbUJBQW1CLG1DQUM5Qiw2QkFBYWxGLE9BQU8sRUFBRTtFQUFBO0VBQ3BCLElBQUksQ0FBQ1IsSUFBSSxHQUFHLGdCQUFnQjtFQUM1QixJQUFJLENBQUNRLE9BQU8sR0FBR0EsT0FBTztBQUN4QixDQUFDOztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTW1GLGlDQUFpQyxtQ0FDNUMsMkNBQWFuRixPQUFPLEVBQUU7RUFBQTtFQUNwQixJQUFJLENBQUNSLElBQUksR0FBRyxtQ0FBbUM7RUFDL0MsSUFBSSxDQUFDUSxPQUFPLEdBQUdBLE9BQU87QUFDeEIsQ0FBQyxFOztBQ3BCUzs7QUFBQTtBQUVaLElBQU1vRixRQUFRLEdBQUcsa0JBQWtCO0FBQ25DLElBQU1DLE9BQU8sR0FBRyxrQkFBa0I7QUFFbEMsSUFBTUMsV0FBVyxHQUFHLElBQUkzQyxPQUFPLEVBQUUsRUFBQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzRDLE9BQU8sQ0FBRUMsSUFBSSxFQUFDQyxLQUFLLEVBQUNDLEdBQUcsRUFBRTtFQUNoQyxJQUFJQyxNQUFNLEdBQUcsRUFBRTtJQUFFQyxNQUFNLEdBQUdILEtBQUs7SUFBRUksR0FBRyxHQUFHSixLQUFLLEdBQUdDLEdBQUc7RUFDbEQsR0FBRztJQUNEQyxNQUFNLElBQUlHLE1BQU0sQ0FBQ0MsWUFBWSxDQUFDUCxJQUFJLENBQUNJLE1BQU0sRUFBRSxDQUFDLENBQUM7RUFDL0MsQ0FBQyxRQUNLQSxNQUFNLEdBQUdDLEdBQUc7RUFDbEIsT0FBT0YsTUFBTTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTSyxvQkFBb0IsQ0FBRUMsSUFBSSxFQUFFQyxRQUFRLEVBQUU7RUFDN0MsSUFBSTtJQUNGLElBQUk5QixLQUFLLEdBQUcrQixJQUFJLENBQUNDLEtBQUssQ0FBQ0gsSUFBSSxDQUFDO0lBQzVCLE9BQU83QixLQUFLLENBQUM4QixRQUFRLENBQUM7RUFDeEIsQ0FBQyxDQUNELE9BQU9HLENBQUMsRUFBRTtJQUNSLElBQUlDLEtBQUssR0FBR2xCLFFBQVEsQ0FBQ21CLElBQUksQ0FBQ04sSUFBSSxDQUFDO0lBQy9CLElBQUlPLE1BQU07SUFDVixJQUFJRixLQUFLLElBQUlBLEtBQUssQ0FBQ25ELE1BQU0sR0FBRyxDQUFDLEVBQUU7TUFDN0JxRCxNQUFNLEdBQUduQixPQUFPLENBQUNrQixJQUFJLENBQUNOLElBQUksQ0FBQztNQUMzQixJQUFJSyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUtKLFFBQVEsSUFBSU0sTUFBTSxJQUFJQSxNQUFNLENBQUNyRCxNQUFNLEdBQUcsQ0FBQyxFQUFFO1FBQ3hELE9BQU9xRCxNQUFNLENBQUMsQ0FBQyxDQUFDO01BQ2xCO0lBQ0Y7SUFDQSxPQUFPM0YsU0FBUztFQUNsQjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzRGLHVCQUF1QixDQUFFUixJQUFJLEVBQUU7RUFDdEMsSUFBTVMsV0FBVyxHQUFHVixvQkFBb0IsQ0FBQ0MsSUFBSSxFQUFFLGFBQWEsQ0FBQztFQUM3RCxJQUFJUyxXQUFXLEVBQUU7SUFDZixPQUFPO01BQ0xBLFdBQVcsRUFBRUMsUUFBUSxDQUFDRCxXQUFXO0lBQ25DLENBQUM7RUFDSDtFQUNBLE9BQU83RixTQUFTO0FBQ2xCO0FBRUEsU0FBUytGLHlCQUF5QixDQUFFWCxJQUFJLEVBQUU7RUFDeEMsSUFBTVksYUFBYSxHQUFHYixvQkFBb0IsQ0FBQ0MsSUFBSSxFQUFFLGVBQWUsQ0FBQztFQUNqRSxJQUFJWSxhQUFhLEVBQUU7SUFDakIsT0FBTztNQUNMQSxhQUFhLEVBQUVBO0lBQ2pCLENBQUM7RUFDSDtFQUNBLE9BQU9oRyxTQUFTO0FBQ2xCO0FBRUEsSUFBTWlHLHVCQUF1QixHQUFHLFNBQTFCQSx1QkFBdUIsQ0FBSUMsTUFBTSxFQUFLO0VBQzFDLE9BQU96QixXQUFXLENBQUN0QyxHQUFHLENBQUMrRCxNQUFNLENBQUM7QUFDaEMsQ0FBQztBQUVELElBQU1DLHFCQUFxQixHQUFHLFNBQXhCQSxxQkFBcUIsQ0FBSUQsTUFBTSxFQUFLO0VBRXhDLElBQU1FLFVBQVUsR0FBRyxPQUFPRixNQUFNLENBQUNFLFVBQVUsS0FBSyxVQUFVLEdBQUdGLE1BQU0sQ0FBQ0UsVUFBVSxFQUFFLEdBQUdGLE1BQU0sQ0FBQ0UsVUFBVTtFQUVwRyxJQUFJQSxVQUFVLEVBQUU7SUFFZEYsTUFBTSxDQUFDRyxZQUFZLENBQUMsVUFBVSxDQUFDO0lBRS9CRCxVQUFVLENBQUNFLGdCQUFnQixDQUFDLFVBQVUsRUFBRSxVQUFBQyxhQUFhLEVBQUk7TUFFdkQsSUFBSUMsS0FBSyxHQUFHRCxhQUFhLENBQUNDLEtBQUs7TUFDL0JBLEtBQUssQ0FBQ0MsSUFBSSxHQUFHLFFBQVE7TUFDckJELEtBQUssQ0FBQ0YsZ0JBQWdCLENBQUMsV0FBVyxFQUFFLFVBQUFJLGNBQWMsRUFBSTtRQUNwRCxJQUFJQyxJQUFJO1FBQ1IsSUFBSTVDLENBQUM7UUFDTDtRQUNBLElBQUkyQyxjQUFjLElBQUlBLGNBQWMsQ0FBQ0UsYUFBYSxFQUFFO1VBQ2xERCxJQUFJLEdBQUdELGNBQWMsQ0FBQ0UsYUFBYSxDQUFDRCxJQUFJO1FBQzFDLENBQUMsTUFDSSxJQUFJM0csU0FBUyxLQUFLLGtCQUFJLEVBQUU7VUFDM0IyRyxJQUFJLEdBQUdILEtBQUssQ0FBQ0csSUFBSTtVQUNqQkEsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUksQ0FBQ3JFLE1BQU0sR0FBRyxDQUFDLEdBQUdxRSxJQUFJLEdBQUdILEtBQUssQ0FBQ0ssVUFBVTtRQUMxRCxDQUFDLE1BQ0ksSUFBSTdHLFNBQVMsS0FBSyxrQkFBSSxFQUFFO1VBQzNCO1VBQ0EyRyxJQUFJLEdBQUdBLElBQUksSUFBSUEsSUFBSSxDQUFDckUsTUFBTSxHQUFHLENBQUMsR0FBR3FFLElBQUksR0FBRyxrQkFBSSxDQUFDRSxVQUFVO1FBQ3pEO1FBQ0E7UUFDQUYsSUFBSSxHQUFHQSxJQUFJLElBQUksRUFBRTtRQUFBLDZCQUNpQjtVQUNoQyxJQUFJaEMsSUFBSSxHQUFHZ0MsSUFBSSxDQUFDNUMsQ0FBQyxDQUFDO1VBQ2xCLElBQUlZLElBQUksQ0FBQ3BCLEtBQUssRUFBRTtZQUNkLElBQUk2QixJQUFJLEdBQUcsT0FBT1QsSUFBSSxDQUFDcEIsS0FBSyxDQUFDb0IsSUFBSSxLQUFLLFFBQVEsR0FBR0EsSUFBSSxDQUFDcEIsS0FBSyxDQUFDb0IsSUFBSSxHQUFHRCxPQUFPLENBQUVDLElBQUksQ0FBQ3BCLEtBQUssQ0FBQ29CLElBQUksRUFBRyxDQUFDLEVBQUdBLElBQUksQ0FBQ21DLElBQUksQ0FBQztZQUM1RyxJQUFJakIsV0FBVyxHQUFHRCx1QkFBdUIsQ0FBQ1IsSUFBSSxDQUFDO1lBQy9DLElBQUlZLGFBQWEsR0FBR0QseUJBQXlCLENBQUNYLElBQUksQ0FBQztZQUNuRCxJQUFNOUUsR0FBRyxHQUFHMkYsdUJBQXVCLENBQUNDLE1BQU0sQ0FBQztZQUMzQyxJQUFJTCxXQUFXLElBQUt2RixHQUFHLElBQUlBLEdBQUcsQ0FBQ3VGLFdBQVksRUFBRTtjQUMzQ3ZGLEdBQUcsQ0FBQ3VGLFdBQVcsQ0FBQ2tCLE9BQU8sQ0FBQyxVQUFBL0MsRUFBRSxFQUFJO2dCQUM1QkEsRUFBRSxDQUFDNkIsV0FBVyxDQUFDO2NBQ2pCLENBQUMsQ0FBQztZQUNKO1lBQ0EsSUFBSUcsYUFBYSxJQUFLMUYsR0FBRyxJQUFJQSxHQUFHLENBQUMwRixhQUFjLEVBQUU7Y0FDL0MxRixHQUFHLENBQUMwRixhQUFhLENBQUNlLE9BQU8sQ0FBQyxVQUFBL0MsRUFBRSxFQUFJO2dCQUM5QkEsRUFBRSxDQUFDZ0MsYUFBYSxDQUFDO2NBQ25CLENBQUMsQ0FBQztZQUNKO1VBQ0Y7UUFDRixDQUFDO1FBbEJELEtBQUtqQyxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUc0QyxJQUFJLENBQUNyRSxNQUFNLEVBQUV5QixDQUFDLEVBQUU7VUFBQTtRQUFBO01BbUJsQyxDQUFDLENBQUM7SUFFSixDQUFDLENBQUM7RUFDSjtBQUVGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFNaUQscUJBQXFCLEdBQUcsU0FBeEJBLHFCQUFxQixDQUFJZCxNQUFNLEVBQUVlLFFBQVEsRUFBSztFQUV6RCxJQUFNM0csR0FBRyxHQUFHbUUsV0FBVyxDQUFDdEMsR0FBRyxDQUFDK0QsTUFBTSxDQUFDO0VBQ25DLElBQUksQ0FBQ3pCLFdBQVcsQ0FBQ3hDLEdBQUcsQ0FBQ2lFLE1BQU0sQ0FBQyxFQUFFO0lBQzVCQyxxQkFBcUIsQ0FBQ0QsTUFBTSxDQUFDO0lBQzdCekIsV0FBVyxDQUFDdkMsR0FBRyxDQUFDZ0UsTUFBTSxFQUFFO01BQ3RCTCxXQUFXLEVBQUU7SUFDZixDQUFDLENBQUM7RUFDSixDQUFDLE1BQU0sSUFBSSxDQUFDdkYsR0FBRyxDQUFDNEcsY0FBYyxDQUFDLGFBQWEsQ0FBQyxFQUFFO0lBQzdDekMsV0FBVyxDQUFDdEMsR0FBRyxDQUFDK0QsTUFBTSxDQUFDLENBQUNMLFdBQVcsR0FBRyxFQUFFO0VBQzFDO0VBQ0FwQixXQUFXLENBQUN0QyxHQUFHLENBQUMrRCxNQUFNLENBQUMsQ0FBQ0wsV0FBVyxDQUFDM0YsSUFBSSxDQUFDK0csUUFBUSxDQUFDO0FBRXBELENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFNRSx1QkFBdUIsR0FBRyxTQUExQkEsdUJBQXVCLENBQUlqQixNQUFNLEVBQUVlLFFBQVEsRUFBSztFQUUzRCxJQUFNM0csR0FBRyxHQUFHbUUsV0FBVyxDQUFDdEMsR0FBRyxDQUFDK0QsTUFBTSxDQUFDO0VBQ25DLElBQUksQ0FBQ3pCLFdBQVcsQ0FBQ3hDLEdBQUcsQ0FBQ2lFLE1BQU0sQ0FBQyxFQUFFO0lBQzVCQyxxQkFBcUIsQ0FBQ0QsTUFBTSxDQUFDO0lBQzdCekIsV0FBVyxDQUFDdkMsR0FBRyxDQUFDZ0UsTUFBTSxFQUFFO01BQ3RCRixhQUFhLEVBQUU7SUFDakIsQ0FBQyxDQUFDO0VBQ0osQ0FBQyxNQUFNLElBQUksQ0FBQzFGLEdBQUcsQ0FBQzRHLGNBQWMsQ0FBQyxlQUFlLENBQUMsRUFBRTtJQUMvQ3pDLFdBQVcsQ0FBQ3RDLEdBQUcsQ0FBQytELE1BQU0sQ0FBQyxDQUFDRixhQUFhLEdBQUcsRUFBRTtFQUM1QztFQUNBdkIsV0FBVyxDQUFDdEMsR0FBRyxDQUFDK0QsTUFBTSxDQUFDLENBQUNGLGFBQWEsQ0FBQzlGLElBQUksQ0FBQytHLFFBQVEsQ0FBQztBQUV0RCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFNRyxxQkFBcUIsR0FBRyxTQUF4QkEscUJBQXFCLENBQUdsQixNQUFNLEVBQUk7RUFDN0MsSUFBSXpCLFdBQVcsQ0FBQ3hDLEdBQUcsQ0FBQ2lFLE1BQU0sQ0FBQyxFQUFFO0lBQzNCekIsV0FBVyxDQUFDNEMsTUFBTSxDQUFDbkIsTUFBTSxDQUFDO0VBQzVCO0FBQ0YsQ0FBQyxDOzs7QUM3TWdEO0FBQ1E7QUFJakM7QUFDWTtBQUVwQyxJQUFJb0IseUJBQXlCLEdBQUcsRUFBRTs7QUFFbEM7QUFDQSxJQUFJQyxrQkFBa0IsR0FBRyxFQUFFO0FBQzNCLElBQUlDLHlCQUF5QixHQUFHLEtBQUs7QUFDckMsU0FBU0MsdUJBQXVCLEdBQUk7RUFDbEMsSUFBSSxDQUFDRCx5QkFBeUIsSUFBSUUsTUFBTSxDQUFDQyxVQUFVLElBQUlELE1BQU0sQ0FBQ0MsVUFBVSxDQUFDQyxPQUFPLEVBQUU7SUFDOUVKLHlCQUF5QixHQUFHLElBQUk7SUFDaENFLE1BQU0sQ0FBQ0MsVUFBVSxDQUFDRSxRQUFRLENBQUMsWUFBTTtNQUMvQixJQUFJOUQsQ0FBQztRQUFFekIsTUFBTSxHQUFHaUYsa0JBQWtCLENBQUNqRixNQUFNO01BQ3pDLEtBQUt5QixDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUd6QixNQUFNLEVBQUV5QixDQUFDLEVBQUUsRUFBRTtRQUMzQndELGtCQUFrQixDQUFDeEQsQ0FBQyxDQUFDLENBQUMyRCxNQUFNLENBQUNDLFVBQVUsQ0FBQ0csWUFBWSxDQUFDO01BQ3ZEO0lBQ0YsQ0FBQyxDQUFDO0VBQ047QUFDRjs7QUFFQTtBQUNBLElBQUlDLG1CQUFtQixHQUFHLEVBQUU7QUFDNUIsU0FBU0MsbUJBQW1CLENBQUVsRSxLQUFLLEVBQUU7RUFBRTtFQUNyQyxJQUFNbUUsaUJBQWlCLEdBQUdDLE1BQU0sQ0FBQ3JDLFdBQVcsR0FBR3FDLE1BQU0sQ0FBQ3JDLFdBQVcsQ0FBQ3NDLEtBQUssR0FBR25JLFNBQVM7RUFDbkYsSUFBTW9JLGdCQUFnQixHQUFJLE9BQU9ILGlCQUFpQixLQUFLLFdBQVcsR0FDN0RQLE1BQU0sQ0FBQ1csVUFBVSxDQUFDLHlCQUF5QixDQUFDLENBQUNDLE9BQU8sR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUM5REwsaUJBQWlCO0VBQ3JCLElBQUlsRSxDQUFDO0lBQUV6QixNQUFNLEdBQUd5RixtQkFBbUIsQ0FBQ3pGLE1BQU07RUFDMUN2QixTQUFLLHVEQUFpRHFILGdCQUFnQixRQUFLO0VBQzNFLEtBQUtyRSxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUd6QixNQUFNLEVBQUV5QixDQUFDLEVBQUUsRUFBRTtJQUMzQmdFLG1CQUFtQixDQUFDaEUsQ0FBQyxDQUFDLENBQUMsQ0FBQ3FFLGdCQUFnQixHQUFHLEVBQUUsSUFBSSxHQUFHLENBQUM7RUFDdkQ7QUFDRjs7QUFFQTtBQUNBLElBQUlHLGFBQWEsR0FBRyxFQUFFO0FBQ3RCLElBQUlDLGdCQUFnQixHQUFHLEtBQUs7QUFDNUIsU0FBU0MsYUFBYSxDQUFFakQsQ0FBQyxFQUFFO0VBQUU7RUFDM0I7RUFDQSxJQUFJekIsQ0FBQztJQUFFekIsTUFBTSxHQUFHaUcsYUFBYSxDQUFDakcsTUFBTTtFQUNwQyxLQUFLeUIsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHekIsTUFBTSxFQUFFeUIsQ0FBQyxFQUFFLEVBQUU7SUFDM0J3RSxhQUFhLENBQUN4RSxDQUFDLENBQUMsRUFBRTtFQUNwQjtFQUNBeUUsZ0JBQWdCLEdBQUcsSUFBSTtFQUN2QjtFQUNBO0VBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0EsSUFBTUUsWUFBWSxHQUFHLFNBQWZBLFlBQVksR0FBZTtFQUMvQixJQUFJQyxPQUFPLEdBQUcsT0FBTztFQUNyQjtFQUNBLElBQUk7SUFDRkEsT0FBTyxHQUFHLElBQUlqQixNQUFNLENBQUNrQixhQUFhLENBQUMsK0JBQStCLENBQUMsQ0FBQ0MsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDQyxPQUFPLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDckQsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQzs7SUFFekk7RUFDQSxDQUFDLENBQUMsT0FBT0QsQ0FBQyxFQUFFO0lBQ1YsSUFBSTtNQUNGLElBQUl1RCxTQUFTLENBQUNDLFNBQVMsQ0FBQywrQkFBK0IsQ0FBQyxDQUFDQyxhQUFhLEVBQUU7UUFDdEVOLE9BQU8sR0FBRyxDQUFDSSxTQUFTLENBQUNHLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJSCxTQUFTLENBQUNHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFQyxXQUFXLENBQUNMLE9BQU8sQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUNyRCxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO01BQ3RKO0lBQ0YsQ0FBQyxDQUFDLE9BQU8yRCxHQUFHLEVBQUU7TUFDWjtJQUFBO0VBRUo7RUFDQSxPQUFPVCxPQUFPLENBQUNVLEtBQUssQ0FBQyxHQUFHLENBQUM7QUFDM0IsQ0FBQzs7QUFFRDtBQUNBLElBQU1DLFlBQVksR0FBSSxVQUFDN0ssSUFBSSxFQUFLO0VBQzlCLE9BQU9pSixNQUFNLENBQUM2QixxQkFBcUIsSUFDNUI3QixNQUFNLENBQUM4Qix3QkFBd0IsSUFDL0I5QixNQUFNLENBQUMrQiwyQkFBMkIsSUFDbEMvQixNQUFNLENBQUNnQyx1QkFBdUIsSUFDOUIsVUFBVTFGLEVBQUUsRUFBRTtJQUNaLE9BQU8wRCxNQUFNLENBQUNpQyxVQUFVLENBQUMzRixFQUFFLEVBQUV2RixJQUFJLENBQUM7RUFDcEMsQ0FBQztBQUNWLENBQUMsQ0FBRSxJQUFJLENBQUM7QUFFUixJQUFNbUwsY0FBYyxHQUFHbEMsTUFBTSxDQUFDbUMsT0FBTzs7QUFFckM7QUFDQSxJQUFNQyxLQUFLLEdBQUcsQ0FBQyxDQUFDZixTQUFTLENBQUNnQixlQUFlOztBQUV6QztBQUNBLElBQU1DLElBQUksR0FBRyxNQUFLLElBQUksQ0FBQyxDQUFDQyxRQUFRLENBQUNDLFlBQVk7QUFDN0MsSUFBTUMsTUFBTSxHQUFHUCxjQUFjLEdBQUdsQyxNQUFNLENBQUNtQyxPQUFPLENBQUNPLGNBQWMsQ0FBQ0MsT0FBTyxDQUFDQyxXQUFXLEVBQUUsS0FBSyxNQUFNLEdBQUcsQ0FBQ04sSUFBSSxJQUFJLENBQUMsQ0FBQ3RDLE1BQU0sQ0FBQzZDLFVBQVU7O0FBRTdIO0FBQ0EsSUFBTUMsZUFBYyxHQUFHLGNBQWMsSUFBSTlDLE1BQU0sSUFDN0NBLE1BQU0sQ0FBQytDLGFBQWEsSUFDcEIvQyxNQUFNLENBQUN1QyxRQUFRLFlBQVl2QyxNQUFNLENBQUMrQyxhQUFhOztBQUVqRDtBQUNBLElBQUksQ0FBQ2IsY0FBYyxFQUFFO0VBQ25CYixTQUFTLENBQUMyQixZQUFZLEdBQUkzQixTQUFTLENBQUM0QixZQUFZLElBQUk1QixTQUFTLENBQUM0QixZQUFZLENBQUNELFlBQVksSUFBSzNCLFNBQVMsQ0FBQzJCLFlBQVksSUFBSTNCLFNBQVMsQ0FBQ2dCLGVBQWUsSUFBSWhCLFNBQVMsQ0FBQzZCLGtCQUFrQixJQUFJN0IsU0FBUyxDQUFDOEIsY0FBYztBQUM3TTs7QUFFQTtBQUNlO0VBRWJ2QixZQUFZLEVBQUVBLFlBQVk7RUFFMUJ3QixRQUFRLEVBQUUsb0JBQU07SUFDZCxPQUFPaEIsS0FBSztFQUNkLENBQUM7RUFFRGlCLFNBQVMsRUFBRSxxQkFBTTtJQUNmLE9BQU9aLE1BQU07RUFDZixDQUFDO0VBRURLLGNBQWMsRUFBRSwwQkFBTTtJQUNwQixPQUFPQSxlQUFjO0VBQ3ZCLENBQUM7RUFFRFEsaUJBQWlCLEVBQUUsNkJBQU07SUFDdkIsT0FBTyxDQUFDLENBQUN0RCxNQUFNLENBQUN1RCxTQUFTO0VBQzNCLENBQUM7RUFFREMsV0FBVyxFQUFFLHVCQUFNO0lBQ2pCLElBQUlDLEVBQUUsR0FBR2xCLFFBQVEsQ0FBQ21CLGFBQWEsQ0FBQyxPQUFPLENBQUM7SUFDeEMsT0FBT0QsRUFBRSxDQUFDRSxXQUFXLENBQUMsK0JBQStCLENBQUMsQ0FBQy9JLE1BQU0sR0FBRyxDQUFDLElBQy9ENkksRUFBRSxDQUFDRSxXQUFXLENBQUMsdUJBQXVCLENBQUMsQ0FBQy9JLE1BQU0sR0FBRyxDQUFDLElBQ2xENkksRUFBRSxDQUFDRSxXQUFXLENBQUMsZUFBZSxDQUFDLENBQUMvSSxNQUFNLEdBQUcsQ0FBQyxJQUMxQzZJLEVBQUUsQ0FBQ0UsV0FBVyxDQUFDLGlCQUFpQixDQUFDLENBQUMvSSxNQUFNLEdBQUcsQ0FBQztFQUNoRCxDQUFDO0VBRURnSixvQkFBb0IsRUFBRSxnQ0FBTTtJQUMxQjtJQUNBLE9BQU8sQ0FBQyxDQUFDNUQsTUFBTSxDQUFDNkQsR0FBRyxJQUFJN0QsTUFBTSxDQUFDNkQsR0FBRyxDQUFDQyxXQUFXLEVBQUU7RUFDakQsQ0FBQztFQUVEQyxlQUFlLEVBQUUsMkJBQWM7SUFBQSxJQUFiQyxHQUFHLHVFQUFHLENBQUMsQ0FBQztJQUN4QixPQUFPLElBQUloRSxNQUFNLENBQUM2RCxHQUFHLENBQUNHLEdBQUcsQ0FBQztFQUM1QixDQUFDO0VBRURDLHFCQUFxQixFQUFFLGlDQUFNO0lBQzNCLE9BQU9qRSxNQUFNLENBQUM2RCxHQUFHLENBQUNLLE1BQU07RUFDMUIsQ0FBQztFQUVEQyxvQkFBb0IsRUFBRSw4QkFBQ2xELE9BQU8sRUFBc0I7SUFBQSxJQUFwQm1ELFNBQVMsdUVBQUcsR0FBRztJQUM3QyxPQUFPcEQsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUlDLE9BQU8sQ0FBQ1UsS0FBSyxDQUFDeUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQ3pELENBQUM7RUFFREMsY0FBYyxFQUFFLHdCQUFDQyxFQUFFLEVBQUs7SUFDdEIsSUFBSTtNQUNGLElBQU1iLEVBQUUsR0FBR2xCLFFBQVEsQ0FBQ2dDLGNBQWMsQ0FBQ0QsRUFBRSxDQUFDO01BQ3RDLElBQUksQ0FBQ2IsRUFBRSxFQUFFO1FBQ1AsTUFBTSxJQUFJOUcsbUJBQW1CLDJCQUFvQjJILEVBQUUsMkJBQXdCO01BQzdFO01BQ0EsT0FBT2IsRUFBRTtJQUNYLENBQUMsQ0FBQyxPQUFPM0YsQ0FBQyxFQUFFO01BQ1YsTUFBTSxJQUFJbkIsbUJBQW1CLDhDQUF1QzJILEVBQUUsZ0JBQU14RyxDQUFDLENBQUNyRyxPQUFPLEVBQUc7SUFDMUY7RUFDRixDQUFDO0VBRUQrTSxlQUFlLEVBQUUseUJBQUNDLEdBQUcsRUFBSztJQUN4QixPQUFPLElBQUlsQixTQUFTLENBQUNrQixHQUFHLENBQUM7RUFDM0IsQ0FBQztFQUVEQyxjQUFjLEVBQUUsd0JBQUNDLFlBQVksRUFBRUMsV0FBVyxFQUF1QjtJQUFBLElBQXJCQyxRQUFRLHVFQUFHLEtBQUs7SUFDMUQsSUFBSTtNQUNGRixZQUFZLENBQUNHLFNBQVMsR0FBR0YsV0FBVztJQUN0QyxDQUFDLENBQUMsT0FBTzlHLENBQUMsRUFBRTtNQUNWeEUsUUFBSSxDQUFDLHNCQUFzQixxQ0FBOEJ3RSxDQUFDLENBQUNyRyxPQUFPLEVBQUc7TUFDckUsSUFBSTJLLEtBQUssRUFBRTtRQUNUdUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxHQUFHQyxXQUFXO01BQzVDLENBQUMsTUFBTTtRQUNMRCxZQUFZLENBQUNySixHQUFHLEdBQUcwRSxNQUFNLENBQUMrRSxHQUFHLENBQUNDLGVBQWUsQ0FBQ0osV0FBVyxDQUFDO01BQzVEO0lBQ0Y7SUFFQSxJQUFJQyxRQUFRLEVBQUU7TUFDWixJQUFJO1FBQ0YsSUFBSUksWUFBWSxHQUFHTixZQUFZLENBQUNPLElBQUksRUFBRTtRQUN0QyxJQUFJRCxZQUFZLEVBQUU7VUFDaEJBLFlBQVksQ0FBQzFKLElBQUksQ0FBQztZQUFBLE9BQU1sQyxTQUFLLENBQUMseUJBQXlCLEVBQUUsY0FBYyxDQUFDO1VBQUEsRUFBQyxDQUM3RG9DLEtBQUssQ0FBQyxVQUFDaUcsR0FBRztZQUFBLE9BQUtwSSxRQUFJLENBQUMseUJBQXlCLEVBQUUsZUFBZSxJQUFJb0ksR0FBRyxDQUFDakssT0FBTyxHQUFHaUssR0FBRyxDQUFDakssT0FBTyxHQUFHaUssR0FBRyxDQUFDLENBQUM7VUFBQSxFQUFDO1FBQ2xIO01BQ0YsQ0FBQyxDQUNELE9BQU81RCxDQUFDLEVBQUU7UUFDUjtRQUNBeEUsUUFBSSxDQUFDLHlCQUF5QixFQUFFLHNCQUFzQixHQUFHd0UsQ0FBQyxDQUFDckcsT0FBTyxDQUFDO1FBQ25FLElBQUk7VUFDRmtOLFlBQVksQ0FBQ1EsWUFBWSxDQUFDLFVBQVUsRUFBRSxLQUFLLENBQUM7VUFDNUNSLFlBQVksQ0FBQ1MsS0FBSyxFQUFFO1FBQ3RCLENBQUMsQ0FBQyxPQUFPMUQsR0FBRyxFQUFFO1VBQ1pwSSxRQUFJLENBQUMseUJBQXlCLEVBQUUsdUJBQXVCLEdBQUdvSSxHQUFHLENBQUNqSyxPQUFPLENBQUM7UUFDeEU7TUFDRjtJQUNGLENBQUMsTUFDSTtNQUNILElBQUk7UUFDRmtOLFlBQVksQ0FBQ1EsWUFBWSxDQUFDLFVBQVUsRUFBRSxLQUFLLENBQUM7UUFDNUNSLFlBQVksQ0FBQ1MsS0FBSyxFQUFFO01BQ3RCLENBQUMsQ0FDRCxPQUFPdEgsQ0FBQyxFQUFFO1FBQ1I7TUFBQTtJQUVKO0VBQ0YsQ0FBQztFQUVEdUgsWUFBWSxFQUFFLHNCQUFDWixHQUFHLEVBQUs7SUFDckIsSUFBSWEsR0FBRyxHQUFHLElBQUlwTCxlQUFlLEVBQUU7SUFDL0IsSUFBSXFMLE1BQU0sR0FBR2hELFFBQVEsQ0FBQ21CLGFBQWEsQ0FBQyxRQUFRLENBQUM7SUFDN0M2QixNQUFNLENBQUM3TSxJQUFJLEdBQUcsaUJBQWlCO0lBQy9CNk0sTUFBTSxDQUFDQyxNQUFNLEdBQUcsWUFBTTtNQUNwQkYsR0FBRyxDQUFDNUwsT0FBTyxFQUFFO0lBQ2YsQ0FBQztJQUNENkwsTUFBTSxDQUFDRSxrQkFBa0IsR0FBRyxZQUFZO01BQ3RDLElBQUlGLE1BQU0sQ0FBQ0csVUFBVSxLQUFLLFFBQVEsSUFBSUgsTUFBTSxDQUFDRyxVQUFVLEtBQUssVUFBVSxFQUFFO1FBQ3RFSCxNQUFNLENBQUNFLGtCQUFrQixHQUFHLElBQUk7UUFDaENILEdBQUcsQ0FBQzVMLE9BQU8sRUFBRTtNQUNmO0lBQ0YsQ0FBQztJQUNENkwsTUFBTSxDQUFDakssR0FBRyxHQUFHbUosR0FBRztJQUNoQmxDLFFBQVEsQ0FBQ29ELG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDQyxXQUFXLENBQUNMLE1BQU0sQ0FBQztJQUM1RCxPQUFPRCxHQUFHLENBQUMxTCxPQUFPO0VBQ3BCLENBQUM7RUFFRGlNLEdBQUcsRUFBRSxhQUFDQyxXQUFXLEVBQUs7SUFDcEIsT0FBTyxDQUFDekUsU0FBUyxDQUFDNEIsWUFBWSxJQUFJNUIsU0FBUyxFQUFFMkIsWUFBWSxDQUFDOEMsV0FBVyxDQUFDO0VBQ3hFLENBQUM7RUFFREMsU0FBUyxFQUFFLG1CQUFDQyxJQUFJLEVBQUVuSyxLQUFLLEVBQUs7SUFDMUJtRSxNQUFNLENBQUNnRyxJQUFJLENBQUMsR0FBR25LLEtBQUs7RUFDdEIsQ0FBQztFQUVEb0ssWUFBWSxFQUFFLHdCQUFNO0lBQ2xCLE9BQU9qRyxNQUFNLENBQUNrRyxTQUFTO0VBQ3pCLENBQUM7RUFFREMsY0FBYyxFQUFFLHdCQUFDN0IsRUFBRSxFQUFLO0lBQ3RCLE9BQU8vQixRQUFRLENBQUNnQyxjQUFjLENBQUNELEVBQUUsQ0FBQztFQUNwQyxDQUFDO0VBRUQ4QixZQUFZLEVBQUUsc0JBQUMzQyxFQUFFLEVBQUs7SUFDcEIsT0FBT0EsRUFBRSxDQUFDNEMsWUFBWSxDQUFDLElBQUksQ0FBQztFQUM5QixDQUFDO0VBRURDLDJCQUEyQixFQUFFLHFDQUFDQyxPQUFPLEVBQXFCO0lBQUEsSUFBbkJDLE9BQU8sdUVBQUcsSUFBSTtJQUNuRCxJQUFNQyx5QkFBeUIsSUFBRyxxQkFBcUIsSUFBSXpHLE1BQU07SUFDakUsSUFBSXlHLHlCQUF5QixFQUFFO01BQzdCcE4sU0FBSyxDQUFDLHNCQUFzQixFQUFFLCtCQUErQixFQUFFLG1CQUFtQixDQUFDO01BQ25GZ0gsbUJBQW1CLENBQUM3SCxJQUFJLENBQUMrTixPQUFPLENBQUM7TUFDakMsSUFBSUMsT0FBTyxFQUFFO1FBQ1hsRyxtQkFBbUIsRUFBRTtNQUN2QjtJQUNGO0lBQ0EsSUFBSUQsbUJBQW1CLENBQUN6RixNQUFNLEtBQUssQ0FBQyxFQUFFO01BQ3BDdkIsU0FBSyxDQUFDLHNCQUFzQixFQUFFLCtCQUErQixFQUFFLDRCQUE0QixDQUFDO01BQzVGMkcsTUFBTSxDQUFDcEIsZ0JBQWdCLENBQUMsbUJBQW1CLEVBQUUwQixtQkFBbUIsQ0FBQztJQUNuRTtFQUNGLENBQUM7RUFFRG9HLDhCQUE4QixFQUFFLHdDQUFDSCxPQUFPLEVBQUs7SUFDM0MsSUFBSWxLLENBQUMsR0FBR2dFLG1CQUFtQixDQUFDekYsTUFBTTtJQUNsQyxPQUFPLEVBQUV5QixDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7TUFDZixJQUFJZ0UsbUJBQW1CLENBQUNoRSxDQUFDLENBQUMsS0FBS2tLLE9BQU8sRUFBRTtRQUN0Q2xHLG1CQUFtQixDQUFDdkUsS0FBSyxDQUFDTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQy9CO01BQ0Y7SUFDRjtJQUNBLElBQUlnRSxtQkFBbUIsQ0FBQ3pGLE1BQU0sS0FBSyxDQUFDLEVBQUU7TUFDcEN2QixTQUFLLENBQUMsc0JBQXNCLEVBQUUsaUVBQWlFLENBQUM7TUFDaEcyRyxNQUFNLENBQUMyRyxtQkFBbUIsQ0FBQyxxQkFBcUIsRUFBRXJHLG1CQUFtQixDQUFDO0lBQ3hFO0VBQ0YsQ0FBQztFQUVEc0csZUFBZSxFQUFFLHlCQUFDTCxPQUFPLEVBQXVCO0lBQUEsSUFBckJNLFdBQVcsdUVBQUcsQ0FBQyxDQUFDO0lBQ3pDaEcsYUFBYSxDQUFDcEUsTUFBTSxDQUFDb0ssV0FBVyxLQUFLLENBQUMsQ0FBQyxHQUFHaEcsYUFBYSxDQUFDakcsTUFBTSxHQUFHaU0sV0FBVyxFQUFFLENBQUMsRUFBRU4sT0FBTyxDQUFDO0lBQ3pGO0lBQ0E7SUFDQTtJQUNBLElBQUksQ0FBQ3pGLGdCQUFnQixFQUFFO01BQ3JCZCxNQUFNLENBQUNwQixnQkFBZ0IsQ0FBQyxRQUFRLEVBQUVtQyxhQUFhLENBQUM7SUFDbEQ7SUFDQTtFQUNGLENBQUM7O0VBRUQrRixrQkFBa0IsRUFBRSw0QkFBQ1AsT0FBTyxFQUFLO0lBQy9CLElBQUlsSyxDQUFDLEdBQUd3RSxhQUFhLENBQUNqRyxNQUFNO0lBQzVCLE9BQU8sRUFBRXlCLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtNQUNmLElBQUl3RSxhQUFhLENBQUN4RSxDQUFDLENBQUMsS0FBS2tLLE9BQU8sRUFBRTtRQUNoQzFGLGFBQWEsQ0FBQy9FLEtBQUssQ0FBQ08sQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN6QjtNQUNGO0lBQ0Y7RUFDRixDQUFDO0VBRUQwSyxNQUFNLEVBQUUsZ0JBQUNDLFVBQVUsRUFBRS9KLElBQUksRUFBSztJQUM1QixJQUFJK0MsTUFBTSxDQUFDUixjQUFjLENBQUN3SCxVQUFVLENBQUMsRUFBRTtNQUNyQ2hILE1BQU0sQ0FBQ2dILFVBQVUsQ0FBQyxDQUFDQyxJQUFJLENBQUNqSCxNQUFNLEVBQUUvQyxJQUFJLENBQUM7SUFDdkM7RUFDRixDQUFDO0VBRUQ7RUFDQWlLLGdCQUFnQixFQUFFLDBCQUFDQyxPQUFPLEVBQUs7SUFDN0IsSUFBSW5ILE1BQU0sQ0FBQ0MsVUFBVSxJQUFJRCxNQUFNLENBQUNDLFVBQVUsQ0FBQ0MsT0FBTyxFQUFFO01BQ2xERixNQUFNLENBQUNDLFVBQVUsQ0FBQ21ILE1BQU0sQ0FBQ0QsT0FBTyxDQUFDO0lBQ25DO0VBQ0YsQ0FBQztFQUVERSx1QkFBdUIsRUFBRSxpQ0FBQ0MsRUFBRSxFQUFLO0lBQy9Cekgsa0JBQWtCLENBQUNySCxJQUFJLENBQUM4TyxFQUFFLENBQUM7SUFDM0J2SCx1QkFBdUIsQ0FBQ0MsTUFBTSxDQUFDQyxVQUFVLENBQUM7RUFDNUMsQ0FBQztFQUVEWCxxQkFBcUIsRUFBRUEscUJBQXFCO0VBQzVDRyx1QkFBdUIsRUFBRUEsdUJBQXVCO0VBRWhEOEgsbUJBQW1CLEVBQUUsNkJBQUNDLElBQUksRUFBRUMsU0FBUyxFQUFLO0lBQ3hDLElBQU1DLEdBQUcsR0FBR0YsSUFBSSxDQUFDbkIsWUFBWSxDQUFDb0IsU0FBUyxDQUFDO0lBQ3hDLE9BQVFDLEdBQUcsS0FBSyxJQUFJLElBQUksZUFBT0EsR0FBRyxNQUFLcFAsU0FBUyxJQUN6QyxPQUFPb1AsR0FBRyxLQUFLLFFBQVEsS0FBS0EsR0FBRyxLQUFLLEVBQUUsSUFBSUEsR0FBRyxLQUFLLE1BQU0sSUFBSUEsR0FBRyxLQUFLRCxTQUFTLENBQUU7RUFDeEYsQ0FBQztFQUVERSxlQUFlLEVBQUUseUJBQUNILElBQUksRUFBRUksU0FBUyxFQUFLO0lBQ3BDLE9BQU9KLElBQUksQ0FBQ0ssU0FBUyxDQUFDQyxRQUFRLENBQUNGLFNBQVMsQ0FBQztFQUMzQyxDQUFDO0VBRURsRSxhQUFhLEVBQUUsdUJBQUNxRSxPQUFPLEVBQUVDLElBQUksRUFBSztJQUNoQyxJQUFJRCxPQUFPLEtBQUssTUFBTSxFQUFFO01BQ3RCLE9BQU94RixRQUFRLENBQUMwRixjQUFjLENBQUNELElBQUksQ0FBQ0UsUUFBUSxFQUFFLENBQUM7SUFDakQ7SUFDQSxPQUFPM0YsUUFBUSxDQUFDbUIsYUFBYSxDQUFDcUUsT0FBTyxFQUFFQyxJQUFJLENBQUM7RUFDOUMsQ0FBQztFQUVERyxnQ0FBZ0MsRUFBRSwwQ0FBQzdMLEVBQUUsRUFBSztJQUN4Q3NELHlCQUF5QixDQUFDcEgsSUFBSSxDQUFDOEQsRUFBRSxDQUFDO0lBQ2xDLElBQUkwRCxNQUFNLENBQUNvSSxlQUFlLEtBQUs5UCxTQUFTLEVBQUU7TUFDeEMwSCxNQUFNLENBQUNvSSxlQUFlLEdBQUcsVUFBQzlELEVBQUUsRUFBSztRQUMvQjFFLHlCQUF5QixDQUFDL0UsS0FBSyxFQUFFLENBQUN5SixFQUFFLENBQUM7TUFDdkMsQ0FBQztJQUNIO0VBQ0YsQ0FBQztFQUVEK0Qsa0JBQWtCLEVBQUUsNEJBQUNqTSxLQUFLLEVBQUs7SUFDN0IsSUFBSSxDQUFDQSxLQUFLLEVBQUU7TUFDVkEsS0FBSyxHQUFHNEQsTUFBTSxDQUFDNUQsS0FBSztJQUN0QjtJQUVBLElBQUlBLEtBQUssQ0FBQ2tNLEtBQUssRUFBRTtNQUNmLE9BQU9sTSxLQUFLLENBQUNrTSxLQUFLO0lBQ3BCLENBQUMsTUFDSSxJQUFJbE0sS0FBSyxDQUFDbU0sT0FBTyxFQUFFO01BQ3RCLE9BQU9uTSxLQUFLLENBQUNtTSxPQUFPLEdBQUdoRyxRQUFRLENBQUNpRyxJQUFJLENBQUNDLFVBQVUsR0FBR2xHLFFBQVEsQ0FBQ21HLGVBQWUsQ0FBQ0QsVUFBVTtJQUN2RjtJQUVBLE9BQU8sQ0FBQztFQUNWLENBQUM7RUFFREUsVUFBVSxFQUFFLHNCQUFNO0lBQ2hCLE9BQVEzSSxNQUFNLENBQUM0SSxXQUFXLEtBQUt0USxTQUFTLEdBQzlCMEgsTUFBTSxDQUFDNEksV0FBVyxHQUNsQixDQUFDckcsUUFBUSxDQUFDbUcsZUFBZSxJQUFJbkcsUUFBUSxDQUFDaUcsSUFBSSxDQUFDSyxVQUFVLElBQUl0RyxRQUFRLENBQUNpRyxJQUFJLEVBQUVDLFVBQVU7RUFDOUYsQ0FBQztFQUVESyxXQUFXLEVBQUUscUJBQUNDLFNBQVMsRUFBSztJQUMxQixPQUFPeEcsUUFBUSxDQUFDdUcsV0FBVyxDQUFDQyxTQUFTLENBQUM7RUFDeEMsQ0FBQztFQUVEQyxTQUFTLEVBQUU7SUFBQSxPQUFNaEosTUFBTTtFQUFBO0FBRXpCLENBQUMsRTs7QUNuWGtDO0FBQ25DLElBQVE0Qiw2QkFBWSxHQUFLcUgsT0FBVyxDQUE1QnJILFlBQVk7O0FBRXBCO0FBQ0EsSUFBTXNILE1BQU0sR0FBRyxDQUNiLHVCQUF1QixFQUN2QixvQkFBb0IsRUFDcEIsbUJBQW1CLEVBQ25CLGtCQUFrQixFQUNsQixpQkFBaUIsQ0FDbEI7QUFDRCxJQUFNQyxNQUFNLEdBQUcsQ0FDYixpQkFBaUIsRUFDakIsY0FBYyxFQUNkLGFBQWEsRUFDYixZQUFZLEVBQ1osV0FBVyxDQUNaO0FBQ0QsSUFBTUMsVUFBVSxHQUFHLENBQ2pCLGtCQUFrQixFQUNsQixlQUFlLEVBQ2YsY0FBYyxFQUNkLGFBQWEsRUFDYixZQUFZLENBQ2I7QUFDRCxJQUFNQyxvQkFBb0IsR0FBRztFQUMzQixHQUFHLEVBQUU7SUFDSEgsTUFBTSxFQUFFLGVBQWU7SUFDdkJJLFNBQVMsRUFBRTtFQUNiLENBQUM7RUFDRCxJQUFJLEVBQUU7SUFDSkosTUFBTSxFQUFFLFVBQVU7SUFDbEJJLFNBQVMsRUFBRTtFQUNiLENBQUM7RUFDRCxLQUFLLEVBQUU7SUFDTEosTUFBTSxFQUFFLGVBQWU7SUFDdkJJLFNBQVMsRUFBRTtFQUNiLENBQUM7RUFDRCxLQUFLLEVBQUU7SUFDTEosTUFBTSxFQUFFLFVBQVU7SUFDbEJJLFNBQVMsRUFBRTtFQUNiLENBQUM7RUFDRCxLQUFLLEVBQUU7SUFDTEosTUFBTSxFQUFFLFVBQVU7SUFDbEJJLFNBQVMsRUFBRTtFQUNiLENBQUM7RUFDRCxNQUFNLEVBQUU7SUFDTkosTUFBTSxFQUFFLGVBQWU7SUFDdkJJLFNBQVMsRUFBRTtFQUNiLENBQUM7RUFDRCxNQUFNLEVBQUU7SUFDTkosTUFBTSxFQUFFLFVBQVU7SUFDbEJJLFNBQVMsRUFBRTtFQUNiO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBLElBQU1DLFdBQVcsR0FBRyxTQUFkQSxXQUFXLENBQUlwQyxPQUFPLEVBQUVxQyxHQUFHLEVBQXdCO0VBQUEsSUFBdEJDLFNBQVMsdUVBQUcsS0FBSztFQUNsRCxPQUFPLFlBQU07SUFDWCxJQUFNQyxNQUFNLEdBQUd2QyxPQUFPLENBQUMwQixVQUFVO0lBQ2pDLElBQUlhLE1BQU0sRUFBRTtNQUNWLElBQU1DLE1BQU0sR0FBR0QsTUFBTSxDQUFDRSxXQUFXO01BQ2pDLElBQU1DLE9BQU8sR0FBR0gsTUFBTSxDQUFDSSxZQUFZO01BQ25DLElBQUlMLFNBQVMsRUFBRTtRQUNidEMsT0FBTyxDQUFDNEMsS0FBSyxDQUFDQyxLQUFLLEdBQUdILE9BQU8sR0FBRyxJQUFJO01BQ3RDLENBQUMsTUFDSTtRQUNIMUMsT0FBTyxDQUFDNEMsS0FBSyxDQUFDQyxLQUFLLEdBQUdMLE1BQU0sR0FBRyxJQUFJO01BQ3JDO01BQ0EsSUFBTU0sTUFBTSxHQUFHOUMsT0FBTyxDQUFDeUMsV0FBVztNQUNsQyxJQUFNTSxPQUFPLEdBQUcvQyxPQUFPLENBQUMyQyxZQUFZO01BQ3BDLElBQU1LLE1BQU0sR0FBRyxDQUFDVixTQUFTLEdBQUlFLE1BQU0sR0FBR08sT0FBTyxHQUFLUCxNQUFNLEdBQUdNLE1BQU8sSUFBSSxHQUFHO01BQ3pFOUMsT0FBTyxDQUFDNEMsS0FBSyxDQUFDSyxRQUFRLEdBQUcsVUFBVTtNQUNuQ2pELE9BQU8sQ0FBQzRDLEtBQUssQ0FBQ00sSUFBSSxHQUFHRixNQUFNLEdBQUcsSUFBSTtJQUNwQztJQUNBLElBQUlYLEdBQUcsRUFBRTtNQUNQQSxHQUFHLENBQUNELFdBQVcsQ0FBQ3BDLE9BQU8sRUFBRXFDLEdBQUcsRUFBRUMsU0FBUyxDQUFDLENBQUM7SUFDM0M7RUFDRixDQUFDO0FBQ0gsQ0FBQztBQUVNLElBQU1hLGdCQUFnQixHQUFHLFNBQW5CQSxnQkFBZ0IsQ0FBSW5ELE9BQU8sRUFBRXRMLEtBQUssRUFBRTBPLFVBQVUsRUFBSztFQUFFO0VBQ2hFLElBQUlsTyxDQUFDO0lBQUV6QixNQUFNLEdBQUd1TyxNQUFNLENBQUN2TyxNQUFNO0VBQzdCaUIsS0FBSyxHQUFHQSxLQUFLLEdBQUcsR0FBRztFQUNuQixJQUFNNE4sU0FBUyxHQUFHNU4sS0FBSyxHQUFHLEdBQUcsS0FBSyxDQUFDO0VBQ25DLElBQU02TixNQUFNLEdBQUd2QyxPQUFPLENBQUMwQixVQUFVO0VBQ2pDLElBQU1jLE1BQU0sR0FBR3hDLE9BQU8sQ0FBQzZDLEtBQUssR0FBRzdDLE9BQU8sQ0FBQzZDLEtBQUssR0FBR04sTUFBTSxDQUFDRSxXQUFXO0VBQ2pFLElBQU1DLE9BQU8sR0FBRzFDLE9BQU8sQ0FBQ3FELE1BQU0sR0FBR3JELE9BQU8sQ0FBQ3FELE1BQU0sR0FBR2QsTUFBTSxDQUFDSSxZQUFZO0VBQ3JFLElBQU1XLFlBQVksR0FBR3BCLG9CQUFvQixDQUFDeE4sS0FBSyxDQUFDcU0sUUFBUSxFQUFFLENBQUM7RUFDM0QsS0FBSTdMLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR3pCLE1BQU0sRUFBRXlCLENBQUMsRUFBRSxFQUFFO0lBQzFCOEssT0FBTyxDQUFDNEMsS0FBSyxDQUFDYixNQUFNLENBQUM3TSxDQUFDLENBQUMsQ0FBQyxHQUFHb08sWUFBWSxDQUFDdkIsTUFBTTtJQUM5Qy9CLE9BQU8sQ0FBQzRDLEtBQUssQ0FBQ1osTUFBTSxDQUFDOU0sQ0FBQyxDQUFDLENBQUMsR0FBR29PLFlBQVksQ0FBQ25CLFNBQVM7SUFDakRuQyxPQUFPLENBQUM0QyxLQUFLLENBQUNYLFVBQVUsQ0FBQy9NLENBQUMsQ0FBQyxDQUFDLEdBQUcsdUJBQXVCO0VBQ3hEO0VBQ0EsSUFBSW9OLFNBQVMsRUFBRTtJQUNiO0lBQ0F0QyxPQUFPLENBQUM0QyxLQUFLLENBQUNDLEtBQUssR0FBR0gsT0FBTyxHQUFHLElBQUk7SUFDcENILE1BQU0sQ0FBQ0ssS0FBSyxDQUFDUyxNQUFNLEdBQUdYLE9BQU8sR0FBRyxJQUFJO0lBQ3BDO0VBQ0YsQ0FBQyxNQUNJO0lBQ0gxQyxPQUFPLENBQUM0QyxLQUFLLENBQUNDLEtBQUssR0FBR0wsTUFBTSxHQUFHLElBQUk7SUFDbkN4QyxPQUFPLENBQUM0QyxLQUFLLENBQUNTLE1BQU0sR0FBR1gsT0FBTyxHQUFHLElBQUk7SUFDckNILE1BQU0sQ0FBQ0ssS0FBSyxDQUFDUyxNQUFNLEdBQUcsT0FBTztFQUMvQjtFQUVBLElBQUlqSSxRQUFRLENBQUNtSSxXQUFXLEVBQUU7SUFDeEJoQixNQUFNLENBQUNnQixXQUFXLENBQUMsUUFBUSxFQUFFbkIsV0FBVyxDQUFDcEMsT0FBTyxFQUFFdkYsNkJBQVksRUFBRTZILFNBQVMsQ0FBQyxDQUFDO0VBQzdFLENBQUMsTUFDSTtJQUNIRixXQUFXLENBQUNwQyxPQUFPLEVBQUV2Riw2QkFBWSxFQUFFNkgsU0FBUyxDQUFDLEVBQUU7RUFDakQ7QUFDRixDQUFDLEM7O0FDaEhXOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU1rQixLQUFLLEdBQUcsU0FBUkEsS0FBSyxDQUFJQyxFQUFFLEVBQUs7RUFDM0IsSUFBSUMsS0FBSyxHQUFHRCxFQUFFLENBQUNoUSxNQUFNO0VBQ3JCLE9BQU8sU0FBU2tRLEVBQUUsR0FBRztJQUNuQixJQUFNQyxJQUFJLEdBQUdDLEtBQUssQ0FBQ0MsU0FBUyxDQUFDblAsS0FBSyxDQUFDbUwsSUFBSSxDQUFDaUUsU0FBUyxFQUFFLENBQUMsQ0FBQztJQUNyRCxJQUFJSCxJQUFJLENBQUNuUSxNQUFNLElBQUlpUSxLQUFLLEVBQUU7TUFDeEIsT0FBT0QsRUFBRSxDQUFDTyxLQUFLLENBQUMsSUFBSSxFQUFFSixJQUFJLENBQUM7SUFDN0IsQ0FBQyxNQUNJO01BQ0gsT0FBTyxTQUFTSyxFQUFFLEdBQUc7UUFDbkIsSUFBTUMsS0FBSyxHQUFHTCxLQUFLLENBQUNDLFNBQVMsQ0FBQ25QLEtBQUssQ0FBQ21MLElBQUksQ0FBQ2lFLFNBQVMsRUFBRSxDQUFDLENBQUM7UUFDdEQsT0FBT0osRUFBRSxDQUFDSyxLQUFLLENBQUMsSUFBSSxFQUFFSixJQUFJLENBQUNqUyxNQUFNLENBQUN1UyxLQUFLLENBQUMsQ0FBQztNQUMzQyxDQUFDO0lBQ0g7RUFDRixDQUFDO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTUMsTUFBTSxHQUFHWCxLQUFLLENBQUMsVUFBQ3JPLEVBQUUsRUFBRTNELElBQUksRUFBSztFQUN4QyxJQUFJNFMsR0FBRyxHQUFHLENBQUM7RUFDWCxJQUFJcE8sR0FBRyxHQUFHeEUsSUFBSSxDQUFDaUMsTUFBTTtFQUNyQixJQUFJd0MsTUFBTSxHQUFHLEVBQUU7RUFFZixPQUFPbU8sR0FBRyxHQUFHcE8sR0FBRyxFQUFFO0lBQ2hCLElBQUliLEVBQUUsQ0FBQzNELElBQUksQ0FBQzRTLEdBQUcsQ0FBQyxDQUFDLEVBQUU7TUFDakJuTyxNQUFNLENBQUNBLE1BQU0sQ0FBQ3hDLE1BQU0sQ0FBQyxHQUFHakMsSUFBSSxDQUFDNFMsR0FBRyxDQUFDO0lBQ25DO0lBQ0FBLEdBQUcsSUFBSSxDQUFDO0VBQ1Y7RUFDQSxPQUFPbk8sTUFBTTtBQUNmLENBQUMsQ0FBQzs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTW9PLEtBQUssR0FBRyxTQUFSQSxLQUFLLENBQUkzUCxLQUFLLEVBQUs7RUFDOUIsSUFBSSxPQUFPQSxLQUFLLEtBQUssUUFBUSxFQUFFO0lBQzdCLE9BQU91QyxRQUFRLENBQUN2QyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLENBQUMsTUFDSTtJQUNILE9BQU80UCxJQUFJLENBQUNDLEtBQUssQ0FBQzdQLEtBQUssQ0FBQztFQUMxQjtBQUNGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU04UCxTQUFTLEdBQUcsU0FBWkEsU0FBUyxDQUFJOVAsS0FBSyxFQUFFK1AsWUFBWSxFQUFLO0VBQ2hELE9BQU8vUCxLQUFLLElBQUkrUCxZQUFZO0FBQzlCLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU1DLFlBQVksR0FBRyxTQUFmQSxZQUFZLENBQUloUSxLQUFLLEVBQUUrUCxZQUFZLEVBQUs7RUFDbkQsT0FBTyxDQUFDRSxLQUFLLENBQUNOLEtBQUssQ0FBQzNQLEtBQUssQ0FBQyxDQUFDLEdBQUcyUCxLQUFLLENBQUMzUCxLQUFLLENBQUMsR0FBRytQLFlBQVk7QUFDM0QsQ0FBQyxDOztBQ2xGVzs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTUcsVUFBVSxHQUFHLFNBQWJBLFVBQVUsQ0FBSUMsTUFBTSxFQUFFQyxLQUFLLEVBQUVwUSxLQUFLLEVBQUs7RUFDbEQsSUFBSVEsQ0FBQyxHQUFHLENBQUM7RUFDVCxJQUFJNlAsSUFBSSxHQUFHRixNQUFNO0VBQ2pCLElBQU1oRyxJQUFJLEdBQUdpRyxLQUFLLENBQUNFLEdBQUcsRUFBRTtFQUN4QixJQUFNdlIsTUFBTSxHQUFHcVIsS0FBSyxDQUFDclIsTUFBTTtFQUMzQixLQUFLeUIsQ0FBQyxFQUFFQSxDQUFDLEdBQUd6QixNQUFNLEVBQUV5QixDQUFDLEVBQUUsRUFBRTtJQUN2QixJQUFJK1AsSUFBSSxHQUFHSCxLQUFLLENBQUM1UCxDQUFDLENBQUM7SUFDbkI2UCxJQUFJLENBQUNFLElBQUksQ0FBQyxHQUFHRixJQUFJLENBQUNFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM3QkYsSUFBSSxHQUFHQSxJQUFJLENBQUNFLElBQUksQ0FBQztFQUNuQjtFQUNBRixJQUFJLENBQUNsRyxJQUFJLENBQUMsR0FBR25LLEtBQUs7QUFDcEIsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTXdRLFFBQVEsR0FBRyxTQUFYQSxRQUFRLENBQUlDLEdBQUcsRUFBSztFQUMvQixJQUFNQyxHQUFHLEdBQUczTyxJQUFJLENBQUM0TyxTQUFTLENBQUNGLEdBQUcsQ0FBQztFQUMvQixPQUFPMU8sSUFBSSxDQUFDQyxLQUFLLENBQUMwTyxHQUFHLENBQUM7QUFDeEIsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU1FLDBCQUEwQixHQUFHLFNBQTdCQSwwQkFBMEIsQ0FBSTVRLEtBQUssRUFBSztFQUNuRCxJQUFJLE9BQU9BLEtBQUssS0FBSyxRQUFRLEVBQUU7SUFDN0IsSUFBSTZRLElBQUksR0FBRzdRLEtBQUssQ0FBQzhGLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFDM0IsT0FBTztNQUNMcUksS0FBSyxFQUFFNUwsUUFBUSxDQUFDc08sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO01BQ3hCbEMsTUFBTSxFQUFFcE0sUUFBUSxDQUFDc08sSUFBSSxDQUFDLENBQUMsQ0FBQztJQUMxQixDQUFDO0VBQ0g7RUFDQSxPQUFPN1EsS0FBSztBQUNkLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU04USxhQUFhLEdBQUcsU0FBaEJBLGFBQWEsQ0FBSUwsR0FBRyxFQUFLO0VBQ3BDLE9BQU9NLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDUCxHQUFHLENBQUMsQ0FBQzFSLE1BQU0sS0FBSyxDQUFDLElBQUkwUixHQUFHLENBQUNRLFdBQVcsS0FBS0YsTUFBTTtBQUNwRSxDQUFDLEM7O0FDMURXOztBQUU0QjtBQUNTO0FBQ1Y7QUFDRTtBQUNYO0FBQzlCOztBQUVBO0FBQ0EsSUFBTUcsT0FBTyxHQUFHLENBQ2Q7RUFDRUMsS0FBSyxFQUFFLFNBQVM7RUFDaEJoRCxLQUFLLEVBQUUsSUFBSTtFQUNYUSxNQUFNLEVBQUU7QUFDVixDQUFDLEVBQ0Q7RUFDRXdDLEtBQUssRUFBRSxZQUFZO0VBQ25CaEQsS0FBSyxFQUFFLElBQUk7RUFDWFEsTUFBTSxFQUFFO0FBQ1YsQ0FBQyxFQUNEO0VBQ0V3QyxLQUFLLEVBQUUsTUFBTTtFQUNiaEQsS0FBSyxFQUFFLElBQUk7RUFDWFEsTUFBTSxFQUFFO0FBQ1YsQ0FBQyxFQUNEO0VBQ0V3QyxLQUFLLEVBQUUsVUFBVTtFQUNqQmhELEtBQUssRUFBRSxJQUFJO0VBQ1hRLE1BQU0sRUFBRTtBQUNWLENBQUMsRUFDRDtFQUNFd0MsS0FBSyxFQUFFLE1BQU07RUFDYmhELEtBQUssRUFBRSxHQUFHO0VBQ1ZRLE1BQU0sRUFBRTtBQUNWLENBQUMsRUFDRDtFQUNFd0MsS0FBSyxFQUFFLEtBQUs7RUFDWmhELEtBQUssRUFBRSxHQUFHO0VBQ1ZRLE1BQU0sRUFBRTtBQUNWLENBQUMsRUFDRDtFQUNFd0MsS0FBSyxFQUFFLFdBQVc7RUFDbEJoRCxLQUFLLEVBQUUsR0FBRztFQUNWUSxNQUFNLEVBQUU7QUFDVixDQUFDLEVBQ0Q7RUFDRXdDLEtBQUssRUFBRSxLQUFLO0VBQ1poRCxLQUFLLEVBQUUsR0FBRztFQUNWUSxNQUFNLEVBQUU7QUFDVixDQUFDLEVBQ0Q7RUFDRXdDLEtBQUssRUFBRSxNQUFNO0VBQ2JoRCxLQUFLLEVBQUUsR0FBRztFQUNWUSxNQUFNLEVBQUU7QUFDVixDQUFDLEVBQ0Q7RUFDRXdDLEtBQUssRUFBRSxNQUFNO0VBQ2JoRCxLQUFLLEVBQUUsR0FBRztFQUNWUSxNQUFNLEVBQUU7QUFDVixDQUFDLEVBQ0Q7RUFDRXdDLEtBQUssRUFBRSxPQUFPO0VBQ2RoRCxLQUFLLEVBQUUsR0FBRztFQUNWUSxNQUFNLEVBQUU7QUFDVixDQUFDLENBQ0Y7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTXlDLHFCQUFxQixHQUFHLFNBQXhCQSxxQkFBcUIsQ0FBSW5ILFdBQVcsRUFBSztFQUM3QyxPQUNFQSxXQUFXLENBQUN0RyxjQUFjLENBQUMsT0FBTyxDQUFDLEtBQ2xDc0csV0FBVyxDQUFDb0gsS0FBSyxDQUFDMU4sY0FBYyxDQUFDLE9BQU8sQ0FBQyxJQUFJc0csV0FBVyxDQUFDb0gsS0FBSyxDQUFDMU4sY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBRTdGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQU0yTiwrQkFBK0IsR0FBRyxTQUFsQ0EsK0JBQStCLENBQUkxRixTQUFTLEVBQUs7RUFDckQsT0FBT0EsU0FBUyxDQUFDMkYsS0FBSyxJQUFJM0YsU0FBUyxDQUFDNEYsS0FBSyxJQUFJNUYsU0FBUyxDQUFDNkYsR0FBRyxJQUFJN0YsU0FBUyxDQUFDOEYsR0FBRyxJQUFJOUYsU0FBUztBQUMxRixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQU0rRixPQUFPLEdBQUc3QyxLQUFLLENBQUMsVUFBQzdFLFdBQVcsRUFBRTJILE1BQU0sRUFBSztFQUM3QyxJQUFJLE9BQU8zSCxXQUFXLENBQUNvSCxLQUFLLEtBQUssU0FBUyxFQUFFO0lBQzFDLE9BQU8sSUFBSTtFQUNiO0VBQ0EsSUFBTVEsQ0FBQyxHQUFHNUgsV0FBVyxDQUFDb0gsS0FBSyxDQUFDMU4sY0FBYyxDQUFDLE9BQU8sQ0FBQyxHQUFHMk4sK0JBQStCLENBQUNySCxXQUFXLENBQUNvSCxLQUFLLENBQUNsRCxLQUFLLENBQUMsR0FBRyxDQUFDO0VBQ2xILElBQU0yRCxDQUFDLEdBQUc3SCxXQUFXLENBQUNvSCxLQUFLLENBQUMxTixjQUFjLENBQUMsUUFBUSxDQUFDLEdBQUcyTiwrQkFBK0IsQ0FBQ3JILFdBQVcsQ0FBQ29ILEtBQUssQ0FBQzFDLE1BQU0sQ0FBQyxHQUFHLENBQUM7RUFDcEgsSUFBTW9ELFNBQVMsR0FBR0YsQ0FBQyxLQUFLRCxNQUFNLENBQUN6RCxLQUFLLElBQUkyRCxDQUFDLEtBQUtGLE1BQU0sQ0FBQ2pELE1BQU07RUFDM0QsSUFBSW9ELFNBQVMsRUFBRTtJQUNidlUsU0FBSyxDQUFDLGVBQWUsMENBQW1Db1UsTUFBTSxDQUFDekQsS0FBSyxlQUFLeUQsTUFBTSxDQUFDakQsTUFBTSxPQUFJO0VBQzVGO0VBQ0EsT0FBT29ELFNBQVM7QUFDbEIsQ0FBQyxDQUFDOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTUMsT0FBTyxHQUFHbEQsS0FBSyxDQUFDLFVBQUM3RSxXQUFXLEVBQUUySCxNQUFNLEVBQUs7RUFDN0MsSUFBTUMsQ0FBQyxHQUFHNUgsV0FBVyxDQUFDb0gsS0FBSyxDQUFDMU4sY0FBYyxDQUFDLE9BQU8sQ0FBQyxHQUFHMk4sK0JBQStCLENBQUNySCxXQUFXLENBQUNvSCxLQUFLLENBQUNsRCxLQUFLLENBQUMsR0FBRyxDQUFDO0VBQ2xILElBQU0yRCxDQUFDLEdBQUc3SCxXQUFXLENBQUNvSCxLQUFLLENBQUMxTixjQUFjLENBQUMsUUFBUSxDQUFDLEdBQUcyTiwrQkFBK0IsQ0FBQ3JILFdBQVcsQ0FBQ29ILEtBQUssQ0FBQzFDLE1BQU0sQ0FBQyxHQUFHLENBQUM7RUFDcEgsSUFBTXNELE9BQU8sR0FBR0osQ0FBQyxHQUFHQyxDQUFDO0VBQ3JCLElBQU1JLFVBQVUsR0FBR04sTUFBTSxDQUFDekQsS0FBSyxHQUFHeUQsTUFBTSxDQUFDakQsTUFBTTtFQUMvQyxPQUFPdUQsVUFBVSxHQUFHRCxPQUFPO0FBQzdCLENBQUMsQ0FBQzs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFNRSxpQkFBaUIsR0FBR3JELEtBQUssQ0FBQyxVQUFDc0QsV0FBVyxFQUFFbkksV0FBVyxFQUFLO0VBQzVELElBQU1vSSxRQUFRLEdBQUc1QyxNQUFNLENBQUNrQyxPQUFPLENBQUMxSCxXQUFXLENBQUMsQ0FBQyxDQUFDbUksV0FBVyxDQUFDO0VBQzFENVUsU0FBSyxDQUFDLHlCQUF5QixFQUFFLGlCQUFpQixHQUFHdUUsSUFBSSxDQUFDNE8sU0FBUyxDQUFDMEIsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztFQUN2RixPQUFPQSxRQUFRLENBQUN0VCxNQUFNLEdBQUcsQ0FBQztBQUM1QixDQUFDLENBQUM7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTXVULG9CQUFvQixHQUFHeEQsS0FBSyxDQUFDLFVBQUNzRCxXQUFXLEVBQUVuSSxXQUFXLEVBQUs7RUFDL0QsSUFBSXNJLFVBQVUsR0FBR1AsT0FBTyxDQUFDL0gsV0FBVyxDQUFDO0VBQ3JDLE9BQU93RixNQUFNLENBQUM4QyxVQUFVLENBQUMsQ0FBQ0gsV0FBVyxDQUFDO0FBQ3hDLENBQUMsQ0FBQzs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQU1JLHFDQUE4QixHQUFHLFNBQWpDQSw4QkFBOEIsQ0FBSXBSLElBQUksRUFBRTVCLENBQUMsRUFBSztFQUNsRDtFQUNBNEIsSUFBSSxDQUFDaVEsS0FBSyxHQUFHLElBQUk7RUFDakJqRSxPQUFXLENBQ1JwRCxHQUFHLENBQUM1SSxJQUFJLENBQUMsQ0FDVDFCLElBQUksQ0FBQyxVQUFDK1MsS0FBSyxFQUFLO0lBQ2ZqVCxDQUFDLENBQUMzQixPQUFPLENBQUM7TUFDUjRVLEtBQUssRUFBRUEsS0FBSztNQUNaeEksV0FBVyxFQUFFN0k7SUFDZixDQUFDLENBQUM7RUFDSixDQUFDLENBQUMsQ0FDRHhCLEtBQUssQ0FBQyxVQUFDaUcsR0FBRyxFQUFLO0lBQ2Q7SUFDQSxJQUFNdEssR0FBRyxHQUFHLE9BQU9zSyxHQUFHLEtBQUssUUFBUSxHQUFHQSxHQUFHLEdBQUcsQ0FBQ0EsR0FBRyxDQUFDekssSUFBSSxFQUFFeUssR0FBRyxDQUFDakssT0FBTyxDQUFDLENBQUM4VyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQzlFbFYsU0FBSyxDQUFDLG9CQUFvQixxQ0FBOEJqQyxHQUFHLDRDQUF5QztJQUNwR2lDLFNBQUssQ0FBQyxrQkFBa0IsNkNBQXNDdUUsSUFBSSxDQUFDNE8sU0FBUyxDQUFDdlAsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRztJQUM5RjVCLENBQUMsQ0FBQzFCLE1BQU0sQ0FBQyx3REFBd0QsQ0FBQztFQUNwRSxDQUFDLENBQUM7QUFDTixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQU02VSx3QkFBaUIsR0FBRyxTQUFwQkEsaUJBQWlCLENBQUl2UixJQUFJLEVBQUV3UixVQUFVLEVBQUVwVCxDQUFDLEVBQUs7RUFDakQsSUFBSW9ULFVBQVUsQ0FBQzdULE1BQU0sSUFBSSxDQUFDLEVBQUU7SUFDMUI7SUFDQXlULHFDQUE4QixDQUFDcFIsSUFBSSxFQUFFNUIsQ0FBQyxDQUFDO0lBQ3ZDO0VBQ0Y7RUFDQSxJQUFNcVQsU0FBUyxHQUFHRCxVQUFVLENBQUM1VCxLQUFLLEVBQUU7RUFDcENvQyxJQUFJLENBQUNpUSxLQUFLLENBQUNsRCxLQUFLLEdBQUc7SUFBRW9ELEtBQUssRUFBRXNCLFNBQVMsQ0FBQzFFO0VBQU0sQ0FBQztFQUM3Qy9NLElBQUksQ0FBQ2lRLEtBQUssQ0FBQzFDLE1BQU0sR0FBRztJQUFFNEMsS0FBSyxFQUFFc0IsU0FBUyxDQUFDbEU7RUFBTyxDQUFDO0VBQy9DdkIsT0FBVyxDQUNScEQsR0FBRyxDQUFDNUksSUFBSSxDQUFDLENBQ1QxQixJQUFJLENBQUMsVUFBQytTLEtBQUssRUFBSztJQUNmalQsQ0FBQyxDQUFDM0IsT0FBTyxDQUFDO01BQ1I0VSxLQUFLLEVBQUVBLEtBQUs7TUFDWnhJLFdBQVcsRUFBRTdJO0lBQ2YsQ0FBQyxDQUFDO0VBQ0osQ0FBQyxDQUFDLENBQ0R4QixLQUFLLENBQUMsVUFBQ2lHLEdBQUcsRUFBSztJQUNkO0lBQ0EsSUFBTXRLLEdBQUcsR0FBRyxPQUFPc0ssR0FBRyxLQUFLLFFBQVEsR0FBR0EsR0FBRyxHQUFHLENBQUNBLEdBQUcsQ0FBQ3pLLElBQUksRUFBRXlLLEdBQUcsQ0FBQ2pLLE9BQU8sQ0FBQyxDQUFDOFcsSUFBSSxDQUFDLElBQUksQ0FBQztJQUM5RWxWLFNBQUssQ0FBQyxvQkFBb0IscUNBQThCakMsR0FBRyw0Q0FBeUM7SUFDcEdpQyxTQUFLLENBQUMsa0JBQWtCLDZDQUFzQ3VFLElBQUksQ0FBQzRPLFNBQVMsQ0FBQ3ZQLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUc7SUFDOUZ1UixpQkFBaUIsQ0FBQ3ZSLElBQUksRUFBRXdSLFVBQVUsRUFBRXBULENBQUMsQ0FBQztFQUN4QyxDQUFDLENBQUM7QUFDTixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTXNULDZCQUFzQixHQUFHLFNBQXpCQSxzQkFBc0IsQ0FBSTdJLFdBQVcsRUFBSztFQUNyRCxJQUFJN0ksSUFBSSxHQUFHb1AsUUFBUSxDQUFDdkcsV0FBVyxDQUFDO0VBQ2hDO0VBQ0EsSUFBSSxPQUFPQSxXQUFXLENBQUNvSCxLQUFLLEtBQUssU0FBUyxFQUFFO0lBQzFDLE9BQU9qUSxJQUFJO0VBQ2I7RUFDQTtFQUNBLElBQUk2SSxXQUFXLENBQUNvSCxLQUFLLENBQUNsRCxLQUFLLEVBQUU7SUFDM0IvTSxJQUFJLENBQUNpUSxLQUFLLENBQUNsRCxLQUFLLEdBQUc7TUFBRW9ELEtBQUssRUFBRUQsK0JBQStCLENBQUNySCxXQUFXLENBQUNvSCxLQUFLLENBQUNsRCxLQUFLO0lBQUUsQ0FBQztFQUN4RjtFQUNBLElBQUlsRSxXQUFXLENBQUNvSCxLQUFLLENBQUMxQyxNQUFNLEVBQUU7SUFDNUJ2TixJQUFJLENBQUNpUSxLQUFLLENBQUMxQyxNQUFNLEdBQUc7TUFBRTRDLEtBQUssRUFBRUQsK0JBQStCLENBQUNySCxXQUFXLENBQUNvSCxLQUFLLENBQUMxQyxNQUFNO0lBQUUsQ0FBQztFQUMxRjtFQUNBLE9BQU92TixJQUFJO0FBQ2IsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU0yUixtQ0FBNEIsR0FBRyxTQUEvQkEsNEJBQTRCLENBQUk5SSxXQUFXLEVBQUs7RUFDM0R6TSxTQUFLLENBQ0gsb0NBQW9DLEVBQ3BDLGdEQUFnRCxHQUFHdUUsSUFBSSxDQUFDNE8sU0FBUyxDQUFDMUcsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FDeEY7RUFDRCxJQUFJK0ksUUFBUSxHQUFHLElBQUkzVSxlQUFlLEVBQUU7RUFDcEMsSUFBSXVVLFVBQVUsR0FBR04sb0JBQW9CLENBQUNwQixPQUFPLENBQUMsQ0FBQ2pILFdBQVcsQ0FBQztFQUMzRCxJQUFJN0ksSUFBSSxHQUFHb1AsUUFBUSxDQUFDdkcsV0FBVyxDQUFDO0VBQ2hDMEksd0JBQWlCLENBQUN2UixJQUFJLEVBQUV3UixVQUFVLEVBQUVJLFFBQVEsQ0FBQztFQUM3QyxPQUFPQSxRQUFRLENBQUNqVixPQUFPO0FBQ3pCLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFNa0ssa0JBQVcsR0FBRyxTQUFkQSxXQUFXLEdBQVM7RUFDL0IsT0FBT2dMLGtCQUFrQixJQUFJQyxnQkFBZ0IsSUFBSUMsc0JBQXNCO0FBQ3pFLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU1DLDBCQUFtQixHQUFHLFNBQXRCQSxtQkFBbUIsR0FBUztFQUN2QyxJQUFJO0lBQ0YsSUFBTUMsRUFBRSxHQUFHLElBQUlKLGtCQUFrQixDQUFDLElBQUksQ0FBQztJQUN2QyxJQUFNSyxFQUFFLEdBQUdELEVBQUUsQ0FBQ0UsaUJBQWlCLENBQUM7TUFBRW5ZLElBQUksRUFBRTtJQUFPLENBQUMsQ0FBQztJQUNqRGtZLEVBQUUsQ0FBQ0UsS0FBSyxFQUFFO0lBQ1ZILEVBQUUsQ0FBQ0csS0FBSyxFQUFFO0lBQ1YsT0FBTyxDQUFDLENBQUN2TCxrQkFBVyxFQUFFO0VBQ3hCLENBQUMsQ0FBQyxPQUFPaEcsQ0FBQyxFQUFFO0lBQ1Z6RSxTQUFLLG9EQUE2Q3lFLENBQUMsQ0FBQ3JHLE9BQU8sRUFBRztJQUM5RCxPQUFPLEtBQUs7RUFDZDtBQUNGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTXVMLG1CQUFZLEdBQUcsU0FBZkEsWUFBWSxDQUFJOEMsV0FBVyxFQUFFd0osV0FBVyxFQUFLO0VBQ3hEO0VBQ0EsSUFBSWhLLEdBQUcsR0FBRyxJQUFJcEwsZUFBZSxFQUFFO0VBQy9CLElBQUlxVixvQkFBb0IsR0FBR3ZCLGlCQUFpQixDQUFDakIsT0FBTyxDQUFDO0VBQ3JEMVQsU0FBSyxDQUFDLG9CQUFvQixFQUFFLGtDQUFrQyxHQUFHa1csb0JBQW9CLENBQUN6SixXQUFXLENBQUMsQ0FBQztFQUNuRyxJQUFNMEosUUFBUSxHQUFHLFNBQVhBLFFBQVEsQ0FBSTlOLEdBQUcsRUFBSztJQUN4QixJQUFJQSxHQUFHLEVBQUU7TUFDUCxJQUFNdEssR0FBRyxHQUFHLE9BQU9zSyxHQUFHLEtBQUssUUFBUSxHQUFHQSxHQUFHLEdBQUcsQ0FBQ0EsR0FBRyxDQUFDekssSUFBSSxFQUFFeUssR0FBRyxDQUFDakssT0FBTyxDQUFDLENBQUM4VyxJQUFJLENBQUMsSUFBSSxDQUFDO01BQzlFbFYsU0FBSyxDQUFDLG9CQUFvQixxQ0FBOEJqQyxHQUFHLDRDQUF5QztJQUN0RztJQUNBd1gsbUNBQTRCLENBQUM5SSxXQUFXLENBQUMsQ0FDdEN2SyxJQUFJLENBQUMsVUFBQ2tVLEdBQUcsRUFBSztNQUNibkssR0FBRyxDQUFDNUwsT0FBTyxDQUFDO1FBQ1Y0VSxLQUFLLEVBQUVtQixHQUFHLENBQUNuQixLQUFLO1FBQ2hCeEksV0FBVyxFQUFFMkosR0FBRyxDQUFDM0o7TUFDbkIsQ0FBQyxDQUFDO0lBQ0osQ0FBQyxDQUFDLENBQ0RySyxLQUFLLENBQUMsVUFBQ2xDLEtBQUssRUFBSztNQUNoQixJQUFJK1YsV0FBVyxFQUFFO1FBQ2ZBLFdBQVcsQ0FBQ3hKLFdBQVcsQ0FBQztNQUMxQjtNQUNBUixHQUFHLENBQUMzTCxNQUFNLENBQUM7UUFDVEosS0FBSyxFQUFFQSxLQUFLO1FBQ1p1TSxXQUFXLEVBQUVBO01BQ2YsQ0FBQyxDQUFDO0lBQ0osQ0FBQyxDQUFDO0VBQ04sQ0FBQztFQUNELElBQUksQ0FBQ21ILHFCQUFxQixDQUFDbkgsV0FBVyxDQUFDLEVBQUU7SUFDdkN6TSxTQUFLLENBQUMsb0JBQW9CLEVBQUUsK0RBQStELENBQUM7SUFDNUY0UCxPQUFXLENBQ1JwRCxHQUFHLENBQUNDLFdBQVcsQ0FBQyxDQUNoQnZLLElBQUksQ0FBQyxVQUFDK1MsS0FBSyxFQUFLO01BQ2ZoSixHQUFHLENBQUM1TCxPQUFPLENBQUM7UUFDVjRVLEtBQUssRUFBRUEsS0FBSztRQUNaeEksV0FBVyxFQUFFQTtNQUNmLENBQUMsQ0FBQztJQUNKLENBQUMsQ0FBQyxDQUNEckssS0FBSyxDQUFDK1QsUUFBUSxDQUFDO0VBQ3BCLENBQUMsTUFBTSxJQUFJRCxvQkFBb0IsQ0FBQ3pKLFdBQVcsQ0FBQyxFQUFFO0lBQzVDek0sU0FBSyxDQUNILG9CQUFvQixFQUNwQiwyRUFBMkUsR0FBR3VFLElBQUksQ0FBQzRPLFNBQVMsQ0FBQzFHLFdBQVcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQ25IO0lBQ0Q7SUFDQSxJQUFJNEosU0FBUyxHQUFHZiw2QkFBc0IsQ0FBQzdJLFdBQVcsQ0FBQztJQUNuRG1ELE9BQVcsQ0FDUnBELEdBQUcsQ0FBQzZKLFNBQVMsQ0FBQyxDQUNkblUsSUFBSSxDQUFDLFVBQUMrUyxLQUFLLEVBQUs7TUFDZmhKLEdBQUcsQ0FBQzVMLE9BQU8sQ0FBQztRQUNWNFUsS0FBSyxFQUFFQSxLQUFLO1FBQ1p4SSxXQUFXLEVBQUU0SjtNQUNmLENBQUMsQ0FBQztJQUNKLENBQUMsQ0FBQyxDQUNEalUsS0FBSyxDQUFDK1QsUUFBUSxDQUFDO0VBQ3BCLENBQUMsTUFBTTtJQUNMblcsU0FBSyxDQUFDLG9CQUFvQixFQUFFLDJEQUEyRCxDQUFDO0lBQ3hGLElBQUlpVyxXQUFXLEVBQUU7TUFDZkEsV0FBVyxDQUFDeEosV0FBVyxDQUFDO0lBQzFCO0lBQ0EwSixRQUFRLEVBQUU7RUFDWjtFQUNBLE9BQU9sSyxHQUFHLENBQUMxTCxPQUFPO0FBQ3BCLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU0rVixxQkFBYyxHQUFHLFNBQWpCQSxjQUFjLENBQUk3SixXQUFXLEVBQUs7RUFDN0MsT0FBT21ELE9BQVcsQ0FBQ3BELEdBQUcsQ0FBQ0MsV0FBVyxDQUFDO0FBQ3JDLENBQUM7QUFFTSxJQUFNOEosWUFBWSxHQUFHLFNBQWZBLFlBQVksQ0FBSUMsR0FBRyxFQUFLO0VBQ25DLElBQU1DLFNBQVMsR0FBRyxDQUFDLFlBQVksRUFBRSxxQkFBcUIsQ0FBQztFQUN2RCxJQUFJQyxDQUFDLEdBQUdGLEdBQUcsQ0FBQ2xPLEtBQUssQ0FBQyxNQUFNLENBQUM7RUFDekIsSUFBSXRGLENBQUMsR0FBRzBULENBQUMsQ0FBQ25WLE1BQU07RUFDaEIsT0FBTyxFQUFFeUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO0lBQ2YsSUFBSXlULFNBQVMsQ0FBQ3ZULE9BQU8sQ0FBQ3dULENBQUMsQ0FBQzFULENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7TUFDaEMwVCxDQUFDLENBQUN0VCxNQUFNLENBQUNKLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDaEI7RUFDRjtFQUNBLE9BQU8wVCxDQUFDLENBQUN4QixJQUFJLENBQUMsTUFBTSxDQUFDO0FBQ3ZCLENBQUM7QUFFTSxJQUFNeUIsWUFBWSxHQUFHLFNBQWZBLFlBQVksQ0FBSUgsR0FBRyxFQUFLO0VBQ25DLElBQU1JLE1BQU0sR0FBRyxXQUFXO0VBQzFCLElBQUlGLENBQUMsR0FBR0YsR0FBRyxDQUFDbE8sS0FBSyxDQUFDLE1BQU0sQ0FBQztFQUN6QixJQUFJdEYsQ0FBQyxHQUFHMFQsQ0FBQyxDQUFDblYsTUFBTTtFQUNoQixPQUFPLEVBQUV5QixDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7SUFDZixJQUFJNFQsTUFBTSxDQUFDalMsSUFBSSxDQUFDK1IsQ0FBQyxDQUFDMVQsQ0FBQyxDQUFDLENBQUMsRUFBRTtNQUNyQjBULENBQUMsQ0FBQ3RULE1BQU0sQ0FBQ0osQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNoQjtFQUNGO0VBQ0EsT0FBTzBULENBQUMsQ0FBQ3hCLElBQUksQ0FBQyxNQUFNLENBQUM7QUFDdkIsQ0FBQztBQUVELElBQUkyQixPQUFPLEdBQUksVUFBQ3ZYLElBQUksRUFBSztFQUN2QixJQUFJd1gsSUFBSSxHQUFHLEVBQUU7RUFDYnhYLElBQUksQ0FBQzBHLE9BQU8sQ0FBQyxVQUFDK1EsSUFBSTtJQUFBLE9BQUtELElBQUksQ0FBQzNYLElBQUksQ0FBQyxJQUFJNlgsTUFBTSxjQUFPRCxJQUFJLFFBQUssR0FBRyxDQUFDLENBQUM7RUFBQSxFQUFDO0VBQ2pFLE9BQU9ELElBQUk7QUFDYixDQUFDLENBQUUsQ0FDRCx1QkFBdUIsRUFDdkIsdUJBQXVCLEVBQ3ZCLHFCQUFxQixFQUNyQix1QkFBdUIsRUFDdkIsdUJBQXVCLEVBQ3ZCLGtDQUFrQyxDQUNuQyxDQUFDO0FBRUssSUFBTUcsWUFBWSxHQUFHLFNBQWZBLFlBQVksQ0FBSVQsR0FBRyxFQUFLO0VBQ25DLElBQU1wQyxNQUFNLEdBQUcsU0FBVEEsTUFBTSxDQUFJbkosRUFBRSxFQUFLO0lBQ3JCLG1DQUE0QkEsRUFBRTtFQUNoQyxDQUFDO0VBQ0QsSUFBSXlMLENBQUMsR0FBR0YsR0FBRyxDQUFDbE8sS0FBSyxDQUFDLE1BQU0sQ0FBQztFQUN6QixJQUFJdEYsQ0FBQyxHQUFHMFQsQ0FBQyxDQUFDblYsTUFBTTtFQUNoQixJQUFJMlYsQ0FBQyxFQUFFQyxFQUFFO0VBQ1QsSUFBSXpTLEtBQUs7RUFDVCxJQUFJZ1AsT0FBTyxHQUFHLEVBQUU7RUFDaEIsSUFBSTBELFNBQVM7RUFDYjtFQUNBLE9BQU8sRUFBRXBVLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtJQUNmLEtBQUtrVSxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdMLE9BQU8sQ0FBQ3RWLE1BQU0sRUFBRTJWLENBQUMsRUFBRSxFQUFFO01BQ25DQyxFQUFFLEdBQUdOLE9BQU8sQ0FBQ0ssQ0FBQyxDQUFDO01BQ2ZDLEVBQUUsQ0FBQ0UsU0FBUyxHQUFHLENBQUM7TUFDaEIzUyxLQUFLLEdBQUd5UyxFQUFFLENBQUN4UyxJQUFJLENBQUMrUixDQUFDLENBQUMxVCxDQUFDLENBQUMsQ0FBQztNQUNyQixJQUFJMEIsS0FBSyxFQUFFO1FBQ1Q7UUFDQTBTLFNBQVMsR0FBR2hELE1BQU0sQ0FBQzFQLEtBQUssQ0FBQ0EsS0FBSyxDQUFDbkQsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQzNDLElBQUltUyxPQUFPLENBQUN4USxPQUFPLENBQUNrVSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtVQUNyQzFELE9BQU8sQ0FBQ3ZVLElBQUksQ0FBQ2lZLFNBQVMsQ0FBQztRQUN6QjtRQUNBVixDQUFDLENBQUN0VCxNQUFNLENBQUNKLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDZDtNQUNGO0lBQ0Y7RUFDRjtFQUNBO0VBQ0EsSUFBSW1VLEVBQUUsRUFBRUEsRUFBRSxDQUFDRSxTQUFTLEdBQUcsQ0FBQztFQUN4QnJVLENBQUMsR0FBRzBULENBQUMsQ0FBQ25WLE1BQU07RUFDWjtFQUNBLE9BQU8sRUFBRXlCLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtJQUNmLEtBQUtrVSxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUd4RCxPQUFPLENBQUNuUyxNQUFNLEVBQUUyVixDQUFDLEVBQUUsRUFBRTtNQUNuQ0MsRUFBRSxHQUFHLElBQUlILE1BQU0sQ0FBQ3RELE9BQU8sQ0FBQ3dELENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztNQUNoQ0MsRUFBRSxDQUFDRSxTQUFTLEdBQUcsQ0FBQztNQUNoQixJQUFJRixFQUFFLENBQUN4UyxJQUFJLENBQUMrUixDQUFDLENBQUMxVCxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ2pCO1FBQ0EwVCxDQUFDLENBQUN0VCxNQUFNLENBQUNKLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDZDtNQUNGO0lBQ0Y7RUFDRjtFQUNBLE9BQU8wVCxDQUFDLENBQUN4QixJQUFJLENBQUMsTUFBTSxDQUFDO0FBQ3ZCLENBQUM7QUFFTSxJQUFNb0MsWUFBWSxHQUFHLFNBQWZBLFlBQVksQ0FBSWQsR0FBRyxFQUFLO0VBQ25DLElBQUllLElBQUksR0FBRyx5Q0FBeUM7RUFDcEQsSUFBSUMsSUFBSSxHQUFHLDJDQUEyQztFQUN0RCxJQUFJQyxLQUFLLEdBQUcsRUFBRTtFQUNkLElBQUlmLENBQUMsR0FBR0YsR0FBRyxDQUFDbE8sS0FBSyxDQUFDLE1BQU0sQ0FBQztFQUN6QixJQUFJdEYsQ0FBQyxHQUFHMFQsQ0FBQyxDQUFDblYsTUFBTTtFQUNoQixJQUFJMlYsQ0FBQyxHQUFHLENBQUM7RUFDVCxJQUFJeFMsS0FBSyxFQUFFeVMsRUFBRTtFQUViLE9BQU8sRUFBRW5VLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtJQUNmd1UsSUFBSSxDQUFDSCxTQUFTLEdBQUcsQ0FBQztJQUNsQjNTLEtBQUssR0FBRzhTLElBQUksQ0FBQzdTLElBQUksQ0FBQytSLENBQUMsQ0FBQzFULENBQUMsQ0FBQyxDQUFDO0lBQ3ZCLElBQUkwQixLQUFLLElBQUkrUyxLQUFLLENBQUN2VSxPQUFPLENBQUN3QixLQUFLLENBQUNBLEtBQUssQ0FBQ25ELE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO01BQzFEa1csS0FBSyxDQUFDdFksSUFBSSxDQUFDdUYsS0FBSyxDQUFDQSxLQUFLLENBQUNuRCxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDckM7RUFDRjtFQUNBeUIsQ0FBQyxHQUFHMFQsQ0FBQyxDQUFDblYsTUFBTTtFQUNaO0VBQ0EsT0FBTyxFQUFFeUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO0lBQ2YsS0FBS2tVLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR08sS0FBSyxDQUFDbFcsTUFBTSxFQUFFMlYsQ0FBQyxFQUFFLEVBQUU7TUFDakNLLElBQUksQ0FBQ0YsU0FBUyxHQUFHLENBQUM7TUFDbEIzUyxLQUFLLEdBQUc2UyxJQUFJLENBQUM1UyxJQUFJLENBQUMrUixDQUFDLENBQUMxVCxDQUFDLENBQUMsQ0FBQztNQUN2QixJQUFJMEIsS0FBSyxJQUFJK1MsS0FBSyxDQUFDdlUsT0FBTyxDQUFDd0IsS0FBSyxDQUFDQSxLQUFLLENBQUNuRCxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtRQUMxRDtRQUNBbVYsQ0FBQyxDQUFDdFQsTUFBTSxDQUFDSixDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2Q7TUFDRjtJQUNGO0VBQ0Y7RUFDQSxPQUFPMFQsQ0FBQyxDQUFDeEIsSUFBSSxDQUFDLE1BQU0sQ0FBQztBQUN2QixDQUFDO0FBRU0sSUFBTXdDLHFCQUFxQixHQUFHLFNBQXhCQSxxQkFBcUIsQ0FBSWxCLEdBQUcsRUFBSztFQUM1QyxJQUFNbUIsQ0FBQyxHQUFHLFNBQVM7RUFDbkIsSUFBTUMsTUFBTSxHQUFHcEIsR0FBRyxDQUFDbE8sS0FBSyxDQUFDLElBQUksQ0FBQztFQUM5QixJQUFJdVAsR0FBRyxHQUFHRCxNQUFNLENBQUNyWSxHQUFHLENBQUMsVUFBQ3VZLEtBQUssRUFBSztJQUM5QixJQUFJQSxLQUFLLENBQUNwVCxLQUFLLENBQUNpVCxDQUFDLENBQUMsRUFBRTtNQUNsQixJQUFJRyxLQUFLLENBQUM1VSxPQUFPLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7UUFDdEMsT0FBT29VLFlBQVksQ0FBQ1EsS0FBSyxDQUFDO01BQzVCO0lBQ0Y7SUFDQSxPQUFPQSxLQUFLO0VBQ2QsQ0FBQyxDQUFDO0VBQ0YsT0FBT0QsR0FBRyxDQUFDM0MsSUFBSSxDQUFDLElBQUksQ0FBQztBQUN2QixDQUFDO0FBRUQsSUFBSTZDLElBQUksR0FBRyxVQUFVO0FBQ3JCLElBQU1DLFlBQVksR0FBRyxTQUFmQSxZQUFZLENBQUl4QixHQUFHLEVBQUV5QixLQUFLLEVBQUV2VCxLQUFLLEVBQUs7RUFDMUMsSUFBTXVRLEtBQUssR0FBR3VCLEdBQUcsQ0FBQ2xPLEtBQUssQ0FBQzJQLEtBQUssQ0FBQztFQUM5QixJQUFJOVUsS0FBSyxHQUFHLENBQUM7RUFDYjtFQUNBLElBQUkwVSxHQUFHLEdBQUc1QyxLQUFLLENBQUMxVixHQUFHLENBQUMsVUFBQ3VZLEtBQUssRUFBSztJQUM3QixJQUFJQSxLQUFLLENBQUNwVCxLQUFLLENBQUNBLEtBQUssQ0FBQyxFQUFFO01BQ3RCLElBQUksRUFBRXZCLEtBQUssR0FBRyxDQUFDLEVBQUU7UUFDZixJQUFJK1AsR0FBRyxHQUFHNEUsS0FBSyxDQUFDL1AsT0FBTyxDQUFDLFlBQVksRUFBRSxZQUFZLENBQUM7UUFDbkQsSUFBSThQLElBQUcsR0FBRzNFLEdBQUcsQ0FBQzVLLEtBQUssQ0FBQyxNQUFNLENBQUM7UUFDM0IsSUFBSXRGLENBQUMsR0FBRzZVLElBQUcsQ0FBQ3RXLE1BQU07UUFDbEIsT0FBTyxFQUFFeUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO1VBQ2YrVSxJQUFJLENBQUNWLFNBQVMsR0FBRyxDQUFDO1VBQ2xCLElBQUlVLElBQUksQ0FBQ3BULElBQUksQ0FBQ2tULElBQUcsQ0FBQzdVLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDckI2VSxJQUFHLENBQUN6VSxNQUFNLENBQUNKLENBQUMsRUFBRSxDQUFDLENBQUM7VUFDbEI7UUFDRjtRQUNBLE9BQU82VSxJQUFHLENBQUMzQyxJQUFJLENBQUMsTUFBTSxDQUFDO01BQ3pCO0lBQ0Y7SUFDQSxPQUFPNEMsS0FBSztFQUNkLENBQUMsQ0FBQztFQUNGLE9BQU9ELEdBQUcsQ0FBQzNDLElBQUksQ0FBQytDLEtBQUssQ0FBQztBQUN4QixDQUFDO0FBRU0sSUFBTUMsd0JBQXdCLEdBQUcsU0FBM0JBLHdCQUF3QixDQUFJMUIsR0FBRyxFQUFLO0VBQy9DLE9BQU93QixZQUFZLENBQUN4QixHQUFHLEVBQUUsSUFBSSxFQUFFLFNBQVMsQ0FBQztBQUMzQyxDQUFDO0FBRU0sSUFBTTJCLHdCQUF3QixHQUFHLFNBQTNCQSx3QkFBd0IsQ0FBSTNCLEdBQUcsRUFBSztFQUMvQyxPQUFPd0IsWUFBWSxDQUFDeEIsR0FBRyxFQUFFLElBQUksRUFBRSxTQUFTLENBQUM7QUFDM0MsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU00QixlQUFlLEdBQUcsU0FBbEJBLGVBQWUsQ0FBSXpXLE9BQU8sRUFBRTZVLEdBQUcsRUFBSztFQUMvQyxJQUFJNkIsT0FBTyxHQUFHN0IsR0FBRyxDQUFDdFQsT0FBTyxDQUFDLFNBQVMsQ0FBQztFQUNwQyxJQUFJb1YsT0FBTyxHQUFHOUIsR0FBRyxDQUFDdFQsT0FBTyxDQUFDLFNBQVMsQ0FBQztFQUNwQyxJQUFJcVYsT0FBTyxFQUFFQyxLQUFLLEVBQUVDLElBQUk7RUFDeEIsSUFBSUosT0FBTyxHQUFHLENBQUMsQ0FBQyxFQUFFO0lBQ2hCLElBQUkxVyxPQUFPLENBQUMrVyxLQUFLLEVBQUU7TUFDakJILE9BQU8sR0FBRy9CLEdBQUcsQ0FBQ3RULE9BQU8sQ0FBQyxNQUFNLEVBQUVtVixPQUFPLENBQUM7TUFDdENHLEtBQUssR0FBR2hDLEdBQUcsQ0FBQy9ULEtBQUssQ0FBQyxDQUFDLEVBQUU4VixPQUFPLENBQUM7TUFDN0JFLElBQUksR0FBR2pDLEdBQUcsQ0FBQy9ULEtBQUssQ0FBQzhWLE9BQU8sR0FBRyxNQUFNLENBQUNoWCxNQUFNLEVBQUVpVixHQUFHLENBQUNqVixNQUFNLENBQUM7TUFDckRpVixHQUFHLEdBQUcsQ0FBQ2dDLEtBQUssRUFBRSxPQUFPLEdBQUc3VyxPQUFPLENBQUMrVyxLQUFLLEVBQUVELElBQUksQ0FBQyxDQUFDdkQsSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUMzRDtJQUNBb0QsT0FBTyxHQUFHOUIsR0FBRyxDQUFDdFQsT0FBTyxDQUFDLFNBQVMsQ0FBQztFQUNsQztFQUNBLElBQUlvVixPQUFPLEdBQUcsQ0FBQyxDQUFDLEVBQUU7SUFDaEIsSUFBSTNXLE9BQU8sQ0FBQ2tTLEtBQUssRUFBRTtNQUNqQjBFLE9BQU8sR0FBRy9CLEdBQUcsQ0FBQ3RULE9BQU8sQ0FBQyxNQUFNLEVBQUVvVixPQUFPLENBQUM7TUFDdENFLEtBQUssR0FBR2hDLEdBQUcsQ0FBQy9ULEtBQUssQ0FBQyxDQUFDLEVBQUU4VixPQUFPLENBQUM7TUFDN0JFLElBQUksR0FBR2pDLEdBQUcsQ0FBQy9ULEtBQUssQ0FBQzhWLE9BQU8sR0FBRyxNQUFNLENBQUNoWCxNQUFNLEVBQUVpVixHQUFHLENBQUNqVixNQUFNLENBQUM7TUFDckRpVixHQUFHLEdBQUcsQ0FBQ2dDLEtBQUssRUFBRSxPQUFPLEdBQUc3VyxPQUFPLENBQUNrUyxLQUFLLEVBQUU0RSxJQUFJLENBQUMsQ0FBQ3ZELElBQUksQ0FBQyxNQUFNLENBQUM7SUFDM0Q7RUFDRjtFQUNBO0VBQ0EsSUFBSW1ELE9BQU8sS0FBSyxDQUFDLENBQUMsSUFBSUMsT0FBTyxLQUFLLENBQUMsQ0FBQyxFQUFFO0lBQ3BDOUIsR0FBRyxHQUFHQSxHQUFHLENBQUN6TyxPQUFPLENBQUMscUJBQXFCLEVBQUUsRUFBRSxDQUFDO0lBQzVDLElBQUlwRyxPQUFPLENBQUMrVyxLQUFLLEVBQUU7TUFDakJsQyxHQUFHLEdBQUdBLEdBQUcsQ0FBQ3pPLE9BQU8sQ0FBQyxrQkFBa0IsRUFBRSxzQkFBc0IsR0FBR3BHLE9BQU8sQ0FBQytXLEtBQUssR0FBRyxNQUFNLENBQUM7SUFDeEY7SUFDQSxJQUFJL1csT0FBTyxDQUFDa1MsS0FBSyxFQUFFO01BQ2pCMkMsR0FBRyxHQUFHQSxHQUFHLENBQUN6TyxPQUFPLENBQUMsa0JBQWtCLEVBQUUsc0JBQXNCLEdBQUdwRyxPQUFPLENBQUNrUyxLQUFLLEdBQUcsTUFBTSxDQUFDO0lBQ3hGO0VBQ0Y7RUFDQSxPQUFPMkMsR0FBRztBQUNaLENBQUM7QUFFTSxJQUFNbUMsd0JBQXdCLEdBQUcsU0FBM0JBLHdCQUF3QixDQUFJbkMsR0FBRyxFQUFLO0VBQy9DLE9BQU9BLEdBQUcsQ0FBQ29DLFFBQVEsQ0FBQyxVQUFVLENBQUMsR0FBR3BDLEdBQUcsR0FBR0EsR0FBRyxDQUFDek8sT0FBTyxDQUFDLGdCQUFnQixFQUFFLHdDQUF3QyxDQUFDO0FBQ2pILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFNOFEsd0JBQXdCLEdBQUcsU0FBM0JBLHdCQUF3QixDQUFJckMsR0FBRyxFQUFzQztFQUFBLElBQXBDblgsSUFBSSx1RUFBR0osU0FBUztFQUFBLElBQUU2WixLQUFLLHVFQUFHLEtBQUs7RUFDM0UsSUFBTTdVLEdBQUcsR0FBRyxxQkFBcUI7RUFDakMsSUFBTThVLFlBQVksR0FBRyxlQUFlO0VBQ3BDLElBQU1DLE9BQU8sR0FBRyxlQUFlO0VBQy9CLElBQU1DLE1BQU0sR0FBRyxhQUFhO0VBQzVCLElBQU1DLElBQUksR0FBRyxnQ0FBZ0M7RUFDN0MsSUFBSUMsS0FBSyxHQUFHM0MsR0FBRyxDQUFDbE8sS0FBSyxDQUFDLE1BQU0sQ0FBQztFQUM3QixJQUFJOFEsT0FBTyxHQUFHLEVBQUU7RUFDaEIsSUFBSUMsTUFBTSxHQUFHLEVBQUU7RUFDZixJQUFJQyxLQUFLO0VBQ1QsSUFBSXJPLEVBQUUsR0FBRyxTQUFTO0VBQ2xCLElBQUlzTyxVQUFVLEdBQUcsRUFBRTtFQUNuQkosS0FBSyxDQUFDblQsT0FBTyxDQUFDLFVBQUN3VCxDQUFDLEVBQUs7SUFDbkIsSUFBSSxDQUFDRixLQUFLLElBQUlKLElBQUksQ0FBQ3ZVLElBQUksQ0FBQzZVLENBQUMsQ0FBQyxFQUFFO01BQzFCRixLQUFLLEdBQUdFLENBQUM7SUFDWCxDQUFDLE1BQU0sSUFBSVIsT0FBTyxDQUFDclUsSUFBSSxDQUFDNlUsQ0FBQyxDQUFDLEVBQUU7TUFDMUJKLE9BQU8sR0FBR0ksQ0FBQztJQUNiLENBQUMsTUFBTSxJQUFJUCxNQUFNLENBQUN0VSxJQUFJLENBQUM2VSxDQUFDLENBQUMsRUFBRTtNQUN6QkgsTUFBTSxHQUFHRyxDQUFDO0lBQ1osQ0FBQyxNQUFNLElBQUlULFlBQVksQ0FBQ3BVLElBQUksQ0FBQzZVLENBQUMsQ0FBQyxFQUFFO01BQy9CLElBQUluYSxJQUFJLElBQUltYSxDQUFDLENBQUN0VyxPQUFPLENBQUM3RCxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRTtRQUNqQ2thLFVBQVUsQ0FBQ3BhLElBQUksQ0FBQ3FhLENBQUMsQ0FBQztNQUNwQixDQUFDLE1BQU0sSUFBSSxDQUFDbmEsSUFBSSxFQUFFO1FBQ2hCa2EsVUFBVSxDQUFDcGEsSUFBSSxDQUFDcWEsQ0FBQyxDQUFDO01BQ3BCO0lBQ0Y7RUFDRixDQUFDLENBQUM7RUFDRixJQUFJVixLQUFLLElBQUlTLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDaFksTUFBTSxHQUFHLENBQUMsQ0FBQyxLQUFLMEMsR0FBRyxFQUFFO0lBQ3REc1YsVUFBVSxDQUFDcGEsSUFBSSxDQUFDOEUsR0FBRyxDQUFDO0VBQ3RCO0VBQ0EsSUFBTXdWLFFBQVEsR0FBRyxDQUFDTCxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFck8sRUFBRSxDQUFDLENBQUN4TCxNQUFNLENBQUM4WixVQUFVLENBQUM7RUFDaEUsT0FBT0UsUUFBUSxDQUFDdkUsSUFBSSxDQUFDLE1BQU0sQ0FBQztBQUM5QixDQUFDOztBQUVEO0FBQ0EsSUFBTU8sa0JBQWtCLEdBQUc5TyxNQUFNLENBQUMrUyxpQkFBaUIsSUFBSS9TLE1BQU0sQ0FBQ2dULG9CQUFvQixJQUFJaFQsTUFBTSxDQUFDaVQsdUJBQXVCO0FBQ3BILElBQU1sRSxnQkFBZ0IsR0FBRy9PLE1BQU0sQ0FBQ2tULGVBQWUsSUFBSWxULE1BQU0sQ0FBQ21ULGtCQUFrQixJQUFJblQsTUFBTSxDQUFDb1QscUJBQXFCO0FBQzVHLElBQU1wRSxzQkFBc0IsR0FDMUJoUCxNQUFNLENBQUNxVCxxQkFBcUIsSUFBSXJULE1BQU0sQ0FBQ3NULHdCQUF3QixJQUFJdFQsTUFBTSxDQUFDdVQsMkJBQTJCO0FBRWhHLElBQU1SLGlCQUFpQixHQUFHakUsa0JBQWtCO0FBQzVDLElBQU1vRSxlQUFlLEdBQUduRSxnQkFBZ0I7QUFDeEMsSUFBTXNFLHFCQUFxQixHQUFHckUsc0JBQXNCLEM7O0FDam9CL0M7O0FBRTRCOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU1sTCxxQkFBVyxHQUFHLFNBQWRBLFdBQVcsR0FBZTtFQUNyQyxPQUFPbUYsT0FBVyxDQUFDM0YsaUJBQWlCLEVBQUU7QUFDeEMsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTWtRLGdCQUFNLEdBQUcsU0FBVEEsTUFBTSxDQUFhL08sR0FBRyxFQUFFO0VBQ25DLE9BQU93RSxPQUFXLENBQUN6RSxlQUFlLENBQUNDLEdBQUcsQ0FBQztBQUN6QyxDQUFDLEM7O0FDekJEO0FBQ0E7QUFDQTtBQUNPLElBQU1nUCxtQkFBbUIsR0FBRzdHLE1BQU0sQ0FBQzhHLE1BQU0sQ0FBQztFQUMvQ0MsZUFBZSxFQUFFLGlCQUFpQjtFQUNsQ0MsZUFBZSxFQUFFLGlCQUFpQjtFQUNsQ0MsYUFBYSxFQUFFLGVBQWU7RUFDOUJDLFlBQVksRUFBRSxjQUFjO0VBQzVCQyxvQkFBb0IsRUFBRSxxQkFBcUI7RUFDM0NDLGlCQUFpQixFQUFFLG1CQUFtQjtFQUN0Q0MsZ0JBQWdCLEVBQUUsa0JBQWtCO0VBQ3BDQyxjQUFjLEVBQUUsZ0JBQWdCO0VBQ2hDQyxpQkFBaUIsRUFBRSxtQkFBbUI7RUFDdENDLDhCQUE4QixFQUFFLHdCQUF3QjtFQUN4REMsNEJBQTRCLEVBQUUsc0JBQXNCO0VBQ3BEQyw0QkFBNEIsRUFBRSxzQkFBc0I7RUFDcERDLG1CQUFtQixFQUFFLHFCQUFxQjtFQUMxQ0MsaUJBQWlCLEVBQUUsNkJBQTZCO0VBQ2hEQyxnQkFBZ0IsRUFBRTtBQUNwQixDQUFDLENBQUM7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU1DLDJCQUEyQixHQUFHOUgsTUFBTSxDQUFDOEcsTUFBTSxDQUFDO0VBQ3ZEaUIsZ0JBQWdCLEVBQUUsa0JBQWtCO0VBQ3BDQyxnQkFBZ0IsRUFBRTtBQUNwQixDQUFDLENBQUM7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU1DLHNCQUFzQixHQUFHakksTUFBTSxDQUFDOEcsTUFBTSxDQUFDO0VBQ2xEb0Isb0JBQW9CLEVBQUUsa0NBQWtDO0VBQ3hEQyxvQkFBb0IsRUFBRSxrQ0FBa0M7RUFDeERDLHNCQUFzQixFQUFFLDhCQUE4QjtFQUN0REMseUJBQXlCLEVBQUUsaUNBQWlDO0VBQzVEQyxXQUFXLEVBQUUsb0JBQW9CO0VBQ2pDQyxTQUFTLEVBQUUsa0JBQWtCO0VBQzdCQyxrQkFBa0IsRUFBRSxvQ0FBb0M7RUFDeERDLG9CQUFvQixFQUFFLDRCQUE0QjtFQUNsREMsY0FBYyxFQUFFLHVCQUF1QjtFQUN2Q0MsaUJBQWlCLEVBQUUseUJBQXlCO0VBQzVDQyxzQkFBc0IsRUFBRSw4QkFBOEI7RUFDdERDLGtCQUFrQixFQUFFLDBCQUEwQjtFQUM5Q0Msb0JBQW9CLEVBQUUsNEJBQTRCO0VBQ2xEQyxrQkFBa0IsRUFBRSwwQkFBMEI7RUFDOUNDLG9CQUFvQixFQUFFLDRCQUE0QjtFQUNsREMsV0FBVyxFQUFFO0FBQ2YsQ0FBQyxDQUFDOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFNQyx1QkFBdUIsR0FBR2xKLE1BQU0sQ0FBQzhHLE1BQU0sQ0FBQztFQUNuRHFDLGFBQWEsRUFBRSwyQkFBMkI7RUFDMUNDLGFBQWEsRUFBRTtBQUNqQixDQUFDLENBQUMsQzs7QUMvREY7QUFDQTtBQUNBO0FBQ08sSUFBTUMsb0JBQW9CLEdBQUdySixNQUFNLENBQUM4RyxNQUFNLENBQUM7RUFDaERDLGVBQWUsRUFBRSxpQkFBaUI7RUFDbENDLGVBQWUsRUFBRSxpQkFBaUI7RUFDbENzQyxlQUFlLEVBQUUsaUJBQWlCO0VBQ2xDQyxjQUFjLEVBQUUsZ0JBQWdCO0VBQ2hDQyxjQUFjLEVBQUUsZ0JBQWdCO0VBQ2hDQyxzQkFBc0IsRUFBRSx1QkFBdUI7RUFDL0NDLGtCQUFrQixFQUFFLG9CQUFvQjtFQUN4Q0MsZ0JBQWdCLEVBQUUsa0JBQWtCO0VBQ3BDQyxxQkFBcUIsRUFBRSx1QkFBdUI7RUFDOUNDLDhCQUE4QixFQUFFLHVDQUF1QztFQUN2RUMsNEJBQTRCLEVBQUUscUNBQXFDO0VBQ25FQyxjQUFjLEVBQUUsMEJBQTBCO0VBQzFDbkMsaUJBQWlCLEVBQUUsNkJBQTZCO0VBQ2hEb0Msa0JBQWtCLEVBQUUsOEJBQThCO0VBQ2xEQyxxQkFBcUIsRUFBRSxnQ0FBZ0M7RUFDdkRDLHVCQUF1QixFQUFFLGtDQUFrQztFQUMzREMsYUFBYSxFQUFFLHlCQUF5QjtFQUN4Q0MsV0FBVyxFQUFFLHVCQUF1QjtFQUNwQ0Msb0JBQW9CLEVBQUUsdUJBQXVCO0VBQzdDQyxxQkFBcUIsRUFBRSwyQkFBMkI7RUFDbERDLHdCQUF3QixFQUFFLDZCQUE2QjtFQUN2REMscUJBQXFCLEVBQUUsNEJBQTRCO0VBQ25EQyxtQkFBbUIsRUFBRTtBQUN2QixDQUFDLENBQUM7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU1DLDRCQUE0QixHQUFHMUssTUFBTSxDQUFDOEcsTUFBTSxDQUFDO0VBQ3hENkQsaUJBQWlCLEVBQUUsbUJBQW1CO0VBQ3RDQyxpQkFBaUIsRUFBRTtBQUNyQixDQUFDLENBQUM7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU1DLHVCQUF1QixHQUFHN0ssTUFBTSxDQUFDOEcsTUFBTSxDQUFDO0VBQ25EdUIseUJBQXlCLEVBQUUsaUNBQWlDO0VBQzVEQyxXQUFXLEVBQUUsb0JBQW9CO0VBQ2pDQyxTQUFTLEVBQUUsa0JBQWtCO0VBQzdCdUMsWUFBWSxFQUFFLHFCQUFxQjtFQUNuQ0MsVUFBVSxFQUFFLG1CQUFtQjtFQUMvQkMsZUFBZSxFQUFFLHdCQUF3QjtFQUN6Q0MsYUFBYSxFQUFFLHNCQUFzQjtFQUNyQ3pDLGtCQUFrQixFQUFFLG9DQUFvQztFQUN4REMsb0JBQW9CLEVBQUUsNEJBQTRCO0VBQ2xEQyxjQUFjLEVBQUUsdUJBQXVCO0VBQ3ZDSSxvQkFBb0IsRUFBRSw0QkFBNEI7RUFDbERILGlCQUFpQixFQUFFLHlCQUF5QjtFQUM1Q0Msc0JBQXNCLEVBQUUsOEJBQThCO0VBQ3REQyxrQkFBa0IsRUFBRSwwQkFBMEI7RUFDOUNFLGtCQUFrQixFQUFFLDBCQUEwQjtFQUM5Q0Msb0JBQW9CLEVBQUUsNEJBQTRCO0VBQ2xEa0MsYUFBYSxFQUFFLG1CQUFtQjtFQUNsQ0MsZUFBZSxFQUFFLHVCQUF1QjtFQUN4Q0MsaUJBQWlCLEVBQUUseUJBQXlCO0VBQzVDQyxrQkFBa0IsRUFBRSwwQkFBMEI7RUFDOUNDLGlCQUFpQixFQUFFLGlDQUFpQztFQUNwREMsZ0JBQWdCLEVBQUU7QUFDcEIsQ0FBQyxDQUFDOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFNQyx3QkFBd0IsR0FBR3hMLE1BQU0sQ0FBQzhHLE1BQU0sQ0FBQztFQUNwRHFDLGFBQWEsRUFBRSwyQkFBMkI7RUFDMUNDLGFBQWEsRUFBRSwyQkFBMkI7RUFDMUM7RUFDQXFDLGdCQUFnQixFQUFFO0FBQ3BCLENBQUMsQ0FBQyxDOztBQy9FRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTUMsc0JBQXNCLEdBQUcxTCxNQUFNLENBQUM4RyxNQUFNLENBQUM7RUFDbERDLGVBQWUsRUFBRSxpQkFBaUI7RUFDbENDLGVBQWUsRUFBRSxpQkFBaUI7RUFDbEMyRSxlQUFlLEVBQUUsNkJBQTZCO0VBQzlDQyxlQUFlLEVBQUUsNkJBQTZCO0VBQzlDQyxhQUFhLEVBQUUsMkJBQTJCO0VBQzFDakUsaUJBQWlCLEVBQUU7QUFDckIsQ0FBQyxDQUFDLEM7O0FDWkY7QUFDQTtBQUNBO0FBQ08sSUFBTWtFLCtCQUErQixHQUFHOUwsTUFBTSxDQUFDOEcsTUFBTSxDQUFDO0VBQzNEaUYsSUFBSSxFQUFFLHVCQUF1QjtFQUM3QkMsS0FBSyxFQUFFLHdCQUF3QjtFQUMvQkMsTUFBTSxFQUFFLHlCQUF5QjtFQUNqQzVnQixLQUFLLEVBQUU7QUFDVCxDQUFDLENBQUMsQzs7QUNSSyxJQUFNNmdCLGtDQUFrQyxHQUFHbE0sTUFBTSxDQUFDOEcsTUFBTSxDQUFDO0VBQzlEcUYsWUFBWSxFQUFFLHdCQUF3QjtFQUN0Q0MsWUFBWSxFQUFFLHdCQUF3QjtFQUN0Q0MsWUFBWSxFQUFFO0FBQ2hCLENBQUMsQ0FBQyxDOzs7Ozs7Ozs7Ozs7Ozs7QUNKRjtBQUNBO0FBQ0E7QUFGQSxJQUdNQyxLQUFLO0VBRVQsZUFBYXhnQixJQUFJLEVBQW9CO0lBQUEsSUFBbEJ1RSxJQUFJLHVFQUFHM0UsU0FBUztJQUFBO0lBQ2pDLElBQUksQ0FBQzZnQixLQUFLLEdBQUd6Z0IsSUFBSTtJQUNqQixJQUFJLENBQUMwZ0IsS0FBSyxHQUFHbmMsSUFBSTtFQUNuQjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLEtBS0EsZUFBWTtNQUNWLE9BQU8sSUFBSSxDQUFDa2MsS0FBSztJQUNuQjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLEtBS0EsZUFBWTtNQUNWLE9BQU8sSUFBSSxDQUFDQyxLQUFLO0lBQ25CO0VBQUM7RUFBQTtBQUFBO0FBSUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBLElBS01DLGNBQWM7RUFBQTtFQUFBO0VBRWxCLHdCQUFhM2dCLElBQUksRUFBRTRnQixTQUFTLEVBQUVyYyxJQUFJLEVBQUU7SUFBQTtJQUFBO0lBQ2xDLDBCQUFNdkUsSUFBSSxFQUFFdUUsSUFBSTtJQUNoQixNQUFLc2MsVUFBVSxHQUFHRCxTQUFTO0lBQUE7RUFDN0I7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUkU7SUFBQTtJQUFBLEtBU0EsZUFBaUI7TUFDZixPQUFPLElBQUksQ0FBQ0MsVUFBVTtJQUN4QjtFQUFDO0VBQUE7QUFBQSxFQWxCMEJMLEtBQUs7QUFzQmxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQSxJQUtNTSxlQUFlO0VBQUE7RUFBQTtFQUVuQix5QkFBYTlnQixJQUFJLEVBQUUrZ0IsVUFBVSxFQUFFeGMsSUFBSSxFQUFFO0lBQUE7SUFBQTtJQUNuQyw0QkFBTXZFLElBQUksRUFBRXVFLElBQUk7SUFDaEIsT0FBS3ljLFdBQVcsR0FBR0QsVUFBVTtJQUFBO0VBQy9COztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBVEU7SUFBQTtJQUFBLEtBVUEsZUFBa0I7TUFDaEIsT0FBTyxJQUFJLENBQUNDLFdBQVc7SUFDekI7RUFBQztFQUFBO0FBQUEsRUFuQjJCUixLQUFLO0FBdUJuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkEsSUFLTVMsaUJBQWlCO0VBQUE7RUFBQTtFQUVyQiwyQkFBYWpoQixJQUFJLEVBQUVraEIsZ0JBQWdCLEVBQUUzYyxJQUFJLEVBQUU7SUFBQTtJQUFBO0lBQ3pDLDRCQUFNdkUsSUFBSSxFQUFFdUUsSUFBSTtJQUNoQixPQUFLNGMsS0FBSyxHQUFHRCxnQkFBZ0I7SUFBQTtFQUMvQjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQU5FO0lBQUE7SUFBQSxLQU9BLGVBQVk7TUFDVixPQUFPLElBQUksQ0FBQ0MsS0FBSztJQUNuQjtFQUFDO0VBQUE7QUFBQSxFQWhCNkJYLEtBQUs7QUFvQnJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQSxJQUtNWSwwQkFBMEI7RUFBQTtFQUFBO0VBRTlCLG9DQUFhcGhCLElBQUksRUFBRXpCLElBQUksRUFBRWdHLElBQUksRUFBRTtJQUFBO0lBQUE7SUFDN0IsNEJBQU12RSxJQUFJLEVBQUV1RSxJQUFJO0lBQ2hCLE9BQUs0YyxLQUFLLEdBQUc1aUIsSUFBSTtJQUFBO0VBQ25COztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLEtBT0EsZUFBWTtNQUNWLE9BQU8sSUFBSSxDQUFDNGlCLEtBQUs7SUFDbkI7RUFBQztFQUFBO0FBQUEsRUFoQnNDWCxLQUFLO0FBb0I5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkEsSUFLTWEsNkJBQTZCO0VBQUE7RUFBQTtFQUVqQyx1Q0FBYXJoQixJQUFJLEVBQUVzaEIsV0FBVyxFQUFFL2MsSUFBSSxFQUFFO0lBQUE7SUFBQTtJQUNwQyw0QkFBTXZFLElBQUksRUFBRXVFLElBQUk7SUFDaEIsT0FBS2dkLFlBQVksR0FBR0QsV0FBVztJQUFBO0VBQ2pDOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLEtBT0EsZUFBbUI7TUFDakIsT0FBTyxJQUFJLENBQUNDLFlBQVk7SUFDMUI7RUFBQztFQUFBO0FBQUEsRUFoQnlDZixLQUFLO0FBb0IxQjtBQUNrQjtBQUNFO0FBQ0k7QUFDa0I7QUFDTTtBQUNPO0FBQ007QUFDRTtBQUNRO0FBQ2I7QUFDTTtBQUNFO0FBQ1E7QUFDVjtBQUN1Qjs7O0FDL0tqRzs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVzQjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQSxJQU9NZ0IsV0FBVztFQUFBO0VBQUE7RUFFZixxQkFBYXhoQixJQUFJLEVBQUV5aEIsT0FBTyxFQUFFbGQsSUFBSSxFQUFFO0lBQUE7SUFBQTtJQUNoQywwQkFBTXZFLElBQUksRUFBRXVFLElBQUk7SUFDaEIsTUFBS21kLFFBQVEsR0FBR0QsT0FBTztJQUFBO0VBQ3pCO0VBQUM7SUFBQTtJQUFBLEtBRUQsZUFBZTtNQUNiLE9BQU8sSUFBSSxDQUFDQyxRQUFRO0lBQ3RCO0VBQUM7RUFBQTtBQUFBLEVBVHVCbEIsS0FBSztBQWEvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTW1CLGdCQUFnQixHQUFHek4sTUFBTSxDQUFDOEcsTUFBTSxDQUFDO0VBQ3JDNEcsWUFBWSxFQUFFLGFBQWE7RUFDM0J6QixNQUFNLEVBQUUsUUFBUTtFQUNoQjBCLGVBQWUsRUFBRTtBQUNuQixDQUFDLENBQUM7QUFFRixJQUFNQyxjQUFjLEdBQUc1TixNQUFNLENBQUM4RyxNQUFNLENBQUM7RUFDbkMrRyxVQUFVLEVBQUUsV0FBVztFQUN2QkMsUUFBUSxFQUFFO0FBQ1osQ0FBQyxDQUFDO0FBRWlDO0FBQ1U7OztBQ3pDakM7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFdUM7QUFDUjtBQUNZO0FBQ3RCO0FBRWpDLElBQUlDLElBQUksR0FBRyxlQUFlOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkEsSUFLTUMsb0JBQWE7RUFBQTtFQUFBO0VBRWpCLHVCQUFhbGlCLElBQUksRUFBRTtJQUFBO0lBQUE7SUFDakI7SUFDQSxNQUFLekIsSUFBSSxHQUFHLENBQUMwakIsSUFBSSxFQUFFamlCLElBQUksQ0FBQyxDQUFDNlYsSUFBSSxDQUFDLElBQUksQ0FBQztJQUNuQ2xWLFNBQUssQ0FBQyxNQUFLcEMsSUFBSSxFQUFFLFFBQVEsQ0FBQztJQUMxQixNQUFLNGpCLFVBQVUsR0FBRzVSLE9BQVcsQ0FBQ3ZGLGFBQWEsQ0FBQyxLQUFLLENBQUM7SUFDbEQsTUFBS29YLE9BQU8sR0FBRyxNQUFLQyxZQUFZLEVBQUU7SUFDbEMsTUFBS0MsTUFBTSxHQUFHLE1BQUtDLFdBQVcsRUFBRTtJQUNoQyxNQUFLQyxZQUFZLEdBQUcsTUFBS0MsaUJBQWlCLEVBQUU7SUFDNUMsTUFBS04sVUFBVSxDQUFDalYsV0FBVyxDQUFDLE1BQUtvVixNQUFNLENBQUM7SUFDeEMsTUFBS0gsVUFBVSxDQUFDalYsV0FBVyxDQUFDLE1BQUtzVixZQUFZLENBQUM7SUFDOUMsTUFBS0wsVUFBVSxDQUFDalYsV0FBVyxDQUFDLE1BQUtrVixPQUFPLENBQUM7SUFDekMsTUFBS00sTUFBTSxHQUFHLENBQUMsRUFBQztJQUNoQixNQUFLQyxTQUFTLEdBQUcsS0FBSztJQUN0QixNQUFLQyxtQkFBbUIsR0FBRyxDQUFDO0lBQzVCLE1BQUtDLE9BQU8sRUFBRTtJQUNkLE1BQUtDLGVBQWUsR0FBRyxNQUFLQyxRQUFRLENBQUNDLElBQUksQ0FBQyxvQ0FBSztJQUMvQyxNQUFLQyxpQkFBaUIsR0FBRyxNQUFLQyxVQUFVLENBQUNGLElBQUksQ0FBQyxvQ0FBSztJQUNuRCxNQUFLRyxpQkFBaUIsR0FBRyxNQUFLQyxVQUFVLENBQUNKLElBQUksQ0FBQyxvQ0FBSztJQUNuRCxNQUFLSyxlQUFlLEdBQUcsTUFBS0MsV0FBVyxDQUFDTixJQUFJLENBQUMsb0NBQUs7SUFDbEQsTUFBS08saUJBQWlCLEdBQUcsTUFBS0QsV0FBVyxDQUFDTixJQUFJLENBQUMsb0NBQUs7SUFDcEQsTUFBS1EsaUJBQWlCLEdBQUcsTUFBS0YsV0FBVyxDQUFDTixJQUFJLENBQUMsb0NBQUs7SUFDcEQsTUFBS1MsZUFBZSxDQUFDLE1BQUtkLFNBQVMsQ0FBQztJQUFBO0VBQ3RDOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxxQkFBYWpmLEtBQUssRUFBRTtNQUNsQkEsS0FBSyxDQUFDZ2dCLGNBQWMsRUFBRTtNQUN0QixJQUFJaGdCLEtBQUssQ0FBQ2lnQixPQUFPLENBQUN6aEIsTUFBTSxHQUFHLENBQUMsSUFBS3dCLEtBQUssQ0FBQzFELElBQUksSUFBSSxVQUFVLElBQUkwRCxLQUFLLENBQUNpZ0IsT0FBTyxDQUFDemhCLE1BQU0sR0FBRyxDQUFFLEVBQUU7UUFDdEY7TUFDRjtNQUNBLElBQUkwaEIsR0FBRyxHQUFHclQsT0FBVyxDQUFDSCxXQUFXLENBQUMsWUFBWSxDQUFDO01BQy9DLElBQUlwUSxJQUFJLEVBQUU2akIsS0FBSztNQUNmLElBQU1DLENBQUMsR0FBR3BnQixLQUFLLENBQUNxZ0IsY0FBYyxJQUFJcmdCLEtBQUssQ0FBQ3NnQixNQUFNO01BQzlDLFFBQVF0Z0IsS0FBSyxDQUFDMUQsSUFBSTtRQUNoQixLQUFLLFlBQVk7VUFDZkEsSUFBSSxHQUFHLFdBQVc7VUFDbEI2akIsS0FBSyxHQUFHbmdCLEtBQUssQ0FBQ3VnQixjQUFjLENBQUMsQ0FBQyxDQUFDO1VBQy9CO1FBQ0YsS0FBSyxXQUFXO1VBQ2Rqa0IsSUFBSSxHQUFHLFdBQVc7VUFDbEI2akIsS0FBSyxHQUFHbmdCLEtBQUssQ0FBQ3VnQixjQUFjLENBQUMsQ0FBQyxDQUFDO1VBQy9CO1FBQ0YsS0FBSyxVQUFVO1VBQ2Jqa0IsSUFBSSxHQUFHLFNBQVM7VUFDaEI2akIsS0FBSyxHQUFHbmdCLEtBQUssQ0FBQ3VnQixjQUFjLENBQUMsQ0FBQyxDQUFDO1VBQy9CO01BQUs7TUFHVEwsR0FBRyxDQUFDTSxjQUFjLENBQUNsa0IsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU4akIsQ0FBQyxDQUFDSyxhQUFhLENBQUNDLFdBQVcsRUFBRSxDQUFDLEVBQ2pFUCxLQUFLLENBQUNRLE9BQU8sRUFBRVIsS0FBSyxDQUFDUyxPQUFPLEVBQUVULEtBQUssQ0FBQ2hVLE9BQU8sRUFBRWdVLEtBQUssQ0FBQ1UsT0FBTyxFQUMxRDdnQixLQUFLLENBQUM4Z0IsT0FBTyxFQUFFOWdCLEtBQUssQ0FBQytnQixNQUFNLEVBQUUvZ0IsS0FBSyxDQUFDZ2hCLFFBQVEsRUFBRWhoQixLQUFLLENBQUNpaEIsT0FBTyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUM7TUFDdEViLENBQUMsQ0FBQ2MsYUFBYSxDQUFDaEIsR0FBRyxDQUFDO0lBQ3RCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxvQkFBWTtNQUNWLElBQUksQ0FBQ2hCLG1CQUFtQixHQUFHLENBQUM7TUFDNUIvWSxRQUFRLENBQUNvRSxtQkFBbUIsQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDa1YsaUJBQWlCLENBQUM7TUFDakV0WixRQUFRLENBQUNvRSxtQkFBbUIsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDNlUsZUFBZSxDQUFDO01BQzdEalosUUFBUSxDQUFDb0UsbUJBQW1CLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQ3VWLGlCQUFpQixDQUFDO01BQ2pFM1osUUFBUSxDQUFDb0UsbUJBQW1CLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQ29WLGVBQWUsQ0FBQztNQUM3RCxJQUFJLENBQUN3QixPQUFPLENBQUMsSUFBSXJELFdBQVcsQ0FBQ0csZ0JBQWdCLENBQUNFLGVBQWUsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUN2RTs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0Esb0JBQVluZSxLQUFLLEVBQUU7TUFDZixJQUFNb2hCLGNBQWMsR0FBSXZVLE9BQVcsQ0FBQ1osa0JBQWtCLENBQUNqTSxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUNrZixtQkFBb0I7TUFDekYsSUFBTW1DLElBQUksR0FBRyxJQUFJLENBQUMzQyxPQUFPLENBQUNqUyxVQUFVLENBQUM2VSxxQkFBcUIsRUFBRTtNQUM1RCxJQUFJdFQsUUFBUSxHQUFJLElBQUksQ0FBQ2tSLG1CQUFtQixHQUFHa0MsY0FBYyxHQUFJQyxJQUFJLENBQUNwVCxJQUFJLEVBQUM7TUFDdkVELFFBQVEsR0FBR3FCLElBQUksQ0FBQzZCLEdBQUcsQ0FBQyxDQUFDLEVBQUVsRCxRQUFRLENBQUM7TUFDaENBLFFBQVEsR0FBR3FCLElBQUksQ0FBQzhCLEdBQUcsQ0FBQ25ELFFBQVEsRUFBRXFULElBQUksQ0FBQ3pULEtBQUssQ0FBQztNQUN6QyxJQUFJMlQsVUFBVSxHQUFHdlQsUUFBUSxHQUFHcVQsSUFBSSxDQUFDelQsS0FBSztNQUN0QyxJQUFJLENBQUN1VCxPQUFPLENBQUMsSUFBSXJELFdBQVcsQ0FBQ0csZ0JBQWdCLENBQUN4QixNQUFNLEVBQUUsSUFBSSxFQUFFOEUsVUFBVSxDQUFDLENBQUM7SUFDNUU7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLG9CQUFZdmhCLEtBQUssRUFBRTtNQUNmLElBQUksQ0FBQ2tmLG1CQUFtQixHQUFHclMsT0FBVyxDQUFDWixrQkFBa0IsQ0FBQ2pNLEtBQUssQ0FBQztNQUNoRSxJQUFJLENBQUNtaEIsT0FBTyxDQUFDLElBQUlyRCxXQUFXLENBQUNHLGdCQUFnQixDQUFDQyxZQUFZLEVBQUUsSUFBSSxDQUFDLENBQUM7TUFDbEUvWCxRQUFRLENBQUMzRCxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDaWQsaUJBQWlCLENBQUM7TUFDOUR0WixRQUFRLENBQUMzRCxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDNGMsZUFBZSxDQUFDO01BQzFEalosUUFBUSxDQUFDM0QsZ0JBQWdCLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQ3NkLGlCQUFpQixDQUFDO01BQzlEM1osUUFBUSxDQUFDM0QsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQ21kLGVBQWUsQ0FBQztJQUM5RDs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQU5FO0lBQUE7SUFBQSxPQU9BLHlCQUFpQjZCLFVBQVUsRUFBRTtNQUMzQixJQUFJLENBQUN0QyxtQkFBbUIsR0FBRyxDQUFDO01BQzVCLElBQUlzQyxVQUFVLEVBQUU7UUFDZCxJQUFJLENBQUM1QyxNQUFNLENBQUNyVSxtQkFBbUIsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDa1YsaUJBQWlCLENBQUM7UUFDaEUsSUFBSSxDQUFDWCxZQUFZLENBQUN2VSxtQkFBbUIsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDa1YsaUJBQWlCLENBQUM7UUFDdEUsSUFBSSxDQUFDZixPQUFPLENBQUNuVSxtQkFBbUIsQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDZ1YsaUJBQWlCLENBQUM7UUFDckVwWixRQUFRLENBQUNvRSxtQkFBbUIsQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDa1YsaUJBQWlCLENBQUM7UUFDakV0WixRQUFRLENBQUNvRSxtQkFBbUIsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDNlUsZUFBZSxDQUFDO1FBQzdEalosUUFBUSxDQUFDb0UsbUJBQW1CLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQ3VWLGlCQUFpQixDQUFDO1FBQ2pFM1osUUFBUSxDQUFDb0UsbUJBQW1CLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQ29WLGVBQWUsQ0FBQztRQUM3RCxJQUFJLENBQUNmLE1BQU0sQ0FBQ25ULFNBQVMsQ0FBQ2dXLEdBQUcsQ0FBQywrQkFBK0IsQ0FBQztRQUMxRCxJQUFJLENBQUMzQyxZQUFZLENBQUNyVCxTQUFTLENBQUNnVyxHQUFHLENBQUMsK0JBQStCLENBQUM7UUFDaEUsSUFBSSxDQUFDL0MsT0FBTyxDQUFDalQsU0FBUyxDQUFDZ1csR0FBRyxDQUFDLCtCQUErQixDQUFDO01BQzdELENBQUMsTUFDSTtRQUNILElBQUksQ0FBQzdDLE1BQU0sQ0FBQ3BjLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUNpZCxpQkFBaUIsQ0FBQztRQUM3RCxJQUFJLENBQUNYLFlBQVksQ0FBQ3RjLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUNpZCxpQkFBaUIsQ0FBQztRQUNuRSxJQUFJLENBQUNmLE9BQU8sQ0FBQ2xjLGdCQUFnQixDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMrYyxpQkFBaUIsQ0FBQztRQUNsRSxJQUFJLENBQUNiLE9BQU8sQ0FBQ2xjLGdCQUFnQixDQUFDLFlBQVksRUFBRSxJQUFJLENBQUNxZCxpQkFBaUIsQ0FBQztRQUNuRSxJQUFJLENBQUNqQixNQUFNLENBQUNuVCxTQUFTLENBQUNpVyxNQUFNLENBQUMsK0JBQStCLENBQUM7UUFDN0QsSUFBSSxDQUFDNUMsWUFBWSxDQUFDclQsU0FBUyxDQUFDaVcsTUFBTSxDQUFDLCtCQUErQixDQUFDO1FBQ25FLElBQUksQ0FBQ2hELE9BQU8sQ0FBQ2pULFNBQVMsQ0FBQ2lXLE1BQU0sQ0FBQywrQkFBK0IsQ0FBQztNQUNoRTtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxtQkFBVztNQUNULElBQUkxVCxRQUFRLEdBQUcsSUFBSSxDQUFDOFEsWUFBWSxDQUFDclMsVUFBVSxDQUFDZSxXQUFXLEdBQUcsSUFBSSxDQUFDd1IsTUFBTTtNQUNyRSxJQUFJLENBQUNGLFlBQVksQ0FBQ25SLEtBQUssQ0FBQ0MsS0FBSyxHQUFHSSxRQUFRLEdBQUcsSUFBSTtNQUMvQyxJQUFJLENBQUMwUSxPQUFPLENBQUMvUSxLQUFLLENBQUNNLElBQUksR0FBSUQsUUFBUSxHQUFJLElBQUksQ0FBQzBRLE9BQU8sQ0FBQ2xSLFdBQVcsR0FBRyxHQUFJLEdBQUksSUFBSTtJQUNoRjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0Esd0JBQWdCO01BQ2QsSUFBSW1VLElBQUksR0FBRzlVLE9BQVcsQ0FBQ3ZGLGFBQWEsQ0FBQyxNQUFNLENBQUM7TUFDNUNxYSxJQUFJLENBQUNsVyxTQUFTLENBQUNnVyxHQUFHLENBQUMsNkJBQTZCLENBQUM7TUFDakQsT0FBT0UsSUFBSTtJQUNiOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSw2QkFBcUI7TUFDbkIsSUFBSUEsSUFBSSxHQUFHOVUsT0FBVyxDQUFDdkYsYUFBYSxDQUFDLE1BQU0sQ0FBQztNQUM1Q3FhLElBQUksQ0FBQ2xXLFNBQVMsQ0FBQ2dXLEdBQUcsQ0FBQywrQkFBK0IsQ0FBQztNQUNuRCxPQUFPRSxJQUFJO0lBQ2I7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLHVCQUFlO01BQ2IsSUFBSUEsSUFBSSxHQUFHOVUsT0FBVyxDQUFDdkYsYUFBYSxDQUFDLE1BQU0sQ0FBQztNQUM1Q3FhLElBQUksQ0FBQ2xXLFNBQVMsQ0FBQ2dXLEdBQUcsQ0FBQyw0QkFBNEIsQ0FBQztNQUNoRCxPQUFPRSxJQUFJO0lBQ2I7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxLQUtBLGVBQWE7TUFDWCxPQUFPLElBQUksQ0FBQzNDLE1BQU07SUFDcEI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQSxPQUpFO0lBQUEsS0FLQSxhQUFXNEMsWUFBWSxDQUFDLGFBQWE7TUFDbkMsSUFBSSxDQUFDNUMsTUFBTSxHQUFHNEMsWUFBWTtNQUMxQixJQUFJLENBQUN6QyxPQUFPLEVBQUU7SUFDaEI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxLQUtBLGVBQWdCO01BQ2QsT0FBTyxJQUFJLENBQUNGLFNBQVM7SUFDdkI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQSxPQUpFO0lBQUEsS0FLQSxhQUFjNEMsSUFBSSxFQUFFO01BQ2xCLElBQUksQ0FBQzVDLFNBQVMsR0FBRzRDLElBQUk7TUFDckIsSUFBSSxDQUFDOUIsZUFBZSxDQUFDOEIsSUFBSSxDQUFDO0lBQzVCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsS0FLQSxlQUFXO01BQ1QsT0FBTyxJQUFJLENBQUNwRCxVQUFVO0lBQ3hCO0VBQUM7RUFBQTtBQUFBLEVBaE95QjVlLGFBQVk7QUFvT3pCMmUsd0VBQWEsRTs7QUNsUDVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFNc0QsYUFBYSxHQUFHdFIsTUFBTSxDQUFDOEcsTUFBTSxDQUFDO0VBQ3pDeUssV0FBVyxFQUFFLElBQUk7RUFDakJDLFNBQVMsRUFBRSxDQUFDO0VBQ1pDLElBQUksRUFBRSxDQUFDO0VBQ1BDLE9BQU8sRUFBRSxDQUFDO0VBQ1ZDLE1BQU0sRUFBRTtBQUNWLENBQUMsQ0FBQzs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFNQyxxQkFBcUIsR0FBRzVSLE1BQU0sQ0FBQzhHLE1BQU0sQ0FBQztFQUNqRCxJQUFJLEVBQUUsc0JBQXNCO0VBQzVCLENBQUMsRUFBRSxvQkFBb0I7RUFDdkIsQ0FBQyxFQUFFLGVBQWU7RUFDbEIsQ0FBQyxFQUFFLGtCQUFrQjtFQUNyQixDQUFDLEVBQUU7QUFDTCxDQUFDLENBQUMsQzs7QUN6QlU7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFdUM7QUFDUjtBQUNQO0FBQ0Q7QUFJbkI7QUFDOEM7QUFDN0I7QUFFakMsSUFBTWlILGFBQUksR0FBRyxrQkFBa0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQSxJQUtNOEQsNEJBQTRCO0VBQUE7RUFBQTtFQUVoQyx3Q0FBZTtJQUFBO0lBQUE7RUFFZjs7RUFFQTtBQUNGO0FBQ0E7RUFGRTtJQUFBO0lBQUEsT0FHQSxnQkFBUSxDQUFDO0lBQ1A7QUFDSjtBQUNBO0VBRkk7SUFBQTtJQUFBLE9BR0YsaUJBQVMsQ0FBQztJQUNSO0FBQ0o7QUFDQTtFQUZJO0lBQUE7SUFBQSxPQUdGLGtCQUFVLENBQUM7SUFDVDtBQUNKO0FBQ0E7RUFGSTtJQUFBO0lBQUEsT0FHRixnQkFBUSxDQUFDO0lBQ1Q7QUFDRjtBQUNBO0VBRkU7SUFBQTtJQUFBLE9BR0EsZ0JBQVEsQ0FBQztJQUNUO0FBQ0Y7QUFDQTtFQUZFO0lBQUE7SUFBQSxPQUdBLGtCQUFVLENBQUM7SUFDWDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFMRTtJQUFBO0lBQUEsT0FNQSxtQkFBVzVpQixLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDckI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLGdCQUFRQSxLQUFLLEVBQXdCO01BQUEsSUFBdEI2aUIsUUFBUSx1RUFBR3BtQixTQUFTO0lBQUcsQ0FBQyxDQUFDO0lBQ3hDO0FBQ0Y7QUFDQTtFQUZFO0lBQUE7SUFBQSxPQUdBLDRCQUFvQixDQUFDO0VBQUM7RUFBQTtBQUFBLEVBakRtQjJELGFBQVk7QUFxRHZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQSxJQVFNMGlCLDBCQUEwQjtFQUFBO0VBQUE7RUFFOUIsc0NBQWU7SUFBQTtJQUFBO0VBRWY7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLHFCQUFhLENBQUM7O0lBRWQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEsbUJBQVc5aUIsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDOztJQUVyQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEscUJBQWFBLEtBQUssRUFBZ0I7TUFBQSxJQUFkNmlCLFFBQVEsdUVBQUcsQ0FBQztJQUFHLENBQUMsQ0FBQzs7SUFFckM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEsNkJBQXFCN2lCLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQzs7SUFFL0I7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEsb0JBQVksQ0FBQzs7SUFFYjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFMRTtJQUFBO0lBQUEsT0FNQSxrQkFBVStpQixLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7O0lBRXBCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxrQkFBVS9pQixLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7O0lBRWxCO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7RUFKSTtJQUFBO0lBQUEsT0FLRixnQkFBUUEsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO0VBQUE7RUFBQTtBQUFBLEVBbkVxQkksYUFBWTtBQXVFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBLElBS000aUIsdUNBQThCO0VBQUE7RUFBQTtFQUVsQyx3Q0FBYXJnQixNQUFNLEVBQUVzZ0IsU0FBUyxFQUFFO0lBQUE7SUFBQTtJQUM5QjtJQUNBLE1BQUt0Z0IsTUFBTSxHQUFHQSxNQUFNO0lBQ3BCLE1BQUtzZ0IsU0FBUyxHQUFHQSxTQUFTO0lBQzFCLE1BQUtDLFdBQVcsR0FBR3ptQixTQUFTO0lBQzVCLE1BQUswbUIsZ0JBQWdCLEdBQUcxbUIsU0FBUztJQUNqQyxNQUFLMm1CLFdBQVcsR0FBRzNtQixTQUFTO0lBQzVCLE1BQUs0bUIsWUFBWSxHQUFHNW1CLFNBQVM7SUFDN0IsTUFBSzZtQixjQUFjLEdBQUc3bUIsU0FBUztJQUMvQixNQUFLOG1CLFVBQVUsR0FBRzltQixTQUFTO0lBQzNCLE1BQUsrbUIsaUJBQWlCLEdBQUcvbUIsU0FBUztJQUNsQyxNQUFLZ25CLE1BQU0sR0FBR3BCLGFBQWEsQ0FBQ0csSUFBSTtJQUNoQyxNQUFLa0IsV0FBVyxHQUFHLEtBQUs7SUFDeEIsTUFBS0MsZ0JBQWdCLEdBQUcsS0FBSztJQUM3QixNQUFLQyxpQkFBaUIsR0FBRyxDQUFDO0lBQzFCLE1BQUtDLFlBQVksR0FBRyxDQUFDO0lBQ3JCLE1BQUtDLHNCQUFzQixHQUFHLE1BQUtDLGlCQUFpQixDQUFDbEUsSUFBSSxDQUFDLHNDQUFLO0lBQy9ELE1BQUtoa0IsUUFBUSxDQUFDLE1BQUtvbkIsU0FBUyxDQUFDO0lBQUE7RUFDL0I7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORTtJQUFBO0lBQUEsT0FPQSxrQkFBVUEsU0FBUyxFQUFFO01BQ25CemxCLFNBQUssQ0FBQ3NoQixhQUFJLEVBQUUsWUFBWSxDQUFDO01BQ3pCLElBQUlrRixVQUFVLEdBQUc1VyxPQUFXLENBQUN2RixhQUFhLENBQUMsS0FBSyxDQUFDO01BQ2pEbWMsVUFBVSxDQUFDaFksU0FBUyxDQUFDZ1csR0FBRyxDQUFDLDJCQUEyQixDQUFDO01BQ3JELElBQUksQ0FBQ21CLGdCQUFnQixHQUFHLElBQUksQ0FBQ2Msc0JBQXNCLEVBQUU7TUFDckQsSUFBSSxDQUFDYixXQUFXLEdBQUcsSUFBSSxDQUFDYyxpQkFBaUIsRUFBRTtNQUMzQyxJQUFJLENBQUNiLFlBQVksR0FBRyxJQUFJLENBQUNjLG9CQUFvQixFQUFFO01BQy9DLElBQUksQ0FBQ2IsY0FBYyxHQUFHLElBQUksQ0FBQ2Msa0JBQWtCLEVBQUU7TUFDL0MsSUFBSSxDQUFDYixVQUFVLEdBQUcsSUFBSSxDQUFDYyxtQkFBbUIsRUFBRTtNQUM1QyxJQUFJLENBQUNiLGlCQUFpQixHQUFHLElBQUksQ0FBQ2MsdUJBQXVCLEVBQUU7TUFDdkROLFVBQVUsQ0FBQ2phLFdBQVcsQ0FBQyxJQUFJLENBQUNvWixnQkFBZ0IsQ0FBQztNQUM3Q2EsVUFBVSxDQUFDamEsV0FBVyxDQUFDLElBQUksQ0FBQ3daLFVBQVUsQ0FBQztNQUN2Q1MsVUFBVSxDQUFDamEsV0FBVyxDQUFDLElBQUksQ0FBQ3VaLGNBQWMsQ0FBQ2lCLElBQUksQ0FBQztNQUNoRFAsVUFBVSxDQUFDamEsV0FBVyxDQUFDLElBQUksQ0FBQ3FaLFdBQVcsQ0FBQztNQUN4Q1ksVUFBVSxDQUFDamEsV0FBVyxDQUFDLElBQUksQ0FBQ3NaLFlBQVksQ0FBQ2tCLElBQUksQ0FBQztNQUM5Q1AsVUFBVSxDQUFDamEsV0FBVyxDQUFDLElBQUksQ0FBQ3laLGlCQUFpQixDQUFDO01BQzlDUCxTQUFTLENBQUNsWixXQUFXLENBQUNpYSxVQUFVLENBQUM7TUFDakMsSUFBSSxDQUFDZCxXQUFXLEdBQUdjLFVBQVU7TUFFN0IsSUFBSVEsYUFBYTtNQUNqQixJQUFNQyxrQkFBa0IsR0FBRyxTQUFyQkEsa0JBQWtCLEdBQVM7UUFDL0JDLFlBQVksQ0FBQ0YsYUFBYSxDQUFDO1FBQzNCQSxhQUFhLEdBQUdwZSxVQUFVLENBQUMsWUFBTTtVQUMvQjRkLFVBQVUsQ0FBQ2hZLFNBQVMsQ0FBQ2lXLE1BQU0sQ0FBQyxnQ0FBZ0MsQ0FBQztRQUMvRCxDQUFDLEVBQUUsSUFBSSxDQUFDO01BQ1YsQ0FBQztNQUVELElBQUk3VSxPQUFXLENBQUNuRyxjQUFjLEVBQUUsRUFBRTtRQUNoQytjLFVBQVUsQ0FBQ2hZLFNBQVMsQ0FBQ2dXLEdBQUcsQ0FBQyxnQ0FBZ0MsQ0FBQztRQUMxRCxJQUFJLENBQUNpQixTQUFTLENBQUNsZ0IsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLFlBQU07VUFDaERpaEIsVUFBVSxDQUFDaFksU0FBUyxDQUFDVCxNQUFNLENBQUMsZ0NBQWdDLENBQUM7VUFDN0RrWixrQkFBa0IsRUFBRTtRQUN0QixDQUFDLENBQUM7UUFDRkEsa0JBQWtCLEVBQUU7TUFDdEIsQ0FBQyxNQUNJO1FBQ0gsSUFBSSxDQUFDeEIsU0FBUyxDQUFDbGdCLGdCQUFnQixDQUFDLFdBQVcsRUFBRSxZQUFNO1VBQ2pEaWhCLFVBQVUsQ0FBQ2hZLFNBQVMsQ0FBQ2dXLEdBQUcsQ0FBQyxnQ0FBZ0MsQ0FBQztRQUM1RCxDQUFDLENBQUM7UUFDRixJQUFJLENBQUNpQixTQUFTLENBQUNsZ0IsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLFlBQU07VUFDaERpaEIsVUFBVSxDQUFDaFksU0FBUyxDQUFDaVcsTUFBTSxDQUFDLGdDQUFnQyxDQUFDO1FBQy9ELENBQUMsQ0FBQztNQUNKO01BRUEsSUFBSSxDQUFDMEMsUUFBUSxDQUFDdEMsYUFBYSxDQUFDRyxJQUFJLENBQUMsQ0FDOUJvQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FDekJDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FDZEMsTUFBTSxDQUFDLEtBQUssQ0FBQztJQUNsQjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsNkJBQXFCO01BQ25CLElBQUksSUFBSSxDQUFDQyxRQUFRLEVBQUUsS0FBSzFDLGFBQWEsQ0FBQ0ksT0FBTyxFQUFFO1FBQzdDLElBQUksQ0FBQzlmLE1BQU0sQ0FBQzRHLEtBQUssQ0FBQyxJQUFJLENBQUM7TUFDekIsQ0FBQyxNQUNJLElBQUksSUFBSSxDQUFDd2IsUUFBUSxFQUFFLEtBQUsxQyxhQUFhLENBQUNLLE1BQU0sRUFBRTtRQUNqRCxJQUFJLENBQUMvZixNQUFNLENBQUNxaUIsTUFBTSxDQUFDLElBQUksQ0FBQztNQUMxQixDQUFDLE1BQ0k7UUFDSCxJQUFJLENBQUNyaUIsTUFBTSxDQUFDMEcsSUFBSSxDQUFDLElBQUksQ0FBQztNQUN4QjtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxrQ0FBMEI7TUFDeEIsSUFBSTRiLE1BQU0sR0FBRzdYLE9BQVcsQ0FBQ3ZGLGFBQWEsQ0FBQyxRQUFRLENBQUM7TUFDaERvZCxNQUFNLENBQUMzYixZQUFZLENBQUMsWUFBWSxFQUFFLGlCQUFpQixDQUFDO01BQ3BEMmIsTUFBTSxDQUFDalosU0FBUyxDQUFDZ1csR0FBRyxDQUFDLCtCQUErQixDQUFDO01BQ3JEaUQsTUFBTSxDQUFDalosU0FBUyxDQUFDZ1csR0FBRyxDQUFDLDhCQUE4QixDQUFDO01BQ3BEaUQsTUFBTSxDQUFDalosU0FBUyxDQUFDZ1csR0FBRyxDQUFDLGdDQUFnQyxDQUFDO01BQ3RELE9BQU9pRCxNQUFNO0lBQ2Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLDZCQUFxQjtNQUNuQixJQUFNQyxJQUFJLEdBQUcsSUFBSTtNQUNqQixJQUFJRCxNQUFNLEdBQUc3WCxPQUFXLENBQUN2RixhQUFhLENBQUMsUUFBUSxDQUFDO01BQ2hEb2QsTUFBTSxDQUFDM2IsWUFBWSxDQUFDLFlBQVksRUFBRSxtQkFBbUIsQ0FBQztNQUN0RDJiLE1BQU0sQ0FBQ2paLFNBQVMsQ0FBQ2dXLEdBQUcsQ0FBQywrQkFBK0IsQ0FBQztNQUNyRGlELE1BQU0sQ0FBQ2paLFNBQVMsQ0FBQ2dXLEdBQUcsQ0FBQyw4QkFBOEIsQ0FBQztNQUNwRGlELE1BQU0sQ0FBQ2paLFNBQVMsQ0FBQ2dXLEdBQUcsQ0FBQyxpQ0FBaUMsQ0FBQztNQUN2RGlELE1BQU0sQ0FBQ2xpQixnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsWUFBTTtRQUNyQyxJQUFJbWlCLElBQUksQ0FBQ0MsYUFBYSxFQUFFLEVBQUU7VUFDeEJELElBQUksQ0FBQ3ZpQixNQUFNLENBQUN5aUIsTUFBTSxFQUFFO1VBQ3BCRixJQUFJLENBQUNHLGFBQWEsQ0FBQyxLQUFLLENBQUM7UUFDM0IsQ0FBQyxNQUNJO1VBQ0hILElBQUksQ0FBQ3ZpQixNQUFNLENBQUMyaUIsSUFBSSxFQUFFO1VBQ2xCSixJQUFJLENBQUNHLGFBQWEsQ0FBQyxJQUFJLENBQUM7UUFDMUI7TUFDRixDQUFDLENBQUM7TUFDRixPQUFPSixNQUFNO0lBQ2Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLGdDQUF3QjtNQUN0QixJQUFNQyxJQUFJLEdBQUcsSUFBSTtNQUNqQixJQUFJSyxNQUFNLEdBQUcsSUFBSXhHLGVBQWEsQ0FBQyxRQUFRLENBQUM7TUFDeEN3RyxNQUFNLENBQUNoQixJQUFJLENBQUN2WSxTQUFTLENBQUNnVyxHQUFHLENBQUMsK0JBQStCLENBQUM7TUFDMUR1RCxNQUFNLENBQUNoQixJQUFJLENBQUN2WSxTQUFTLENBQUNnVyxHQUFHLENBQUMsNkJBQTZCLENBQUM7TUFDeER1RCxNQUFNLENBQUNoQixJQUFJLENBQUN2WSxTQUFTLENBQUNnVyxHQUFHLENBQUMsc0JBQXNCLENBQUM7TUFDakR1RCxNQUFNLENBQUNDLEVBQUUsQ0FBQ2hILGdCQUFnQixDQUFDeEIsTUFBTSxFQUFFLFVBQUN6YyxLQUFLLEVBQUs7UUFDNUMsSUFBTXVoQixVQUFVLEdBQUcyRCxNQUFNLENBQUNsbEIsS0FBSyxDQUFDYSxJQUFJLENBQUM7UUFDckM4akIsSUFBSSxDQUFDdmlCLE1BQU0sQ0FBQytpQixTQUFTLENBQUM1RCxVQUFVLENBQUM7TUFDbkMsQ0FBQyxDQUFDO01BQ0YsT0FBT3lELE1BQU07SUFDZjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsOEJBQXNCO01BQ3BCLElBQU1MLElBQUksR0FBRyxJQUFJO01BQ2pCLElBQUlLLE1BQU0sR0FBRyxJQUFJeEcsZUFBYSxDQUFDLE1BQU0sQ0FBQztNQUN0Q3dHLE1BQU0sQ0FBQ2hCLElBQUksQ0FBQ3ZZLFNBQVMsQ0FBQ2dXLEdBQUcsQ0FBQywrQkFBK0IsQ0FBQztNQUMxRHVELE1BQU0sQ0FBQ2hCLElBQUksQ0FBQ3ZZLFNBQVMsQ0FBQ2dXLEdBQUcsQ0FBQywrQkFBK0IsQ0FBQztNQUMxRHVELE1BQU0sQ0FBQ2hCLElBQUksQ0FBQ3ZZLFNBQVMsQ0FBQ2dXLEdBQUcsQ0FBQyxzQkFBc0IsQ0FBQztNQUNqRHVELE1BQU0sQ0FBQ0MsRUFBRSxDQUFDaEgsZ0JBQWdCLENBQUNDLFlBQVksRUFBRSxZQUFNO1FBQzdDLElBQUl5RyxJQUFJLENBQUNILFFBQVEsRUFBRSxLQUFLMUMsYUFBYSxDQUFDSSxPQUFPLEVBQUU7VUFDN0N5QyxJQUFJLENBQUN2QixnQkFBZ0IsR0FBRyxJQUFJO1VBQzVCdUIsSUFBSSxDQUFDdmlCLE1BQU0sQ0FBQzRHLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO1FBQy9CO1FBQ0EyYixJQUFJLENBQUN4RCxPQUFPLENBQUMsSUFBSXJFLEtBQUssQ0FBQ3NCLGNBQWMsQ0FBQ0MsVUFBVSxDQUFDLENBQUM7TUFDcEQsQ0FBQyxDQUFDO01BQ0YyRyxNQUFNLENBQUNDLEVBQUUsQ0FBQ2hILGdCQUFnQixDQUFDeEIsTUFBTSxFQUFFLFVBQUN6YyxLQUFLLEVBQUs7UUFDNUMsSUFBTXVoQixVQUFVLEdBQUcyRCxNQUFNLENBQUNsbEIsS0FBSyxDQUFDYSxJQUFJLENBQUM7UUFDckM4akIsSUFBSSxDQUFDdmlCLE1BQU0sQ0FBQ2dqQixNQUFNLENBQUM3RCxVQUFVLEVBQUVvRCxJQUFJLENBQUN0QixpQkFBaUIsS0FBSyxDQUFDLEdBQUdubkIsU0FBUyxHQUFFeW9CLElBQUksQ0FBQ3RCLGlCQUFpQixDQUFDO1FBQ2hHc0IsSUFBSSxDQUFDTCxXQUFXLENBQUMvQyxVQUFVLEdBQUdvRCxJQUFJLENBQUN0QixpQkFBaUIsRUFBRXNCLElBQUksQ0FBQ3RCLGlCQUFpQixDQUFDO01BQy9FLENBQUMsQ0FBQztNQUNGMkIsTUFBTSxDQUFDQyxFQUFFLENBQUNoSCxnQkFBZ0IsQ0FBQ0UsZUFBZSxFQUFFLFlBQU07UUFDaEQsSUFBSXdHLElBQUksQ0FBQ3ZCLGdCQUFnQixJQUFJdUIsSUFBSSxDQUFDSCxRQUFRLEVBQUUsS0FBSzFDLGFBQWEsQ0FBQ0ssTUFBTSxFQUFFO1VBQ3JFd0MsSUFBSSxDQUFDdkIsZ0JBQWdCLEdBQUcsS0FBSztVQUM3QnVCLElBQUksQ0FBQ3ZpQixNQUFNLENBQUNxaUIsTUFBTSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUM7UUFDaEM7UUFDQUUsSUFBSSxDQUFDeEQsT0FBTyxDQUFDLElBQUlyRSxLQUFLLENBQUNzQixjQUFjLENBQUNFLFFBQVEsQ0FBQyxDQUFDO01BQ2xELENBQUMsQ0FBQztNQUNGLE9BQU8wRyxNQUFNO0lBQ2Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLCtCQUF1QjtNQUNyQixJQUFJckQsSUFBSSxHQUFHOVUsT0FBVyxDQUFDdkYsYUFBYSxDQUFDLE1BQU0sQ0FBQztNQUM1QyxJQUFJaEcsSUFBSSxHQUFHdUwsT0FBVyxDQUFDdkYsYUFBYSxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUM7TUFDdERxYSxJQUFJLENBQUNsVyxTQUFTLENBQUNnVyxHQUFHLENBQUMsK0JBQStCLENBQUM7TUFDbkRFLElBQUksQ0FBQ2xXLFNBQVMsQ0FBQ2dXLEdBQUcsQ0FBQywwQkFBMEIsQ0FBQztNQUM5Q0UsSUFBSSxDQUFDblksV0FBVyxDQUFDbEksSUFBSSxDQUFDO01BQ3RCLE9BQU9xZ0IsSUFBSTtJQUNiOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxtQ0FBMkI7TUFDekIsSUFBTWdELElBQUksR0FBRyxJQUFJO01BQ2pCLElBQUlELE1BQU0sR0FBRzdYLE9BQVcsQ0FBQ3ZGLGFBQWEsQ0FBQyxRQUFRLENBQUM7TUFDaERvZCxNQUFNLENBQUMzYixZQUFZLENBQUMsWUFBWSxFQUFFLG1CQUFtQixDQUFDO01BQ3REMmIsTUFBTSxDQUFDalosU0FBUyxDQUFDZ1csR0FBRyxDQUFDLCtCQUErQixDQUFDO01BQ3JEaUQsTUFBTSxDQUFDalosU0FBUyxDQUFDZ1csR0FBRyxDQUFDLDhCQUE4QixDQUFDO01BQ3BEaUQsTUFBTSxDQUFDalosU0FBUyxDQUFDZ1csR0FBRyxDQUFDLGlDQUFpQyxDQUFDO01BQ3ZEaUQsTUFBTSxDQUFDbGlCLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxZQUFNO1FBQ3JDbWlCLElBQUksQ0FBQ3ZpQixNQUFNLENBQUMwSSxnQkFBZ0IsRUFBRTtNQUNoQyxDQUFDLENBQUM7TUFDRixPQUFPNFosTUFBTTtJQUNmOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxnQkFBUWpsQixLQUFLLEVBQUU7TUFDYixJQUFJQSxLQUFLLEVBQUU7UUFDVCxJQUFJLENBQUNtakIsZ0JBQWdCLENBQUNuWCxTQUFTLENBQUNpVyxNQUFNLENBQUMsdUNBQXVDLENBQUM7UUFDL0UsSUFBSSxDQUFDa0IsZ0JBQWdCLENBQUNwZ0IsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQytnQixzQkFBc0IsQ0FBQztNQUM5RSxDQUFDLE1BQ0k7UUFDSCxJQUFJLENBQUNYLGdCQUFnQixDQUFDblgsU0FBUyxDQUFDZ1csR0FBRyxDQUFDLHVDQUF1QyxDQUFDO1FBQzVFLElBQUksQ0FBQ21CLGdCQUFnQixDQUFDclksbUJBQW1CLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQ2daLHNCQUFzQixDQUFDO01BQ2pGO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEsb0JBQVk5akIsS0FBSyxFQUFFO01BQ2pCLElBQUk0bEIsR0FBRyxHQUFHLENBQUM7TUFDWCxJQUFJQyxJQUFJLEdBQUk3bEIsS0FBSyxLQUFLLENBQUMsSUFBSWlRLEtBQUssQ0FBQ2pRLEtBQUssQ0FBQyxHQUFJLENBQUMsR0FBR3VDLFFBQVEsQ0FBQ3ZDLEtBQUssR0FBRyxFQUFFLENBQUM7TUFDbkUsSUFBSThsQixJQUFJLEdBQUcsQ0FBQztNQUNaLElBQUlELElBQUksSUFBSSxFQUFFLEVBQUU7UUFDZEQsR0FBRyxHQUFHcmpCLFFBQVEsQ0FBQ3NqQixJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQ3pCQSxJQUFJLEdBQUdBLElBQUksR0FBRyxFQUFFO01BQ2xCO01BQ0FDLElBQUksR0FBSTlsQixLQUFLLEtBQUssQ0FBQyxJQUFJaVEsS0FBSyxDQUFDalEsS0FBSyxDQUFDLEdBQUksQ0FBQyxHQUFHdUMsUUFBUSxDQUFDdkMsS0FBSyxHQUFHLEVBQUUsQ0FBQztNQUUvRCxJQUFJK2xCLFlBQVksR0FBSUgsR0FBRyxHQUFHLEVBQUUsR0FBSSxDQUFDLEdBQUcsR0FBR0EsR0FBRyxDQUFDLEdBQUcsQ0FBQ0EsR0FBRyxDQUFDO01BQ25ERyxZQUFZLENBQUNwcEIsSUFBSSxDQUFFa3BCLElBQUksR0FBRyxFQUFFLEdBQUksQ0FBQyxHQUFHLEdBQUdBLElBQUksQ0FBQyxHQUFHLENBQUNBLElBQUksQ0FBQyxDQUFDO01BQ3RERSxZQUFZLENBQUNwcEIsSUFBSSxDQUFFbXBCLElBQUksR0FBRyxFQUFFLEdBQUksQ0FBQyxHQUFHLEdBQUdBLElBQUksQ0FBQyxHQUFHLENBQUNBLElBQUksQ0FBQyxDQUFDO01BQ3RELE9BQU9DLFlBQVksQ0FBQ3JULElBQUksQ0FBQyxHQUFHLENBQUM7SUFDL0I7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLHFCQUFhO01BQ1gsT0FBTyxJQUFJLENBQUNtUixZQUFZO0lBQzFCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUxFO0lBQUE7SUFBQSxPQU1BLG1CQUFXN2pCLEtBQUssRUFBRTtNQUNoQixJQUFJLENBQUNxakIsWUFBWSxDQUFDcmpCLEtBQUssR0FBR0EsS0FBSztNQUMvQixJQUFJLENBQUM2akIsWUFBWSxHQUFHN2pCLEtBQUs7TUFDekIsSUFBSUEsS0FBSyxLQUFLLENBQUMsRUFBRTtRQUNmLElBQUksQ0FBQ3FsQixhQUFhLENBQUMsSUFBSSxDQUFDO01BQzFCLENBQUMsTUFDSSxJQUFJLElBQUksQ0FBQ0YsYUFBYSxFQUFFLEVBQUU7UUFDN0IsSUFBSSxDQUFDRSxhQUFhLENBQUMsS0FBSyxDQUFDO01BQzNCO01BQ0EsT0FBTyxJQUFJO0lBQ2I7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLHFCQUFhcmxCLEtBQUssRUFBYztNQUFBLElBQVpqQixNQUFNLHVFQUFHLENBQUM7TUFDNUIsSUFBSSxDQUFDdWtCLGNBQWMsQ0FBQ3RqQixLQUFLLEdBQUdqQixNQUFNLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBSWlCLEtBQUssR0FBQ2pCLE1BQU87TUFDN0QsSUFBSSxJQUFJLENBQUM2a0IsaUJBQWlCLEtBQUssQ0FBQyxJQUFJcmhCLFFBQVEsQ0FBQyxJQUFJLENBQUNxaEIsaUJBQWlCLENBQUMsSUFBSXJoQixRQUFRLENBQUN2QyxLQUFLLENBQUMsRUFBRTtRQUN2RixJQUFJLENBQUNzakIsY0FBYyxDQUFDdGpCLEtBQUssR0FBRyxDQUFDO01BQy9CO01BQ0EsSUFBSSxDQUFDdWpCLFVBQVUsQ0FBQ3lDLFNBQVMsR0FBRyxJQUFJLENBQUNDLFVBQVUsQ0FBQ3JXLElBQUksQ0FBQ3NXLEtBQUssQ0FBQ2xtQixLQUFLLENBQUMsQ0FBQztNQUM5RCxPQUFPLElBQUk7SUFDYjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFMRTtJQUFBO0lBQUEsT0FNQSw2QkFBcUJBLEtBQUssRUFBRTtNQUMxQnhDLFNBQUssQ0FBQ3NoQixhQUFJLEVBQUUseUJBQXlCLEdBQUc5ZSxLQUFLLENBQUM7TUFDOUMsSUFBSSxDQUFDNGpCLGlCQUFpQixHQUFHNWpCLEtBQUs7SUFDaEM7RUFBQztJQUFBO0lBQUEsT0FFRCwrQkFBdUI7TUFDckIsT0FBTyxJQUFJLENBQUM0akIsaUJBQWlCO0lBQy9COztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUxFO0lBQUE7SUFBQSxPQU1BLG9CQUFZO01BQ1YsT0FBTyxJQUFJLENBQUNILE1BQU07SUFDcEI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEsa0JBQVVWLEtBQUssRUFBRTtNQUNmdmxCLFNBQUssQ0FBQ3NoQixhQUFJLEVBQUUsY0FBYyxHQUFHNkQscUJBQXFCLENBQUNJLEtBQUssQ0FBQyxDQUFDO01BQzFELElBQUksQ0FBQ1UsTUFBTSxHQUFHVixLQUFLO01BQ25CLElBQUksQ0FBQ29ELGFBQWEsQ0FBQyxJQUFJLENBQUMxQyxNQUFNLENBQUM7TUFDL0IsT0FBTyxJQUFJO0lBQ2I7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEseUJBQWlCO01BQ2YsT0FBUSxPQUFPLElBQUksSUFBSSxDQUFDOWdCLE1BQU0sR0FBSSxJQUFJLENBQUNBLE1BQU0sQ0FBQ3lqQixLQUFLLEdBQUcsSUFBSSxDQUFDMUMsV0FBVztJQUN4RTs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsdUJBQWVYLEtBQUssRUFBRTtNQUNwQixJQUFJLENBQUNXLFdBQVcsR0FBR1gsS0FBSztNQUN4QixJQUFJLENBQUNzRCxrQkFBa0IsQ0FBQyxJQUFJLENBQUMzQyxXQUFXLENBQUM7TUFDekMsT0FBTyxJQUFJO0lBQ2I7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLHVCQUFlWCxLQUFLLEVBQUU7TUFDcEIsSUFBSUEsS0FBSyxLQUFLVixhQUFhLENBQUNJLE9BQU8sRUFBRTtRQUNuQyxJQUFJLENBQUNVLGdCQUFnQixDQUFDblgsU0FBUyxDQUFDaVcsTUFBTSxDQUFDLDJCQUEyQixDQUFDO1FBQ25FLElBQUksQ0FBQ2tCLGdCQUFnQixDQUFDblgsU0FBUyxDQUFDZ1csR0FBRyxDQUFDLDRCQUE0QixDQUFDO01BQ25FLENBQUMsTUFDSTtRQUNILElBQUksQ0FBQ21CLGdCQUFnQixDQUFDblgsU0FBUyxDQUFDZ1csR0FBRyxDQUFDLDJCQUEyQixDQUFDO1FBQ2hFLElBQUksQ0FBQ21CLGdCQUFnQixDQUFDblgsU0FBUyxDQUFDaVcsTUFBTSxDQUFDLDRCQUE0QixDQUFDO01BQ3RFO01BQ0EsT0FBTyxJQUFJO0lBQ2I7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORTtJQUFBO0lBQUEsT0FPQSw0QkFBb0JjLEtBQUssRUFBRTtNQUN6QixJQUFJQSxLQUFLLEVBQUU7UUFDVCxJQUFJLENBQUNLLFdBQVcsQ0FBQ3BYLFNBQVMsQ0FBQ2dXLEdBQUcsQ0FBQywyQkFBMkIsQ0FBQztRQUMzRCxJQUFJLENBQUNvQixXQUFXLENBQUNwWCxTQUFTLENBQUNpVyxNQUFNLENBQUMsNkJBQTZCLENBQUM7UUFDaEUsSUFBSSxDQUFDb0IsWUFBWSxDQUFDcmpCLEtBQUssR0FBRyxDQUFDO01BQzdCLENBQUMsTUFDSTtRQUNILElBQUksQ0FBQ29qQixXQUFXLENBQUNwWCxTQUFTLENBQUNpVyxNQUFNLENBQUMsMkJBQTJCLENBQUM7UUFDOUQsSUFBSSxDQUFDbUIsV0FBVyxDQUFDcFgsU0FBUyxDQUFDZ1csR0FBRyxDQUFDLDZCQUE2QixDQUFDO1FBQzdELElBQUksQ0FBQ3FCLFlBQVksQ0FBQ3JqQixLQUFLLEdBQUcsSUFBSSxDQUFDNmpCLFlBQVk7TUFDN0M7SUFDRjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQU5FO0lBQUE7SUFBQSxPQU9BLDRCQUFvQnlDLFlBQVksRUFBRTtNQUNoQyxJQUFJQSxZQUFZLEVBQUU7UUFDaEIsSUFBSSxDQUFDOUMsaUJBQWlCLENBQUN4WCxTQUFTLENBQUNnVyxHQUFHLENBQUMsc0NBQXNDLENBQUM7UUFDNUUsSUFBSSxDQUFDd0IsaUJBQWlCLENBQUN4WCxTQUFTLENBQUNpVyxNQUFNLENBQUMsaUNBQWlDLENBQUM7TUFDNUUsQ0FBQyxNQUNJO1FBQ0gsSUFBSSxDQUFDdUIsaUJBQWlCLENBQUN4WCxTQUFTLENBQUNpVyxNQUFNLENBQUMsc0NBQXNDLENBQUM7UUFDL0UsSUFBSSxDQUFDdUIsaUJBQWlCLENBQUN4WCxTQUFTLENBQUNnVyxHQUFHLENBQUMsaUNBQWlDLENBQUM7TUFDekU7TUFDQSxPQUFPLElBQUk7SUFDYjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0Esa0JBQVV1RSxLQUFLLEVBQUU7TUFDZi9vQixTQUFLLENBQUNzaEIsYUFBSSxFQUFFLGNBQWMsR0FBR3lILEtBQUssQ0FBQztNQUNuQyxJQUFJLENBQUNBLEtBQUssRUFBRTtRQUNWLElBQUksQ0FBQ2pELGNBQWMsQ0FBQ3RqQixLQUFLLEdBQUcsQ0FBQztRQUM3QixJQUFJLENBQUNzakIsY0FBYyxDQUFDa0QsUUFBUSxHQUFHLElBQUk7TUFDckMsQ0FBQyxNQUNJO1FBQ0gsSUFBSSxDQUFDbEQsY0FBYyxDQUFDa0QsUUFBUSxHQUFHLEtBQUs7TUFDdEM7SUFDRjs7SUFFQTtBQUNGO0FBQ0E7RUFGRTtJQUFBO0lBQUEsT0FHQSxrQkFBVTtNQUNSLElBQUksQ0FBQzFCLE1BQU0sQ0FBQyxLQUFLLENBQUM7TUFDbEIsSUFBSSxJQUFJLENBQUM1QixXQUFXLElBQUksSUFBSSxDQUFDQSxXQUFXLENBQUNsVyxVQUFVLEVBQUU7UUFDbkQsSUFBSSxDQUFDa1csV0FBVyxDQUFDbFcsVUFBVSxDQUFDeVosV0FBVyxDQUFDLElBQUksQ0FBQ3ZELFdBQVcsQ0FBQztNQUMzRDtNQUNBLElBQUksQ0FBQ0EsV0FBVyxHQUFHem1CLFNBQVM7TUFDNUIsSUFBSSxDQUFDd21CLFNBQVMsR0FBR3htQixTQUFTO0lBQzVCO0VBQUM7RUFBQTtBQUFBLEVBNWIwQ3FtQiwwQkFBMEI7QUFnY2hFLElBQU00RCxrQkFBa0IsR0FBRzlELDRCQUE0QjtBQUN2RCxJQUFNK0QsZ0JBQWdCLEdBQUc3RCwwQkFBMEI7QUFDbkQsSUFBTThELG9CQUFvQixHQUFHNUQsdUNBQThCLEM7O0FDL2xCdEQ7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFNEI7QUFDNkI7QUFDRTtBQUNQO0FBQ2Y7QUFDTjtBQUUzQyxJQUFNbEUsK0JBQUksR0FBRyxrQkFBa0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQSxJQVFNK0gsMkNBQWdCO0VBQUE7RUFBQTtFQUVwQiwwQkFBYXBVLEtBQUssRUFBRTVWLElBQUksRUFBRTtJQUFBO0lBQUE7SUFDeEI7SUFDQSxNQUFLNFYsS0FBSyxHQUFHQSxLQUFLO0lBQ2xCLElBQU1xVSxtQkFBbUIsR0FBRzFaLE9BQVcsQ0FBQzFCLG1CQUFtQixDQUFDLE1BQUsrRyxLQUFLLEVBQUUsVUFBVSxDQUFDLElBQUlyRixPQUFXLENBQUN0QixlQUFlLENBQUMsTUFBSzJHLEtBQUssRUFBRSxlQUFlLENBQUM7SUFDL0ksSUFBSXFVLG1CQUFtQixFQUFFO01BQ3ZCLE1BQUtDLEtBQUssR0FBRyxNQUFLdFUsS0FBSyxDQUFDdVUsU0FBUyxDQUFDLElBQUksQ0FBQztNQUN2QyxNQUFLblosTUFBTSxHQUFHLE1BQUs0RSxLQUFLLENBQUN6RixVQUFVO01BQ25DLE1BQUtpYSxNQUFNLEdBQUcsTUFBS0MsZ0JBQWdCLENBQUMsTUFBS3pVLEtBQUssQ0FBQztJQUNqRDtJQUNBLE1BQUswVSxVQUFVLEdBQUd0cUIsSUFBSTtJQUN0QixNQUFLdXFCLE1BQU0sR0FBRyxLQUFLO0lBQ25CLE1BQUtDLFNBQVMsR0FBRzVxQixTQUFTO0lBQzFCLE1BQUs2cUIsMkJBQTJCLEdBQUcsTUFBSzdVLEtBQUs7SUFDN0NyRixPQUFXLENBQUM1Qix1QkFBdUIsQ0FBQyxNQUFLK2IsdUJBQXVCLENBQUMxSCxJQUFJLENBQUMsd0RBQUssQ0FBQztJQUFBO0VBQzlFOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQRTtJQUFBO0lBQUEsT0FRQSwwQkFBa0JwTixLQUFLLEVBQUU7TUFDdkIsSUFBSUEsS0FBSyxDQUFDekYsVUFBVSxDQUFDaEIsU0FBUyxDQUFDQyxRQUFRLENBQUMseUJBQXlCLENBQUMsRUFBRTtRQUNsRSxPQUFPd0csS0FBSyxDQUFDekYsVUFBVTtNQUN6QixDQUFDLE1BQ0k7UUFDSCxJQUFNYSxNQUFNLEdBQUc0RSxLQUFLLENBQUN6RixVQUFVO1FBQy9CLElBQU13YSxHQUFHLEdBQUdwYSxPQUFXLENBQUN2RixhQUFhLENBQUMsS0FBSyxDQUFDO1FBQzVDMmYsR0FBRyxDQUFDeGIsU0FBUyxDQUFDZ1csR0FBRyxDQUFDLHlCQUF5QixDQUFDO1FBQzVDblUsTUFBTSxDQUFDNFosWUFBWSxDQUFDRCxHQUFHLEVBQUUvVSxLQUFLLENBQUM7UUFDL0I1RSxNQUFNLENBQUM0WSxXQUFXLENBQUNoVSxLQUFLLENBQUM7UUFDekIrVSxHQUFHLENBQUN6ZCxXQUFXLENBQUMwSSxLQUFLLENBQUM7UUFDdEIsT0FBTytVLEdBQUc7TUFDWjtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQRTtJQUFBO0lBQUEsT0FRQSxvQkFBWTtNQUNWLElBQUksQ0FBQyxJQUFJLENBQUNULEtBQUssRUFBRTs7TUFFakI7TUFDQSxJQUFJbmYsRUFBRSxHQUFHLElBQUksQ0FBQzZLLEtBQUs7TUFDbkIsSUFBSWlWLFFBQVEsR0FBRzlmLEVBQUUsQ0FBQ29GLFVBQVU7TUFDNUIsSUFBSTJhLFdBQVcsR0FBRyxJQUFJLENBQUNWLE1BQU07TUFDN0IsSUFBSVMsUUFBUSxFQUFFO1FBQ1pBLFFBQVEsQ0FBQ2pCLFdBQVcsQ0FBQzdlLEVBQUUsQ0FBQztRQUN4QjtRQUNBLElBQUk4ZixRQUFRLEtBQUssSUFBSSxDQUFDN1osTUFBTSxFQUFFO1VBQzVCNlosUUFBUSxDQUFDMWEsVUFBVSxDQUFDeVosV0FBVyxDQUFDaUIsUUFBUSxDQUFDO1VBQ3pDQyxXQUFXLEdBQUcsSUFBSSxDQUFDOVosTUFBTTtRQUMzQjtNQUNGLENBQUMsTUFBTTtRQUNMLElBQUk7VUFDRmpHLEVBQUUsQ0FBQ3FhLE1BQU0sRUFBRTtRQUNiLENBQUMsQ0FBQyxPQUFPaGdCLENBQUMsRUFBRTtVQUNWeEUsUUFBSSxDQUFDcWhCLCtCQUFJLHlEQUFrRDdjLENBQUMsQ0FBQ3JHLE9BQU8sRUFBRztRQUN6RTtNQUNGO01BQ0EsSUFBSSxDQUFDNlcsS0FBSyxHQUFHLElBQUksQ0FBQ3NVLEtBQUssQ0FBQ0MsU0FBUyxDQUFDLElBQUksQ0FBQztNQUN2Q1csV0FBVyxDQUFDNWQsV0FBVyxDQUFDLElBQUksQ0FBQzBJLEtBQUssQ0FBQztNQUNuQyxJQUFJLElBQUksQ0FBQzRVLFNBQVMsRUFBRTtRQUNsQixJQUFJLENBQUNBLFNBQVMsQ0FBQ08sTUFBTSxFQUFFO01BQ3pCO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORTtJQUFBO0lBQUEsT0FPQSw4QkFBc0JDLFFBQVEsRUFBRTtNQUFBO01BQzlCLElBQU1DLFFBQVEsR0FBRyxJQUFJLENBQUNDLFdBQVcsRUFBRTtNQUNuQyxJQUFNQyxXQUFXLEdBQUcsT0FBT0YsUUFBUSxLQUFLLFdBQVc7TUFFbkRELFFBQVEsQ0FBQ0ksU0FBUyxHQUFHLFlBQU07UUFDekJ6cUIsU0FBSyxDQUFDc2hCLCtCQUFJLEVBQUUsOEJBQThCLENBQUM7UUFDM0MsSUFBSWdKLFFBQVEsRUFBRTtVQUNaQSxRQUFRLENBQUNoRCxNQUFNLENBQUMsSUFBSSxDQUFDO1FBQ3ZCO1FBQ0EsTUFBSSxDQUFDcEQsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ2lCLHFCQUFxQixFQUFFNWUsU0FBUyxFQUFFO1VBQ3RGeXJCLElBQUksRUFBRTdGLGFBQWEsQ0FBQ0UsU0FBUztVQUM3QlEsS0FBSyxFQUFFSixxQkFBcUIsQ0FBQ04sYUFBYSxDQUFDRSxTQUFTO1FBQ3RELENBQUMsQ0FBQyxDQUFDO1FBQ0gsTUFBSSxDQUFDYixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDYyxhQUFhLEVBQUV6ZSxTQUFTLEVBQUU7VUFDOUUwckIsTUFBTSxFQUFFTixRQUFRLENBQUNNO1FBQ25CLENBQUMsQ0FBQyxDQUFDO01BQ0wsQ0FBQztNQUNETixRQUFRLENBQUNPLGdCQUFnQixHQUFHLFVBQUM3bkIsS0FBSyxFQUFLO1FBQUU7UUFDdkMvQyxTQUFLLENBQUNzaEIsK0JBQUksRUFBRSxxQ0FBcUMsQ0FBQztRQUNsRCxJQUFJLENBQUM3TyxLQUFLLENBQUM0WCxRQUFRLENBQUNoRixRQUFRLENBQUMsSUFBSTRDLE1BQU0sQ0FBQzRDLFFBQVEsQ0FBQ1IsUUFBUSxDQUFDaEYsUUFBUSxDQUFDLEVBQUU7VUFDbkUsTUFBSSxDQUFDMEQsS0FBSyxHQUFHLElBQUk7UUFDbkI7UUFDQSxJQUFJeUIsV0FBVyxFQUFFO1VBQ2ZGLFFBQVEsQ0FBQ1EsbUJBQW1CLENBQUNULFFBQVEsQ0FBQ2hGLFFBQVEsQ0FBQztRQUNqRDtNQUNGLENBQUM7TUFDRGdGLFFBQVEsQ0FBQ1UsT0FBTyxHQUFHLFlBQU07UUFDdkIvcUIsU0FBSyxDQUFDc2hCLCtCQUFJLEVBQUUsNEJBQTRCLENBQUM7UUFDekMsSUFBSWtKLFdBQVcsRUFBRTtVQUNmRixRQUFRLENBQUNuRCxRQUFRLENBQUN0QyxhQUFhLENBQUNHLElBQUksQ0FBQztRQUN2QztRQUNBLE1BQUksQ0FBQ2QsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ2lCLHFCQUFxQixFQUFFNWUsU0FBUyxFQUFFO1VBQ3RGeXJCLElBQUksRUFBRTdGLGFBQWEsQ0FBQ0csSUFBSTtVQUN4Qk8sS0FBSyxFQUFFSixxQkFBcUIsQ0FBQ04sYUFBYSxDQUFDRyxJQUFJO1FBQ2pELENBQUMsQ0FBQyxDQUFDO01BQ0wsQ0FBQztNQUNEcUYsUUFBUSxDQUFDVyxZQUFZLEdBQUcsVUFBQ2pvQixLQUFLLEVBQUs7UUFBRTtRQUNuQyxJQUFJeW5CLFdBQVcsRUFBRTtVQUNmRixRQUFRLENBQUNqRCxXQUFXLENBQUNnRCxRQUFRLENBQUNZLFdBQVcsRUFBRXZELElBQUksQ0FBQ3FCLEtBQUssR0FBR3NCLFFBQVEsQ0FBQ2hGLFFBQVEsR0FBR3BtQixTQUFTLENBQUM7UUFDeEY7UUFDQSxNQUFJLENBQUNpbEIsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ2dCLG9CQUFvQixFQUFFM2UsU0FBUyxFQUFFO1VBQ3JGdkIsSUFBSSxFQUFFMnNCLFFBQVEsQ0FBQ1ksV0FBVztVQUMxQjVGLFFBQVEsRUFBRWdGLFFBQVEsQ0FBQ2hGO1FBQ3JCLENBQUMsQ0FBQyxDQUFDO01BQ0wsQ0FBQztNQUNEZ0YsUUFBUSxDQUFDYSxRQUFRLEdBQUcsVUFBQ25vQixLQUFLLEVBQUssQ0FBRTtRQUNyQztNQUFBLENBQ0s7TUFDRHNuQixRQUFRLENBQUNjLFNBQVMsR0FBRyxVQUFDcG9CLEtBQUssRUFBSyxDQUFFO1FBQ3RDO01BQUEsQ0FDSztNQUNEc25CLFFBQVEsQ0FBQ2UsTUFBTSxHQUFHLFlBQU07UUFDdEJwckIsU0FBSyxDQUFDc2hCLCtCQUFJLEVBQUUsMkJBQTJCLENBQUM7UUFDeEMsSUFBSWtKLFdBQVcsRUFBRTtVQUNmRixRQUFRLENBQUNuRCxRQUFRLENBQUN0QyxhQUFhLENBQUNJLE9BQU8sQ0FBQztRQUMxQztRQUNBLE1BQUksQ0FBQ2YsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ2lCLHFCQUFxQixFQUFFNWUsU0FBUyxFQUFFO1VBQ3RGeXJCLElBQUksRUFBRTdGLGFBQWEsQ0FBQ0ksT0FBTztVQUMzQk0sS0FBSyxFQUFFSixxQkFBcUIsQ0FBQ04sYUFBYSxDQUFDSSxPQUFPO1FBQ3BELENBQUMsQ0FBQyxDQUFDO01BQ0wsQ0FBQztNQUNEb0YsUUFBUSxDQUFDZ0IsT0FBTyxHQUFHLFlBQU07UUFDdkJyckIsU0FBSyxDQUFDc2hCLCtCQUFJLEVBQUUsNEJBQTRCLENBQUM7UUFDekMsSUFBSWtKLFdBQVcsRUFBRTtVQUNmRixRQUFRLENBQUNuRCxRQUFRLENBQUN0QyxhQUFhLENBQUNLLE1BQU0sQ0FBQztRQUN6QztRQUNBLE1BQUksQ0FBQ2hCLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUNpQixxQkFBcUIsRUFBRTVlLFNBQVMsRUFBRTtVQUN0RnlyQixJQUFJLEVBQUU3RixhQUFhLENBQUNLLE1BQU07VUFDMUJLLEtBQUssRUFBRUoscUJBQXFCLENBQUNOLGFBQWEsQ0FBQ0ssTUFBTTtRQUNuRCxDQUFDLENBQUMsQ0FBQztNQUNMLENBQUM7TUFDRG1GLFFBQVEsQ0FBQ2lCLGNBQWMsR0FBRyxVQUFDdm9CLEtBQUssRUFBSztRQUFFO1FBQ3JDLElBQUl5bkIsV0FBVyxJQUFJRixRQUFRLENBQUNpQixTQUFTLEVBQUUsS0FBSyxNQUFJLENBQUN0VyxLQUFLLENBQUMwVixNQUFNLEVBQUU7VUFDN0RMLFFBQVEsQ0FBQ3BDLFNBQVMsQ0FBQyxNQUFJLENBQUNqVCxLQUFLLENBQUMwVixNQUFNLENBQUM7UUFDdkM7UUFDQSxNQUFJLENBQUN6RyxPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDYyxhQUFhLEVBQUV6ZSxTQUFTLEVBQUU7VUFDOUUwckIsTUFBTSxFQUFFTixRQUFRLENBQUN6QixLQUFLLEdBQUcsQ0FBQyxHQUFHeUIsUUFBUSxDQUFDTTtRQUN4QyxDQUFDLENBQUMsQ0FBQztNQUNMLENBQUM7TUFDRDtNQUNBTixRQUFRLENBQUNtQixXQUFXLEdBQUcsWUFBTTtRQUFFeHJCLFNBQUssQ0FBQ3NoQiwrQkFBSSxFQUFFLGdDQUFnQyxDQUFDO01BQUMsQ0FBQztNQUM5RStJLFFBQVEsQ0FBQ29CLFNBQVMsR0FBRyxZQUFNO1FBQUV6ckIsU0FBSyxDQUFDc2hCLCtCQUFJLEVBQUUsOEJBQThCLENBQUM7TUFBQyxDQUFDO01BQzFFK0ksUUFBUSxDQUFDcUIsWUFBWSxHQUFHLFlBQU07UUFDNUIxckIsU0FBSyxDQUFDc2hCLCtCQUFJLEVBQUUsaUNBQWlDLENBQUM7UUFDOUMsTUFBSSxDQUFDNEMsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ2EsdUJBQXVCLEVBQUV4ZSxTQUFTLEVBQUU7VUFDeEYwUixLQUFLLEVBQUUsTUFBSSxDQUFDc0UsS0FBSyxDQUFDMFcsVUFBVTtVQUM1QnhhLE1BQU0sRUFBRSxNQUFJLENBQUM4RCxLQUFLLENBQUMyVztRQUNyQixDQUFDLENBQUMsQ0FBQztNQUNMLENBQUM7TUFDRHZCLFFBQVEsQ0FBQ3dCLFFBQVEsR0FBRyxZQUFNO1FBQ3hCN3JCLFNBQUssQ0FBQ3NoQiwrQkFBSSxFQUFFLDZCQUE2QixDQUFDO1FBQzFDLE1BQUksQ0FBQzRDLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUNhLHVCQUF1QixFQUFFeGUsU0FBUyxFQUFFO1VBQ3hGMFIsS0FBSyxFQUFFLE1BQUksQ0FBQ3NFLEtBQUssQ0FBQzBXLFVBQVU7VUFDNUJ4YSxNQUFNLEVBQUUsTUFBSSxDQUFDOEQsS0FBSyxDQUFDMlc7UUFDckIsQ0FBQyxDQUFDLENBQUM7TUFDTCxDQUFDO01BQ0R2QixRQUFRLENBQUN5QixnQkFBZ0IsR0FBRyxZQUFNO1FBQ2hDOXJCLFNBQUssQ0FBQ3NoQiwrQkFBSSxFQUFFLHFDQUFxQyxDQUFDO01BQ3BELENBQUM7TUFDRCtJLFFBQVEsQ0FBQzBCLFdBQVcsR0FBRyxZQUFNO1FBQUUvckIsU0FBSyxDQUFDc2hCLCtCQUFJLEVBQUUsa0NBQWtDLENBQUM7TUFBQyxDQUFDO01BQ2hGK0ksUUFBUSxDQUFDMkIsU0FBUyxHQUFHLFlBQU07UUFBRWhzQixTQUFLLENBQUNzaEIsK0JBQUksRUFBRSw4QkFBOEIsQ0FBQztNQUFDLENBQUM7TUFDMUUrSSxRQUFRLENBQUM0QixTQUFTLEdBQUcsWUFBTTtRQUFFanNCLFNBQUssQ0FBQ3NoQiwrQkFBSSxFQUFFLDhCQUE4QixDQUFDO01BQUMsQ0FBQztNQUMxRStJLFFBQVEsQ0FBQzZCLFNBQVMsR0FBRyxZQUFNO1FBQUVsc0IsU0FBSyxDQUFDc2hCLCtCQUFJLEVBQUUsOEJBQThCLENBQUM7TUFBQyxDQUFDO01BQzFFO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORTtJQUFBO0lBQUEsT0FPQSxpQ0FBeUJ3SCxZQUFZLEVBQUU7TUFDckMsSUFBSUEsWUFBWSxFQUFFO1FBQ2hCLElBQUksSUFBSSxDQUFDVyxNQUFNLEVBQUU7VUFDZixJQUFJLENBQUNBLE1BQU0sQ0FBQ2piLFNBQVMsQ0FBQ2dXLEdBQUcsQ0FBQyxxQ0FBcUMsQ0FBQztRQUNsRTtRQUNBLElBQUksQ0FBQ3ZQLEtBQUssQ0FBQ3pHLFNBQVMsQ0FBQ2dXLEdBQUcsQ0FBQyxxQ0FBcUMsQ0FBQztNQUNqRSxDQUFDLE1BQ0k7UUFDSCxJQUFJLElBQUksQ0FBQ2lGLE1BQU0sRUFBRTtVQUNmLElBQUksQ0FBQ0EsTUFBTSxDQUFDamIsU0FBUyxDQUFDaVcsTUFBTSxDQUFDLHFDQUFxQyxDQUFDO1FBQ3JFO1FBQ0EsSUFBSSxDQUFDeFAsS0FBSyxDQUFDekcsU0FBUyxDQUFDaVcsTUFBTSxDQUFDLHFDQUFxQyxDQUFDO01BQ3BFO01BQ0EsSUFBSSxDQUFDUCxPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDa0Isd0JBQXdCLEVBQUU3ZSxTQUFTLEVBQUU2cEIsWUFBWSxDQUFDLENBQUM7SUFDNUc7O0lBRUM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLG1CQUFXbm5CLE9BQU8sRUFBRTtNQUNsQjNCLFNBQUssQ0FBQ3NoQiwrQkFBSSxFQUFFLGFBQWEsQ0FBQztNQUMxQixJQUFNZ0ksbUJBQW1CLEdBQUcxWixPQUFXLENBQUMxQixtQkFBbUIsQ0FBQyxJQUFJLENBQUMrRyxLQUFLLEVBQUUsVUFBVSxDQUFDLElBQUlyRixPQUFXLENBQUN0QixlQUFlLENBQUMsSUFBSSxDQUFDMkcsS0FBSyxFQUFFLGVBQWUsQ0FBQztNQUMvSSxJQUFJcVUsbUJBQW1CLEVBQUU7UUFDdkIsSUFBSSxDQUFDRyxNQUFNLEdBQUcsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUN6VSxLQUFLLENBQUM7TUFDakQ7TUFDQSxJQUFNTyxRQUFRLEdBQUcsSUFBSTNVLGVBQWUsRUFBRTtNQUN0QyxJQUFNc3JCLGtCQUFrQixHQUFHeHFCLE9BQU8sQ0FBQzJvQixRQUFRO01BQzNDLElBQU04QixPQUFPLEdBQUd4YyxPQUFXLENBQUMxQixtQkFBbUIsQ0FBQyxJQUFJLENBQUMrRyxLQUFLLEVBQUUsT0FBTyxDQUFDO01BQ3BFLElBQUlrWCxrQkFBa0IsSUFBSTdDLG1CQUFtQixFQUFFO1FBQzdDLElBQUk2QyxrQkFBa0IsRUFBRTtVQUN0QixJQUFJLENBQUN0QyxTQUFTLEdBQUdsb0IsT0FBTyxDQUFDMm9CLFFBQVE7UUFDbkMsQ0FBQyxNQUNJO1VBQ0gsSUFBSSxDQUFDVCxTQUFTLEdBQUcsSUFBSVQsb0JBQW9CLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQ0ssTUFBTSxDQUFDO1FBQzlEO1FBQ0EsSUFBSSxDQUFDeFUsS0FBSyxDQUFDcVYsUUFBUSxHQUFHLEtBQUs7UUFDM0IsSUFBSSxDQUFDVCxTQUFTLENBQUN3QyxRQUFRLENBQUMsSUFBSSxDQUFDdEQsS0FBSyxDQUFDO1FBQ25DLElBQUksQ0FBQ2MsU0FBUyxDQUFDaEMsYUFBYSxDQUFDdUUsT0FBTyxDQUFDO01BQ3ZDO01BQ0EsSUFBSSxDQUFDRSxvQkFBb0IsQ0FBQyxJQUFJLENBQUN4QywyQkFBMkIsQ0FBQztNQUMzRHRVLFFBQVEsQ0FBQ25WLE9BQU8sRUFBRTtNQUNsQixPQUFPbVYsUUFBUSxDQUFDalYsT0FBTztJQUN6Qjs7SUFFQTtBQUNGO0FBQ0E7RUFGRTtJQUFBO0lBQUEsT0FHQSxtQkFBVztNQUNUUCxTQUFLLENBQUNzaEIsK0JBQUksRUFBRSxXQUFXLENBQUM7SUFDMUI7RUFBQztJQUFBO0lBQUEsT0FFRCwyQkFBeUM7TUFBQTtNQUFBLElBQXhCaUwsY0FBYyx1RUFBRyxLQUFLO01BQ3JDLElBQUksQ0FBQzFnQixJQUFJLEVBQUUsQ0FDUnpKLEtBQUssQ0FBQyxVQUFBcUMsQ0FBQyxFQUFJO1FBQ1YsSUFBSThuQixjQUFjLEVBQUU7VUFDbEIsTUFBSSxDQUFDekUsSUFBSSxFQUFFO1VBQ1gsTUFBSSxDQUFDamMsSUFBSSxFQUFFLENBQ1IzSixJQUFJLENBQUMsWUFBTTtZQUNWLE1BQUksQ0FBQ2dpQixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDb0IsbUJBQW1CLEVBQUUvZSxTQUFTLEVBQUU7Y0FBQzZPLE9BQU8sRUFBRSxNQUFJLENBQUNtSDtZQUFLLENBQUMsQ0FBQyxDQUFDO1VBQy9HLENBQUMsQ0FBQyxDQUNEN1MsS0FBSyxDQUFDLFVBQUFpRyxHQUFHLEVBQUk7WUFDWixNQUFJLENBQUM2YixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDbUIscUJBQXFCLEVBQUU5ZSxTQUFTLEVBQUU7Y0FDdEZpQixLQUFLLEVBQUdtSSxHQUFHLENBQUNqSyxPQUFPLEdBQUdpSyxHQUFHLENBQUNqSyxPQUFPLEdBQUdpSyxHQUFJO2NBQ3hDeUYsT0FBTyxFQUFFLE1BQUksQ0FBQ21IO1lBQ2hCLENBQUMsQ0FBQyxDQUFDO1VBQ0wsQ0FBQyxDQUFDO1FBQ04sQ0FBQyxNQUFNO1VBQ0wsTUFBSSxDQUFDaVAsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ21CLHFCQUFxQixFQUFFOWUsU0FBUyxFQUFFO1lBQ3RGaUIsS0FBSyxFQUFHdUUsQ0FBQyxDQUFDckcsT0FBTyxHQUFHcUcsQ0FBQyxDQUFDckcsT0FBTyxHQUFHcUcsQ0FBRTtZQUNsQ3FKLE9BQU8sRUFBRSxNQUFJLENBQUNtSDtVQUNoQixDQUFDLENBQUMsQ0FBQztRQUNMO01BQ0YsQ0FBQyxDQUFDO0lBQ047RUFBQztJQUFBO0lBQUEsT0FFRCxnQkFBUTtNQUNOalYsU0FBSyxDQUFDc2hCLCtCQUFJLEVBQUUsNEJBQTRCLENBQUM7TUFDekMsSUFBTTlMLFFBQVEsR0FBRyxJQUFJM1UsZUFBZSxFQUFFO01BQ3RDLElBQUk7UUFDRixJQUFJK0ssWUFBWSxHQUFHLElBQUksQ0FBQ3FKLEtBQUssQ0FBQ3BKLElBQUksRUFBRTtRQUNwQyxJQUFJRCxZQUFZLEVBQUU7VUFDaEJBLFlBQVksQ0FDVDFKLElBQUksQ0FBQyxZQUFNO1lBQ1ZsQyxTQUFLLENBQUNzaEIsK0JBQUksRUFBRSxvQ0FBb0MsQ0FBQztZQUNqRDlMLFFBQVEsQ0FBQ25WLE9BQU8sRUFBRTtVQUNwQixDQUFDLENBQUMsQ0FDRCtCLEtBQUssQ0FBQ29ULFFBQVEsQ0FBQ2xWLE1BQU0sQ0FBQztRQUMzQixDQUFDLE1BQU07VUFDTE4sU0FBSyxDQUFDc2hCLCtCQUFJLEVBQUUsb0NBQW9DLENBQUM7VUFDakQ5TCxRQUFRLENBQUNuVixPQUFPLEVBQUU7UUFDcEI7TUFDRixDQUFDLENBQUMsT0FBT29FLENBQUMsRUFBRTtRQUNWdkUsU0FBSyxDQUFDb2hCLCtCQUFJLEVBQUUsdUNBQXVDLEdBQUc3YyxDQUFDLENBQUNyRyxPQUFPLENBQUM7UUFDaEVvWCxRQUFRLENBQUNsVixNQUFNLENBQUNtRSxDQUFDLENBQUM7TUFDcEI7TUFDQSxPQUFPK1EsUUFBUSxDQUFDalYsT0FBTztJQUN6QjtFQUFDO0lBQUE7SUFBQSxPQUVELGlCQUFTO01BQ1BQLFNBQUssQ0FBQ3NoQiwrQkFBSSxFQUFFLDZCQUE2QixDQUFDO01BQzFDLElBQUk7UUFDRixJQUFJLENBQUNyTSxLQUFLLENBQUNsSixLQUFLLEVBQUU7TUFDcEIsQ0FBQyxDQUNELE9BQU90SCxDQUFDLEVBQUU7UUFDUnhFLFFBQUksQ0FBQ3FoQiwrQkFBSSxFQUFFLCtDQUErQyxHQUFHN2MsQ0FBQyxDQUFDckcsT0FBTyxDQUFDO01BQ3pFO0lBQ0Y7RUFBQztJQUFBO0lBQUEsT0FFRCxrQkFBVTtNQUNSNEIsU0FBSyxDQUFDc2hCLCtCQUFJLEVBQUUsOEJBQThCLENBQUM7TUFDM0MsSUFBSTtRQUNGLElBQUkxVixZQUFZLEdBQUcsSUFBSSxDQUFDcUosS0FBSyxDQUFDcEosSUFBSSxFQUFFO1FBQ3BDLElBQUlELFlBQVksRUFBRTtVQUNoQkEsWUFBWSxDQUFDMUosSUFBSSxDQUFDO1lBQUEsT0FBTWxDLFNBQUssQ0FBQ3NoQiwrQkFBSSxFQUFFLG9DQUFvQyxDQUFDO1VBQUEsRUFBQyxDQUM3RGxmLEtBQUssQ0FBQyxVQUFDaUcsR0FBRztZQUFBLE9BQUtwSSxRQUFJLENBQUNxaEIsK0JBQUksRUFBRSw0Q0FBNEMsSUFBSWpaLEdBQUcsQ0FBQ2pLLE9BQU8sR0FBR2lLLEdBQUcsQ0FBQ2pLLE9BQU8sR0FBR2lLLEdBQUcsQ0FBQyxDQUFDO1VBQUEsRUFBQztRQUMzSDtNQUNGLENBQUMsQ0FDRCxPQUFPNUQsQ0FBQyxFQUFFO1FBQ1J4RSxRQUFJLENBQUNxaEIsK0JBQUksRUFBRSxnREFBZ0QsR0FBRzdjLENBQUMsQ0FBQ3JHLE9BQU8sQ0FBQztNQUMxRTtJQUNGO0VBQUM7SUFBQTtJQUFBLE9BRUQsZ0JBQVE7TUFDTjRCLFNBQUssQ0FBQ3NoQiwrQkFBSSxFQUFFLDRCQUE0QixDQUFDO01BQ3pDLElBQUk7UUFDRixJQUFJLENBQUNyTSxLQUFLLENBQUN1WCxJQUFJLEVBQUU7TUFDbkIsQ0FBQyxDQUNELE9BQU8vbkIsQ0FBQyxFQUFFO1FBQ1I7TUFBQTtJQUVKO0VBQUM7SUFBQTtJQUFBLE9BRUQsZ0JBQVE7TUFDTixJQUFJLENBQUN3USxLQUFLLENBQUMyVCxLQUFLLEdBQUcsSUFBSTtNQUN2QixJQUFNMEIsUUFBUSxHQUFHLElBQUksQ0FBQ0MsV0FBVyxFQUFFO01BQ25DLElBQUlELFFBQVEsRUFBRTtRQUNaQSxRQUFRLENBQUN6QyxhQUFhLENBQUMsSUFBSSxDQUFDO01BQzlCO0lBQ0Y7RUFBQztJQUFBO0lBQUEsT0FFRCxrQkFBVTtNQUNSLElBQUksQ0FBQzVTLEtBQUssQ0FBQzJULEtBQUssR0FBRyxLQUFLO01BQ3hCLElBQU0wQixRQUFRLEdBQUcsSUFBSSxDQUFDQyxXQUFXLEVBQUU7TUFDbkMsSUFBSUQsUUFBUSxFQUFFO1FBQ1pBLFFBQVEsQ0FBQ3pDLGFBQWEsQ0FBQyxLQUFLLENBQUM7TUFDL0I7SUFDRjtFQUFDO0lBQUE7SUFBQSxPQUVELG1CQUFXcmxCLEtBQUssRUFBRTtNQUNoQixJQUFJLENBQUNvbEIsTUFBTSxFQUFFO01BQ2IsSUFBSSxDQUFDM1MsS0FBSyxDQUFDMFYsTUFBTSxHQUFHbm9CLEtBQUs7SUFDM0I7RUFBQztJQUFBO0lBQUEsT0FFRCxnQkFBUThoQixVQUFVLEVBQXdCO01BQUEsSUFBdEJlLFFBQVEsdUVBQUdwbUIsU0FBUztNQUN0QyxJQUFJLENBQUNnVyxLQUFLLENBQUNnVyxXQUFXLEdBQUc1RixRQUFRLEdBQUdmLFVBQVUsR0FBR2UsUUFBUSxHQUFHZixVQUFVO0lBQ3hFO0VBQUM7SUFBQTtJQUFBLE9BRUQsNEJBQW9CO01BQ2xCLElBQUk7UUFDRixJQUFJLElBQUksQ0FBQ21GLE1BQU0sRUFBRTtVQUNmN1osT0FBVyxDQUFDL0IsZ0JBQWdCLENBQUMsSUFBSSxDQUFDNGIsTUFBTSxDQUFDO1FBQzNDO01BQ0YsQ0FBQyxDQUNELE9BQU9obEIsQ0FBQyxFQUFFO1FBQ1IsTUFBTUEsQ0FBQztRQUNQO01BQ0Y7SUFDRjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUhFO0lBQUE7SUFBQSxPQUlBLHFCQUFhO01BQ1gsSUFBSTtRQUNGLElBQUksQ0FBQytuQixJQUFJLEVBQUU7UUFDWCxJQUFJLENBQUN2WCxLQUFLLENBQUM4VixPQUFPLENBQUNuZCxJQUFJLENBQUMsSUFBSSxDQUFDcUgsS0FBSyxDQUFDO01BQ3JDLENBQUMsQ0FDRCxPQUFPeFEsQ0FBQyxFQUFFO1FBQ1I7TUFBQTtJQUVKOztJQUVBO0FBQ0Y7QUFDQTtFQUZFO0lBQUE7SUFBQSxPQUdBLHNCQUFjO01BQ1osSUFBSSxDQUFDZ29CLFFBQVEsRUFBRTtJQUNqQjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEsaUNBQXlCM25CLFdBQVcsRUFBRTtNQUNwQyxJQUFJLElBQUksQ0FBQytrQixTQUFTLElBQUsva0IsV0FBVyxHQUFHLEdBQUcsS0FBSyxDQUFFLEVBQUU7UUFDL0MsSUFBSSxJQUFJLENBQUMya0IsTUFBTSxFQUFFO1VBQ2YsSUFBSSxDQUFDQSxNQUFNLENBQUNqYixTQUFTLENBQUNnVyxHQUFHLENBQUMsMEJBQTBCLENBQUM7UUFDdkQ7UUFDQSxJQUFJLENBQUN2UCxLQUFLLENBQUN6RyxTQUFTLENBQUNpVyxNQUFNLENBQUMsMEJBQTBCLENBQUM7TUFDekQ7SUFDRjs7SUFFQTtBQUNGO0FBQ0E7SUFDRTtFQUFBO0lBQUE7SUFBQSxPQUNBLHdDQUFnQ3ZYLE9BQU8sRUFBRSxDQUFDOztJQUUxQztFQUFBO0lBQUE7SUFBQSxPQUNBLDJDQUFtQ0EsT0FBTyxFQUFFLENBQUM7O0lBRTdDO0VBQUE7SUFBQTtJQUFBLE9BQ0EsNEJBQW9CdFAsSUFBSSxFQUFFOHVCLFFBQVEsRUFBRXR1QixPQUFPLEVBQUUsQ0FBQzs7SUFFOUM7RUFBQTtJQUFBO0lBQUEsT0FDQSxvQ0FBNEJSLElBQUksRUFBRTBFLEdBQUcsRUFBRUUsS0FBSyxFQUFFLENBQUM7O0lBRS9DO0VBQUE7SUFBQTtJQUFBLE9BQ0EsK0JBQXVCK2QsZ0JBQWdCLEVBQUUsQ0FBQzs7SUFFMUM7RUFBQTtJQUFBO0lBQUEsT0FDQSwrQkFBdUJBLGdCQUFnQixFQUFFLENBQUM7O0lBRTFDO0VBQUE7SUFBQTtJQUFBLE9BQ0EsMkJBQW1CQSxnQkFBZ0IsRUFBRSxDQUFDOztJQUd0QztBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsdUJBQWU7TUFDYixPQUFPLElBQUksQ0FBQ3NKLFNBQVM7SUFDdkI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLG1CQUFXO01BQ1QsT0FBTyxJQUFJLENBQUNGLFVBQVU7SUFDeEI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxLQUtBLGVBQWE7TUFDWCxPQUFPLElBQUksQ0FBQ0MsTUFBTTtJQUNwQjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBLE9BSkU7SUFBQSxLQUtBLGFBQVdwbkIsS0FBSyxFQUFFO01BQ2hCLElBQUksQ0FBQ29uQixNQUFNLEdBQUdwbkIsS0FBSztNQUNuQixJQUFJLElBQUksQ0FBQ3FuQixTQUFTLEVBQUU7UUFDbEIsSUFBSSxDQUFDQSxTQUFTLENBQUN3QyxRQUFRLENBQUM3cEIsS0FBSyxDQUFDO01BQ2hDO0lBQ0Y7RUFBQztFQUFBO0FBQUEsRUF2ZDRCMG1CLGtCQUFrQjtBQTJkbENHLDBHQUFnQixFOztBQzllbkI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFNEI7QUFDNkI7QUFDRTtBQUt0RDtBQUNnQztBQUNOO0FBRTNDLElBQU0vSCx3Q0FBSSxHQUFHLDBCQUEwQjtBQUN2QyxJQUFNcUwsTUFBTSxHQUFHLENBQUM7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBLElBUU1DLDREQUF3QjtFQUFBO0VBQUE7RUFFNUIsa0NBQWEzWCxLQUFLLEVBQUU1VixJQUFJLEVBQUU7SUFBQTtJQUFBO0lBQ3hCO0lBQ0EsTUFBSzRWLEtBQUssR0FBR0EsS0FBSztJQUNsQixJQUFNcVUsbUJBQW1CLEdBQUcsSUFBSSxFQUFDO0lBQ2pDLElBQUlBLG1CQUFtQixFQUFFO01BQ3ZCLE1BQUtDLEtBQUssR0FBRyxNQUFLdFUsS0FBSyxDQUFDdVUsU0FBUyxDQUFDLElBQUksQ0FBQztNQUN2QyxNQUFLblosTUFBTSxHQUFHLE1BQUs0RSxLQUFLLENBQUN6RixVQUFVO01BQ25DLE1BQUtpYSxNQUFNLEdBQUcsTUFBS0MsZ0JBQWdCLENBQUMsTUFBS3pVLEtBQUssQ0FBQztJQUNqRDtJQUNBLE1BQUswVSxVQUFVLEdBQUd0cUIsSUFBSTtJQUN0QixNQUFLdXFCLE1BQU0sR0FBRyxLQUFLO0lBQ25CLE1BQUtpRCxXQUFXLEdBQUcsS0FBSyxFQUFDO0lBQ3pCLE1BQUtDLG9CQUFvQixHQUFHLEtBQUssRUFBQztJQUNsQyxNQUFLQyxjQUFjLEdBQUcsS0FBSyxFQUFDO0lBQzVCLE1BQUtDLGVBQWUsR0FBRyxLQUFLLEVBQUM7SUFDN0IsTUFBS0MsbUJBQW1CLEdBQUcsQ0FBQztJQUM1QixNQUFLQyxtQkFBbUIsR0FBRyxDQUFDLEVBQUM7SUFDN0IsTUFBS3JELFNBQVMsR0FBRzVxQixTQUFTO0lBQzFCLE1BQUtrdUIsZUFBZSxHQUFHbHVCLFNBQVM7SUFDaEMsTUFBSzZxQiwyQkFBMkIsR0FBRyxNQUFLN1UsS0FBSztJQUM3Q3JGLE9BQVcsQ0FBQzVCLHVCQUF1QixDQUFDLE1BQUsrYix1QkFBdUIsQ0FBQzFILElBQUksQ0FBQyxpRUFBSyxDQUFDOztJQUU1RTtJQUNBO0lBQ0EsTUFBSytLLEdBQUcsR0FBR251QixTQUFTO0lBQ3BCO0lBQ0EsTUFBS291QixVQUFVLEdBQUdwdUIsU0FBUztJQUFBO0VBQzdCOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQRTtJQUFBO0lBQUEsT0FRQSwwQkFBa0JnVyxLQUFLLEVBQUU7TUFDdkIsSUFBSUEsS0FBSyxDQUFDekYsVUFBVSxDQUFDaEIsU0FBUyxDQUFDQyxRQUFRLENBQUMseUJBQXlCLENBQUMsRUFBRTtRQUNsRSxPQUFPd0csS0FBSyxDQUFDekYsVUFBVTtNQUN6QixDQUFDLE1BQ0k7UUFDSCxJQUFNYSxNQUFNLEdBQUc0RSxLQUFLLENBQUN6RixVQUFVO1FBQy9CLElBQU13YSxHQUFHLEdBQUdwYSxPQUFXLENBQUN2RixhQUFhLENBQUMsS0FBSyxDQUFDO1FBQzVDMmYsR0FBRyxDQUFDeGIsU0FBUyxDQUFDZ1csR0FBRyxDQUFDLHlCQUF5QixDQUFDO1FBQzVDblUsTUFBTSxDQUFDNFosWUFBWSxDQUFDRCxHQUFHLEVBQUUvVSxLQUFLLENBQUM7UUFDL0I1RSxNQUFNLENBQUM0WSxXQUFXLENBQUNoVSxLQUFLLENBQUM7UUFDekIrVSxHQUFHLENBQUN6ZCxXQUFXLENBQUMwSSxLQUFLLENBQUM7UUFDdEIsT0FBTytVLEdBQUc7TUFDWjtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQRTtJQUFBO0lBQUEsT0FRQSxrQ0FBMEJQLE1BQU0sRUFBRXhVLEtBQUssRUFBRTtNQUN2QyxJQUFNaEssRUFBRSxHQUFHLGlCQUFpQjtNQUM1QixJQUFJb2lCLFVBQVUsR0FBR25rQixRQUFRLENBQUNva0IsYUFBYSxZQUFLcmlCLEVBQUUsRUFBRztNQUNqRCxJQUFJLENBQUNvaUIsVUFBVSxFQUFFO1FBQ2ZBLFVBQVUsR0FBR25rQixRQUFRLENBQUNtQixhQUFhLENBQUMsT0FBTyxDQUFDO1FBQzVDZ2pCLFVBQVUsQ0FBQ3BpQixFQUFFLEdBQUcsaUJBQWlCO1FBQ2pDb2lCLFVBQVUsQ0FBQ0UsV0FBVyxHQUFHLGFBQWE7UUFDdENGLFVBQVUsQ0FBQzNjLEtBQUssQ0FBQ0MsS0FBSyxHQUFHLE1BQU0sRUFBQztRQUNoQzBjLFVBQVUsQ0FBQzNjLEtBQUssQ0FBQ1MsTUFBTSxHQUFHLE1BQU0sRUFBQztRQUNqQ2tjLFVBQVUsQ0FBQzNjLEtBQUssQ0FBQ0ssUUFBUSxHQUFHLFVBQVU7UUFDdENzYyxVQUFVLENBQUMzYyxLQUFLLENBQUM4YyxPQUFPLEdBQUcsTUFBTTtRQUNqQy9ELE1BQU0sQ0FBQ1EsWUFBWSxDQUFDb0QsVUFBVSxFQUFFcFksS0FBSyxDQUFDO1FBQ3RDO1FBQ047UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO01BQ0k7O01BQ0EsT0FBT29ZLFVBQVU7SUFDbkI7RUFBQztJQUFBO0lBQUEsT0FFRCw4QkFBc0JJLElBQUksRUFBRUMsUUFBUSxFQUFFelksS0FBSyxFQUFFd1UsTUFBTSxFQUFFO01BQ25ELElBQUksSUFBSSxDQUFDcUQsb0JBQW9CLEtBQUtXLElBQUksRUFBRTtRQUN0QztNQUNGO01BQ0EsSUFBSSxDQUFDWCxvQkFBb0IsR0FBR1csSUFBSTtNQUNoQyxJQUFNckIsT0FBTyxHQUFHcUIsSUFBSSxHQUFHeFksS0FBSyxDQUFDMlQsS0FBSyxHQUFHOEUsUUFBUSxDQUFDOUUsS0FBSztNQUNuRCxJQUFJNkUsSUFBSSxFQUFFO1FBQ1JDLFFBQVEsQ0FBQy9DLE1BQU0sR0FBRzFWLEtBQUssQ0FBQzBWLE1BQU07UUFDOUIrQyxRQUFRLENBQUM5RSxLQUFLLEdBQUd3RCxPQUFPO1FBQ3hCblgsS0FBSyxDQUFDMlQsS0FBSyxHQUFHLElBQUk7UUFDbEI4RSxRQUFRLENBQUNoZCxLQUFLLENBQUM4YyxPQUFPLEdBQUcsY0FBYztRQUN2Q3ZZLEtBQUssQ0FBQ3ZFLEtBQUssQ0FBQzhjLE9BQU8sR0FBRyxNQUFNO1FBQzVCL0QsTUFBTSxDQUFDL1ksS0FBSyxDQUFDSyxRQUFRLEdBQUcsVUFBVTtNQUNwQyxDQUFDLE1BQU07UUFDTGtFLEtBQUssQ0FBQzBWLE1BQU0sR0FBRytDLFFBQVEsQ0FBQy9DLE1BQU07UUFDOUIrQyxRQUFRLENBQUM5RSxLQUFLLEdBQUcsSUFBSTtRQUNyQjNULEtBQUssQ0FBQzJULEtBQUssR0FBR3dELE9BQU87UUFDckJuWCxLQUFLLENBQUN2RSxLQUFLLENBQUM4YyxPQUFPLEdBQUcsY0FBYztRQUNwQyxJQUFJO1VBQ0YsSUFBSSxDQUFDRSxRQUFRLENBQUNDLE1BQU0sRUFBRTtZQUNwQixJQUFJLENBQUM1aEIsS0FBSyxDQUFDLElBQUksQ0FBQztZQUNoQixJQUFJLENBQUNGLElBQUksRUFBRTtVQUNiLENBQUMsTUFBTTtZQUNMLElBQUksQ0FBQ0UsS0FBSyxDQUFDLEtBQUssQ0FBQztVQUNuQjtRQUNGLENBQUMsQ0FBQyxPQUFPdEgsQ0FBQyxFQUFFO1VBQ1Z4RSxRQUFJLHFDQUE4QndFLENBQUMsQ0FBQ3JHLE9BQU8sT0FBSTtRQUNqRDtRQUNBc3ZCLFFBQVEsQ0FBQ2hkLEtBQUssQ0FBQzhjLE9BQU8sR0FBRyxNQUFNO01BQ2pDO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLG9CQUFZO01BQ1YsSUFBSSxDQUFDLElBQUksQ0FBQ2pFLEtBQUssRUFBRTs7TUFFakI7TUFDQSxJQUFJbmYsRUFBRSxHQUFHLElBQUksQ0FBQzZLLEtBQUs7TUFDbkIsSUFBSWlWLFFBQVEsR0FBRzlmLEVBQUUsQ0FBQ29GLFVBQVU7TUFDNUIsSUFBSTJhLFdBQVcsR0FBRyxJQUFJLENBQUNWLE1BQU07TUFDN0IsSUFBSSxDQUFDbUUsdUJBQXVCLENBQUN4akIsRUFBRSxDQUFDO01BQ2hDO01BQ0EsSUFBSSxJQUFJLENBQUNnakIsR0FBRyxFQUFFO1FBQ1osSUFBSSxDQUFDQSxHQUFHLENBQUNTLFdBQVcsRUFBRTtRQUN0QixJQUFJLENBQUNULEdBQUcsR0FBR251QixTQUFTO01BQ3RCO01BQ0EsSUFBSSxJQUFJLENBQUNvdUIsVUFBVSxFQUFFO1FBQ25CLElBQUksQ0FBQ1MsdUJBQXVCLENBQUMsSUFBSSxDQUFDVCxVQUFVLENBQUM7UUFDN0MsSUFBSSxJQUFJLENBQUNBLFVBQVUsQ0FBQzdkLFVBQVUsRUFBRTtVQUM5QixJQUFJLENBQUM2ZCxVQUFVLENBQUM3ZCxVQUFVLENBQUN5WixXQUFXLENBQUMsSUFBSSxDQUFDb0UsVUFBVSxDQUFDO1FBQ3pEO1FBQ0EsSUFBSSxDQUFDQSxVQUFVLEdBQUdwdUIsU0FBUztNQUM3QjtNQUNBLElBQUksSUFBSSxDQUFDNHFCLFNBQVMsRUFBRTtRQUNsQixJQUFJLENBQUNBLFNBQVMsQ0FBQ08sTUFBTSxFQUFFO1FBQ3ZCLElBQUksQ0FBQ1AsU0FBUyxHQUFHNXFCLFNBQVM7TUFDNUI7TUFDQSxJQUFJaXJCLFFBQVEsRUFBRTtRQUNaQSxRQUFRLENBQUNqQixXQUFXLENBQUM3ZSxFQUFFLENBQUM7UUFDeEI7UUFDQSxJQUFJOGYsUUFBUSxLQUFLLElBQUksQ0FBQzdaLE1BQU0sRUFBRTtVQUM1QjZaLFFBQVEsQ0FBQzFhLFVBQVUsQ0FBQ3laLFdBQVcsQ0FBQ2lCLFFBQVEsQ0FBQztVQUN6Q0MsV0FBVyxHQUFHLElBQUksQ0FBQzlaLE1BQU07UUFDM0I7TUFDRixDQUFDLE1BQU07UUFDTCxJQUFJO1VBQ0ZqRyxFQUFFLENBQUNxYSxNQUFNLEVBQUU7UUFDYixDQUFDLENBQUMsT0FBT2hnQixDQUFDLEVBQUU7VUFDVnhFLFFBQUksQ0FBQ3FoQix3Q0FBSSx5REFBa0Q3YyxDQUFDLENBQUNyRyxPQUFPLEVBQUc7UUFDekU7TUFDRjtNQUNBLElBQUksQ0FBQzZXLEtBQUssR0FBRyxJQUFJLENBQUNzVSxLQUFLLENBQUNDLFNBQVMsQ0FBQyxJQUFJLENBQUM7TUFDdkNXLFdBQVcsQ0FBQzVkLFdBQVcsQ0FBQyxJQUFJLENBQUMwSSxLQUFLLENBQUM7TUFDbkMsSUFBSSxJQUFJLENBQUNrWSxlQUFlLEVBQUU7UUFDeEIsSUFBSSxDQUFDQSxlQUFlLENBQUNZLFNBQVMsRUFBRTtRQUNoQyxJQUFJLENBQUNaLGVBQWUsR0FBR2x1QixTQUFTO01BQ2xDO01BQ0EsSUFBSSxDQUFDMnFCLE1BQU0sR0FBRyxLQUFLO01BQ25CLElBQUksQ0FBQ2lELFdBQVcsR0FBRyxLQUFLO01BQ3hCLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUcsS0FBSztNQUNqQyxJQUFJLENBQUNDLGNBQWMsR0FBRyxLQUFLO01BQzNCLElBQUksQ0FBQ0MsZUFBZSxHQUFHLEtBQUs7TUFDNUIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRyxDQUFDO0lBQzlCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0EsOEJBQXNCNUMsUUFBUSxFQUFFO01BQUE7TUFDOUIsSUFBTUMsUUFBUSxHQUFHLElBQUksQ0FBQ0MsV0FBVyxFQUFFO01BQ25DRixRQUFRLENBQUNJLFNBQVMsR0FBRyxZQUFNO1FBQ3pCenFCLFNBQUssQ0FBQ3NoQix3Q0FBSSxFQUFFLDhCQUE4QixDQUFDO1FBQzNDLElBQUlnSixRQUFRLEVBQUU7VUFDWkEsUUFBUSxDQUFDaEQsTUFBTSxDQUFDLElBQUksQ0FBQztRQUN2QjtRQUNBLE1BQUksQ0FBQ3BELE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUNpQixxQkFBcUIsRUFBRTVlLFNBQVMsRUFBRTtVQUN0RnlyQixJQUFJLEVBQUU3RixhQUFhLENBQUNFLFNBQVM7VUFDN0JRLEtBQUssRUFBRUoscUJBQXFCLENBQUNOLGFBQWEsQ0FBQ0UsU0FBUztRQUN0RCxDQUFDLENBQUMsQ0FBQztRQUNILE1BQUksQ0FBQ2IsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ2MsYUFBYSxFQUFFemUsU0FBUyxFQUFFO1VBQzlFMHJCLE1BQU0sRUFBRU4sUUFBUSxDQUFDTTtRQUNuQixDQUFDLENBQUMsQ0FBQztNQUNMLENBQUM7TUFFRE4sUUFBUSxDQUFDVSxPQUFPLEdBQUc7UUFBQSxPQUFNLE1BQUksQ0FBQ2lELFdBQVcsQ0FBQzNMLElBQUksQ0FBQyxNQUFJLENBQUM7TUFBQTtNQUNwRGdJLFFBQVEsQ0FBQ08sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDcUQsb0JBQW9CLENBQUM1TCxJQUFJLENBQUMsSUFBSSxDQUFDO01BQ2hFZ0ksUUFBUSxDQUFDVyxZQUFZLEdBQUcsSUFBSSxDQUFDa0QsZ0JBQWdCLENBQUM3TCxJQUFJLENBQUMsSUFBSSxDQUFDO01BQ3hEZ0ksUUFBUSxDQUFDZSxNQUFNLEdBQUcsSUFBSSxDQUFDK0MsVUFBVSxDQUFDOUwsSUFBSSxDQUFDLElBQUksQ0FBQztNQUM1Q2dJLFFBQVEsQ0FBQ2dCLE9BQU8sR0FBRyxJQUFJLENBQUMrQyxXQUFXLENBQUMvTCxJQUFJLENBQUMsSUFBSSxDQUFDO01BRTlDZ0ksUUFBUSxDQUFDaUIsY0FBYyxHQUFHLFVBQUN2b0IsS0FBSyxFQUFLO1FBQUU7UUFDckMsSUFBSXVuQixRQUFRLENBQUNpQixTQUFTLEVBQUUsS0FBSyxNQUFJLENBQUN0VyxLQUFLLENBQUMwVixNQUFNLEVBQUU7VUFDOUNMLFFBQVEsQ0FBQ3BDLFNBQVMsQ0FBQyxNQUFJLENBQUNqVCxLQUFLLENBQUMwVixNQUFNLENBQUM7UUFDdkM7UUFDQSxNQUFJLENBQUN6RyxPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDYyxhQUFhLEVBQUV6ZSxTQUFTLEVBQUU7VUFDOUUwckIsTUFBTSxFQUFFTixRQUFRLENBQUN6QixLQUFLLEdBQUcsQ0FBQyxHQUFHeUIsUUFBUSxDQUFDTTtRQUN4QyxDQUFDLENBQUMsQ0FBQztNQUNMLENBQUM7TUFDRDtNQUNBTixRQUFRLENBQUNtQixXQUFXLEdBQUcsWUFBTTtRQUFFeHJCLFNBQUssQ0FBQ3NoQix3Q0FBSSxFQUFFLGdDQUFnQyxDQUFDO01BQUMsQ0FBQztNQUM5RStJLFFBQVEsQ0FBQ29CLFNBQVMsR0FBRyxZQUFNO1FBQUV6ckIsU0FBSyxDQUFDc2hCLHdDQUFJLEVBQUUsOEJBQThCLENBQUM7TUFBQyxDQUFDO01BQzFFK0ksUUFBUSxDQUFDcUIsWUFBWSxHQUFHLFlBQU07UUFDNUIxckIsU0FBSyxDQUFDc2hCLHdDQUFJLEVBQUUsaUNBQWlDLENBQUM7UUFDOUMsTUFBSSxDQUFDNEMsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ2EsdUJBQXVCLEVBQUV4ZSxTQUFTLEVBQUU7VUFDeEYwUixLQUFLLEVBQUUsTUFBSSxDQUFDc0UsS0FBSyxDQUFDMFcsVUFBVTtVQUM1QnhhLE1BQU0sRUFBRSxNQUFJLENBQUM4RCxLQUFLLENBQUMyVztRQUNyQixDQUFDLENBQUMsQ0FBQztNQUNMLENBQUM7TUFDRHZCLFFBQVEsQ0FBQ3dCLFFBQVEsR0FBRyxZQUFNO1FBQ3hCN3JCLFNBQUssQ0FBQ3NoQix3Q0FBSSxFQUFFLDZCQUE2QixDQUFDO1FBQzFDLE1BQUksQ0FBQzRDLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUNhLHVCQUF1QixFQUFFeGUsU0FBUyxFQUFFO1VBQ3hGMFIsS0FBSyxFQUFFLE1BQUksQ0FBQ3NFLEtBQUssQ0FBQzBXLFVBQVU7VUFDNUJ4YSxNQUFNLEVBQUUsTUFBSSxDQUFDOEQsS0FBSyxDQUFDMlc7UUFDckIsQ0FBQyxDQUFDLENBQUM7TUFDTCxDQUFDO01BQ0R2QixRQUFRLENBQUN5QixnQkFBZ0IsR0FBRyxZQUFNO1FBQ2hDOXJCLFNBQUssQ0FBQ3NoQix3Q0FBSSxFQUFFLHFDQUFxQyxDQUFDO01BQ3BELENBQUM7TUFDRCtJLFFBQVEsQ0FBQzBCLFdBQVcsR0FBRyxZQUFNO1FBQUUvckIsU0FBSyxDQUFDc2hCLHdDQUFJLEVBQUUsa0NBQWtDLENBQUM7TUFBQyxDQUFDO01BQ2hGK0ksUUFBUSxDQUFDMkIsU0FBUyxHQUFHLFlBQU07UUFBRWhzQixTQUFLLENBQUNzaEIsd0NBQUksRUFBRSw4QkFBOEIsQ0FBQztNQUFDLENBQUM7TUFDMUUrSSxRQUFRLENBQUM0QixTQUFTLEdBQUcsWUFBTTtRQUFFanNCLFNBQUssQ0FBQ3NoQix3Q0FBSSxFQUFFLDhCQUE4QixDQUFDO01BQUMsQ0FBQztNQUMxRStJLFFBQVEsQ0FBQzZCLFNBQVMsR0FBRyxZQUFNO1FBQUVsc0IsU0FBSyxDQUFDc2hCLHdDQUFJLEVBQUUsOEJBQThCLENBQUM7TUFBQyxDQUFDO01BQzFFO0lBQ0Y7RUFBQztJQUFBO0lBQUEsT0FFRCxpQ0FBeUIrSSxRQUFRLEVBQUU7TUFDakNBLFFBQVEsQ0FBQ0ksU0FBUyxHQUFHeHJCLFNBQVM7TUFDOUJvckIsUUFBUSxDQUFDVSxPQUFPLEdBQUc5ckIsU0FBUztNQUM1Qm9yQixRQUFRLENBQUNPLGdCQUFnQixHQUFHM3JCLFNBQVM7TUFDckNvckIsUUFBUSxDQUFDVyxZQUFZLEdBQUcvckIsU0FBUztNQUNqQ29yQixRQUFRLENBQUNlLE1BQU0sR0FBR25zQixTQUFTO01BQzNCb3JCLFFBQVEsQ0FBQ2dCLE9BQU8sR0FBR3BzQixTQUFTO01BQzVCb3JCLFFBQVEsQ0FBQ2lCLGNBQWMsR0FBR3JzQixTQUFTO01BQ25Db3JCLFFBQVEsQ0FBQ21CLFdBQVcsR0FBR3ZzQixTQUFTO01BQ2hDb3JCLFFBQVEsQ0FBQ29CLFNBQVMsR0FBR3hzQixTQUFTO01BQzlCb3JCLFFBQVEsQ0FBQ3FCLFlBQVksR0FBR3pzQixTQUFTO01BQ2pDb3JCLFFBQVEsQ0FBQ3dCLFFBQVEsR0FBRzVzQixTQUFTO01BQzdCb3JCLFFBQVEsQ0FBQ3lCLGdCQUFnQixHQUFHN3NCLFNBQVM7TUFDckNvckIsUUFBUSxDQUFDMEIsV0FBVyxHQUFHOXNCLFNBQVM7TUFDaENvckIsUUFBUSxDQUFDMkIsU0FBUyxHQUFHL3NCLFNBQVM7TUFDOUJvckIsUUFBUSxDQUFDNEIsU0FBUyxHQUFHaHRCLFNBQVM7TUFDOUJvckIsUUFBUSxDQUFDNkIsU0FBUyxHQUFHanRCLFNBQVM7SUFDaEM7RUFBQztJQUFBO0lBQUEsT0FFRCw4QkFBc0I2TyxPQUFPLEVBQUVnVCxPQUFPLEVBQUU7TUFBQTtNQUN0QyxJQUFJQSxPQUFPLEVBQUU7UUFBRTtRQUNiO1FBQ0FBLE9BQU8sQ0FBQ2tILEVBQUUsQ0FBQ3BZLE9BQVcsQ0FBQ2hGLHFCQUFxQixFQUFFLENBQUNoTSxLQUFLLEVBQUUsVUFBQ21FLEtBQUssRUFBRWEsSUFBSSxFQUFLO1VBQ3JFLElBQ0V2RSxJQUFJLEdBSUZ1RSxJQUFJLENBSk52RSxJQUFJO1lBQ0pndkIsT0FBTyxHQUdMenFCLElBQUksQ0FITnlxQixPQUFPO1lBQ1BsdUIsS0FBSyxHQUVIeUQsSUFBSSxDQUZOekQsS0FBSztZQUNMaUwsR0FBRyxHQUNEeEgsSUFBSSxDQUROd0gsR0FBRztVQUVMLElBQUkvTCxJQUFJLENBQUNrSyxXQUFXLEVBQUUsS0FBSyxjQUFjLEVBQUU7WUFDekMsSUFBSThrQixPQUFPLENBQUM5a0IsV0FBVyxFQUFFLEtBQUssaUJBQWlCLEVBQUU7Y0FDL0MsTUFBSSxDQUFDMmEsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUMvQix1QkFBdUIsQ0FBQ1Esa0JBQWtCLEVBQUUzZixTQUFTLEVBQUU7Z0JBQ3RGb3VCLFVBQVUsRUFBRXZmLE9BQU87Z0JBQ25Cd2dCLFVBQVUsRUFBRXhOO2NBQ2QsQ0FBQyxDQUFDLENBQUM7Y0FDSCxNQUFJLENBQUN5TixVQUFVLEdBQUcsS0FBSztjQUN2QjtjQUNBek4sT0FBTyxDQUFDME4sT0FBTyxFQUFFO2NBQ2pCLElBQUlyTCxDQUFDLEdBQUd2YSxVQUFVLENBQUMsWUFBTTtnQkFDdkJzZSxZQUFZLENBQUMvRCxDQUFDLENBQUM7Z0JBQ2YsTUFBSSxDQUFDc0wsY0FBYyxDQUFDcmpCLEdBQUcsRUFBRSxLQUFLLENBQUM7Y0FDakMsQ0FBQyxFQUFFLElBQUksQ0FBQztjQUNSO1lBQ0YsQ0FBQyxNQUFNO2NBQ0wsTUFBSSxDQUFDOFksT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUMvQix1QkFBdUIsQ0FBQ00sZUFBZSxFQUFFemYsU0FBUyxFQUFFO2dCQUNuRm91QixVQUFVLEVBQUV2ZixPQUFPO2dCQUNuQndnQixVQUFVLEVBQUV4TixPQUFPO2dCQUNuQjVnQixLQUFLLEVBQUUwRDtjQUNULENBQUMsQ0FBQyxDQUFDO1lBQ0w7VUFDRixDQUFDLE1BQU07WUFDTCxNQUFJLENBQUNzZ0IsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUMvQix1QkFBdUIsQ0FBQ00sZUFBZSxFQUFFemYsU0FBUyxFQUFFO2NBQ25Gb3VCLFVBQVUsRUFBRXZmLE9BQU87Y0FDbkJ3Z0IsVUFBVSxFQUFFeE4sT0FBTztjQUNuQjVnQixLQUFLLEVBQUUwRDtZQUNULENBQUMsQ0FBQyxDQUFDO1VBQ0w7VUFFQSxJQUFJdkUsSUFBSSxDQUFDa0ssV0FBVyxFQUFFLEtBQUssWUFBWSxFQUFFO1lBQ3ZDLElBQUksTUFBSSxDQUFDeWpCLGVBQWUsRUFBRTtjQUN4QmxNLE9BQU8sQ0FBQzROLGNBQWMsRUFBRTtZQUMxQjtZQUNBLE1BQUksQ0FBQzFCLGVBQWUsR0FBRyxDQUFDLE1BQUksQ0FBQ0EsZUFBZTtZQUM1QyxNQUFJLENBQUNDLG1CQUFtQixHQUFHLE1BQUksQ0FBQ0EsbUJBQW1CLEdBQUcsQ0FBQztZQUN2RG5NLE9BQU8sQ0FBQzZOLGlCQUFpQixFQUFFO1VBQzdCO1VBRUEsSUFBSXh1QixLQUFLLElBQUlkLElBQUksQ0FBQ2tLLFdBQVcsRUFBRSxLQUFLLGNBQWMsRUFBRTtZQUNsRHVYLE9BQU8sQ0FBQzhOLFNBQVMsRUFBRTtVQUNyQjtRQUVGLENBQUMsQ0FBQztRQUNGOU4sT0FBTyxDQUFDa0gsRUFBRSxDQUFDcFksT0FBVyxDQUFDaEYscUJBQXFCLEVBQUUsQ0FBQ2lrQixlQUFlLEVBQUUsWUFBTTtVQUNwRTtVQUNBLElBQUk7WUFDRi9nQixPQUFPLENBQUMvQixLQUFLLEVBQUU7VUFDakIsQ0FBQyxDQUFDLE9BQU90SCxDQUFDLEVBQUU7WUFDVnpFLFNBQUssQ0FBQ3NoQix3Q0FBSSxrREFBMkM3YyxDQUFDLENBQUNyRyxPQUFPLEVBQUc7VUFDbkU7VUFDQSxNQUFJLENBQUNtd0IsVUFBVSxHQUFHLElBQUk7VUFDdEIsTUFBSSxDQUFDckssT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUMvQix1QkFBdUIsQ0FBQ08saUJBQWlCLEVBQUUxZixTQUFTLEVBQUU7WUFDckZvdUIsVUFBVSxFQUFFdmYsT0FBTztZQUNuQndnQixVQUFVLEVBQUV4TjtVQUNkLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDO1FBQ0ZBLE9BQU8sQ0FBQ2tILEVBQUUsQ0FBQ3BZLE9BQVcsQ0FBQ2hGLHFCQUFxQixFQUFFLENBQUNra0Isa0JBQWtCLEVBQUUsVUFBQy9yQixLQUFLLEVBQUVhLElBQUksRUFBSztVQUNsRixrQkFLSUEsSUFBSSxDQUpObXJCLEtBQUs7WUFDSEMsTUFBTSxlQUFOQSxNQUFNO1lBQ05DLEtBQUssZUFBTEEsS0FBSztVQUdULE1BQUksQ0FBQy9LLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDL0IsdUJBQXVCLENBQUNTLGlCQUFpQixFQUFFNWYsU0FBUyxFQUFFO1lBQ3JGb3VCLFVBQVUsRUFBRXZmLE9BQU87WUFDbkJ3Z0IsVUFBVSxFQUFFeE4sT0FBTztZQUNuQm9PLFFBQVEsRUFBR0YsTUFBTSxHQUFDQyxLQUFLLEdBQUU7VUFDM0IsQ0FBQyxDQUFDLENBQUM7VUFDSCxJQUFJLENBQUMsTUFBSSxDQUFDRSxtQkFBbUIsSUFBSSxDQUFDLE1BQUksQ0FBQ3BDLGNBQWMsRUFBRTtVQUN2RCxNQUFJLENBQUNBLGNBQWMsR0FBSWlDLE1BQU0sR0FBQ0MsS0FBSyxJQUFJLENBQUU7UUFDM0MsQ0FBQyxDQUFDO1FBQ0Y7UUFDQTtRQUNBO1FBQ0FuTyxPQUFPLENBQUNrSCxFQUFFLENBQUNwWSxPQUFXLENBQUNoRixxQkFBcUIsRUFBRSxDQUFDd2tCLFdBQVcsRUFBRSxVQUFDcnNCLEtBQUssRUFBRWEsSUFBSSxFQUFLO1VBQzNFLE1BQUksQ0FBQ21wQixjQUFjLEdBQUcsS0FBSztVQUMzQixJQUFJLENBQUMsTUFBSSxDQUFDb0MsbUJBQW1CLEVBQUU7WUFDN0IsSUFFSUUsTUFBTSxHQUVOenJCLElBQUksQ0FITjByQixJQUFJLENBQ0ZELE1BQU07WUFHVixJQUFJLENBQUNBLE1BQU0sRUFBRTtZQUNYLElBQU1yckIsTUFBTSxHQUFHMm9CLE1BQU07WUFDakM7WUFDVTNzQixTQUFLLENBQUNzaEIsd0NBQUksa0RBQTJDK04sTUFBTSxnQkFBTXJyQixNQUFNLEVBQUc7VUFDNUU7VUFDQSxNQUFJLENBQUNrZ0IsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUMvQix1QkFBdUIsQ0FBQ1UsZ0JBQWdCLEVBQUU3ZixTQUFTLEVBQUU7WUFDcEZvdUIsVUFBVSxFQUFFdmYsT0FBTztZQUNuQndnQixVQUFVLEVBQUV4TjtVQUNkLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDO01BQ0o7TUFFQWhULE9BQU8sQ0FBQzhjLGdCQUFnQixHQUFHLElBQUksQ0FBQzJFLG9CQUFvQixDQUFDbE4sSUFBSSxDQUFDLElBQUksQ0FBQztNQUMvRHZVLE9BQU8sQ0FBQ2tkLFlBQVksR0FBRyxJQUFJLENBQUN3RSxnQkFBZ0IsQ0FBQ25OLElBQUksQ0FBQyxJQUFJLENBQUM7TUFDdkR2VSxPQUFPLENBQUNzZCxNQUFNLEdBQUcsSUFBSSxDQUFDcUUsVUFBVSxDQUFDcE4sSUFBSSxDQUFDLElBQUksQ0FBQztNQUMzQ3ZVLE9BQU8sQ0FBQ3VkLE9BQU8sR0FBRyxJQUFJLENBQUNxRSxXQUFXLENBQUNyTixJQUFJLENBQUMsSUFBSSxDQUFDO0lBQy9DO0VBQUM7SUFBQTtJQUFBLE9BRUQsaUNBQXlCdlUsT0FBTyxFQUFFO01BQ2hDQSxPQUFPLENBQUM4YyxnQkFBZ0IsR0FBRzNyQixTQUFTO01BQ3BDNk8sT0FBTyxDQUFDa2QsWUFBWSxHQUFHL3JCLFNBQVM7TUFDaEM2TyxPQUFPLENBQUNzZCxNQUFNLEdBQUduc0IsU0FBUztNQUMxQjZPLE9BQU8sQ0FBQ3VkLE9BQU8sR0FBR3BzQixTQUFTO0lBQzdCO0VBQUM7SUFBQTtJQUFBLE9BRUQsdUJBQWU7TUFDYmUsU0FBSyxDQUFDc2hCLHdDQUFJLEVBQUUsNEJBQTRCLENBQUM7TUFDekM7TUFDQSxJQUFJLElBQUksQ0FBQzZOLG1CQUFtQixFQUFFO1FBQzVCO01BQ0Y7TUFDQSxJQUFJLENBQUM1RSxXQUFXLEVBQUUsQ0FBQ3BELFFBQVEsQ0FBQ3RDLGFBQWEsQ0FBQ0csSUFBSSxDQUFDO01BQy9DLElBQUksQ0FBQ2QsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ2lCLHFCQUFxQixFQUFFNWUsU0FBUyxFQUFFO1FBQ3RGeXJCLElBQUksRUFBRTdGLGFBQWEsQ0FBQ0csSUFBSTtRQUN4Qk8sS0FBSyxFQUFFSixxQkFBcUIsQ0FBQ04sYUFBYSxDQUFDRyxJQUFJO01BQ2pELENBQUMsQ0FBQyxDQUFDO0lBQ0w7RUFBQztJQUFBO0lBQUEsT0FFRCw4QkFBc0JqaUIsS0FBSyxFQUFFO01BQzNCLElBQU0rSyxPQUFPLEdBQUcvSyxLQUFLLENBQUNzZ0IsTUFBTTtNQUM1QnJqQixTQUFLLENBQUNzaEIsd0NBQUksRUFBRSw4Q0FBOEMsR0FBR3hULE9BQU8sQ0FBQ3VYLFFBQVEsR0FBRSxHQUFHLENBQUM7TUFDbkYsSUFBSSxDQUFDLElBQUksQ0FBQ2tKLFVBQVUsRUFBRTtRQUNwQixJQUFJLENBQUNoRSxXQUFXLEVBQUUsQ0FBQ08sbUJBQW1CLENBQUNoZCxPQUFPLENBQUN1WCxRQUFRLENBQUM7TUFDMUQ7SUFDRjtFQUFDO0lBQUE7SUFBQSxPQUVELDBCQUFrQnRpQixLQUFLLEVBQUU7TUFDdkIsSUFBTStLLE9BQU8sR0FBRy9LLEtBQUssQ0FBQ3NnQixNQUFNO01BQzVCLElBQUksSUFBSSxDQUFDa0wsVUFBVSxFQUFFO1FBQ25CLElBQUksQ0FBQyxJQUFJLENBQUN6QixvQkFBb0IsRUFBRTtVQUM5QixJQUFNNkMsV0FBVyxHQUFHLElBQUksQ0FBQ3RDLFVBQVUsQ0FBQ2hJLFFBQVE7VUFDNUMsSUFBTXJoQixNQUFNLEdBQUc4SixPQUFPLENBQUNtZCxXQUFXLEdBQUcsSUFBSSxDQUFDaUMsbUJBQW1CO1VBQzdELElBQU14dkIsSUFBSSxHQUFJK1UsS0FBSyxDQUFDa2QsV0FBVyxDQUFDLElBQUlBLFdBQVcsS0FBSyxDQUFDLEdBQUk3aEIsT0FBTyxDQUFDbWQsV0FBVyxHQUFHMEUsV0FBVyxHQUFHaEQsTUFBTSxHQUFHM29CLE1BQU07VUFDNUcsSUFBSSxDQUFDdW1CLFdBQVcsRUFBRSxDQUFDbEQsV0FBVyxDQUFDM3BCLElBQUksRUFBRUEsSUFBSSxDQUFDO1VBQzFDLElBQUksQ0FBQ3dtQixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDZ0Isb0JBQW9CLEVBQUUzZSxTQUFTLEVBQUU7WUFDckZ2QixJQUFJLEVBQUVBLElBQUk7WUFDVjJuQixRQUFRLEVBQUUzbkI7VUFDWixDQUFDLENBQUMsQ0FBQztRQUNMO01BQ0YsQ0FBQyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUM2d0IsVUFBVSxFQUFFO1FBQzNCLElBQUksQ0FBQ2hFLFdBQVcsRUFBRSxDQUFDbEQsV0FBVyxDQUFDdlosT0FBTyxDQUFDbWQsV0FBVyxFQUFFaHNCLFNBQVMsQ0FBQztRQUM5RCxJQUFJLENBQUNpbEIsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ2dCLG9CQUFvQixFQUFFM2UsU0FBUyxFQUFFO1VBQ3JGdkIsSUFBSSxFQUFFb1EsT0FBTyxDQUFDbWQsV0FBVztVQUN6QjVGLFFBQVEsRUFBRXZYLE9BQU8sQ0FBQ3VYO1FBQ3BCLENBQUMsQ0FBQyxDQUFDO01BQ0w7SUFDRjtFQUFDO0lBQUE7SUFBQSxPQUVELHNCQUFjO01BQ1pybEIsU0FBSyxDQUFDc2hCLHdDQUFJLEVBQUUsMkJBQTJCLENBQUM7TUFDeEMsSUFBSSxDQUFDaUosV0FBVyxFQUFFLENBQUNwRCxRQUFRLENBQUN0QyxhQUFhLENBQUNJLE9BQU8sQ0FBQztNQUNsRCxJQUFJLENBQUNmLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUNpQixxQkFBcUIsRUFBRTVlLFNBQVMsRUFBRTtRQUN0RnlyQixJQUFJLEVBQUU3RixhQUFhLENBQUNJLE9BQU87UUFDM0JNLEtBQUssRUFBRUoscUJBQXFCLENBQUNOLGFBQWEsQ0FBQ0ksT0FBTztNQUNwRCxDQUFDLENBQUMsQ0FBQztJQUNMO0VBQUM7SUFBQTtJQUFBLE9BRUQsdUJBQWU7TUFDYmpsQixTQUFLLENBQUNzaEIsd0NBQUksRUFBRSw0QkFBNEIsQ0FBQztNQUN6QyxJQUFJLENBQUNpSixXQUFXLEVBQUUsQ0FBQ3BELFFBQVEsQ0FBQ3RDLGFBQWEsQ0FBQ0ssTUFBTSxDQUFDO01BQ2pELElBQUksQ0FBQ2hCLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUNpQixxQkFBcUIsRUFBRTVlLFNBQVMsRUFBRTtRQUN0RnlyQixJQUFJLEVBQUU3RixhQUFhLENBQUNLLE1BQU07UUFDMUJLLEtBQUssRUFBRUoscUJBQXFCLENBQUNOLGFBQWEsQ0FBQ0ssTUFBTTtNQUNuRCxDQUFDLENBQUMsQ0FBQztJQUNMO0VBQUM7SUFBQTtJQUFBLE9BRUQsOEJBQXNCbmlCLEtBQUssRUFBRTtNQUMzQixJQUFNK0ssT0FBTyxHQUFHL0ssS0FBSyxDQUFDc2dCLE1BQU07TUFDNUIsSUFBTXJmLE1BQU0sR0FBRzJvQixNQUFNO01BQ3JCLElBQUksQ0FBQ08sbUJBQW1CLEdBQUcsSUFBSSxDQUFDalksS0FBSyxDQUFDZ1csV0FBVztNQUNqRGpyQixTQUFLLENBQUNzaEIsd0NBQUksd0NBQWlDeFQsT0FBTyxDQUFDdVgsUUFBUSxlQUFLcmhCLE1BQU0sRUFBRztNQUN6RSxJQUFJLENBQUN1bUIsV0FBVyxFQUFFLENBQUNPLG1CQUFtQixDQUFDaGQsT0FBTyxDQUFDdVgsUUFBUSxHQUFHcmhCLE1BQU0sQ0FBQztJQUNuRTtFQUFDO0lBQUE7SUFBQSxPQUVELDBCQUFrQmpCLEtBQUssRUFBRTtNQUN2QixJQUFNK0ssT0FBTyxHQUFHL0ssS0FBSyxDQUFDc2dCLE1BQU07TUFDNUIsSUFBTWlILFFBQVEsR0FBRyxJQUFJLENBQUNDLFdBQVcsRUFBRTtNQUNuQ0QsUUFBUSxDQUFDakQsV0FBVyxDQUFDdlosT0FBTyxDQUFDbWQsV0FBVyxFQUFFWCxRQUFRLENBQUNzRixtQkFBbUIsRUFBRSxDQUFDO01BQ3pFLElBQUk5aEIsT0FBTyxDQUFDbWQsV0FBVyxJQUFJbmQsT0FBTyxDQUFDdVgsUUFBUSxFQUFFO1FBQzNDLElBQUksQ0FBQ3dLLG9CQUFvQixDQUFDLEtBQUssRUFBRSxJQUFJLENBQUN4QyxVQUFVLEVBQUUsSUFBSSxDQUFDcFksS0FBSyxFQUFFLElBQUksQ0FBQ3dVLE1BQU0sQ0FBQztNQUM1RTtJQUNGO0VBQUM7SUFBQTtJQUFBLE9BRUQsc0JBQWM7TUFDWnpwQixTQUFLLENBQUNzaEIsd0NBQUksRUFBRSwrQkFBK0IsQ0FBQztNQUM1QyxJQUFJLENBQUNpSixXQUFXLEVBQUUsQ0FBQ3BELFFBQVEsQ0FBQ3RDLGFBQWEsQ0FBQ0ksT0FBTyxDQUFDO01BQ2xELElBQUksQ0FBQ2YsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ2lCLHFCQUFxQixFQUFFNWUsU0FBUyxFQUFFO1FBQ3RGeXJCLElBQUksRUFBRTdGLGFBQWEsQ0FBQ0ksT0FBTztRQUMzQk0sS0FBSyxFQUFFSixxQkFBcUIsQ0FBQ04sYUFBYSxDQUFDSSxPQUFPO01BQ3BELENBQUMsQ0FBQyxDQUFDO0lBQ0w7RUFBQztJQUFBO0lBQUEsT0FFRCx1QkFBZTtNQUNiamxCLFNBQUssQ0FBQ3NoQix3Q0FBSSxFQUFFLGdDQUFnQyxDQUFDO01BQzdDLElBQUksQ0FBQ2lKLFdBQVcsRUFBRSxDQUFDcEQsUUFBUSxDQUFDdEMsYUFBYSxDQUFDSyxNQUFNLENBQUM7TUFDakQsSUFBSSxDQUFDaEIsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ2lCLHFCQUFxQixFQUFFNWUsU0FBUyxFQUFFO1FBQ3RGeXJCLElBQUksRUFBRTdGLGFBQWEsQ0FBQ0ssTUFBTTtRQUMxQkssS0FBSyxFQUFFSixxQkFBcUIsQ0FBQ04sYUFBYSxDQUFDSyxNQUFNO01BQ25ELENBQUMsQ0FBQyxDQUFDO0lBQ0w7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORTtJQUFBO0lBQUEsT0FPQSxpQ0FBeUI0RCxZQUFZLEVBQUU7TUFDckMsSUFBSUEsWUFBWSxFQUFFO1FBQ2hCLElBQUksSUFBSSxDQUFDVyxNQUFNLEVBQUU7VUFDZixJQUFJLENBQUNBLE1BQU0sQ0FBQ2piLFNBQVMsQ0FBQ2dXLEdBQUcsQ0FBQyxxQ0FBcUMsQ0FBQztRQUNsRTtRQUNBLElBQUksSUFBSSxDQUFDNkksVUFBVSxFQUFFO1VBQ25CLElBQUksQ0FBQ0EsVUFBVSxDQUFDN2UsU0FBUyxDQUFDZ1csR0FBRyxDQUFDLHFDQUFxQyxDQUFDO1FBQ3RFO1FBQ0EsSUFBSSxDQUFDdlAsS0FBSyxDQUFDekcsU0FBUyxDQUFDZ1csR0FBRyxDQUFDLHFDQUFxQyxDQUFDO01BQ2pFLENBQUMsTUFDSTtRQUNILElBQUksSUFBSSxDQUFDaUYsTUFBTSxFQUFFO1VBQ2YsSUFBSSxDQUFDQSxNQUFNLENBQUNqYixTQUFTLENBQUNpVyxNQUFNLENBQUMscUNBQXFDLENBQUM7UUFDckU7UUFDQSxJQUFJLElBQUksQ0FBQzRJLFVBQVUsRUFBRTtVQUNuQixJQUFJLENBQUNBLFVBQVUsQ0FBQzdlLFNBQVMsQ0FBQ2lXLE1BQU0sQ0FBQyxxQ0FBcUMsQ0FBQztRQUN6RTtRQUNBLElBQUksQ0FBQ3hQLEtBQUssQ0FBQ3pHLFNBQVMsQ0FBQ2lXLE1BQU0sQ0FBQyxxQ0FBcUMsQ0FBQztNQUNwRTtNQUNBLElBQUksQ0FBQ1AsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ2tCLHdCQUF3QixFQUFFN2UsU0FBUyxFQUFFNnBCLFlBQVksQ0FBQyxDQUFDO0lBQzVHOztJQUVDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQRTtJQUFBO0lBQUEsT0FRQSxtQkFBV25uQixPQUFPLEVBQUU7TUFDbEIzQixTQUFLLENBQUNzaEIsd0NBQUksRUFBRSxhQUFhLENBQUM7TUFDMUI7TUFDQSxJQUFJLENBQUNyTSxLQUFLLENBQUNxVixRQUFRLEdBQUcsSUFBSTtNQUMxQixJQUFJLENBQUNyVixLQUFLLENBQUN6RyxTQUFTLENBQUNnVyxHQUFHLENBQUMsZUFBZSxDQUFDO01BQ3pDLElBQU04RSxtQkFBbUIsR0FBRzFaLE9BQVcsQ0FBQzFCLG1CQUFtQixDQUFDLElBQUksQ0FBQytHLEtBQUssRUFBRSxVQUFVLENBQUMsSUFBSXJGLE9BQVcsQ0FBQ3RCLGVBQWUsQ0FBQyxJQUFJLENBQUMyRyxLQUFLLEVBQUUsZUFBZSxDQUFDO01BQy9JLElBQUlxVSxtQkFBbUIsRUFBRTtRQUN2QixJQUFJLENBQUNHLE1BQU0sR0FBRyxJQUFJLENBQUNDLGdCQUFnQixDQUFDLElBQUksQ0FBQ3pVLEtBQUssQ0FBQztNQUNqRDtNQUNBLElBQU1PLFFBQVEsR0FBRyxJQUFJM1UsZUFBZSxFQUFFO01BQ3RDLElBQU1zckIsa0JBQWtCLEdBQUd4cUIsT0FBTyxDQUFDMm9CLFFBQVE7TUFDM0MsSUFBTThCLE9BQU8sR0FBR3hjLE9BQVcsQ0FBQzFCLG1CQUFtQixDQUFDLElBQUksQ0FBQytHLEtBQUssRUFBRSxPQUFPLENBQUM7TUFDcEUsSUFBSWtYLGtCQUFrQixJQUFJN0MsbUJBQW1CLEVBQUU7UUFDN0MsSUFBSTZDLGtCQUFrQixFQUFFO1VBQ3RCLElBQUksQ0FBQ3RDLFNBQVMsR0FBR2xvQixPQUFPLENBQUMyb0IsUUFBUTtRQUNuQyxDQUFDLE1BQ0k7VUFDSCxJQUFJLENBQUNULFNBQVMsR0FBRyxJQUFJVCxvQkFBb0IsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDSyxNQUFNLENBQUM7UUFDOUQ7UUFDQSxJQUFJLENBQUN4VSxLQUFLLENBQUNxVixRQUFRLEdBQUcsS0FBSztRQUMzQixJQUFJLENBQUNULFNBQVMsQ0FBQ3dDLFFBQVEsQ0FBQyxJQUFJLENBQUNrQyxVQUFVLENBQUM7UUFDeEMsSUFBSSxDQUFDMUUsU0FBUyxDQUFDaEMsYUFBYSxDQUFDdUUsT0FBTyxDQUFDO01BQ3ZDO01BQ0EsSUFBSSxDQUFDRSxvQkFBb0IsQ0FBQyxJQUFJLENBQUN4QywyQkFBMkIsQ0FBQztNQUMzRHRVLFFBQVEsQ0FBQ25WLE9BQU8sRUFBRTtNQUNsQixPQUFPbVYsUUFBUSxDQUFDalYsT0FBTztJQUN6Qjs7SUFFQTtBQUNGO0FBQ0E7RUFGRTtJQUFBO0lBQUEsT0FHQSxtQkFBVztNQUNUUCxTQUFLLENBQUNzaEIsd0NBQUksRUFBRSxXQUFXLENBQUM7SUFDMUI7RUFBQztJQUFBO0lBQUEsT0FFRCwyQkFBeUM7TUFBQTtNQUFBLElBQXhCaUwsY0FBYyx1RUFBRyxLQUFLO01BQ3JDLElBQUksQ0FBQzFnQixJQUFJLEVBQUUsQ0FDUnpKLEtBQUssQ0FBQyxVQUFBcUMsQ0FBQyxFQUFJO1FBQ1YsSUFBSThuQixjQUFjLEVBQUU7VUFDbEIsTUFBSSxDQUFDekUsSUFBSSxFQUFFO1VBQ1gsTUFBSSxDQUFDamMsSUFBSSxFQUFFLENBQ1IzSixJQUFJLENBQUMsWUFBTTtZQUNWLE1BQUksQ0FBQ2dpQixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDb0IsbUJBQW1CLEVBQUUvZSxTQUFTLEVBQUU7Y0FBQzZPLE9BQU8sRUFBRSxNQUFJLENBQUNtSDtZQUFLLENBQUMsQ0FBQyxDQUFDO1VBQy9HLENBQUMsQ0FBQyxDQUNEN1MsS0FBSyxDQUFDLFVBQUFpRyxHQUFHLEVBQUk7WUFDWixNQUFJLENBQUM2YixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDbUIscUJBQXFCLEVBQUU5ZSxTQUFTLEVBQUU7Y0FDdEZpQixLQUFLLEVBQUdtSSxHQUFHLENBQUNqSyxPQUFPLEdBQUdpSyxHQUFHLENBQUNqSyxPQUFPLEdBQUdpSyxHQUFJO2NBQ3hDeUYsT0FBTyxFQUFFLE1BQUksQ0FBQ21IO1lBQ2hCLENBQUMsQ0FBQyxDQUFDO1VBQ0wsQ0FBQyxDQUFDO1FBQ04sQ0FBQyxNQUFNO1VBQ0wsTUFBSSxDQUFDaVAsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ21CLHFCQUFxQixFQUFFOWUsU0FBUyxFQUFFO1lBQ3RGaUIsS0FBSyxFQUFHdUUsQ0FBQyxDQUFDckcsT0FBTyxHQUFHcUcsQ0FBQyxDQUFDckcsT0FBTyxHQUFHcUcsQ0FBRTtZQUNsQ3FKLE9BQU8sRUFBRSxNQUFJLENBQUNtSDtVQUNoQixDQUFDLENBQUMsQ0FBQztRQUNMO01BQ0YsQ0FBQyxDQUFDO0lBQ047O0lBRUE7RUFBQTtJQUFBO0lBQUEsT0FDQSx3QkFBZ0I2YSxNQUFNLEVBQUVDLGdCQUFnQixFQUFFO01BQ3hDLElBQU16RixRQUFRLEdBQUcsSUFBSSxDQUFDQyxXQUFXLEVBQUU7TUFDbkNELFFBQVEsQ0FBQ2pELFdBQVcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO01BQzFCLElBQUksQ0FBQ2dHLFVBQVUsR0FBRyxJQUFJLENBQUMyQyx3QkFBd0IsQ0FBQyxJQUFJLENBQUN2RyxNQUFNLEVBQUUsSUFBSSxDQUFDeFUsS0FBSyxDQUFDO01BQ3hFLElBQUksQ0FBQzRhLG9CQUFvQixDQUFDLElBQUksQ0FBQ1YsbUJBQW1CLEVBQUUsSUFBSSxDQUFDOUIsVUFBVSxFQUFFLElBQUksQ0FBQ3BZLEtBQUssRUFBRSxJQUFJLENBQUN3VSxNQUFNLENBQUM7TUFDN0Y7TUFDQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtNQUNNLElBQUkyRCxHQUFHLEdBQUd4ZCxPQUFXLENBQUNsRixlQUFlLENBQUM7UUFBQzFLLEtBQUssRUFBRSxJQUFJO1FBQUVpd0IsZ0JBQWdCLEVBQUU7TUFBQyxDQUFDLENBQUM7TUFDekUsSUFBSSxDQUFDQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUM3QyxVQUFVLEVBQUVELEdBQUcsQ0FBQztNQUMvQ0EsR0FBRyxDQUFDK0MsV0FBVyxDQUFDLElBQUksQ0FBQzlDLFVBQVUsQ0FBQztNQUNoQ0QsR0FBRyxDQUFDcEYsRUFBRSxDQUFDcFksT0FBVyxDQUFDaEYscUJBQXFCLEVBQUUsQ0FBQ3dsQixjQUFjLEVBQUUsWUFBTTtRQUMvRGhELEdBQUcsQ0FBQ2lELFVBQVUsQ0FBQ1AsTUFBTSxDQUFDO01BQ3hCLENBQUMsQ0FBQztNQUNGLElBQUksQ0FBQzFDLEdBQUcsR0FBR0EsR0FBRztNQUNkem1CLE1BQU0sQ0FBQzJwQixpQkFBaUIsR0FBRyxJQUFJLENBQUNsRCxHQUFHO01BQ3JDO0FBQ0o7QUFDQTtJQUNFO0VBQUM7SUFBQTtJQUFBLE9BRUQsZ0JBQTRCO01BQUEsSUFBdEJtRCxZQUFZLHVFQUFHLEtBQUs7TUFDeEJ2d0IsU0FBSyxDQUFDc2hCLHdDQUFJLEVBQUUsNEJBQTRCLENBQUM7TUFDekMsSUFBTTlMLFFBQVEsR0FBRyxJQUFJM1UsZUFBZSxFQUFFO01BQ3RDLElBQUk7UUFDRixJQUFJK0ssWUFBWTtRQUNoQixJQUFJMmtCLFlBQVksSUFBSSxJQUFJLENBQUNsRCxVQUFVLElBQUksSUFBSSxDQUFDQSxVQUFVLENBQUNNLE1BQU0sRUFBRTtVQUM3RC9oQixZQUFZLEdBQUcsSUFBSSxDQUFDeWhCLFVBQVUsQ0FBQ3hoQixJQUFJLEVBQUU7UUFDdkMsQ0FBQyxNQUFNO1VBQ0xELFlBQVksR0FBRyxJQUFJLENBQUNxSixLQUFLLENBQUNwSixJQUFJLEVBQUU7UUFDbEM7UUFDQSxJQUFJRCxZQUFZLEVBQUU7VUFDaEJBLFlBQVksQ0FDVDFKLElBQUksQ0FBQyxZQUFNO1lBQ1ZsQyxTQUFLLENBQUNzaEIsd0NBQUksRUFBRSxvQ0FBb0MsQ0FBQztZQUNqRDlMLFFBQVEsQ0FBQ25WLE9BQU8sRUFBRTtVQUNwQixDQUFDLENBQUMsQ0FDRCtCLEtBQUssQ0FBQ29ULFFBQVEsQ0FBQ2xWLE1BQU0sQ0FBQztRQUMzQixDQUFDLE1BQU07VUFDTE4sU0FBSyxDQUFDc2hCLHdDQUFJLEVBQUUsb0NBQW9DLENBQUM7VUFDakQ5TCxRQUFRLENBQUNuVixPQUFPLEVBQUU7UUFDcEI7TUFDRixDQUFDLENBQUMsT0FBT29FLENBQUMsRUFBRTtRQUNWdkUsU0FBSyxDQUFDb2hCLHdDQUFJLEVBQUUsdUNBQXVDLEdBQUc3YyxDQUFDLENBQUNyRyxPQUFPLENBQUM7UUFDaEVvWCxRQUFRLENBQUNsVixNQUFNLENBQUNtRSxDQUFDLENBQUM7TUFDcEI7TUFDQSxPQUFPK1EsUUFBUSxDQUFDalYsT0FBTztJQUN6QjtFQUFDO0lBQUE7SUFBQSxPQUVELGlCQUFxRDtNQUFBLElBQTlDZ3dCLFlBQVksdUVBQUcsS0FBSztNQUFBLElBQUVDLGNBQWMsdUVBQUcsS0FBSztNQUNqRHh3QixTQUFLLENBQUNzaEIsd0NBQUksRUFBRSw2QkFBNkIsQ0FBQztNQUMxQyxJQUFJO1FBQ0YsSUFBSWlQLFlBQVksSUFBSUMsY0FBYyxJQUFJLElBQUksQ0FBQ25ELFVBQVUsRUFBRTtVQUNyRCxJQUFJLENBQUNBLFVBQVUsQ0FBQ3RoQixLQUFLLEVBQUU7VUFDdkIsSUFBSSxDQUFDa0osS0FBSyxDQUFDbEosS0FBSyxFQUFFO1FBQ3BCLENBQUMsTUFBTSxJQUFJd2tCLFlBQVksSUFBSSxDQUFDLElBQUksQ0FBQ2xELFVBQVUsQ0FBQ00sTUFBTSxJQUFJLElBQUksQ0FBQ04sVUFBVSxFQUFFO1VBQ3JFLElBQUksQ0FBQ0EsVUFBVSxDQUFDdGhCLEtBQUssRUFBRTtRQUN6QixDQUFDLE1BQU07VUFDTCxJQUFJLENBQUNrSixLQUFLLENBQUNsSixLQUFLLEVBQUU7UUFDcEI7TUFDRixDQUFDLENBQUMsT0FBT3RILENBQUMsRUFBRTtRQUNWeEUsUUFBSSxDQUFDcWhCLHdDQUFJLEVBQUUsK0NBQStDLEdBQUc3YyxDQUFDLENBQUNyRyxPQUFPLENBQUM7TUFDekU7SUFDRjtFQUFDO0lBQUE7SUFBQSxPQUVELGtCQUE4QjtNQUFBLElBQXRCbXlCLFlBQVksdUVBQUcsS0FBSztNQUMxQnZ3QixTQUFLLENBQUNzaEIsd0NBQUksRUFBRSw4QkFBOEIsQ0FBQztNQUMzQyxJQUFJO1FBQ0YsSUFBSTFWLFlBQVksR0FBRyxJQUFJLENBQUN1akIsbUJBQW1CLElBQUksSUFBSSxDQUFDOUIsVUFBVSxHQUFHLElBQUksQ0FBQ0EsVUFBVSxDQUFDeGhCLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQ29KLEtBQUssQ0FBQ3BKLElBQUksRUFBRTtRQUMzRyxJQUFJMGtCLFlBQVksSUFBSSxJQUFJLENBQUNwQixtQkFBbUIsRUFBRTtVQUM1QyxJQUFJLENBQUNsYSxLQUFLLENBQUNwSixJQUFJLEVBQUUsQ0FBQ3pKLEtBQUssQ0FBQyxVQUFDaUcsR0FBRztZQUFBLE9BQUtwSSxRQUFJLENBQUNxaEIsd0NBQUksRUFBRSw0Q0FBNEMsSUFBSWpaLEdBQUcsQ0FBQ2pLLE9BQU8sR0FBR2lLLEdBQUcsQ0FBQ2pLLE9BQU8sR0FBR2lLLEdBQUcsQ0FBQyxDQUFDO1VBQUEsRUFBQztRQUNoSTtRQUNBLElBQUl1RCxZQUFZLEVBQUU7VUFDaEJBLFlBQVksQ0FBQzFKLElBQUksQ0FBQztZQUFBLE9BQU1sQyxTQUFLLENBQUNzaEIsd0NBQUksRUFBRSxvQ0FBb0MsQ0FBQztVQUFBLEVBQUMsQ0FDN0RsZixLQUFLLENBQUMsVUFBQ2lHLEdBQUc7WUFBQSxPQUFLcEksUUFBSSxDQUFDcWhCLHdDQUFJLEVBQUUsNENBQTRDLElBQUlqWixHQUFHLENBQUNqSyxPQUFPLEdBQUdpSyxHQUFHLENBQUNqSyxPQUFPLEdBQUdpSyxHQUFHLENBQUMsQ0FBQztVQUFBLEVBQUM7UUFDM0g7TUFDRixDQUFDLENBQUMsT0FBTzVELENBQUMsRUFBRTtRQUNWeEUsUUFBSSxDQUFDcWhCLHdDQUFJLEVBQUUsZ0RBQWdELEdBQUc3YyxDQUFDLENBQUNyRyxPQUFPLENBQUM7TUFDMUU7SUFDRjtFQUFDO0lBQUE7SUFBQSxPQUVELGdCQUFRO01BQ040QixTQUFLLENBQUNzaEIsd0NBQUksRUFBRSw0QkFBNEIsQ0FBQztNQUN6QyxJQUFJO1FBQ0YsSUFBSSxJQUFJLENBQUMrTCxVQUFVLEVBQUU7VUFDbkIsSUFBSSxDQUFDQSxVQUFVLENBQUNiLElBQUksRUFBRTtRQUN4QjtRQUNBLElBQUksQ0FBQ3ZYLEtBQUssQ0FBQ3VYLElBQUksRUFBRTtNQUNuQixDQUFDLENBQ0QsT0FBTy9uQixDQUFDLEVBQUU7UUFDUjtNQUFBO0lBRUo7RUFBQztJQUFBO0lBQUEsT0FFRCxnQkFBUTtNQUNOLElBQUksSUFBSSxDQUFDNG9CLFVBQVUsRUFBRTtRQUNuQixJQUFJLENBQUNBLFVBQVUsQ0FBQ3pFLEtBQUssR0FBRyxJQUFJLENBQUN1RyxtQkFBbUI7TUFDbEQ7TUFDQSxJQUFJLENBQUNsYSxLQUFLLENBQUMyVCxLQUFLLEdBQUcsSUFBSTtNQUN2QixJQUFNMEIsUUFBUSxHQUFHLElBQUksQ0FBQ0MsV0FBVyxFQUFFO01BQ25DLElBQUlELFFBQVEsRUFBRTtRQUNaQSxRQUFRLENBQUN6QyxhQUFhLENBQUMsSUFBSSxDQUFDO01BQzlCO0lBQ0Y7RUFBQztJQUFBO0lBQUEsT0FFRCxrQkFBVTtNQUNSLElBQUksSUFBSSxDQUFDd0YsVUFBVSxFQUFFO1FBQ25CLElBQUksQ0FBQ0EsVUFBVSxDQUFDekUsS0FBSyxHQUFHLENBQUMsSUFBSSxDQUFDdUcsbUJBQW1CO1FBQ2pELElBQUksQ0FBQ2xhLEtBQUssQ0FBQzJULEtBQUssR0FBRyxJQUFJLENBQUN1RyxtQkFBbUI7TUFDN0MsQ0FBQyxNQUFNO1FBQ0wsSUFBSSxDQUFDbGEsS0FBSyxDQUFDMlQsS0FBSyxHQUFHLEtBQUs7TUFDMUI7TUFDQSxJQUFNMEIsUUFBUSxHQUFHLElBQUksQ0FBQ0MsV0FBVyxFQUFFO01BQ25DLElBQUlELFFBQVEsRUFBRTtRQUNaQSxRQUFRLENBQUN6QyxhQUFhLENBQUMsS0FBSyxDQUFDO01BQy9CO0lBQ0Y7RUFBQztJQUFBO0lBQUEsT0FFRCxtQkFBV3JsQixLQUFLLEVBQUU7TUFDaEIsSUFBSSxDQUFDb2xCLE1BQU0sRUFBRTtNQUNiLElBQUksSUFBSSxDQUFDeUYsVUFBVSxJQUFJLElBQUksQ0FBQzhCLG1CQUFtQixFQUFFO1FBQy9DLElBQUksQ0FBQzlCLFVBQVUsQ0FBQzFDLE1BQU0sR0FBR25vQixLQUFLO01BQ2hDLENBQUMsTUFBTTtRQUNMLElBQUksQ0FBQ3lTLEtBQUssQ0FBQzBWLE1BQU0sR0FBR25vQixLQUFLO01BQzNCO0lBQ0Y7RUFBQztJQUFBO0lBQUEsT0FFRCxnQkFBUThoQixVQUFVLEVBQXdCO01BQUEsSUFBdEJlLFFBQVEsdUVBQUdwbUIsU0FBUztNQUN0QyxJQUFJLElBQUksQ0FBQ3N2QixVQUFVLEVBQUU7UUFDbkIsSUFBSSxDQUFDMUUsU0FBUyxDQUFDeEMsV0FBVyxDQUFDL0MsVUFBVSxFQUFFZSxRQUFRLENBQUM7UUFDaEQsSUFBSSxDQUFDbkIsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ2UsV0FBVyxFQUFFMWUsU0FBUyxFQUFFO1VBQUV3eEIsSUFBSSxFQUFFbk0sVUFBVTtVQUFFZSxRQUFRLEVBQUVBO1FBQVMsQ0FBQyxDQUFDLENBQUM7UUFFeEgsSUFBSSxJQUFJLENBQUNnSSxVQUFVLElBQUkvSSxVQUFVLEdBQUcsR0FBRyxFQUFFO1VBQ3ZDLElBQUk7WUFDRixJQUFJLENBQUMrSSxVQUFVLENBQUM3ZSxTQUFTLENBQUNpVyxNQUFNLENBQUMsUUFBUSxDQUFDO1lBQzFDLElBQUksQ0FBQzRJLFVBQVUsQ0FBQ3BDLFdBQVcsR0FBRyxJQUFJLENBQUNvQyxVQUFVLENBQUNoSSxRQUFRLEdBQUdmLFVBQVU7WUFDbkUsSUFBSSxDQUFDeUksY0FBYyxHQUFHLElBQUk7WUFDMUIsSUFBSSxDQUFDOEMsb0JBQW9CLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQ3hDLFVBQVUsRUFBRSxJQUFJLENBQUNwWSxLQUFLLEVBQUUsSUFBSSxDQUFDd1UsTUFBTSxDQUFDO1VBQzNFLENBQUMsQ0FBQyxPQUFPaGxCLENBQUMsRUFBRTtZQUNWeEUsUUFBSSxDQUFDcWhCLHdDQUFJLEVBQUUsd0NBQXdDLEdBQUc3YyxDQUFDLENBQUNyRyxPQUFPLENBQUM7VUFDbEU7UUFDRixDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUNpdkIsVUFBVSxJQUFJL0ksVUFBVSxJQUFJLEdBQUcsRUFBRTtVQUMvQyxJQUFJLENBQUN5SSxjQUFjLEdBQUcsS0FBSztVQUMzQixJQUFJLENBQUM4QyxvQkFBb0IsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDeEMsVUFBVSxFQUFFLElBQUksQ0FBQ3BZLEtBQUssRUFBRSxJQUFJLENBQUN3VSxNQUFNLENBQUM7UUFDNUU7TUFDRixDQUFDLE1BQU07UUFDTCxJQUFJLENBQUN4VSxLQUFLLENBQUNnVyxXQUFXLEdBQUc1RixRQUFRLEdBQUdmLFVBQVUsR0FBR2UsUUFBUSxHQUFHZixVQUFVO01BQ3hFO0lBQ0Y7RUFBQztJQUFBO0lBQUEsT0FFRCw0QkFBb0I7TUFDbEIsSUFBSTtRQUNGLElBQUksSUFBSSxDQUFDbUYsTUFBTSxFQUFFO1VBQ2Y3WixPQUFXLENBQUMvQixnQkFBZ0IsQ0FBQyxJQUFJLENBQUM0YixNQUFNLENBQUM7UUFDM0M7TUFDRixDQUFDLENBQ0QsT0FBT2hsQixDQUFDLEVBQUU7UUFDUixNQUFNQSxDQUFDO1FBQ1A7TUFDRjtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0VBSEU7SUFBQTtJQUFBLE9BSUEscUJBQWE7TUFDWCxJQUFJO1FBQ0YsSUFBSSxDQUFDK25CLElBQUksRUFBRTtRQUNYLElBQUksQ0FBQ3ZYLEtBQUssQ0FBQzhWLE9BQU8sQ0FBQ25kLElBQUksQ0FBQyxJQUFJLENBQUNxSCxLQUFLLENBQUM7TUFDckMsQ0FBQyxDQUNELE9BQU94USxDQUFDLEVBQUU7UUFDUjtNQUFBO0lBRUo7O0lBRUE7QUFDRjtBQUNBO0VBRkU7SUFBQTtJQUFBLE9BR0Esc0JBQWM7TUFDWixJQUFJLENBQUNnb0IsUUFBUSxFQUFFO0lBQ2pCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQRTtJQUFBO0lBQUEsT0FRQSxpQ0FBeUIzbkIsV0FBVyxFQUFFO01BQ3BDLElBQUksSUFBSSxDQUFDK2tCLFNBQVMsSUFBSy9rQixXQUFXLEdBQUcsR0FBRyxLQUFLLENBQUUsRUFBRTtRQUMvQyxJQUFJLElBQUksQ0FBQzJrQixNQUFNLEVBQUU7VUFDZixJQUFJLENBQUNBLE1BQU0sQ0FBQ2piLFNBQVMsQ0FBQ2dXLEdBQUcsQ0FBQywwQkFBMEIsQ0FBQztRQUN2RDtRQUNBLElBQUksQ0FBQ3ZQLEtBQUssQ0FBQ3pHLFNBQVMsQ0FBQ2lXLE1BQU0sQ0FBQywwQkFBMEIsQ0FBQztNQUN6RDtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtJQUNFO0VBQUE7SUFBQTtJQUFBLE9BQ0Esd0NBQWdDdlgsT0FBTyxFQUFFLENBQUM7O0lBRTFDO0VBQUE7SUFBQTtJQUFBLE9BQ0EsMkNBQW1DQSxPQUFPLEVBQUUsQ0FBQzs7SUFFN0M7RUFBQTtJQUFBO0lBQUEsT0FDQSw0QkFBb0J0UCxJQUFJLEVBQUU4dUIsUUFBUSxFQUFFdHVCLE9BQU8sRUFBRSxDQUFDOztJQUU5QztFQUFBO0lBQUE7SUFBQSxPQUNBLG9DQUE0QlIsSUFBSSxFQUFFMEUsR0FBRyxFQUFFRSxLQUFLLEVBQUUsQ0FBQzs7SUFFL0M7RUFBQTtJQUFBO0lBQUEsT0FDQSwrQkFBdUIrZCxnQkFBZ0IsRUFBRSxDQUFDOztJQUUxQztFQUFBO0lBQUE7SUFBQSxPQUNBLCtCQUF1QkEsZ0JBQWdCLEVBQUUsQ0FBQzs7SUFFMUM7RUFBQTtJQUFBO0lBQUEsT0FDQSwyQkFBbUJBLGdCQUFnQixFQUFFLENBQUM7O0lBR3RDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSx1QkFBZTtNQUNiLE9BQU8sSUFBSSxDQUFDc0osU0FBUztJQUN2Qjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsbUJBQVc7TUFDVCxPQUFPLElBQUksQ0FBQ0YsVUFBVTtJQUN4Qjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLEtBS0EsZUFBYTtNQUNYLE9BQU8sS0FBSztJQUNkOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsT0FKRTtJQUFBLEtBS0EsYUFBV25uQixLQUFLLEVBQUU7TUFDaEI7SUFBQTtFQUNEO0lBQUE7SUFBQSxLQUVELGVBQWtCO01BQ2hCLE9BQU8sSUFBSSxDQUFDcXFCLFdBQVc7SUFDekIsQ0FBQztJQUFBLEtBRUQsYUFBZ0JycUIsS0FBSyxFQUFFO01BQ3JCLElBQUksQ0FBQ3FxQixXQUFXLEdBQUdycUIsS0FBSztNQUN4QixJQUFJLElBQUksQ0FBQ3FuQixTQUFTLEVBQUU7UUFDbEIsSUFBSSxDQUFDQSxTQUFTLENBQUN3QyxRQUFRLENBQUM3cEIsS0FBSyxDQUFDO01BQ2hDO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORTtJQUFBO0lBQUEsS0FPQSxlQUEyQjtNQUN6QixPQUFPLElBQUksQ0FBQ3NxQixvQkFBb0I7SUFDbEM7RUFBQztFQUFBO0FBQUEsRUE5MUJvQzVELGtCQUFrQjtBQWsyQjFDMEQsb0lBQXdCLEU7Ozs7Ozs7Ozs7Ozs7OztBQ3ozQlM7QUFDQztBQUNwQjtBQUU3QixJQUFNdEwsc0JBQUksR0FBRyxrQkFBa0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUZBLElBR3FCb1Asa0NBQWdCO0VBQUE7RUFBQTtFQUVuQywwQkFBYTl5QixJQUFJLEVBQUU7SUFBQTtJQUFBO0lBQ2pCO0lBQ0EsTUFBSzRpQixLQUFLLEdBQUc1aUIsSUFBSSxJQUFJMGpCLHNCQUFJO0lBQ3pCLE1BQUtxUCxpQkFBaUIsR0FBRyxFQUFFO0lBQzNCLE1BQUtDLGFBQWEsR0FBRyxFQUFFO0lBQUE7RUFDekI7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEsa0NBQTBCeHlCLE9BQU8sRUFBRTtNQUNqQyxJQUFJO1FBQ0YsT0FBTyxPQUFPQSxPQUFPLENBQUN3RixJQUFJLEtBQUssUUFBUSxHQUFHVyxJQUFJLENBQUNDLEtBQUssQ0FBQ3BHLE9BQU8sQ0FBQ3dGLElBQUksQ0FBQyxHQUFHeEYsT0FBTyxDQUFDd0YsSUFBSTtNQUNuRixDQUFDLENBQ0QsT0FBT2EsQ0FBQyxFQUFFO1FBQ1J4RSxRQUFJLENBQUMsSUFBSSxDQUFDdWdCLEtBQUssRUFBRSw0Q0FBNEMsR0FBR3BpQixPQUFPLENBQUN3RixJQUFJLEdBQUcsV0FBVyxHQUFHYSxDQUFDLENBQUNyRyxPQUFPLENBQUM7TUFDekc7TUFDQSxPQUFPLElBQUk7SUFDYjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFMRTtJQUFBO0lBQUEsT0FNQSw0QkFBb0I4TyxPQUFPLEVBQUU7TUFDM0IsSUFBSSxDQUFDeWpCLGlCQUFpQixDQUFDeHhCLElBQUksQ0FBQytOLE9BQU8sQ0FBQztJQUN0Qzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsaUJBQVM5TyxPQUFPLEVBQUU7TUFBRTtNQUNsQjZCLFFBQUksQ0FBQyxJQUFJLENBQUN1Z0IsS0FBSyxFQUFFLGdDQUFnQyxDQUFDO0lBQ3BEOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUxFO0lBQUE7SUFBQSxPQU1BLGNBQU1xUSxPQUFPLEVBQUU7TUFBRztNQUNoQjV3QixRQUFJLENBQUMsSUFBSSxDQUFDdWdCLEtBQUssRUFBRSw2QkFBNkIsQ0FBQztJQUNqRDs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsbUJBQVdzUSxXQUFXLEVBQUU7TUFDdEIsSUFBTTl1QixDQUFDLEdBQUcsSUFBSW5CLGVBQWUsRUFBRTtNQUMvQixJQUFNb0ssRUFBRSxHQUFHbUgsSUFBSSxDQUFDc1csS0FBSyxDQUFDdFcsSUFBSSxDQUFDMmUsTUFBTSxFQUFFLEdBQUcsT0FBTyxDQUFDLENBQUNsaUIsUUFBUSxDQUFDLEVBQUUsQ0FBQztNQUMzRGlpQixXQUFXLENBQUM3bEIsRUFBRSxHQUFHQSxFQUFFO01BQ25CNmxCLFdBQVcsQ0FBQ0UsS0FBSyxHQUFHLElBQUk7TUFDeEIsSUFBSSxDQUFDSixhQUFhLENBQUN6eEIsSUFBSSxDQUFDO1FBQUM4TCxFQUFFLEVBQUVBLEVBQUU7UUFBRTFLLE9BQU8sRUFBRXlCO01BQUMsQ0FBQyxDQUFDO01BQzdDLElBQUksQ0FBQ2l2QixJQUFJLENBQUNILFdBQVcsQ0FBQztNQUN0QixPQUFPOXVCLENBQUMsQ0FBQ3pCLE9BQU87SUFDbEI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLHdDQUFnQzJNLE9BQU8sRUFBRTtNQUN2QyxJQUFJLENBQUN5akIsaUJBQWlCLENBQUN4eEIsSUFBSSxDQUFDK04sT0FBTyxDQUFDO0lBQ3RDOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSwyQ0FBbUNBLE9BQU8sRUFBRTtNQUMxQyxJQUFJbEssQ0FBQyxHQUFHLElBQUksQ0FBQzJ0QixpQkFBaUIsQ0FBQ3B2QixNQUFNO01BQ3JDLElBQUkydkIsUUFBUTtNQUNaLE9BQU0sRUFBRWx1QixDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7UUFDZGt1QixRQUFRLEdBQUcsSUFBSSxDQUFDUCxpQkFBaUIsQ0FBQzN0QixDQUFDLENBQUM7UUFDcEMsSUFBSWt1QixRQUFRLEtBQUtoa0IsT0FBTyxFQUFFO1VBQ3hCLElBQUksQ0FBQ3lqQixpQkFBaUIsQ0FBQ3Z0QixNQUFNLENBQUNKLENBQUMsRUFBRSxDQUFDLENBQUM7VUFDbkM7UUFDRjtNQUNGO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEsK0JBQXVCNUUsT0FBTyxFQUFFO01BQzlCLElBQUk0RSxDQUFDLEVBQUVrSyxPQUFPO01BQ2QsSUFBSTNMLE1BQU0sR0FBRyxJQUFJLENBQUNvdkIsaUJBQWlCLENBQUNwdkIsTUFBTTtNQUMxQyxLQUFLeUIsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHekIsTUFBTSxFQUFFeUIsQ0FBQyxFQUFFLEVBQUU7UUFDM0JrSyxPQUFPLEdBQUcsSUFBSSxDQUFDeWpCLGlCQUFpQixDQUFDM3RCLENBQUMsQ0FBQztRQUNuQyxJQUFJa0ssT0FBTyxDQUFDaWtCLE9BQU8sQ0FBQy95QixPQUFPLENBQUMsRUFBRTtVQUM1QixPQUFPLElBQUk7UUFDYjtNQUNGO01BQ0EsT0FBTyxLQUFLO0lBQ2Q7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLCtCQUF1QlIsSUFBSSxFQUFFO01BQzNCLElBQUksQ0FBQ3F6QixJQUFJLENBQUM7UUFDUkcscUJBQXFCLEVBQUU7VUFDckJ4ekIsSUFBSSxFQUFFQTtRQUNSO01BQ0YsQ0FBQyxDQUFDO0lBQ0o7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLCtCQUF1QkEsSUFBSSxFQUFFO01BQzNCLElBQUksQ0FBQ3F6QixJQUFJLENBQUM7UUFDUkksbUJBQW1CLEVBQUU7VUFDbkJ6ekIsSUFBSSxFQUFFQTtRQUNSO01BQ0YsQ0FBQyxDQUFDO0lBQ0o7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORTtJQUFBO0lBQUEsT0FPQSw0QkFBb0JBLElBQUksRUFBRStQLFVBQVUsRUFBRS9KLElBQUksRUFBRTtNQUMxQyxJQUFJLENBQUNxdEIsSUFBSSxDQUFDO1FBQ1JLLGdCQUFnQixFQUFFO1VBQ2hCMXpCLElBQUksRUFBRUEsSUFBSTtVQUNWMnpCLE1BQU0sRUFBRTVqQixVQUFVO1VBQ2xCdlAsT0FBTyxFQUFFd0Y7UUFDWDtNQUNGLENBQUMsQ0FBQztJQUNKOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0Esb0NBQTRCaEcsSUFBSSxFQUFFMEUsR0FBRyxFQUFFRSxLQUFLLEVBQUU7TUFDNUMsSUFBSSxDQUFDeXVCLElBQUksQ0FBQztRQUNSTyx1QkFBdUIsRUFBRTtVQUN2QjV6QixJQUFJLEVBQUVBLElBQUk7VUFDVjBFLEdBQUcsRUFBRUEsR0FBRztVQUNSRSxLQUFLLEVBQUVBO1FBQ1Q7TUFDRixDQUFDLENBQUM7SUFDSjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsMkJBQW1CNUUsSUFBSSxFQUFFO01BQ3ZCLElBQUksQ0FBQ3F6QixJQUFJLENBQUM7UUFDUlEsaUJBQWlCLEVBQUU7VUFDakI3ekIsSUFBSSxFQUFFQTtRQUNSO01BQ0YsQ0FBQyxDQUFDO0lBQ0o7RUFBQztFQUFBO0FBQUEsRUF4TDJDZ0YsYUFBWTs7O0FDVDlDOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRXFDO0FBQ1Q7QUFDVTtBQUlqQztBQUN5QjtBQUUxQyxJQUFNMGUsa0JBQUksR0FBRyxrQkFBa0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQSxJQUtNb1EsMEJBQVk7RUFBQTtFQUFBO0VBRWhCLHNCQUFhQyxTQUFTLEVBQUUvekIsSUFBSSxFQUFFO0lBQUE7SUFBQTtJQUM1QiwwQkFBTUEsSUFBSSxJQUFJMGpCLGtCQUFJO0lBQ2xCLE1BQUtzUSxVQUFVLEdBQUdELFNBQVM7SUFDM0IsTUFBS0Usb0JBQW9CLEdBQUcsRUFBRTtJQUM5QixNQUFLQyxVQUFVLEdBQUc3eUIsU0FBUztJQUMzQixNQUFLOHlCLGtCQUFrQixHQUFHOXlCLFNBQVM7SUFDbkMsTUFBSzB4QixpQkFBaUIsR0FBRyxFQUFFO0lBQzNCLE1BQUtxQixhQUFhLEdBQUcsS0FBSztJQUMxQixNQUFLQyxXQUFXLEdBQUcsQ0FBQztJQUNwQixNQUFLQyxXQUFXLEdBQUcsQ0FBQztJQUNwQixNQUFLQyxnQkFBZ0IsR0FBRyxDQUFDO0lBQ3pCLE1BQUtDLGdCQUFnQixHQUFHLEVBQUU7SUFDMUIsTUFBS0MsVUFBVSxHQUFHLENBQUM7SUFDbkIsTUFBS0MsUUFBUSxHQUFHLE1BQUtDLFFBQVEsQ0FBQ2xRLElBQUksQ0FBQywyQ0FBSztJQUV4QyxNQUFLbVEsY0FBYyxHQUFHLENBQUM7SUFBQTtFQUN6QjtFQUFDO0lBQUE7SUFBQSxPQUVELDZCQUFxQkMsRUFBRSxFQUFFbHlCLE9BQU8sRUFBRTtNQUFBO01BQ2hDO01BQ0EsSUFBSW15QixPQUFPLEdBQUc5cEIsVUFBVSxDQUFDLFlBQU07UUFDN0JzZSxZQUFZLENBQUN3TCxPQUFPLENBQUM7UUFDckIsSUFBSUQsRUFBRSxDQUFDcG1CLFVBQVUsS0FBSyxDQUFDLEVBQUU7VUFDdkJ0TSxJQUFJLENBQUMsTUFBSSxDQUFDeWdCLEtBQUssRUFBRSxpQkFBaUIsQ0FBQztVQUNuQyxNQUFJLENBQUM2UixVQUFVLEdBQUcsQ0FBQztVQUNuQixPQUFPLE1BQUksQ0FBQ1Isb0JBQW9CLENBQUN0d0IsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUMzQyxNQUFJLENBQUMwdkIsSUFBSSxDQUFDLE1BQUksQ0FBQ1ksb0JBQW9CLENBQUNyd0IsS0FBSyxFQUFFLENBQUM7VUFDOUM7VUFDQSxJQUFJLE1BQUksQ0FBQ293QixVQUFVLElBQUksTUFBSSxDQUFDQSxVQUFVLENBQUNlLFlBQVksRUFBRTtZQUNuRCxNQUFJLENBQUNmLFVBQVUsQ0FBQ2UsWUFBWSxFQUFFO1VBQ2hDO1VBQ0EsTUFBSSxDQUFDek8sT0FBTyxDQUFDLElBQUl6RCwwQkFBMEIsQ0FBQ3BCLCtCQUErQixDQUFDQyxJQUFJLEVBQUUsTUFBSSxDQUFDa0IsS0FBSyxFQUFFO1lBQUNvUyxNQUFNLEVBQUU7VUFBSSxDQUFDLENBQUMsQ0FBQztRQUNoSCxDQUFDLE1BQU0sSUFBR0gsRUFBRSxDQUFDcG1CLFVBQVUsS0FBSyxDQUFDLEVBQUU7VUFDN0IsSUFBSSxFQUFFLE1BQUksQ0FBQzhsQixnQkFBZ0IsR0FBRyxNQUFJLENBQUNDLGdCQUFnQixFQUFFO1lBQ25EbnlCLFFBQUksQ0FBQyxNQUFJLENBQUN1Z0IsS0FBSywyREFBb0QsTUFBSSxDQUFDMlIsZ0JBQWdCLEdBQUMsQ0FBQyx1Q0FBb0M7WUFDOUg7WUFDQTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7WUFDVSxNQUFJLENBQUNVLFVBQVUsRUFBRTtZQUNqQnR5QixPQUFPLENBQUNELE1BQU0sQ0FBQztjQUFDakIsSUFBSSxFQUFFO1lBQVMsQ0FBQyxDQUFDO1lBQ2pDLE1BQUksQ0FBQ2t6QixRQUFRLEVBQUU7VUFDakIsQ0FBQyxNQUFNO1lBQ0x4eUIsSUFBSSxDQUFDLE1BQUksQ0FBQ3lnQixLQUFLLHlFQUFrRSxNQUFJLENBQUMyUixnQkFBZ0IsVUFBTztZQUM3RyxNQUFJLENBQUNLLGNBQWMsR0FBRyxNQUFJLENBQUNNLG1CQUFtQixDQUFDTCxFQUFFLEVBQUVseUIsT0FBTyxDQUFDO1VBQzdEO1FBQ0YsQ0FBQyxNQUFNO1VBQ0xSLElBQUksQ0FBQyxNQUFJLENBQUN5Z0IsS0FBSyxpRUFBMERpUyxFQUFFLENBQUNwbUIsVUFBVSxRQUFLO1FBQzdGO01BQ0YsQ0FBQyxFQUFFLEdBQUcsQ0FBQztNQUNQLE9BQU9xbUIsT0FBTztJQUNoQjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQU5FO0lBQUE7SUFBQSxPQU9BLCtCQUF1QkQsRUFBRSxFQUFFO01BQ3pCLElBQUlBLEVBQUUsRUFBRTtRQUNOQSxFQUFFLENBQUNNLE1BQU0sR0FBRzl6QixTQUFTO1FBQ3JCd3pCLEVBQUUsQ0FBQ08sU0FBUyxHQUFHL3pCLFNBQVM7UUFDeEJ3ekIsRUFBRSxDQUFDUSxPQUFPLEdBQUdoMEIsU0FBUztRQUN0Qnd6QixFQUFFLENBQUNTLE9BQU8sR0FBR2owQixTQUFTO01BQ3hCO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUkU7SUFBQTtJQUFBLE9BU0EsNEJBQW9Cd3pCLEVBQUUsRUFBRWx5QixPQUFPLEVBQUU7TUFBQTtNQUUvQjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7TUFFSSxJQUFJLENBQUM4eEIsVUFBVSxHQUFHLENBQUM7TUFDbkIsSUFBSSxDQUFDRixnQkFBZ0IsR0FBRyxDQUFDO01BQ3pCakwsWUFBWSxDQUFDLElBQUksQ0FBQ3NMLGNBQWMsQ0FBQztNQUNqQyxJQUFJLENBQUNBLGNBQWMsR0FBRyxJQUFJLENBQUNNLG1CQUFtQixDQUFDTCxFQUFFLEVBQUVseUIsT0FBTyxDQUFDO01BRTNEa3lCLEVBQUUsQ0FBQ1EsT0FBTyxHQUFHLFVBQUMveUIsS0FBSyxFQUFLO1FBQ3RCRCxRQUFJLENBQUMsTUFBSSxDQUFDdWdCLEtBQUssb0RBQTZDdGdCLEtBQUssQ0FBQ2IsSUFBSSxPQUFJO1FBQzFFLE1BQUksQ0FBQ3d6QixVQUFVLEVBQUU7UUFDakJ0eUIsT0FBTyxDQUFDRCxNQUFNLENBQUNKLEtBQUssQ0FBQztRQUNyQixNQUFJLENBQUNna0IsT0FBTyxDQUFDLElBQUl6RCwwQkFBMEIsQ0FBQ3BCLCtCQUErQixDQUFDemdCLEtBQUssRUFBRSxNQUFJLENBQUM0aEIsS0FBSyxFQUFFO1VBQUNvUyxNQUFNLEVBQUUsTUFBSTtVQUFFMXlCLEtBQUssRUFBRUE7UUFBSyxDQUFDLENBQUMsQ0FBQztNQUMvSCxDQUFDO01BRUR1eUIsRUFBRSxDQUFDTyxTQUFTLEdBQUcsVUFBQzUwQixPQUFPLEVBQUs7UUFDMUIsTUFBSSxDQUFDK3lCLE9BQU8sQ0FBQy95QixPQUFPLENBQUM7TUFDdkIsQ0FBQztNQUVEcTBCLEVBQUUsQ0FBQ1MsT0FBTyxHQUFHLFVBQUNud0IsS0FBSyxFQUFLO1FBQ3RCLElBQUlBLEtBQUssQ0FBQzJuQixJQUFJLEdBQUcsSUFBSSxFQUFFO1VBQ3JCenFCLFFBQUksQ0FBQyxNQUFJLENBQUN1Z0IsS0FBSyw4QkFBdUJ6ZCxLQUFLLENBQUMybkIsSUFBSSxFQUFHO1FBQ3JELENBQUMsTUFBTTtVQUNMMXFCLFNBQUssQ0FBQyxNQUFJLENBQUN3Z0IsS0FBSyw4QkFBdUJ6ZCxLQUFLLENBQUMybkIsSUFBSSxFQUFHO1FBQ3REO1FBQ0EsSUFBSSxNQUFJLENBQUNrSCxVQUFVLElBQUksTUFBSSxDQUFDQSxVQUFVLENBQUN1QixhQUFhLEVBQUU7VUFDcEQsTUFBSSxDQUFDdkIsVUFBVSxDQUFDdUIsYUFBYSxDQUFDcHdCLEtBQUssQ0FBQztRQUN0QztRQUNBLE1BQUksQ0FBQzh2QixVQUFVLEVBQUU7UUFDakIsTUFBSSxDQUFDTyxxQkFBcUIsQ0FBQ1gsRUFBRSxJQUFJLE1BQUksQ0FBQ1gsVUFBVSxDQUFDO1FBQ2pELE1BQUksQ0FBQ08sVUFBVSxHQUFHLENBQUM7UUFDbkIsTUFBSSxDQUFDbk8sT0FBTyxDQUFDLElBQUl6RCwwQkFBMEIsQ0FBQ3BCLCtCQUErQixDQUFDRSxLQUFLLEVBQUUsTUFBSSxDQUFDaUIsS0FBSyxFQUFFO1VBQUNvUyxNQUFNLEVBQUUsTUFBSTtVQUFFN3ZCLEtBQUssRUFBRUE7UUFBSyxDQUFDLENBQUMsQ0FBQztNQUMvSCxDQUFDO0lBRUg7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORTtJQUFBO0lBQUEsT0FPQSxrQ0FBMEI3QyxLQUFLLEVBQUU7TUFDL0IsSUFBSSxJQUFJLENBQUMweEIsVUFBVSxJQUFJLElBQUksQ0FBQ0EsVUFBVSxDQUFDdUIsYUFBYSxFQUFFO1FBQ3BELElBQUksQ0FBQ3ZCLFVBQVUsQ0FBQ3VCLGFBQWEsQ0FBQ2p6QixLQUFLLENBQUM7TUFDdEM7TUFDQSxJQUFJLENBQUNna0IsT0FBTyxDQUFDLElBQUl6RCwwQkFBMEIsQ0FBQ3BCLCtCQUErQixDQUFDRSxLQUFLLEVBQUUsSUFBSSxDQUFDaUIsS0FBSyxFQUFFO1FBQUNvUyxNQUFNLEVBQUU7TUFBSSxDQUFDLENBQUMsQ0FBQztNQUMvRzN5QixRQUFJLENBQUMsSUFBSSxDQUFDdWdCLEtBQUssd0VBQWlFdGdCLEtBQUssQ0FBQ2IsSUFBSSxlQUFLYSxLQUFLLENBQUNtekIsTUFBTSxFQUFHO01BQzlHLElBQUksQ0FBQ1IsVUFBVSxFQUFFO01BQ2pCLElBQUksQ0FBQ08scUJBQXFCLENBQUMsSUFBSSxDQUFDdEIsVUFBVSxDQUFDO0lBQzdDOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxzQkFBYztNQUNaLElBQUksQ0FBQ0csV0FBVyxHQUFHLENBQUM7TUFDcEIsSUFBSSxDQUFDRSxnQkFBZ0IsR0FBRyxDQUFDO01BQ3pCakwsWUFBWSxDQUFDLElBQUksQ0FBQ3NMLGNBQWMsQ0FBQztJQUNuQzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEsZUFBT3BuQixHQUFHLEVBQUVrb0IsWUFBWSxFQUFFO01BQUE7TUFDeEIsSUFBTUMsY0FBYyxHQUFHM2pCLE9BQVcsQ0FBQzdGLFFBQVEsRUFBRSxJQUFJNkYsT0FBVyxDQUFDNUYsU0FBUyxFQUFFO01BQ3hFaEssU0FBSyxDQUFDLElBQUksQ0FBQ3dnQixLQUFLLDhCQUF1QnBWLEdBQUcsT0FBSTtNQUM5QyxJQUFJLENBQUNtbkIsUUFBUSxFQUFFO01BQ2YsSUFBSSxDQUFDUCxhQUFhLEdBQUcsS0FBSztNQUMxQixJQUFJLENBQUNELGtCQUFrQixHQUFHdUIsWUFBWTtNQUN0QzFqQixPQUFXLENBQUNyQyxlQUFlLENBQUMsSUFBSSxDQUFDK2tCLFFBQVEsQ0FBQztNQUMxQyxJQUFJLENBQUNSLFVBQVUsR0FBRzBCLGdCQUFnQixDQUFDcG9CLEdBQUcsQ0FBQztNQUN2QyxJQUFJLENBQUNxb0Isa0JBQWtCLENBQUMsSUFBSSxDQUFDM0IsVUFBVSxFQUFFLElBQUksQ0FBQ0Msa0JBQWtCLENBQUM7TUFDakUsSUFBSXdCLGNBQWMsSUFBSSxJQUFJLENBQUN0QixXQUFXLEVBQUUsR0FBRyxJQUFJLENBQUNDLFdBQVcsRUFBRTtRQUMzRGx5QixTQUFLLENBQUMsSUFBSSxDQUFDd2dCLEtBQUssRUFBRSxvRUFBb0UsQ0FBQztRQUN2RixJQUFJa1MsT0FBTyxHQUFHOXBCLFVBQVUsQ0FBQyxZQUFNO1VBQzdCLElBQUksTUFBSSxDQUFDa3BCLFVBQVUsSUFBSSxNQUFJLENBQUNBLFVBQVUsQ0FBQ3psQixVQUFVLEtBQUssQ0FBQyxFQUFFO1lBQ3ZEck0sU0FBSyxDQUFDLE1BQUksQ0FBQ3dnQixLQUFLLDJCQUEyQjtZQUMzQ3hnQixTQUFLLENBQUMsTUFBSSxDQUFDd2dCLEtBQUssRUFBRSxxRkFBcUYsQ0FBQztZQUN4RyxNQUFJLENBQUM0UyxxQkFBcUIsQ0FBQyxNQUFJLENBQUN0QixVQUFVLENBQUM7WUFDM0MsTUFBSSxDQUFDNEIsS0FBSyxDQUFDdG9CLEdBQUcsRUFBRWtvQixZQUFZLENBQUM7VUFDL0I7VUFDQXBNLFlBQVksQ0FBQ3dMLE9BQU8sQ0FBQztRQUN2QixDQUFDLEVBQUUsSUFBSSxDQUFDO01BQ1Y7SUFDRjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFSRTtJQUFBO0lBQUEsT0FTQSx5QkFBaUJFLE1BQU0sRUFBRVUsWUFBWSxFQUFFO01BQ3JDdHpCLFNBQUssQ0FBQyxJQUFJLENBQUN3Z0IsS0FBSyx3Q0FBaUNvUyxNQUFNLENBQUN4bkIsR0FBRyxPQUFJO01BQy9ELElBQUksQ0FBQ21uQixRQUFRLEVBQUU7TUFDZixJQUFJLENBQUNQLGFBQWEsR0FBRyxLQUFLO01BQzFCLElBQUksQ0FBQ0Qsa0JBQWtCLEdBQUd1QixZQUFZO01BQ3RDMWpCLE9BQVcsQ0FBQ3JDLGVBQWUsQ0FBQyxJQUFJLENBQUMra0IsUUFBUSxDQUFDO01BQzFDLElBQUksQ0FBQ1IsVUFBVSxHQUFHYyxNQUFNO01BQ3hCLElBQUksQ0FBQ2Esa0JBQWtCLENBQUMsSUFBSSxDQUFDM0IsVUFBVSxFQUFFLElBQUksQ0FBQ0Msa0JBQWtCLENBQUM7SUFDbkU7O0lBRUE7QUFDRjtBQUNBO0VBRkU7SUFBQTtJQUFBLE9BR0EsZUFBT2xCLE9BQU8sRUFBRTtNQUNkN3dCLFNBQUssQ0FBQyxJQUFJLENBQUN3Z0IsS0FBSyxFQUFFLG1CQUFtQixDQUFDO01BQ3RDLElBQUksSUFBSSxDQUFDc1IsVUFBVSxFQUFFO1FBQ25CLElBQUlqQixPQUFPLEVBQUU7VUFDWCxJQUFJLENBQUNJLElBQUksQ0FBQ0osT0FBTyxDQUFDO1FBQ3BCO1FBQ0EsSUFBSSxDQUFDdUMscUJBQXFCLENBQUMsSUFBSSxDQUFDdEIsVUFBVSxDQUFDO1FBQzNDLElBQUksQ0FBQ1MsUUFBUSxFQUFFO01BQ2pCO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0VBRkU7SUFBQTtJQUFBLE9BR0Esb0JBQVk7TUFDVixJQUFJLENBQUNWLG9CQUFvQixDQUFDdHdCLE1BQU0sR0FBRyxDQUFDO01BQ3BDLElBQUksT0FBTyxJQUFJLENBQUN1d0IsVUFBVSxLQUFLLFdBQVcsSUFBSSxDQUFDLElBQUksQ0FBQ0UsYUFBYSxFQUFFO1FBQ2pFaHlCLFNBQUssQ0FBQyxJQUFJLENBQUN3Z0IsS0FBSyxFQUFFLGVBQWUsQ0FBQztRQUNsQ3hnQixTQUFLLENBQUMsSUFBSSxDQUFDd2dCLEtBQUssdUJBQWdCLElBQUksQ0FBQ3NSLFVBQVUsQ0FBQzFtQixHQUFHLG1CQUFnQjtRQUNuRTtRQUNBLElBQUk7VUFDRixJQUFJLENBQUMwbUIsVUFBVSxDQUFDOWIsS0FBSyxFQUFFO1FBQ3pCLENBQUMsQ0FBQyxPQUFPdlIsQ0FBQyxFQUFFO1VBQ1Z4RSxRQUFJLENBQUMsSUFBSSxDQUFDdWdCLEtBQUssK0NBQXdDL2IsQ0FBQyxDQUFDckcsT0FBTyxPQUFJO1VBQ3BFLElBQUksQ0FBQ2cxQixxQkFBcUIsQ0FBQyxJQUFJLENBQUN0QixVQUFVLENBQUM7UUFDN0MsQ0FBQyxTQUFTO1VBQ1IsSUFBSSxJQUFJLENBQUNBLFVBQVUsRUFBRTtZQUNuQjl4QixTQUFLLENBQUMsSUFBSSxDQUFDd2dCLEtBQUssMEJBQW1CLElBQUksQ0FBQ3NSLFVBQVUsQ0FBQzFtQixHQUFHLGdCQUFhO1VBQ3JFO1FBQ0Y7UUFDQXBMLFNBQUssQ0FBQyxJQUFJLENBQUN3Z0IsS0FBSyxFQUFFLGVBQWUsQ0FBQztNQUNwQztNQUNBLElBQUksQ0FBQ3NSLFVBQVUsR0FBRzd5QixTQUFTO01BQzNCLElBQUksQ0FBQyt5QixhQUFhLEdBQUcsSUFBSTtNQUN6QixJQUFJLENBQUNLLFVBQVUsR0FBRyxDQUFDO01BQ25CLE9BQU0sSUFBSSxDQUFDMUIsaUJBQWlCLENBQUNwdkIsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUN2QyxJQUFJLENBQUNvdkIsaUJBQWlCLENBQUNudkIsS0FBSyxFQUFFO01BQ2hDO01BQ0FvTyxPQUFXLENBQUNuQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUM2a0IsUUFBUSxDQUFDO0lBQy9DOztJQUVBO0FBQ0Y7QUFDQTtFQUZFO0lBQUE7SUFBQSxPQUdBLDZCQUFxQnFCLFVBQVUsRUFBRTtNQUMvQixJQUFJLENBQUMxQyxJQUFJLENBQUM7UUFDUjJDLGVBQWUsRUFBRUQsVUFBVTtRQUMzQi92QixJQUFJLEVBQUU7VUFDSml3QixTQUFTLEVBQUU7WUFDVHgwQixJQUFJLEVBQUUsV0FBVztZQUNqQncwQixTQUFTLEVBQUU7VUFDYjtRQUNGO01BQ0YsQ0FBQyxDQUFDO0lBQ0o7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEsY0FBTS9DLFdBQVcsRUFBRTtNQUNqQixJQUFJLElBQUksQ0FBQ2dCLFVBQVUsS0FBSzd5QixTQUFTLElBQUksSUFBSSxDQUFDb3pCLFVBQVUsS0FBSyxDQUFDLENBQUMsc0JBQXNCO1FBQy9FLElBQUk7VUFDRnJ5QixTQUFLLENBQUMsSUFBSSxDQUFDd2dCLEtBQUssRUFBRSxvQkFBb0IsR0FBR2pjLElBQUksQ0FBQzRPLFNBQVMsQ0FBQzJkLFdBQVcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7VUFDOUUsSUFBSSxDQUFDZ0IsVUFBVSxDQUFDZ0MsSUFBSSxDQUFDdnZCLElBQUksQ0FBQzRPLFNBQVMsQ0FBQzJkLFdBQVcsQ0FBQyxDQUFDO1VBQ2pELE9BQU8sSUFBSTtRQUNiLENBQUMsQ0FDRCxPQUFPcnNCLENBQUMsRUFBRTtVQUNSekUsU0FBSyxDQUFDLElBQUksQ0FBQ3dnQixLQUFLLG9DQUE2QnNRLFdBQVcsZUFBS3JzQixDQUFDLEVBQUc7VUFDakUsT0FBTyxLQUFLO1FBQ2Q7TUFDRixDQUFDLE1BQ0ksSUFBSSxJQUFJLENBQUNxdEIsVUFBVSxLQUFLN3lCLFNBQVMsS0FDakMsSUFBSSxDQUFDNnlCLFVBQVUsQ0FBQ3psQixVQUFVLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQ3lsQixVQUFVLENBQUN6bEIsVUFBVSxLQUFLLENBQUMsQ0FBQyxFQUFFLGtDQUFtQztVQUM3RyxPQUFPLEtBQUs7UUFDZCxDQUFDLE1BQ0ksSUFBSSxJQUFJLENBQUMybEIsYUFBYSxFQUFFO1FBQzNCLE9BQU8sS0FBSztNQUNkLENBQUMsTUFDSTtRQUNILElBQUksQ0FBQ0gsb0JBQW9CLENBQUMxeUIsSUFBSSxDQUFDMnhCLFdBQVcsQ0FBQztRQUMzQyxPQUFPLElBQUk7TUFDYjtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxpQkFBUzF5QixPQUFPLEVBQUU7TUFBRTtNQUNsQixJQUFJMjFCLE9BQU8sR0FBRyxJQUFJLENBQUNDLHFCQUFxQixDQUFDNTFCLE9BQU8sQ0FBQztNQUNqRCxJQUFJLENBQUMyMUIsT0FBTyxJQUFJMzFCLE9BQU8sQ0FBQ3dGLElBQUksRUFBRTtRQUM1QixJQUFJcXdCLElBQUksR0FBRyxJQUFJLENBQUNDLHdCQUF3QixDQUFDOTFCLE9BQU8sQ0FBQztRQUNqRCxJQUFJNjFCLElBQUksS0FBSyxJQUFJLEVBQUU7VUFDakJoMEIsUUFBSSxDQUFDLElBQUksQ0FBQ3VnQixLQUFLLEVBQUUsK0VBQStFLENBQUM7VUFDakcsT0FBTyxJQUFJO1FBQ2I7UUFDQXhnQixTQUFLLENBQUMsSUFBSSxDQUFDd2dCLEtBQUssRUFBRSx3QkFBd0IsR0FBR2pjLElBQUksQ0FBQzRPLFNBQVMsQ0FBQzhnQixJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzNFLElBQUlBLElBQUksQ0FBQ0UsV0FBVyxLQUFLbDFCLFNBQVMsRUFBRTtVQUNsQyxJQUFJLE9BQU9nMUIsSUFBSSxDQUFDRSxXQUFXLEtBQUssU0FBUyxJQUFJRixJQUFJLENBQUNFLFdBQVcsRUFBRTtZQUM3RCxJQUFJLElBQUksQ0FBQ3ZDLFVBQVUsRUFBRTtjQUNuQixJQUFJLENBQUNBLFVBQVUsQ0FBQ3dDLGlCQUFpQixDQUFDSCxJQUFJLENBQUM7WUFDekM7WUFDQSxPQUFPLElBQUk7VUFDYixDQUFDLE1BQU07WUFDTCxJQUFJLElBQUksQ0FBQ3JDLFVBQVUsRUFBRTtjQUNuQixJQUFJLENBQUNBLFVBQVUsQ0FBQ3lDLG1CQUFtQixDQUFDSixJQUFJLENBQUM7WUFDM0M7WUFDQSxPQUFPLElBQUk7VUFDYjtRQUNGLENBQUMsTUFBTSxJQUFJQSxJQUFJLENBQUNqRCxLQUFLLElBQUlpRCxJQUFJLENBQUNocEIsRUFBRSxFQUFFO1VBQ2hDLElBQU1xcEIsTUFBTSxHQUFHLElBQUksQ0FBQzFELGFBQWEsQ0FBQ252QixJQUFJLENBQUMsVUFBQTJJLEVBQUU7WUFBQSxPQUFJQSxFQUFFLENBQUNhLEVBQUUsS0FBS2dwQixJQUFJLENBQUNocEIsRUFBRTtVQUFBLEVBQUM7VUFDL0QsSUFBUTFLLE9BQU8sR0FBSyt6QixNQUFNLENBQWxCL3pCLE9BQU87VUFDZixJQUFJQSxPQUFPLElBQUkwekIsSUFBSSxDQUFDcndCLElBQUksRUFBRTtZQUN4QnJELE9BQU8sQ0FBQ0YsT0FBTyxDQUFDNHpCLElBQUksQ0FBQ3J3QixJQUFJLENBQUM7VUFDNUIsQ0FBQyxNQUFNLElBQUlyRCxPQUFPLElBQUkwekIsSUFBSSxDQUFDL3pCLEtBQUssRUFBRTtZQUNoQ0ssT0FBTyxDQUFDRCxNQUFNLENBQUMyekIsSUFBSSxDQUFDL3pCLEtBQUssQ0FBQztVQUM1QjtRQUNGLENBQUMsTUFBTSxJQUFJK3pCLElBQUksQ0FBQ3J3QixJQUFJLEtBQUszRSxTQUFTLEVBQUU7VUFDbEMsSUFBUTJFLElBQUksR0FBS3F3QixJQUFJLENBQWJyd0IsSUFBSTtVQUNaLElBQUlBLElBQUksQ0FBQ3hGLE9BQU8sS0FBS2EsU0FBUyxFQUFFO1lBQzlCLElBQUkyRSxJQUFJLENBQUN2RSxJQUFJLEtBQUssT0FBTyxJQUFJLElBQUksQ0FBQ3V5QixVQUFVLEVBQUU7Y0FDNUMsSUFBSSxDQUFDQSxVQUFVLENBQUMyQyxvQkFBb0IsQ0FBQzN3QixJQUFJLENBQUN4RixPQUFPLEVBQUV3RixJQUFJLENBQUN5dkIsTUFBTSxDQUFDO2NBQy9ELE9BQU8sSUFBSTtZQUNiO1VBQ0YsQ0FBQyxNQUFNLElBQUl6dkIsSUFBSSxDQUFDdkUsSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUNqQyxJQUFJdUUsSUFBSSxDQUFDOG1CLElBQUksS0FBSywrQkFBK0IsRUFBRTtjQUNqRCxJQUFJLENBQUNvSCxVQUFVLENBQUNtQixPQUFPLEdBQUcsSUFBSSxDQUFDdUIsd0JBQXdCLENBQUNuUyxJQUFJLENBQUMsSUFBSSxDQUFDO2NBQ2xFLElBQUksQ0FBQzBQLGtCQUFrQixDQUFDMXhCLE9BQU8sQ0FBQyxJQUFJLENBQUM7Y0FDckMsT0FBTyxJQUFJO1lBQ2IsQ0FBQyxNQUFNLElBQUl1RCxJQUFJLENBQUM4bUIsSUFBSSxLQUFLLHFDQUFxQyxFQUFFO2NBQzlELElBQUksQ0FBQ2tILFVBQVUsQ0FBQzZDLHNCQUFzQixDQUFDN3dCLElBQUksQ0FBQ3dFLFdBQVcsQ0FBQztjQUN4RCxPQUFPLElBQUk7WUFDYixDQUFDLE1BQU0sSUFBSXhFLElBQUksQ0FBQzhtQixJQUFJLEtBQUssZ0NBQWdDLEVBQUU7Y0FDekQsSUFBSSxDQUFDcUgsa0JBQWtCLENBQUN6eEIsTUFBTSxDQUFDLGdDQUFnQyxDQUFDO2NBQ2hFLE9BQU8sSUFBSTtZQUNiO1VBQ0YsQ0FBQyxNQUFNLElBQUlzRCxJQUFJLENBQUN2RSxJQUFJLEtBQUssT0FBTyxFQUFFO1lBQ2hDLElBQUl1RSxJQUFJLENBQUM4bUIsSUFBSSxLQUFLLGdDQUFnQyxFQUFFO2NBQ2xELElBQUksQ0FBQ3FILGtCQUFrQixDQUFDenhCLE1BQU0sQ0FBQyxnQ0FBZ0MsQ0FBQztjQUNoRSxPQUFPLElBQUk7WUFDYixDQUFDLE1BQU0sSUFBSXNELElBQUksQ0FBQzhtQixJQUFJLEtBQUssOEJBQThCLEVBQUU7Y0FDdkQsSUFBSSxDQUFDcUgsa0JBQWtCLENBQUN6eEIsTUFBTSxDQUFDLDhCQUE4QixDQUFDO2NBQzlELE9BQU8sSUFBSTtZQUNiO1VBQ0Y7UUFDRjtNQUNGO01BQ0EsT0FBT3l6QixPQUFPO0lBQ2hCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsS0FLQSxlQUFvQjtNQUNsQixPQUFPLElBQUksQ0FBQy9CLGFBQWE7SUFDM0I7RUFBQztFQUFBO0FBQUEsRUF6WHdCdEIsa0NBQWdCO0FBNlg1QmdCLDRFQUFZLEU7O0FDL1lmOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUU4QjtBQUNJO0FBQ1YsQ0FBQzs7QUFFckMsSUFBTXBRLHNCQUFJLEdBQUcseUJBQXlCOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BLElBT01vVCwwQ0FBd0I7RUFBQTtFQUFBO0VBRTVCLGtDQUFhL0MsU0FBUyxFQUFFO0lBQUE7SUFBQSx5QkFDaEJBLFNBQVMsRUFBRXJRLHNCQUFJO0VBQ3ZCOztFQUVBO0FBQ0Y7QUFDQTtFQUZFO0lBQUE7SUFBQSxPQUdBLGlCQUFTbGpCLE9BQU8sRUFBRTtNQUNoQixJQUFJQSxPQUFPLENBQUN3RixJQUFJLEVBQUU7UUFDaEIsSUFBSXF3QixJQUFJLEdBQUcsSUFBSSxDQUFDQyx3QkFBd0IsQ0FBQzkxQixPQUFPLENBQUM7UUFDakQsSUFBSSx3R0FBZUEsT0FBTyxDQUFDLEVBQUU7VUFDM0IsSUFBSTYxQixJQUFJLENBQUNyd0IsSUFBSSxLQUFLM0UsU0FBUyxFQUFFO1lBQzNCLElBQUlnMUIsSUFBSSxDQUFDcndCLElBQUksQ0FBQzRTLEdBQUcsS0FBS3ZYLFNBQVMsRUFBRTtjQUMvQixJQUFJZzFCLElBQUksQ0FBQ3J3QixJQUFJLENBQUM0UyxHQUFHLENBQUNuWCxJQUFJLEtBQUssT0FBTyxFQUFFO2dCQUNsQyxJQUFJLENBQUN1eUIsVUFBVSxDQUFDK0MsVUFBVSxDQUFDVixJQUFJLENBQUNyd0IsSUFBSSxDQUFDO2dCQUNyQyxPQUFPLElBQUk7Y0FDYjtZQUNGO1lBQ0EsSUFBSXF3QixJQUFJLENBQUNyd0IsSUFBSSxDQUFDaXdCLFNBQVMsS0FBSzUwQixTQUFTLEVBQUU7Y0FDckMsSUFBSXFVLGFBQWEsQ0FBQzJnQixJQUFJLENBQUNyd0IsSUFBSSxDQUFDaXdCLFNBQVMsQ0FBQyxFQUFFO2dCQUN0QyxJQUFJLENBQUNqQyxVQUFVLENBQUNnRCxnQkFBZ0IsRUFBRTtnQkFDbEMsT0FBTyxJQUFJO2NBQ2IsQ0FBQyxNQUFNO2dCQUNMLElBQUksQ0FBQ2hELFVBQVUsQ0FBQ2lELGlCQUFpQixDQUFDWixJQUFJLENBQUNyd0IsSUFBSSxDQUFDaXdCLFNBQVMsQ0FBQztnQkFDdEQsT0FBTyxJQUFJO2NBQ2I7WUFDRjtZQUNBLElBQUlJLElBQUksQ0FBQ3J3QixJQUFJLENBQUN2RSxJQUFJLEtBQUssUUFBUSxFQUFFO2NBQy9CLElBQUk0MEIsSUFBSSxDQUFDcndCLElBQUksQ0FBQzhtQixJQUFJLEtBQUssbUNBQW1DLElBQ3ZEdUosSUFBSSxDQUFDcndCLElBQUksQ0FBQzhtQixJQUFJLEtBQUssb0NBQW9DLEVBQUU7Z0JBQzFELElBQUksQ0FBQ2tILFVBQVUsQ0FBQ2tELHVCQUF1QixFQUFFO2dCQUN6QyxPQUFPLElBQUk7Y0FDYixDQUFDLE1BQU0sSUFBSWIsSUFBSSxDQUFDcndCLElBQUksQ0FBQzhtQixJQUFJLEtBQUssZ0NBQWdDLEVBQUU7Z0JBQzlELElBQUksQ0FBQ2tILFVBQVUsQ0FBQ21ELFdBQVcsRUFBRTtnQkFDN0IsT0FBTyxJQUFJO2NBQ2IsQ0FBQyxNQUFNLElBQUlkLElBQUksQ0FBQ3J3QixJQUFJLENBQUM4bUIsSUFBSSxLQUFLLDhCQUE4QixFQUFFO2dCQUM1RCxJQUFJLENBQUNrSCxVQUFVLENBQUNvRCxrQkFBa0IsRUFBRTtnQkFDcEMsT0FBTyxJQUFJO2NBQ2IsQ0FBQyxNQUFNO2dCQUNMLElBQUksQ0FBQ3BELFVBQVUsQ0FBQ3FELGtCQUFrQixDQUFDaEIsSUFBSSxDQUFDcndCLElBQUksQ0FBQztnQkFDN0MsT0FBTyxJQUFJO2NBQ2I7WUFDRjtZQUNBLElBQUlxd0IsSUFBSSxDQUFDcndCLElBQUksQ0FBQ3VDLGNBQWMsQ0FBQyxRQUFRLENBQUMsRUFBRTtjQUN0QyxJQUFJOHRCLElBQUksQ0FBQ3J3QixJQUFJLENBQUNzeEIsTUFBTSxLQUFLLGdDQUFnQyxFQUFFO2dCQUN6RCxJQUFJLENBQUN0RCxVQUFVLENBQUNtRCxXQUFXLEVBQUU7Z0JBQzdCLE9BQU8sSUFBSTtjQUNiO1lBQ0Y7WUFDQSxJQUFJZCxJQUFJLENBQUM1MEIsSUFBSSxLQUFLSixTQUFTLEVBQUU7Y0FDM0IsSUFBSWcxQixJQUFJLENBQUM1MEIsSUFBSSxLQUFLLFVBQVUsRUFBRTtnQkFDNUI7Z0JBQ0EsSUFBSTQwQixJQUFJLENBQUMxQyxNQUFNLEtBQUt0eUIsU0FBUyxFQUFFO2tCQUM3QixJQUFJLENBQUMyeUIsVUFBVSxDQUFDdUQsY0FBYyxDQUFDbEIsSUFBSSxDQUFDMUMsTUFBTSxFQUFFMEMsSUFBSSxDQUFDcndCLElBQUksQ0FBQztrQkFDdEQsT0FBTyxJQUFJO2dCQUNiLENBQUMsTUFBTTtrQkFDTCxJQUFJLENBQUNndUIsVUFBVSxDQUFDd0QsVUFBVSxDQUFDbkIsSUFBSSxDQUFDcndCLElBQUksQ0FBQztrQkFDckMsT0FBTyxJQUFJO2dCQUNiO2NBQ0Y7WUFDRjtVQUNGLENBQUMsTUFBTSxJQUFJcXdCLElBQUksQ0FBQzUwQixJQUFJLEtBQUtKLFNBQVMsRUFBRTtZQUNsQyxJQUFJZzFCLElBQUksQ0FBQzUwQixJQUFJLEtBQUssVUFBVSxFQUFFO2NBQzVCLElBQUksQ0FBQ3V5QixVQUFVLENBQUN3RCxVQUFVLENBQUNuQixJQUFJLENBQUNvQixRQUFRLENBQUM7Y0FDekMsT0FBTyxJQUFJO1lBQ2I7VUFDRjtVQUNBLElBQUksQ0FBQ3pELFVBQVUsQ0FBQzBELGVBQWUsQ0FBQyxJQUFJLEVBQUVsM0IsT0FBTyxDQUFDO1FBQ2hEO01BQ0YsQ0FBQyxNQUFNO1FBQ0w2QixRQUFJLENBQUNxaEIsc0JBQUksRUFBRSxtQ0FBbUMsQ0FBQztNQUNqRDtJQUNGO0VBQUM7RUFBQTtBQUFBLEVBMUVvQ29RLGFBQVk7QUE2RXBDZ0QsZ0dBQXdCLEU7Ozs7Ozs7Ozs7Ozs7OztBQzVGSTtBQUNPO0FBSWpDO0FBQ2dDO0FBQ047QUFFM0MsSUFBTXBULGtCQUFJLEdBQUcsaUJBQWlCO0FBQUEsSUFFeEJpVSw4QkFBZ0I7RUFBQTtFQUFBO0VBRXBCLDBCQUFhNUQsU0FBUyxFQUFFL3pCLElBQUksRUFBRTtJQUFBO0lBQUE7SUFDNUIsMEJBQU1BLElBQUksSUFBSTBqQixrQkFBSTtJQUNsQixNQUFLc1EsVUFBVSxHQUFHRCxTQUFTO0lBQzNCLE1BQUs2RCxZQUFZLEdBQUd2MkIsU0FBUztJQUM3QixNQUFLdzJCLGVBQWUsR0FBR3gyQixTQUFTO0lBQ2hDLE1BQUt5MkIscUJBQXFCLEdBQUcsTUFBS0EscUJBQXFCLENBQUNyVCxJQUFJLENBQUMsMkNBQUs7SUFBQTtFQUNwRTs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0Esb0NBQTRCc1QsV0FBVyxFQUFFO01BQ3ZDQSxXQUFXLENBQUM1QyxNQUFNLEdBQUc5ekIsU0FBUztNQUM5QjAyQixXQUFXLENBQUMxQyxPQUFPLEdBQUdoMEIsU0FBUztNQUMvQjAyQixXQUFXLENBQUN6QyxPQUFPLEdBQUdqMEIsU0FBUztNQUMvQjAyQixXQUFXLENBQUMzQyxTQUFTLEdBQUcvekIsU0FBUztJQUNuQzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsaUNBQXlCMDJCLFdBQVcsRUFBRTtNQUFBO01BQ3BDQSxXQUFXLENBQUMxQyxPQUFPLEdBQUcsVUFBQ2x3QixLQUFLLEVBQUs7UUFDL0IsTUFBSSxDQUFDNnVCLFVBQVUsQ0FBQ2dFLGtCQUFrQixDQUFDRCxXQUFXLEVBQUU1eUIsS0FBSyxDQUFDN0MsS0FBSyxDQUFDOUIsT0FBTyxDQUFDO01BQ3RFLENBQUM7TUFDRHUzQixXQUFXLENBQUMzQyxTQUFTLEdBQUcsSUFBSSxDQUFDMEMscUJBQXFCO01BQ2xEQyxXQUFXLENBQUM1QyxNQUFNLEdBQUcsWUFBTTtRQUN6QixNQUFJLENBQUNuQixVQUFVLENBQUNpRSxpQkFBaUIsQ0FBQ0YsV0FBVyxDQUFDO01BQ2hELENBQUM7TUFDREEsV0FBVyxDQUFDekMsT0FBTyxHQUFHLFVBQUNud0IsS0FBSyxFQUFLO1FBQy9CLE1BQUksQ0FBQzZ1QixVQUFVLENBQUNrRSxrQkFBa0IsQ0FBQ0gsV0FBVyxDQUFDO1FBQy9DLE1BQUksQ0FBQ3pSLE9BQU8sQ0FBQyxJQUFJekQsMEJBQTBCLENBQUNwQiwrQkFBK0IsQ0FBQ0UsS0FBSyxFQUFFLE1BQUksQ0FBQ2lCLEtBQUssRUFBRTtVQUFDb1MsTUFBTSxFQUFFLE1BQUk7VUFBRTd2QixLQUFLLEVBQUVBO1FBQUssQ0FBQyxDQUFDLENBQUM7TUFDL0gsQ0FBQztJQUNIOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7SUFDRTtFQUFBO0lBQUE7SUFBQSxPQUNBLG1DQUEyQmd6QixVQUFVLEVBQUU7TUFDckM5MUIsUUFBSSxDQUFDLElBQUksQ0FBQ3VnQixLQUFLLEVBQUUsd0NBQXdDLENBQUM7SUFDNUQ7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7SUFDRTtFQUFBO0lBQUE7SUFBQSxPQUNBLGdDQUF3QnVWLFVBQVUsRUFBRXgxQixPQUFPLEVBQUU7TUFDM0NOLFFBQUksQ0FBQyxJQUFJLENBQUN1Z0IsS0FBSyxFQUFFLHFDQUFxQyxDQUFDO0lBQ3pEOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0EsK0JBQXVCemQsS0FBSyxFQUFFO01BQzVCLElBQU0zRSxPQUFPLEdBQUcyRSxLQUFLO01BQ3JCLElBQUksSUFBSSxDQUFDaXhCLHFCQUFxQixDQUFDNTFCLE9BQU8sQ0FBQyxFQUFFO1FBQ3ZDLE9BQU8sSUFBSTtNQUNiO01BQ0EsSUFBSTYxQixJQUFJLEdBQUcsSUFBSSxDQUFDQyx3QkFBd0IsQ0FBQzkxQixPQUFPLENBQUM7TUFDakQsSUFBSTYxQixJQUFJLEtBQUssSUFBSSxFQUFFO1FBQ2pCaDBCLFFBQUksQ0FBQyxJQUFJLENBQUN1Z0IsS0FBSyxFQUFFLCtFQUErRSxDQUFDO1FBQ2pHLE9BQU8sSUFBSTtNQUNiO01BQ0F4Z0IsU0FBSyxDQUFDLElBQUksQ0FBQ3dnQixLQUFLLEVBQUUsMEJBQTBCLEdBQUdqYyxJQUFJLENBQUM0TyxTQUFTLENBQUM4Z0IsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztNQUM3RSxJQUNFcndCLElBQUksR0FJRnF3QixJQUFJLENBSk5yd0IsSUFBSTtRQUNKMnRCLE1BQU0sR0FHSjBDLElBQUksQ0FITjFDLE1BQU07UUFDTmx5QixJQUFJLEdBRUY0MEIsSUFBSSxDQUZONTBCLElBQUk7UUFDSjRMLEVBQUUsR0FDQWdwQixJQUFJLENBRE5ocEIsRUFBRTtNQUVKLElBQUlySCxJQUFJLElBQUlBLElBQUksQ0FBQ3hGLE9BQU8sSUFBSXdGLElBQUksQ0FBQ3ZFLElBQUksS0FBSyxPQUFPLEVBQUU7UUFDakQsSUFBSSxDQUFDdXlCLFVBQVUsQ0FBQ2dFLGtCQUFrQixDQUFDLElBQUksQ0FBQ0osWUFBWSxFQUFFNXhCLElBQUksQ0FBQ3hGLE9BQU8sQ0FBQztRQUNuRSxPQUFPLElBQUk7TUFDYjtNQUFFLElBQUl3RixJQUFJLElBQUlBLElBQUksQ0FBQzhtQixJQUFJLElBQUk5bUIsSUFBSSxDQUFDdkUsSUFBSSxLQUFLLE9BQU8sRUFBRTtRQUNoRCxJQUFJLENBQUN1eUIsVUFBVSxDQUFDZ0Usa0JBQWtCLENBQUMsSUFBSSxDQUFDSixZQUFZLEVBQUU1eEIsSUFBSSxDQUFDOG1CLElBQUksQ0FBQztRQUNoRSxPQUFPLElBQUk7TUFDYixDQUFDLE1BQU0sSUFBSTZHLE1BQU0sRUFBRTtRQUNqQixJQUFJLENBQUNLLFVBQVUsQ0FBQ3VELGNBQWMsQ0FBQzVELE1BQU0sRUFBRTN0QixJQUFJLENBQUM7UUFDNUMsT0FBTyxJQUFJO01BQ2IsQ0FBQyxNQUFNLElBQUl2RSxJQUFJLEtBQUssVUFBVSxFQUFFO1FBQzlCLElBQUksQ0FBQ3V5QixVQUFVLENBQUN3RCxVQUFVLENBQUN4eEIsSUFBSSxDQUFDO1FBQ2hDLE9BQU8sSUFBSTtNQUNiLENBQUMsTUFBTSxJQUFJQSxJQUFJLElBQUlBLElBQUksQ0FBQ3ZFLElBQUksS0FBSyxRQUFRLEVBQUU7UUFDekMsSUFBSXVFLElBQUksQ0FBQzhtQixJQUFJLEtBQUssOEJBQThCLEVBQUU7VUFDaEQsSUFBSSxDQUFDa0gsVUFBVSxDQUFDb0Qsa0JBQWtCLEVBQUU7VUFDcEMsT0FBTyxJQUFJO1FBQ2I7UUFDQWgxQixTQUFLLENBQUNzaEIsa0JBQUksNENBQXFDMWQsSUFBSSxDQUFDOG1CLElBQUksRUFBRztNQUM3RCxDQUFDLE1BQU0sSUFBSXVKLElBQUksQ0FBQ2pELEtBQUssSUFBSS9sQixFQUFFLEVBQUU7UUFDNUIsSUFBTXFwQixNQUFNLEdBQUcsSUFBSSxDQUFDMUQsYUFBYSxDQUFDbnZCLElBQUksQ0FBQyxVQUFBMkksRUFBRTtVQUFBLE9BQUlBLEVBQUUsQ0FBQ2EsRUFBRSxLQUFLQSxFQUFFO1FBQUEsRUFBQztRQUN6RCxJQUFRMUssT0FBTyxHQUFLK3pCLE1BQU0sQ0FBbEIvekIsT0FBTztRQUNmLElBQUlBLE9BQU8sSUFBSTB6QixJQUFJLENBQUNyd0IsSUFBSSxFQUFFO1VBQ3hCckQsT0FBTyxDQUFDRixPQUFPLENBQUM0ekIsSUFBSSxDQUFDcndCLElBQUksQ0FBQztVQUMxQixPQUFPLElBQUk7UUFDYixDQUFDLE1BQU0sSUFBSXJELE9BQU8sSUFBSTB6QixJQUFJLENBQUMvekIsS0FBSyxFQUFFO1VBQ2hDSyxPQUFPLENBQUNELE1BQU0sQ0FBQzJ6QixJQUFJLENBQUMvekIsS0FBSyxDQUFDO1VBQzFCLE9BQU8sSUFBSTtRQUNiO01BQ0Y7TUFDQSxPQUFPLEtBQUs7SUFDZDs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFkRTtJQUFBO0lBQUEsT0FlQSxlQUFPODFCLFVBQVUsRUFBdUQ7TUFBQSxJQUFyREMsWUFBWSx1RUFBR2gzQixTQUFTO01BQUEsSUFBRWkzQixhQUFhLHVFQUFHajNCLFNBQVM7TUFDcEUsSUFBSSxDQUFDc3pCLFFBQVEsRUFBRTtNQUNmLElBQU12d0IsQ0FBQyxHQUFHaTBCLFlBQVksSUFBSSxJQUFJcDFCLGVBQWUsRUFBRTtNQUMvQyxJQUFJO1FBQ0YsSUFBSXMxQixVQUFVLEdBQUc7VUFDZkgsVUFBVSxFQUFFQSxVQUFVO1VBQ3RCSSxvQkFBb0IsRUFBRSxDQUFDO1VBQ3ZCQyxZQUFZLEVBQUU7UUFDaEIsQ0FBQztRQUNELElBQUksT0FBT0gsYUFBYSxLQUFLLFdBQVcsRUFBRTtVQUN4Q0MsVUFBVSxDQUFDRCxhQUFhLEdBQUdBLGFBQWE7UUFDMUM7UUFDQWwyQixTQUFLLENBQUNzaEIsa0JBQUksb0NBQTZCL2MsSUFBSSxDQUFDNE8sU0FBUyxDQUFDZ2pCLFVBQVUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUc7UUFDN0UsSUFBSUcsSUFBSSxHQUFHLElBQUlDLGlCQUF3QixDQUFDSixVQUFVLEVBQ2hEO1VBQ0VLLFFBQVEsRUFBRSxDQUNSO1lBQUNDLGVBQWUsRUFBRTtVQUFLLENBQUMsRUFDeEI7WUFBQ0MsdUJBQXVCLEVBQUU7VUFBSSxDQUFDO1FBRW5DLENBQUMsQ0FBQztRQUNKLElBQUksQ0FBQ0Msc0JBQXNCLENBQUNMLElBQUksQ0FBQztRQUNqQyxJQUFJLENBQUNiLGVBQWUsR0FBR2EsSUFBSTtRQUMzQnQwQixDQUFDLENBQUMzQixPQUFPLENBQUNpMkIsSUFBSSxDQUFDO01BQ2pCLENBQUMsQ0FBQyxPQUFPN3hCLENBQUMsRUFBRTtRQUNWeEUsUUFBSSxDQUFDcWhCLGtCQUFJLGtEQUEyQzdjLENBQUMsQ0FBQ3JHLE9BQU8sRUFBRztRQUNoRTRELENBQUMsQ0FBQzFCLE1BQU0sQ0FBQ21FLENBQUMsQ0FBQ3JHLE9BQU8sQ0FBQztNQUNyQjtNQUNBLE9BQU80RCxDQUFDLENBQUNtRSxjQUFjLENBQUMsU0FBUyxDQUFDLEdBQUduRSxDQUFDLENBQUN6QixPQUFPLEdBQUd5QixDQUFDO0lBQ3BEOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBWkU7SUFBQTtJQUFBLE9BYUEsb0NBQTRCNDBCLGFBQWEsRUFBa0U7TUFBQSxJQUFoRUMsd0JBQXdCLHVFQUFHNTNCLFNBQVM7TUFBQSxJQUFFZzNCLFlBQVksdUVBQUdoM0IsU0FBUztNQUN2RyxJQUFJLENBQUNzekIsUUFBUSxFQUFFO01BQ2YsSUFBTXZ3QixDQUFDLEdBQUdpMEIsWUFBWSxJQUFJLElBQUlwMUIsZUFBZSxFQUFFO01BQy9DLElBQUk7UUFDRmIsU0FBSyxDQUFDc2hCLGtCQUFJLHlEQUFrRC9jLElBQUksQ0FBQzRPLFNBQVMsQ0FBQ3lqQixhQUFhLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUFHO1FBQ3JHLElBQUlOLElBQUksR0FBRyxJQUFJQyxpQkFBd0IsQ0FBQ0ssYUFBYSxDQUFDO1FBQ3RELElBQUlDLHdCQUF3QixFQUFFO1VBQzVCLElBQUksQ0FBQ3JCLFlBQVksR0FBR2MsSUFBSSxDQUFDdmdCLGlCQUFpQixDQUFDOGdCLHdCQUF3QixDQUFDajVCLElBQUksRUFBRTtZQUFDazVCLE9BQU8sRUFBRTtVQUFJLENBQUMsQ0FBQztVQUMxRixJQUFJLENBQUNDLHVCQUF1QixDQUFDLElBQUksQ0FBQ3ZCLFlBQVksQ0FBQztRQUNqRDtRQUNBLElBQUksQ0FBQ21CLHNCQUFzQixDQUFDTCxJQUFJLENBQUM7UUFDakMsSUFBSSxDQUFDYixlQUFlLEdBQUdhLElBQUk7UUFDM0J0MEIsQ0FBQyxDQUFDM0IsT0FBTyxDQUFDaTJCLElBQUksQ0FBQztNQUNqQixDQUFDLENBQUMsT0FBTzd4QixDQUFDLEVBQUU7UUFDVnhFLFFBQUksQ0FBQ3FoQixrQkFBSSxrREFBMkM3YyxDQUFDLENBQUNyRyxPQUFPLEVBQUc7UUFDaEU0RCxDQUFDLENBQUMxQixNQUFNLENBQUNtRSxDQUFDLENBQUNyRyxPQUFPLENBQUM7TUFDckI7TUFDQSxPQUFPNEQsQ0FBQyxDQUFDbUUsY0FBYyxDQUFDLFNBQVMsQ0FBQyxHQUFHbkUsQ0FBQyxDQUFDekIsT0FBTyxHQUFHeUIsQ0FBQztJQUNwRDs7SUFFQTtBQUNGO0FBQ0E7RUFGRTtJQUFBO0lBQUEsT0FHQSxvQkFBWTtNQUNWLElBQUksSUFBSSxDQUFDd3pCLFlBQVksRUFBRTtRQUNyQixJQUFJLENBQUN3QiwwQkFBMEIsQ0FBQyxJQUFJLENBQUN4QixZQUFZLENBQUM7UUFDbEQsSUFBSTtVQUNGLElBQUksQ0FBQ0EsWUFBWSxDQUFDeGYsS0FBSyxFQUFFO1FBQzNCLENBQUMsQ0FBQyxPQUFPdlIsQ0FBQyxFQUFFO1VBQ1Z4RSxRQUFJLENBQUNxaEIsa0JBQUksdUNBQWdDN2MsQ0FBQyxDQUFDckcsT0FBTyxFQUFHO1FBQ3ZELENBQUMsU0FBUztVQUNSLElBQUksQ0FBQ28zQixZQUFZLEdBQUd2MkIsU0FBUztRQUMvQjtNQUNGO01BQ0EsSUFBSSxJQUFJLENBQUN3MkIsZUFBZSxFQUFFO1FBQ3hCejFCLFNBQUssQ0FBQ3NoQixrQkFBSSxFQUFFLFlBQVksQ0FBQztRQUN6QixJQUFJLENBQUMyVix5QkFBeUIsQ0FBQyxJQUFJLENBQUN4QixlQUFlLENBQUM7UUFDcEQsSUFBSTtVQUNGLElBQUksQ0FBQ0EsZUFBZSxDQUFDemYsS0FBSyxFQUFFO1FBQzlCLENBQUMsQ0FBQyxPQUFPdlIsQ0FBQyxFQUFFO1VBQ1Z4RSxRQUFJLENBQUNxaEIsa0JBQUksMENBQW1DN2MsQ0FBQyxDQUFDckcsT0FBTyxFQUFHO1FBQzFELENBQUMsU0FBUztVQUNSLElBQUksQ0FBQ3EzQixlQUFlLEdBQUd4MkIsU0FBUztRQUNsQztNQUNGO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEsNkJBQXFCaTRCLGtCQUFrQixFQUFFO01BQ3ZDbDNCLFNBQUssQ0FBQ3NoQixrQkFBSSxFQUFFLHVCQUF1QixDQUFDO01BQ3BDLE9BQU8sSUFBSSxDQUFDbVUsZUFBZSxDQUFDMEIsbUJBQW1CLENBQUNELGtCQUFrQixDQUFDO0lBQ3JFOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0EsOEJBQXNCMWdCLEdBQUcsRUFBRTtNQUN6QnhXLFNBQUssQ0FBQ3NoQixrQkFBSSxFQUFFLHdCQUF3QixDQUFDO01BQ3JDLE9BQU8sSUFBSSxDQUFDbVUsZUFBZSxDQUFDMkIsb0JBQW9CLENBQUMsSUFBSWIscUJBQTRCLENBQUMvZixHQUFHLENBQUMsQ0FBQztJQUN6Rjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFMRTtJQUFBO0lBQUEsT0FNQSx5QkFBaUJxZCxTQUFTLEVBQUU7TUFDMUI3ekIsU0FBSyxDQUFDc2hCLGtCQUFJLEVBQUUsZ0JBQWdCLENBQUM7TUFDN0IsT0FBTyxJQUFJLENBQUNtVSxlQUFlLENBQUM0QixlQUFlLENBQUN4RCxTQUFTLENBQUM7SUFDeEQ7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEsY0FBTWhELE9BQU8sRUFBRTtNQUNiLElBQUksSUFBSSxDQUFDMkUsWUFBWSxFQUFFO1FBQ3JCLElBQU1wM0IsT0FBTyxHQUFHLE9BQU95eUIsT0FBTyxLQUFLLFFBQVEsR0FBR0EsT0FBTyxHQUFHdHNCLElBQUksQ0FBQzRPLFNBQVMsQ0FBQzBkLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQ3hGN3dCLFNBQUssQ0FBQ3NoQixrQkFBSSx3Q0FBaUNsakIsT0FBTyxFQUFHO1FBQ3JELElBQUk7VUFDRixJQUFJLENBQUNvM0IsWUFBWSxDQUFDMUIsSUFBSSxDQUFDMTFCLE9BQU8sQ0FBQztVQUMvQixPQUFPLElBQUk7UUFDYixDQUFDLENBQUMsT0FBT2lLLEdBQUcsRUFBRTtVQUNabkksU0FBSyxDQUFDb2hCLGtCQUFJLEVBQUVqWixHQUFHLENBQUNsQyxjQUFjLENBQUMsU0FBUyxDQUFDLEdBQUdrQyxHQUFHLENBQUNqSyxPQUFPLEdBQUdpSyxHQUFHLENBQUM7UUFDaEU7TUFDRjtNQUNBLE9BQU8sS0FBSztJQUNkOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsS0FLQSxlQUFrQjtNQUNoQixPQUFPLElBQUksQ0FBQ290QixlQUFlO0lBQzdCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsS0FLQSxlQUFtQjtNQUNqQixPQUFPLElBQUksQ0FBQ0QsWUFBWTtJQUMxQjtFQUFDO0VBQUE7QUFBQSxFQXRTNEI5RSxrQ0FBZ0I7QUEwU2hDNkUsZ0ZBQWdCLEU7O0FDclRuQjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFK0I7QUFDSDtBQUNNO0FBQ0c7QUFDTjtBQUUzQyxJQUFNalUsc0JBQUksR0FBRyx1QkFBdUI7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTWdXLGdCQUFnQixHQUFHLFNBQW5CQSxnQkFBZ0IsQ0FBSXpELFNBQVMsRUFBSztFQUN0QyxPQUFPLE9BQU9BLFNBQVMsS0FBSyxXQUFXLElBQ3BDLE9BQU9BLFNBQVMsS0FBSyxRQUFRLElBQUlBLFNBQVMsQ0FBQ3R5QixNQUFNLEtBQUssQ0FBRTtBQUM3RCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQSxJQUtNZzJCLHdDQUFzQjtFQUFBO0VBQUE7RUFFMUIsZ0NBQWE1RixTQUFTLEVBQUU7SUFBQTtJQUFBLHlCQUNoQkEsU0FBUyxFQUFFclEsc0JBQUk7RUFDdkI7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORTtJQUFBO0lBQUEsT0FPQSxtQ0FBMkJ5VSxVQUFVLEVBQUU7TUFDckNBLFVBQVUsQ0FBQ3lCLHVCQUF1QixHQUFHdjRCLFNBQVM7TUFDOUM4MkIsVUFBVSxDQUFDMEIsMEJBQTBCLEdBQUd4NEIsU0FBUztNQUNqRDgyQixVQUFVLENBQUMyQixjQUFjLEdBQUd6NEIsU0FBUztNQUN6QztNQUNJODJCLFVBQVUsQ0FBQzRCLE9BQU8sR0FBRzE0QixTQUFTO01BQzlCODJCLFVBQVUsQ0FBQzZCLGFBQWEsR0FBRzM0QixTQUFTO0lBQ3RDOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVJFO0lBQUE7SUFBQSxPQVNBLGdDQUF3QjgyQixVQUFVLEVBQUV4MUIsT0FBTyxFQUFFO01BQUE7TUFFM0MsSUFBSXMzQixnQkFBZ0I7TUFDcEIsSUFBTUMsWUFBWSxHQUFHLElBQUk7TUFFekIvQixVQUFVLENBQUN5Qix1QkFBdUIsR0FBRyxZQUFNO1FBQ3pDeDNCLFNBQUssQ0FBQ3NoQixzQkFBSSxvREFBNkN5VSxVQUFVLENBQUNnQyxlQUFlLEVBQUc7UUFDcEYsSUFBSWhDLFVBQVUsQ0FBQ2dDLGVBQWUsS0FBSyxXQUFXLEVBQUU7VUFDOUMvM0IsU0FBSyxDQUFDc2hCLHNCQUFJLEVBQUUsdUJBQXVCLENBQUM7VUFDcEMsSUFBSS9nQixPQUFPLEVBQUU7WUFDWEEsT0FBTyxDQUFDRixPQUFPLENBQUMsS0FBSSxDQUFDO1VBQ3ZCLENBQUMsTUFBTTtZQUNMLEtBQUksQ0FBQ3V4QixVQUFVLENBQUNvRyxvQkFBb0IsRUFBRTtVQUN4QztRQUNGLENBQUMsTUFBTSxJQUFJakMsVUFBVSxDQUFDZ0MsZUFBZSxLQUFLLFFBQVEsSUFDaERoQyxVQUFVLENBQUNnQyxlQUFlLEtBQUssY0FBYyxFQUFFO1VBQy9DOTNCLFFBQUksQ0FBQ3FoQixzQkFBSSxFQUFFLHdCQUF3QixDQUFDO1VBQ3BDLElBQUkvZ0IsT0FBTyxFQUFFO1lBQ1hBLE9BQU8sQ0FBQ0QsTUFBTSxFQUFFO1VBQ2xCO1FBQ0Y7TUFDRixDQUFDO01BRUR5MUIsVUFBVSxDQUFDMkIsY0FBYyxHQUFHLFVBQUMzMEIsS0FBSyxFQUFLO1FBQ3JDL0MsU0FBSyxDQUFDc2hCLHNCQUFJLG9EQUE2Q3ZlLEtBQUssQ0FBQzh3QixTQUFTLEVBQUc7UUFDekUsSUFBSTl3QixLQUFLLENBQUM4d0IsU0FBUyxFQUFFO1VBQ25CLEtBQUksQ0FBQ2pDLFVBQVUsQ0FBQ3FHLGNBQWMsQ0FBQ2wxQixLQUFLLENBQUM4d0IsU0FBUyxDQUFDO1FBQ2pELENBQUMsTUFBTSxJQUFJOXdCLEtBQUssQ0FBQzh3QixTQUFTLEtBQUssSUFBSSxJQUFJLEtBQUksQ0FBQ3FFLG1CQUFtQixFQUFFO1VBQy9EO1VBQ0EsS0FBSSxDQUFDdEcsVUFBVSxDQUFDdUcsd0JBQXdCLENBQUMsS0FBSSxDQUFDRCxtQkFBbUIsQ0FBQztVQUNsRSxLQUFJLENBQUNBLG1CQUFtQixHQUFHajVCLFNBQVM7UUFDdEM7TUFDRixDQUFDOztNQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7TUFFSTtNQUNBODJCLFVBQVUsQ0FBQzRCLE9BQU8sR0FBRyxVQUFDNTBCLEtBQUssRUFBSztRQUM5Qi9DLFNBQUssQ0FBQ3NoQixzQkFBSSx1Q0FBZ0N2ZSxLQUFLLENBQUM3RCxPQUFPLEVBQUc7UUFDMUQsSUFBSTZELEtBQUssQ0FBQzdELE9BQU8sSUFBSTZELEtBQUssQ0FBQzdELE9BQU8sQ0FBQ3FDLE1BQU0sR0FBRyxDQUFDLElBQUksS0FBSSxDQUFDMjJCLG1CQUFtQixLQUFLajVCLFNBQVMsRUFBRTtVQUN2RixLQUFJLENBQUNpNUIsbUJBQW1CLEdBQUduMUIsS0FBSyxDQUFDN0QsT0FBTyxDQUFDLENBQUMsQ0FBQztVQUMzQyxLQUFJLENBQUMweUIsVUFBVSxDQUFDd0csbUJBQW1CLENBQUNyMUIsS0FBSyxDQUFDN0QsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZEO01BQ0YsQ0FBQztNQUVENjJCLFVBQVUsQ0FBQzBCLDBCQUEwQixHQUFHLFVBQUMxMEIsS0FBSyxFQUFLO1FBQ2pELElBQU13aUIsS0FBSyxHQUFHd1EsVUFBVSxDQUFDc0Msa0JBQWtCO1FBQzNDcjRCLFNBQUssQ0FBQ3NoQixzQkFBSSx1REFBZ0RpRSxLQUFLLEVBQUc7UUFDbEUsSUFBSUEsS0FBSyxLQUFLLFdBQVcsSUFBSTNWLE9BQVcsQ0FBQzVGLFNBQVMsRUFBRSxFQUFFO1VBQ3BEO1VBQ0E7VUFDQTtVQUNBaEssU0FBSyxDQUFDc2hCLHNCQUFJLEVBQUUsNkJBQTZCLENBQUM7VUFDMUMsS0FBSSxDQUFDc1EsVUFBVSxDQUFDMEcsdUJBQXVCLEVBQUU7VUFDekM7VUFDQTtVQUNBdkMsVUFBVSxDQUFDMkIsY0FBYyxDQUFDO1lBQUM3RCxTQUFTLEVBQUM7VUFBSSxDQUFDLENBQUM7UUFDN0MsQ0FBQyxNQUNJLElBQUl0TyxLQUFLLEtBQUssUUFBUSxFQUFFO1VBQzNCLElBQUlzUyxnQkFBZ0IsRUFBRTtZQUNwQjNRLFlBQVksQ0FBQzJRLGdCQUFnQixDQUFDO1VBQ2hDO1VBQ0EsS0FBSSxDQUFDakcsVUFBVSxDQUFDMkcsb0JBQW9CLEVBQUU7VUFDdEMsS0FBSSxDQUFDM0csVUFBVSxDQUFDNEcscUJBQXFCLENBQUN6MUIsS0FBSyxDQUFDO1FBQzlDLENBQUMsTUFDSSxJQUFJd2lCLEtBQUssS0FBSyxjQUFjLEVBQUU7VUFDakM7VUFDQXNTLGdCQUFnQixHQUFHanZCLFVBQVUsQ0FBRSxZQUFNO1lBQ25DNUksU0FBSyxDQUFDc2hCLHNCQUFJLDJGQUEyRjtZQUNyRzRGLFlBQVksQ0FBQzJRLGdCQUFnQixDQUFDO1lBQzlCLEtBQUksQ0FBQ2pHLFVBQVUsQ0FBQzRHLHFCQUFxQixDQUFDejFCLEtBQUssQ0FBQztVQUM5QyxDQUFDLEVBQUUrMEIsWUFBWSxDQUFDO1FBQ2xCLENBQUMsTUFDSTtVQUNILElBQUlELGdCQUFnQixFQUFFO1lBQ3BCNzNCLFNBQUssQ0FBQ3NoQixzQkFBSSx3RUFBd0U7WUFDbEY0RixZQUFZLENBQUMyUSxnQkFBZ0IsQ0FBQztVQUNoQztRQUNGO01BQ0YsQ0FBQztNQUVEOUIsVUFBVSxDQUFDMEMseUJBQXlCLEdBQUcsWUFBTTtRQUMzQyxJQUFNbFQsS0FBSyxHQUFHd1EsVUFBVSxDQUFDMkMsaUJBQWlCO1FBQzFDMTRCLFNBQUssQ0FBQ3NoQixzQkFBSSxzREFBK0NpRSxLQUFLLEVBQUc7UUFDakUsSUFBSUEsS0FBSyxLQUFLLFVBQVUsRUFBRTtVQUN4QixLQUFJLENBQUNxTSxVQUFVLENBQUMwRyx1QkFBdUIsRUFBRTtRQUMzQztNQUNGLENBQUM7TUFFRHZDLFVBQVUsQ0FBQzRDLGNBQWMsR0FBRyxZQUFNO1FBQ2hDMzRCLFNBQUssQ0FBQ3NoQixzQkFBSSwwQkFBMEI7TUFDdEMsQ0FBQztJQUVIOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0EsK0JBQXVCdmUsS0FBSyxFQUFFO01BQzVCLElBQU0zRSxPQUFPLEdBQUcyRSxLQUFLO01BQ3JCLElBQUksb0lBQTRCQSxLQUFLLEdBQUc7UUFDdEMsT0FBTyxJQUFJO01BQ2I7TUFDQSxJQUFJa3hCLElBQUksR0FBRyxJQUFJLENBQUNDLHdCQUF3QixDQUFDOTFCLE9BQU8sQ0FBQztNQUNqRCxJQUFJNjFCLElBQUksS0FBSyxJQUFJLEVBQUU7UUFDakJoMEIsUUFBSSxDQUFDLElBQUksQ0FBQ3VnQixLQUFLLEVBQUUsK0VBQStFLENBQUM7UUFDakcsT0FBTyxJQUFJO01BQ2I7TUFDQXhnQixTQUFLLENBQUMsSUFBSSxDQUFDd2dCLEtBQUssRUFBRSwwQkFBMEIsR0FBR2pjLElBQUksQ0FBQzRPLFNBQVMsQ0FBQzhnQixJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO01BQzdFLElBQ0Vyd0IsSUFBSSxHQUNGcXdCLElBQUksQ0FETnJ3QixJQUFJO01BRU4sSUFBSUEsSUFBSSxJQUFJQSxJQUFJLENBQUN2RSxJQUFJLEtBQUssUUFBUSxFQUFFO1FBQ2xDLElBQUl1RSxJQUFJLENBQUM4bUIsSUFBSSxLQUFLLGdDQUFnQyxFQUFFO1VBQ2xELElBQUksQ0FBQ2tILFVBQVUsQ0FBQ21ELFdBQVcsRUFBRTtVQUM3QixJQUFJLENBQUNuRCxVQUFVLENBQUNvRCxrQkFBa0IsRUFBRTtVQUNwQyxPQUFPLElBQUk7UUFDYjtRQUNBaDFCLFNBQUssQ0FBQ3NoQixzQkFBSSw0Q0FBcUMxZCxJQUFJLENBQUM4bUIsSUFBSSxFQUFHO1FBQzNELElBQUksQ0FBQ2tILFVBQVUsQ0FBQ3FELGtCQUFrQixDQUFDcnhCLElBQUksQ0FBQztRQUN4QyxPQUFPLElBQUk7TUFDYixDQUFDLE1BQU0sSUFBSUEsSUFBSSxJQUFJQSxJQUFJLENBQUNzeEIsTUFBTSxJQUFJdHhCLElBQUksQ0FBQ3N4QixNQUFNLEtBQU0sZ0NBQWdDLEVBQUU7UUFDbkYsSUFBSSxDQUFDdEQsVUFBVSxDQUFDbUQsV0FBVyxFQUFFO1FBQzdCLElBQUksQ0FBQ25ELFVBQVUsQ0FBQ29ELGtCQUFrQixFQUFFO1FBQ3BDLE9BQU8sSUFBSTtNQUNiO01BQ0EsSUFBSSxDQUFDcEQsVUFBVSxDQUFDZ0gsb0JBQW9CLENBQUMsSUFBSSxDQUFDcEQsWUFBWSxFQUFFcDNCLE9BQU8sQ0FBQztNQUNoRSxPQUFPLEtBQUs7SUFDZDs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQU5FO0lBQUE7SUFBQSxPQU9BLHNCQUFjb1ksR0FBRyxFQUFFO01BQUE7TUFDakJ4VyxTQUFLLENBQUNzaEIsc0JBQUksRUFBRSxnQkFBZ0IsQ0FBQztNQUM3QixJQUFNOUwsUUFBUSxHQUFHLElBQUkzVSxlQUFlLEVBQUU7TUFFdEMsSUFBSSxDQUFDNDBCLGVBQWUsQ0FBQzJCLG9CQUFvQixDQUFDNWdCLEdBQUcsQ0FBQyxDQUMzQ3RVLElBQUksQ0FBQyxJQUFJLENBQUMwdkIsVUFBVSxDQUFDaUgsWUFBWSxDQUFDLENBQ2xDejJCLEtBQUssQ0FBQyxVQUFDaUcsR0FBRyxFQUFLO1FBQ2QsTUFBSSxDQUFDdXBCLFVBQVUsQ0FBQ2tILFVBQVUsQ0FBQ3p3QixHQUFHLENBQUM7TUFDakMsQ0FBQyxDQUFDO01BQ0o7TUFDQSxJQUFJLENBQUNvdEIsZUFBZSxDQUFDc0QsWUFBWSxFQUFFLENBQ2hDNzJCLElBQUksQ0FBQyxVQUFBZzFCLGtCQUFrQixFQUFJO1FBQzFCQSxrQkFBa0IsQ0FBQzFnQixHQUFHLEdBQUcrZix3QkFBK0IsQ0FBQ1csa0JBQWtCLENBQUMxZ0IsR0FBRyxDQUFDO1FBQ2hGLE1BQUksQ0FBQ2lmLGVBQWUsQ0FBQzBCLG1CQUFtQixDQUFDRCxrQkFBa0IsQ0FBQyxDQUN6RGgxQixJQUFJLENBQUMsTUFBSSxDQUFDMHZCLFVBQVUsQ0FBQ2lILFlBQVksQ0FBQyxDQUNsQ3oyQixLQUFLLENBQUMsVUFBQ2lHLEdBQUcsRUFBSztVQUNkLE1BQUksQ0FBQ3VwQixVQUFVLENBQUNrSCxVQUFVLENBQUN6d0IsR0FBRyxDQUFDO1FBQ2pDLENBQUMsQ0FBQztRQUNKbU4sUUFBUSxDQUFDblYsT0FBTyxDQUFDNjJCLGtCQUFrQixDQUFDO01BQ3RDLENBQUMsQ0FBQyxDQUNEOTBCLEtBQUssQ0FBQ29ULFFBQVEsQ0FBQ2xWLE1BQU0sQ0FBQztNQUV6QixPQUFPa1YsUUFBUSxDQUFDalYsT0FBTztJQUN6Qjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFMRTtJQUFBO0lBQUEsT0FNQSx5QkFBaUJzekIsU0FBUyxFQUFFO01BQzFCN3pCLFNBQUssQ0FBQ3NoQixzQkFBSSxFQUFFLHNCQUFzQixDQUFDO01BQ25DLElBQUlnVyxnQkFBZ0IsQ0FBQ3pELFNBQVMsQ0FBQyxFQUFFO1FBQy9CN3pCLFNBQUssQ0FBQ3NoQixzQkFBSSxFQUFFLDJCQUEyQixDQUFDO01BQzFDLENBQUMsTUFBTSxJQUFJdVMsU0FBUyxLQUFLLElBQUksRUFBRTtRQUM3Qjd6QixTQUFLLENBQUNzaEIsc0JBQUksRUFBRSxnQ0FBZ0MsQ0FBQztRQUM3QyxJQUFJMFgsWUFBWSxHQUFHLElBQUl6QyxlQUFzQixDQUFDO1VBQzVDMEMsYUFBYSxFQUFFcEYsU0FBUyxDQUFDb0YsYUFBYTtVQUN0Q3BGLFNBQVMsRUFBRUEsU0FBUyxDQUFDQTtRQUN2QixDQUFDLENBQUM7UUFDRixJQUFJLENBQUM0QixlQUFlLENBQUM0QixlQUFlLENBQUMyQixZQUFZLENBQUMsQ0FDL0M5MkIsSUFBSSxDQUFDLFlBQU07VUFDVjtRQUFBLENBQ0QsQ0FBQyxDQUNERSxLQUFLLENBQUMsVUFBQWlHLEdBQUcsRUFBSTtVQUNabkksU0FBSyxDQUFDb2hCLHNCQUFJLDZDQUFzQ2paLEdBQUcsRUFBRztRQUN4RCxDQUFDLENBQUM7TUFDTixDQUFDLE1BQU07UUFDTHJJLFNBQUssQ0FBQ3NoQixzQkFBSSxFQUFFLDJCQUEyQixDQUFDO1FBQ3hDLElBQUksQ0FBQ21VLGVBQWUsQ0FBQzRCLGVBQWUsQ0FBQ3hELFNBQVMsQ0FBQyxDQUM1QzN4QixJQUFJLENBQUMsWUFBTTtVQUNWO1FBQUEsQ0FDRCxDQUFDLENBQ0RFLEtBQUssQ0FBQyxVQUFBaUcsR0FBRyxFQUFJO1VBQ1puSSxTQUFLLENBQUNvaEIsc0JBQUksNkNBQXNDalosR0FBRyxFQUFHO1FBQ3hELENBQUMsQ0FBQztNQUNOO0lBQ0Y7RUFBQztFQUFBO0FBQUEsRUE5T2tDa3RCLGFBQWdCO0FBa1B0Q2dDLDhGQUFzQixFOztBQzdRekI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRTRCO0FBQ0g7QUFFckMsSUFBTWpXLGFBQUksR0FBRyxtQkFBbUI7QUFDaEMsSUFBTTRYLFVBQVUsR0FBRyxvQkFBb0I7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU1DLHFCQUFZO0VBRXZCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFLHdCQUFxQztJQUFBLElBQXhCQyxTQUFTLHVFQUFHRixVQUFVO0lBQUE7SUFDakMsSUFBSTtNQUNGO01BQ0EsSUFBSSxDQUFDRyxjQUFjLEdBQUd6cEIsT0FBVyxDQUFDNUUsY0FBYyxDQUFDb3VCLFNBQVMsQ0FBQztJQUM3RCxDQUFDLENBQUMsT0FBTzMwQixDQUFDLEVBQUU7TUFDVnZFLFNBQUssQ0FBQ29oQixhQUFJLCtFQUF3RTdjLENBQUMsQ0FBQ3JHLE9BQU8sRUFBRztNQUM5RixNQUFNcUcsQ0FBQztJQUNUO0VBQ0Y7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLDBCQUFrQjJiLFVBQVUsRUFBRTtNQUM1QnBnQixTQUFLLENBQUNzaEIsYUFBSSxFQUFFLG9CQUFvQixDQUFDO01BQ2pDbEIsVUFBVSxDQUFDa1osT0FBTyxDQUFDLElBQUksRUFBRTFwQixPQUFXLENBQUM3QyxZQUFZLENBQUMsSUFBSSxDQUFDc3NCLGNBQWMsQ0FBQyxDQUFDO0lBQ3pFOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0Esc0JBQWM5dEIsV0FBVyxFQUFFO01BQ3pCLElBQUlDLFFBQVEsR0FBRyxJQUFJLENBQUMrdEIsVUFBVTtNQUM5QnY1QixTQUFLLENBQUNzaEIsYUFBSSxFQUFFLGdCQUFnQixDQUFDO01BQzdCMVIsT0FBVyxDQUFDdkUsY0FBYyxDQUFDLElBQUksQ0FBQ2d1QixjQUFjLEVBQUU5dEIsV0FBVyxFQUFFQyxRQUFRLENBQUM7SUFDeEU7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLHdCQUFnQjtNQUNkeEwsU0FBSyxDQUFDc2hCLGFBQUksRUFBRSxnQkFBZ0IsQ0FBQztNQUM3QjFSLE9BQVcsQ0FBQ3ZFLGNBQWMsQ0FBQyxJQUFJLENBQUNndUIsY0FBYyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUNFLFVBQVUsQ0FBQztJQUN4RTs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLEtBS0EsZUFBa0I7TUFDaEIsT0FBTzNwQixPQUFXLENBQUMxQixtQkFBbUIsQ0FBQyxJQUFJLENBQUNtckIsY0FBYyxFQUFFLFVBQVUsQ0FBQztJQUN6RTs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLEtBS0EsZUFBWTtNQUNWLE9BQU8sSUFBSSxDQUFDQSxjQUFjO0lBQzVCO0VBQUM7RUFBQTtBQUFBO0FBSVlGLGtFQUFZLEU7O0FDeEZmOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFNSyxnQ0FBZ0MsR0FBRyxTQUFuQ0EsZ0NBQWdDLENBQUlDLElBQUksRUFBSztFQUNqRCxRQUFRQSxJQUFJO0lBQ1YsS0FBSyxJQUFJO0lBQ1QsS0FBSyxNQUFNO01BQ1RqOEIsT0FBTyxDQUFDeUMsSUFBSSxDQUFDLCtGQUErRixDQUFDLEVBQUM7TUFDOUcsT0FBTyxHQUFHO0lBQ1osS0FBSyxJQUFJO0lBQ1QsS0FBSyxNQUFNO01BQ1R6QyxPQUFPLENBQUN5QyxJQUFJLENBQ1Ysc0dBQXNHLENBQ3ZHLEVBQUM7TUFDRixPQUFPLElBQUk7RUFBQTtFQUVmLE9BQU93NUIsSUFBSTtBQUNiLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTUMsZUFBZSxHQUFHLFNBQWxCQSxlQUFlLENBQUlDLFdBQVcsRUFBSztFQUM5QyxJQUFJQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO0VBQ2hCcm1CLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDbW1CLFdBQVcsQ0FBQyxDQUFDM3pCLE9BQU8sQ0FBQyxVQUFDMUQsR0FBRyxFQUFFYSxLQUFLLEVBQUs7SUFDL0M7SUFDQXkyQixPQUFPLENBQUN0M0IsR0FBRyxDQUFDLEdBQUd1M0Isa0JBQWtCLENBQUNGLFdBQVcsQ0FBQ3IzQixHQUFHLENBQUMsQ0FBQztFQUNyRCxDQUFDLENBQUM7RUFDRixPQUFPczNCLE9BQU87QUFDaEIsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFNRSw0QkFBNEIsR0FBRyxTQUEvQkEsNEJBQTRCLENBQUluNEIsT0FBTyxFQUF5QjtFQUFBLElBQXZCbzRCLE1BQU0sdUVBQUc5NkIsU0FBUztFQUN0RSxJQUFNKzZCLFFBQVEsR0FBR3I0QixPQUFPLENBQUNzNEIsVUFBVSxJQUFJdDRCLE9BQU8sQ0FBQ3E0QixRQUFRO0VBQ3ZELElBQU1QLElBQUksR0FBR0QsZ0NBQWdDLENBQUM3M0IsT0FBTyxDQUFDdTRCLE1BQU0sSUFBSXY0QixPQUFPLENBQUM4M0IsSUFBSSxDQUFDO0VBQzdFLElBQU1VLFdBQVcsR0FBR3g0QixPQUFPLENBQUN5NEIsT0FBTyxHQUFHLENBQUN6NEIsT0FBTyxDQUFDMDRCLEdBQUcsRUFBRTE0QixPQUFPLENBQUN5NEIsT0FBTyxDQUFDLENBQUNsbEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHdlQsT0FBTyxDQUFDMDRCLEdBQUc7RUFDNUYsSUFBSUMsUUFBUSxhQUFNTixRQUFRLGdCQUFNcjRCLE9BQU8sQ0FBQzQ0QixJQUFJLGNBQUlkLElBQUksY0FBSVUsV0FBVyxNQUFHO0VBQ3RFLElBQUksT0FBT3g0QixPQUFPLENBQUM2NEIsZ0JBQWdCLEtBQUssV0FBVyxFQUFFO0lBQ25ELElBQU1DLGFBQWEsR0FBR2YsZUFBZSxDQUFDLzNCLE9BQU8sQ0FBQzY0QixnQkFBZ0IsQ0FBQztJQUMvRFQsTUFBTSxHQUFHeG1CLE1BQU0sQ0FBQ21uQixNQUFNLENBQUNYLE1BQU0sRUFBRVUsYUFBYSxDQUFDO0VBQy9DO0VBQ0EsSUFBSSxPQUFPVixNQUFNLEtBQUssV0FBVyxFQUFFO0lBQ2pDLElBQUlZLEVBQUUsR0FBRyxFQUFFO0lBQ1hwbkIsTUFBTSxDQUFDQyxJQUFJLENBQUN1bUIsTUFBTSxDQUFDLENBQUMvekIsT0FBTyxDQUFDLFVBQUMxRCxHQUFHLEVBQUVhLEtBQUssRUFBSztNQUMxQztNQUNBdzNCLEVBQUUsQ0FBQ3g3QixJQUFJLENBQUMsQ0FBQ21ELEdBQUcsRUFBRXkzQixNQUFNLENBQUN6M0IsR0FBRyxDQUFDLENBQUMsQ0FBQzRTLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN2QyxDQUFDLENBQUM7SUFDRixJQUFJeWxCLEVBQUUsQ0FBQ3A1QixNQUFNLEdBQUcsQ0FBQyxFQUFFO01BQ2pCKzRCLFFBQVEsSUFBSSxHQUFHLEdBQUdLLEVBQUUsQ0FBQ3psQixJQUFJLENBQUMsR0FBRyxDQUFDO0lBQ2hDO0VBQ0Y7RUFFQSxPQUFPb2xCLFFBQVE7QUFDakIsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTU0sNEJBQTRCLEdBQUcsU0FBL0JBLDRCQUE0QixDQUFJajVCLE9BQU8sRUFBeUI7RUFBQSxJQUF2Qm80QixNQUFNLHVFQUFHOTZCLFNBQVM7RUFDdEUsSUFBUTQ3QixZQUFZLEdBQXVCbDVCLE9BQU8sQ0FBMUNrNUIsWUFBWTtJQUFFTCxnQkFBZ0IsR0FBSzc0QixPQUFPLENBQTVCNjRCLGdCQUFnQjtFQUN0QyxJQUFNUixRQUFRLEdBQUdhLFlBQVksQ0FBQ2IsUUFBUTtFQUN0QyxJQUFNUCxJQUFJLEdBQUdELGdDQUFnQyxDQUFDcUIsWUFBWSxDQUFDcEIsSUFBSSxLQUFLTyxRQUFRLEtBQUssS0FBSyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQztFQUNyRyxJQUFJTSxRQUFRLGFBQU1OLFFBQVEsZ0JBQU1hLFlBQVksQ0FBQ04sSUFBSSxjQUFJZCxJQUFJLGNBQUlvQixZQUFZLENBQUNSLEdBQUcsTUFBRztFQUNoRixJQUFJRyxnQkFBZ0IsRUFBRTtJQUNwQixJQUFNQyxhQUFhLEdBQUdmLGVBQWUsQ0FBQy8zQixPQUFPLENBQUM2NEIsZ0JBQWdCLENBQUM7SUFDL0RULE1BQU0sR0FBR3htQixNQUFNLENBQUNtbkIsTUFBTSxDQUFDWCxNQUFNLEVBQUVVLGFBQWEsQ0FBQztFQUMvQztFQUNBLElBQUlWLE1BQU0sRUFBRTtJQUNWLElBQUlZLEVBQUUsR0FBRyxFQUFFO0lBQ1hwbkIsTUFBTSxDQUFDQyxJQUFJLENBQUN1bUIsTUFBTSxDQUFDLENBQUMvekIsT0FBTyxDQUFDLFVBQUMxRCxHQUFHLEVBQUVhLEtBQUssRUFBSztNQUMxQztNQUNBdzNCLEVBQUUsQ0FBQ3g3QixJQUFJLENBQUMsQ0FBQ21ELEdBQUcsRUFBRXkzQixNQUFNLENBQUN6M0IsR0FBRyxDQUFDLENBQUMsQ0FBQzRTLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN2QyxDQUFDLENBQUM7SUFDRixJQUFJeWxCLEVBQUUsQ0FBQ3A1QixNQUFNLEdBQUcsQ0FBQyxFQUFFO01BQ2pCKzRCLFFBQVEsSUFBSSxHQUFHLEdBQUdLLEVBQUUsQ0FBQ3psQixJQUFJLENBQUMsR0FBRyxDQUFDO0lBQ2hDO0VBQ0Y7RUFFQSxPQUFPb2xCLFFBQVE7QUFDakIsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFNUSxlQUFlLEdBQUcsU0FBbEJBLGVBQWUsQ0FBSW41QixPQUFPLEVBQUs7RUFDMUMsSUFBUTQ0QixJQUFJLEdBQW1HNTRCLE9BQU8sQ0FBOUc0NEIsSUFBSTtJQUFFUSxXQUFXLEdBQXNGcDVCLE9BQU8sQ0FBeEdvNUIsV0FBVztJQUFFZixRQUFRLEdBQTRFcjRCLE9BQU8sQ0FBM0ZxNEIsUUFBUTtJQUFFZ0IsT0FBTyxHQUFtRXI1QixPQUFPLENBQWpGcTVCLE9BQU87SUFBRXZCLElBQUksR0FBNkQ5M0IsT0FBTyxDQUF4RTgzQixJQUFJO0lBQUVXLE9BQU8sR0FBb0R6NEIsT0FBTyxDQUFsRXk0QixPQUFPO0lBQUVDLEdBQUcsR0FBK0MxNEIsT0FBTyxDQUF6RDA0QixHQUFHO0lBQUUxRyxVQUFVLEdBQW1DaHlCLE9BQU8sQ0FBcERneUIsVUFBVTtJQUFFNkcsZ0JBQWdCLEdBQWlCNzRCLE9BQU8sQ0FBeEM2NEIsZ0JBQWdCO0lBQUVTLFVBQVUsR0FBS3Q1QixPQUFPLENBQXRCczVCLFVBQVU7RUFDMUcsSUFBSUMsT0FBTyxHQUFHWCxJQUFJO0VBQ2xCLElBQUlZLFdBQVcsR0FBR0osV0FBVyxLQUFLZixRQUFRLEtBQUssSUFBSSxHQUFHLE1BQU0sR0FBRyxPQUFPLENBQUM7RUFDdkUsSUFBSW9CLE9BQU8sR0FBR0osT0FBTyxLQUFLdkIsSUFBSSxLQUFLLElBQUksR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDO0VBQ3JELElBQUlVLFdBQVcsR0FBR0MsT0FBTyxHQUFHLENBQUNDLEdBQUcsRUFBRUQsT0FBTyxDQUFDLENBQUNsbEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHbWxCLEdBQUc7RUFDMUQsSUFBSWdCLFVBQVUsR0FBR0osVUFBVSxJQUFJLEtBQUs7RUFDcEMsSUFBSVQsZ0JBQWdCLElBQUlILEdBQUcsS0FBSyxlQUFlLEVBQUU7SUFDL0M7SUFDQSxpQkFBVWMsV0FBVyxnQkFBTUQsT0FBTyxjQUFJRSxPQUFPLGdDQUFzQkMsVUFBVSxtQkFBU2IsZ0JBQWdCLENBQUNILEdBQUcsY0FBSTFHLFVBQVU7RUFDMUg7RUFDQSxpQkFBVXdILFdBQVcsZ0JBQU1ELE9BQU8sY0FBSUUsT0FBTyxjQUFJakIsV0FBVyxjQUFJeEcsVUFBVTtBQUM1RSxDQUFDO0FBRU0sSUFBTTJILHNCQUFzQixHQUFHLFNBQXpCQSxzQkFBc0IsQ0FBSWx3QixHQUFHLEVBQUs7RUFDN0M7RUFDQSxJQUFJbXZCLElBQUksRUFBRVAsUUFBUSxFQUFFUCxJQUFJLEVBQUVZLEdBQUcsRUFBRTFHLFVBQVU7RUFDekMsSUFBTTRILE9BQU8sR0FBRyxJQUFJN3ZCLEdBQUcsQ0FBQ04sR0FBRyxDQUFDO0VBQzVCLElBQU13SCxLQUFLLEdBQUcyb0IsT0FBTyxDQUFDQyxRQUFRLENBQUNsekIsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDMkosTUFBTSxDQUFDLFVBQUNqUSxDQUFDO0lBQUEsT0FBS0EsQ0FBQyxDQUFDVCxNQUFNLEdBQUcsQ0FBQztFQUFBLEVBQUM7RUFDckV5NEIsUUFBUSxHQUFHdUIsT0FBTyxDQUFDdkIsUUFBUTtFQUMzQk8sSUFBSSxHQUFHZ0IsT0FBTyxDQUFDRSxRQUFRO0VBQ3ZCaEMsSUFBSSxHQUFHOEIsT0FBTyxDQUFDOUIsSUFBSSxDQUFDbDRCLE1BQU0sR0FBRyxDQUFDLEdBQUdnNkIsT0FBTyxDQUFDOUIsSUFBSSxHQUFHLEdBQUc7RUFDbkRZLEdBQUcsR0FBR3puQixLQUFLLENBQUMsQ0FBQyxDQUFDO0VBQ2QrZ0IsVUFBVSxHQUFHL2dCLEtBQUssQ0FBQ0EsS0FBSyxDQUFDclIsTUFBTSxHQUFHLENBQUMsQ0FBQztFQUNwQyxPQUFPO0lBQUV5NEIsUUFBUSxFQUFSQSxRQUFRO0lBQUVQLElBQUksRUFBSkEsSUFBSTtJQUFFWSxHQUFHLEVBQUhBLEdBQUc7SUFBRUUsSUFBSSxFQUFKQSxJQUFJO0lBQUU1RyxVQUFVLEVBQVZBO0VBQVcsQ0FBQztBQUNsRCxDQUFDLEM7O0FDbEtEO0FBQ0E7QUFDQTtBQUNPLElBQU0rSCxhQUFhLEdBQUdub0IsTUFBTSxDQUFDOEcsTUFBTSxDQUFDO0VBQ3pDc2hCLEdBQUcsRUFBRSxLQUFLO0VBQ1ZDLElBQUksRUFBRSxNQUFNO0VBQ1pDLEdBQUcsRUFBRTtBQUNQLENBQUMsQ0FBQzs7QUFFRjtBQUNBO0FBQ0E7QUFDTyxJQUFNQyxvQkFBb0IsR0FBR3ZvQixNQUFNLENBQUM4RyxNQUFNLENBQUM7RUFDaEQwaEIsSUFBSSxFQUFFLE1BQU07RUFDWkMsSUFBSSxFQUFFLE1BQU07RUFDWkMsSUFBSSxFQUFFLE1BQU07RUFDWkMsS0FBSyxFQUFFLE9BQU87RUFDZEMsSUFBSSxFQUFFO0FBQ1IsQ0FBQyxDQUFDOztBQUVGO0FBQ0E7QUFDQTtBQUNPLElBQU1DLG9CQUFvQixHQUFHN29CLE1BQU0sQ0FBQzhHLE1BQU0sQ0FBQztFQUNoRGdpQixHQUFHLEVBQUUsS0FBSztFQUNWQyxJQUFJLEVBQUUsTUFBTTtFQUNaSCxJQUFJLEVBQUU7QUFDUixDQUFDLENBQUMsQzs7QUMzQkY7QUFDQTtBQUNBO0FBQ08sSUFBTUksaUJBQWlCLEdBQUdocEIsTUFBTSxDQUFDOEcsTUFBTSxDQUFDO0VBQzdDbWlCLEdBQUcsRUFBRSxLQUFLO0VBQ1ZDLEdBQUcsRUFBQztBQUNOLENBQUMsQ0FBQyxDOztBQ05VOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRTRCO0FBQ2tCO0FBQ2Y7QUFDTTtBQUNVO0FBQ2lCO0FBQ1Y7QUFDRjtBQUNyQjtBQUNJO0FBQ1k7QUFDTDtBQUNvQztBQUNoRDtBQUM0QztBQUNNO0FBQzFDO0FBQ0Q7QUFDdUI7QUFDckI7QUFFbkQsSUFBTUMsYUFBYSxHQUFHLGdCQUFnQjtBQUN0QyxJQUFNcGIsZ0JBQUksR0FBRyxlQUFlOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQU1xYixzQkFBc0IsR0FBRyxTQUF6QkEsc0JBQXNCLEdBQVM7RUFDbkMsSUFBTTF4QixFQUFFLEdBQUdtSCxJQUFJLENBQUNzVyxLQUFLLENBQUN0VyxJQUFJLENBQUMyZSxNQUFNLEVBQUUsR0FBRyxPQUFPLENBQUMsQ0FBQ2xpQixRQUFRLENBQUMsRUFBRSxDQUFDO0VBQzNELDRCQUFxQjVELEVBQUU7QUFDekIsQ0FBQzs7QUFFRDtBQUNBLElBQU0yeEIsY0FBYyxHQUFHO0VBQ3JCNUMsUUFBUSxFQUFFLEtBQUs7RUFDZlAsSUFBSSxFQUFFLEdBQUc7RUFDVFksR0FBRyxFQUFFLE1BQU07RUFDWHdDLHFCQUFxQixFQUFFLElBQUk7RUFDM0JDLGNBQWMsRUFBRSxvQkFBb0I7RUFDcENDLGdCQUFnQixFQUFFO0lBQ2hCL0csVUFBVSxFQUFFLENBQUM7TUFBRWdILElBQUksRUFBRTtJQUFnQyxDQUFDLENBQUM7SUFDdkQ1RyxvQkFBb0IsRUFBRSxDQUFDO0lBQ3ZCQyxZQUFZLEVBQUU7RUFDaEIsQ0FBQztFQUFFO0VBQ0hMLFVBQVUsRUFBRS8yQixTQUFTO0VBQUU7RUFDdkJnK0IsWUFBWSxFQUFFVixpQkFBaUIsQ0FBQ0MsR0FBRztFQUNuQ1UseUJBQXlCLEVBQUUsSUFBSTtFQUMvQkMsbUNBQW1DLEVBQUUsS0FBSztFQUMxQ0MsbUJBQW1CLEVBQUUsSUFBSTtFQUN6QnZHLHdCQUF3QixFQUFFNTNCLFNBQVM7RUFDbkNvK0IsaUJBQWlCLEVBQUUsSUFBSTtFQUN2QkMsZUFBZSxFQUFFLEtBQUs7RUFDdEJDLHFCQUFxQixFQUFFLEtBQUs7RUFDNUI5TyxjQUFjLEVBQUU7QUFDbEIsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQSxJQU1NK08seUJBQWE7RUFBQTtFQUFBO0VBQ2pCLHlCQUFjO0lBQUE7SUFBQTtJQUNaO0lBQ0EsTUFBS0MsS0FBSyxHQUFHeCtCLFNBQVM7SUFDdEIsTUFBS3krQixRQUFRLEdBQUd6K0IsU0FBUztJQUN6QixNQUFLMCtCLFdBQVcsR0FBRzErQixTQUFTO0lBQzVCLE1BQUsyK0IsYUFBYSxHQUFHMytCLFNBQVM7SUFDOUIsTUFBSzQrQixpQkFBaUIsR0FBRzUrQixTQUFTO0lBQ2xDLE1BQUs2K0IsaUJBQWlCLEdBQUcsSUFBSTtJQUM3QixNQUFLQyxjQUFjLEdBQUc5K0IsU0FBUztJQUMvQixNQUFLKytCLFlBQVksR0FBRy8rQixTQUFTO0lBQzdCLE1BQUtnL0IsYUFBYSxHQUFHLElBQUlwOUIsZUFBZSxFQUFFO0lBQzFDLE1BQUtxOUIscUJBQXFCLEdBQUcsSUFBSXI5QixlQUFlLEVBQUU7SUFDbEQsTUFBS3M5QixxQkFBcUIsR0FBRyxJQUFJdDlCLGVBQWUsRUFBRTtJQUNsRCxNQUFLdTlCLFlBQVksR0FBRyxDQUFDO0lBQ3JCLE1BQUtDLGNBQWMsR0FBRyxhQUFhO0lBQ25DLE1BQUtDLHFCQUFxQixHQUFHci9CLFNBQVM7SUFBQTtFQUN4QztFQUFDO0lBQUE7SUFBQSxPQUVELG1DQUEwQjtNQUN4QixPQUFPLElBQUksQ0FBQ2cvQixhQUFhLENBQUMxOUIsT0FBTztJQUNuQztFQUFDO0lBQUE7SUFBQSxPQUVELDJDQUFrQztNQUNoQyxPQUFPLElBQUksQ0FBQzI5QixxQkFBcUIsQ0FBQzM5QixPQUFPO0lBQzNDO0VBQUM7SUFBQTtJQUFBLE9BRUQsMkNBQWtDO01BQ2hDLE9BQU8sSUFBSSxDQUFDNDlCLHFCQUFxQixDQUFDNTlCLE9BQU87SUFDM0M7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLCtCQUFzQjJNLE9BQU8sRUFBRTtNQUFBO01BQzdCLElBQUksQ0FBQ3JCLElBQUksR0FBR3FCLE9BQU8sQ0FBQ3JCLElBQUksQ0FBQ3dXLElBQUksQ0FBQ25WLE9BQU8sQ0FBQztNQUN0QyxJQUFJLENBQUNuQixLQUFLLEdBQUdtQixPQUFPLENBQUNuQixLQUFLLENBQUNzVyxJQUFJLENBQUNuVixPQUFPLENBQUM7TUFDeEMsSUFBSSxDQUFDc2EsTUFBTSxHQUFHdGEsT0FBTyxDQUFDc2EsTUFBTSxDQUFDbkYsSUFBSSxDQUFDblYsT0FBTyxDQUFDO01BQzFDLElBQUksQ0FBQ3NmLElBQUksR0FBR3RmLE9BQU8sQ0FBQ3NmLElBQUksQ0FBQ25LLElBQUksQ0FBQ25WLE9BQU8sQ0FBQztNQUN0QyxJQUFJLENBQUM0YSxJQUFJLEdBQUc1YSxPQUFPLENBQUM0YSxJQUFJLENBQUN6RixJQUFJLENBQUNuVixPQUFPLENBQUM7TUFDdEMsSUFBSSxDQUFDMGEsTUFBTSxHQUFHMWEsT0FBTyxDQUFDMGEsTUFBTSxDQUFDdkYsSUFBSSxDQUFDblYsT0FBTyxDQUFDO01BQzFDLElBQUksQ0FBQ2diLFNBQVMsR0FBR2hiLE9BQU8sQ0FBQ2diLFNBQVMsQ0FBQzdGLElBQUksQ0FBQ25WLE9BQU8sQ0FBQztNQUNoRCxJQUFJLENBQUNpYixNQUFNLEdBQUdqYixPQUFPLENBQUNpYixNQUFNLENBQUM5RixJQUFJLENBQUNuVixPQUFPLENBQUM7TUFDMUMsSUFBSSxDQUFDVyxnQkFBZ0IsR0FBR1gsT0FBTyxDQUFDVyxnQkFBZ0IsQ0FBQ3dVLElBQUksQ0FBQ25WLE9BQU8sQ0FBQztNQUM5REEsT0FBTyxDQUFDOGEsRUFBRSxDQUFDLEdBQUcsRUFBRSxVQUFDamxCLEtBQUssRUFBSztRQUN6QixNQUFJLENBQUNtaEIsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUNwZCxLQUFLLENBQUMxRCxJQUFJLEVBQUUsTUFBSSxFQUFFMEQsS0FBSyxDQUFDYSxJQUFJLENBQUMsQ0FBQztNQUNqRSxDQUFDLENBQUM7SUFDSjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFMRTtJQUFBO0lBQUEsT0FNQSw0QkFBbUIyNkIsV0FBVyxFQUE4QjtNQUFBLElBQTVCekIsY0FBYyx1RUFBRzc5QixTQUFTO01BQ3hELElBQUksT0FBT3MvQixXQUFXLEtBQUssV0FBVyxJQUFJekIsY0FBYyxLQUFLNzlCLFNBQVMsRUFBRTtRQUN0RSxJQUFJOG5CLElBQUksR0FBRyxJQUFJb1MsUUFBWSxDQUFDMkQsY0FBYyxDQUFDO1FBQzNDL1YsSUFBSSxDQUFDeVgsZ0JBQWdCLENBQUMsSUFBSSxDQUFDO01BQzdCO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFURTtJQUFBO0lBQUEsT0FVQSxzQkFBYTc4QixPQUFPLEVBQUV1TCxPQUFPLEVBQUU7TUFDN0IsSUFBSXZMLE9BQU8sSUFBSXVMLE9BQU8sRUFBRTtRQUN0QkEsT0FBTyxDQUFDOGEsRUFBRSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUN5Vyw0QkFBNEIsQ0FBQztRQUNsRHZ4QixPQUFPLENBQUN3eEIsU0FBUyxDQUFDLzhCLE9BQU8sQ0FBQztNQUM1QjtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0EsOEJBQXFCZ3lCLFVBQVUsRUFBRTtNQUMvQjN6QixTQUFLLENBQUNzaEIsZ0JBQUksRUFBRSx1QkFBdUIsQ0FBQztNQUNwQztNQUNBLElBQUksQ0FBQ3NjLGFBQWEsQ0FBQzNNLElBQUksQ0FBQztRQUN0QmtELFdBQVcsRUFBRVI7TUFDZixDQUFDLENBQUM7SUFDSjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBbkJFO0lBQUE7SUFBQSxPQW9CQSx1QkFDRUEsVUFBVSxFQUNWZ0wsY0FBYyxFQUNkQyxTQUFTLEVBQ1RDLGNBQWMsRUFDZEMsZUFBZSxFQUdmO01BQUEsSUFGQUMsU0FBUyx1RUFBRzkvQixTQUFTO01BQUEsSUFDckIrL0IsU0FBUyx1RUFBRy8vQixTQUFTO01BRXJCZSxTQUFLLENBQUNzaEIsZ0JBQUksRUFBRSxnQkFBZ0IsQ0FBQztNQUM3QixJQUFJMmQsS0FBSyxHQUFHO1FBQ1ZDLFlBQVksRUFBRXZMLFVBQVU7UUFDeEJ3TCxTQUFTLEVBQUVSLGNBQWM7UUFDekJDLFNBQVMsRUFBRUEsU0FBUztRQUNwQlEsV0FBVyxFQUFFUCxjQUFjO1FBQzNCUSxXQUFXLEVBQUVQO01BQ2YsQ0FBQztNQUNELElBQUksT0FBT0MsU0FBUyxLQUFLLFdBQVcsSUFBSUEsU0FBUyxLQUFLM0Msb0JBQW9CLENBQUNELElBQUksRUFBRTtRQUMvRThDLEtBQUssQ0FBQ0ssYUFBYSxHQUFHUCxTQUFTO01BQ2pDLENBQUMsTUFBTSxJQUFJbnZCLE9BQVcsQ0FBQzVGLFNBQVMsRUFBRSxFQUFFO1FBQ2xDO1FBQ0E7TUFBQTtNQUVGLElBQUksT0FBT2cxQixTQUFTLEtBQUssV0FBVyxJQUFJQSxTQUFTLEtBQUtsRCxvQkFBb0IsQ0FBQ0ssSUFBSSxFQUFFO1FBQy9FOEMsS0FBSyxDQUFDTSxhQUFhLEdBQUdQLFNBQVM7TUFDakM7TUFDQSxJQUFJLENBQUM5YSxPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQy9CLHVCQUF1QixDQUFDdkMsV0FBVyxFQUFFLElBQUksQ0FBQyxDQUFDO01BQzVFO01BQ0EsSUFBSSxDQUFDK2hCLGFBQWEsQ0FBQzNNLElBQUksQ0FBQ2dPLEtBQUssQ0FBQztNQUM5QixPQUFPLElBQUk7SUFDYjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEsd0JBQWV6b0IsR0FBRyxFQUFFO01BQUE7TUFDbEJ4VyxTQUFLLENBQUNzaEIsZ0JBQUksRUFBRSxpQkFBaUIsQ0FBQztNQUM5QjtNQUNBLElBQUksQ0FBQ3FjLFdBQVcsQ0FDYjVFLFlBQVksQ0FBQ3ZpQixHQUFHLENBQUMsQ0FDakJ0VSxJQUFJLENBQUMsVUFBQ2cxQixrQkFBa0IsRUFBSztRQUM1QmwzQixTQUFLLENBQUNzaEIsZ0JBQUksRUFBRSxtQkFBbUIsQ0FBQztRQUNoQ3RoQixTQUFLLENBQUNzaEIsZ0JBQUksRUFBRSxnQkFBZ0IsQ0FBQztRQUM3QixNQUFJLENBQUNrZSxXQUFXLENBQUMsTUFBSSxDQUFDOUIsUUFBUSxDQUFDL0osVUFBVSxFQUFFLE1BQUksQ0FBQytKLFFBQVEsQ0FBQ2lCLGNBQWMsRUFBRXpILGtCQUFrQixDQUFDO01BQzlGLENBQUMsQ0FBQyxDQUNEOTBCLEtBQUssQ0FBQyxVQUFDbEMsS0FBSyxFQUFLO1FBQ2hCLE1BQUksQ0FBQzQ0QixVQUFVLENBQUM1NEIsS0FBSyxDQUFDO01BQ3hCLENBQUMsQ0FBQztJQUNOOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVhFO0lBQUE7SUFBQSxPQVlBLHFCQUFZeXpCLFVBQVUsRUFBRWdMLGNBQWMsRUFBRW5vQixHQUFHLEVBQUU7TUFDM0N4VyxTQUFLLENBQUNzaEIsZ0JBQUkscUNBQThCcVMsVUFBVSwrQkFBcUJnTCxjQUFjLE9BQUk7TUFDekYsSUFBSSxDQUFDemEsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUMvQix1QkFBdUIsQ0FBQ0MsWUFBWSxFQUFFLElBQUksRUFBRTdILEdBQUcsQ0FBQyxDQUFDO01BQ2xGO01BQ0E7TUFDQSxJQUFJLENBQUNvbkIsYUFBYSxDQUFDM00sSUFBSSxDQUFDO1FBQ3RCd08sWUFBWSxFQUFFOUwsVUFBVTtRQUN4QndMLFNBQVMsRUFBRVIsY0FBYztRQUN6Qi82QixJQUFJLEVBQUU7VUFDSjRTLEdBQUcsRUFBRUE7UUFDUDtNQUNGLENBQUMsQ0FBQztJQUNKOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQRTtJQUFBO0lBQUEsT0FRQSx3QkFBZXFkLFNBQVMsRUFBRTtNQUN4Qjd6QixTQUFLLENBQUNzaEIsZ0JBQUksRUFBRSxpQkFBaUIsQ0FBQztNQUM5QixJQUFJLENBQUM0QyxPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQy9CLHVCQUF1QixDQUFDRyxlQUFlLEVBQUUsSUFBSSxFQUFFc1YsU0FBUyxDQUFDLENBQUM7TUFDM0Y7TUFDQSxJQUFJLENBQUMrSixhQUFhLENBQUMzTSxJQUFJLENBQUM7UUFDdEIyQyxlQUFlLEVBQUUsSUFBSSxDQUFDOEosUUFBUSxDQUFDL0osVUFBVTtRQUN6Q3dMLFNBQVMsRUFBRSxJQUFJLENBQUN6QixRQUFRLENBQUNpQixjQUFjO1FBQ3ZDLzZCLElBQUksRUFBRTtVQUNKaXdCLFNBQVMsRUFBRUE7UUFDYjtNQUNGLENBQUMsQ0FBQztJQUNKOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFiRTtJQUFBO0lBQUEsT0FjQSxrQkFBUytDLGFBQWEsRUFBZ0U7TUFBQTtNQUFBLElBQTlEQyx3QkFBd0IsdUVBQUc1M0IsU0FBUztNQUFBLElBQUUrMkIsVUFBVSx1RUFBRy8yQixTQUFTO01BQ2xGZSxTQUFLLENBQUNzaEIsZ0JBQUksRUFBRSxXQUFXLENBQUM7TUFDeEIsSUFBSTBVLFVBQVUsSUFBSVksYUFBYSxFQUFFO1FBQy9CMzJCLFFBQUksQ0FDRixvT0FBb08sQ0FDck87UUFFRDIyQixhQUFhLENBQUNaLFVBQVUsR0FBR0EsVUFBVTtNQUN2QztNQUNBLElBQUksQ0FBQzBILFFBQVEsQ0FBQzFILFVBQVUsR0FBR1ksYUFBYSxHQUFHQSxhQUFhLENBQUNaLFVBQVUsR0FBR0EsVUFBVTtNQUNoRixJQUFJaDBCLENBQUM7TUFDTCxJQUFJNDBCLGFBQWEsS0FBSzMzQixTQUFTLEVBQUU7UUFDL0IrQyxDQUFDLEdBQUcsSUFBSSxDQUFDMjdCLFdBQVcsQ0FBQytCLDBCQUEwQixDQUFDOUksYUFBYSxFQUFFQyx3QkFBd0IsRUFBRTUzQixTQUFTLENBQUM7TUFDckcsQ0FBQyxNQUFNO1FBQ0wrQyxDQUFDLEdBQUcsSUFBSSxDQUFDMjdCLFdBQVcsQ0FBQ2pLLEtBQUssQ0FBQyxJQUFJLENBQUNnSyxRQUFRLENBQUMxSCxVQUFVLEVBQUUvMkIsU0FBUyxFQUFFLElBQUksQ0FBQ3krQixRQUFRLENBQUN4SCxhQUFhLENBQUM7TUFDOUY7TUFDQWwwQixDQUFDLENBQUNFLElBQUksQ0FBQyxVQUFDNnpCLFVBQVUsRUFBSztRQUNyQixNQUFJLENBQUM3UixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQy9CLHVCQUF1QixDQUFDeEMseUJBQXlCLEVBQUUsTUFBSSxFQUFFbWEsVUFBVSxDQUFDLENBQUM7UUFDdEcsTUFBSSxDQUFDNEosYUFBYSxDQUNoQixNQUFJLENBQUNqQyxRQUFRLENBQUMvSixVQUFVLEVBQ3hCLE1BQUksQ0FBQytKLFFBQVEsQ0FBQ2lCLGNBQWMsRUFDNUIsTUFBSSxDQUFDakIsUUFBUSxDQUFDVCxZQUFZLEVBQzFCLE1BQUksQ0FBQ1MsUUFBUSxDQUFDTixtQkFBbUIsRUFDakMsTUFBSSxDQUFDTSxRQUFRLENBQUNILHFCQUFxQixFQUNuQyxNQUFJLENBQUNHLFFBQVEsQ0FBQzRCLGFBQWEsRUFDM0IsTUFBSSxDQUFDNUIsUUFBUSxDQUFDNkIsYUFBYSxDQUM1QjtNQUNILENBQUMsQ0FBQyxDQUFDbjlCLEtBQUssQ0FBQyxVQUFDcUMsQ0FBQyxFQUFLO1FBQ2R4RSxRQUFJLENBQUNxaEIsZ0JBQUksRUFBRSx3Q0FBd0MsQ0FBQztRQUNwRCxNQUFJLENBQUM0QyxPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDckMsZUFBZSxFQUFFLE1BQUksQ0FBQyxDQUFDO01BQy9FLENBQUMsQ0FBQztNQUNGO01BQ0EsT0FBTyxJQUFJO0lBQ2I7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLHVCQUFjO01BQ1osSUFBSSxJQUFJLENBQUNxakIsYUFBYSxFQUFFO1FBQ3RCNTlCLFNBQUssQ0FBQ3NoQixnQkFBSSxFQUFFLHFCQUFxQixDQUFDO1FBQ2xDLElBQUksQ0FBQ3NjLGFBQWEsQ0FBQ3JMLFFBQVEsRUFBRTtNQUMvQjtNQUNBLElBQUksSUFBSSxDQUFDb0wsV0FBVyxFQUFFO1FBQ3BCMzlCLFNBQUssQ0FBQ3NoQixnQkFBSSxFQUFFLG1CQUFtQixDQUFDO1FBQ2hDLElBQUksQ0FBQ3FjLFdBQVcsQ0FBQ3BMLFFBQVEsRUFBRTtNQUM3QjtNQUNBLElBQUksSUFBSSxDQUFDa0wsS0FBSyxFQUFFO1FBQ2QsSUFBSSxDQUFDQSxLQUFLLENBQUNtQyxZQUFZLEVBQUU7TUFDM0I7TUFDQSxJQUFJLENBQUNoQyxhQUFhLEdBQUczK0IsU0FBUztNQUM5QixJQUFJLENBQUMwK0IsV0FBVyxHQUFHMStCLFNBQVM7TUFDNUIsSUFBSSxDQUFDNCtCLGlCQUFpQixHQUFHNStCLFNBQVM7TUFDbEMsSUFBSSxJQUFJLENBQUM4K0IsY0FBYyxFQUFFO1FBQ3ZCLzlCLFNBQUssQ0FBQ3NoQixnQkFBSSxFQUFFLHFCQUFxQixDQUFDO1FBQ2xDLElBQUksQ0FBQ3ljLGNBQWMsQ0FBQzhCLFVBQVUsRUFBRTtRQUNoQyxJQUFJLENBQUM5QixjQUFjLEdBQUc5K0IsU0FBUztNQUNqQztNQUNBLElBQUksQ0FBQzYrQixpQkFBaUIsR0FBRyxJQUFJO0lBQy9COztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBVEU7SUFBQTtJQUFBLE9BVUEsNEJBQW1CbjhCLE9BQU8sRUFBRW9sQixJQUFJLEVBQUU7TUFDaEMsSUFBSXBsQixPQUFPLElBQUlvbEIsSUFBSSxFQUFFO1FBQ25CcGxCLE9BQU8sQ0FBQzZKLFFBQVEsR0FBR29FLE9BQVcsQ0FBQzFCLG1CQUFtQixDQUFDNlksSUFBSSxDQUFDQSxJQUFJLEVBQUUsVUFBVSxDQUFDO1FBQ3pFLElBQUlwbEIsT0FBTyxDQUFDNkosUUFBUSxFQUFFO1VBQ3BCLElBQUksQ0FBQ3V5QixjQUFjLENBQUMrQixlQUFlLENBQUNuK0IsT0FBTyxDQUFDdTdCLHlCQUF5QixDQUFDO1FBQ3hFO01BQ0Y7SUFDRjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0Esd0JBQWV2N0IsT0FBTyxFQUFFO01BQ3RCLElBQVE4c0IsY0FBYyxHQUFLOXNCLE9BQU8sQ0FBMUI4c0IsY0FBYztNQUN0QixJQUFJLENBQUNBLGNBQWMsRUFBRTtNQUNyQixJQUFJO1FBQ0YsSUFBSTdlLE9BQVcsQ0FBQ3pGLFdBQVcsRUFBRSxJQUFJeUYsT0FBVyxDQUFDckYsb0JBQW9CLEVBQUUsRUFBRTtVQUNuRSxJQUFJLENBQUN3ekIsY0FBYyxDQUFDdFAsY0FBYyxDQUFDcU0sZUFBZSxDQUFDbjVCLE9BQU8sQ0FBQyxFQUFFaU8sT0FBVyxDQUFDekYsV0FBVyxFQUFFLENBQUM7UUFDekYsQ0FBQyxNQUFNO1VBQ0wsTUFBTSxJQUFJNDFCLEtBQUssRUFBRTtRQUNuQjtNQUNGLENBQUMsQ0FBQyxPQUFPdDdCLENBQUMsRUFBRTtRQUNWdkUsU0FBSyxDQUNIb2hCLGdCQUFJLCtIQUVMO01BQ0g7SUFDRjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsMEJBQWlCO01BQ2Z0aEIsU0FBSyxDQUFDc2hCLGdCQUFJLEVBQUUsaUJBQWlCLENBQUM7TUFDOUIsSUFBSSxDQUFDc2MsYUFBYSxDQUFDM00sSUFBSSxDQUFDO1FBQ3RCK08sU0FBUyxFQUFFLElBQUksQ0FBQ3RDLFFBQVEsQ0FBQy9KLFVBQVU7UUFDbkN3TCxTQUFTLEVBQUUsSUFBSSxDQUFDekIsUUFBUSxDQUFDaUI7TUFDM0IsQ0FBQyxDQUFDO0lBQ0o7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLGNBQUtoOUIsT0FBTyxFQUFFO01BQUE7TUFDWixJQUFNNlQsUUFBUSxHQUFHLElBQUkzVSxlQUFlLEVBQUU7TUFDdEMsSUFBSSxDQUFDMDFCLGtCQUFrQixFQUFFLElBQUksQ0FBQy9DLHFCQUFxQixFQUFFLEVBQUU7UUFDckRoZSxRQUFRLENBQUNsVixNQUFNLENBQ2IscUdBQXFHLENBQ3RHO01BQ0gsQ0FBQyxNQUFNO1FBQ0wsSUFBSSxDQUFDMi9CLFdBQVcsRUFBRTtRQUNsQixJQUFJLENBQUN2QyxRQUFRLEdBQUducUIsTUFBTSxDQUFDbW5CLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRWtDLGNBQWMsRUFBRWo3QixPQUFPLENBQUM7UUFDMUQsSUFBSSxDQUFDKzdCLFFBQVEsQ0FBQ2lCLGNBQWMsR0FBRyxJQUFJLENBQUNqQixRQUFRLENBQUNpQixjQUFjLElBQUloQyxzQkFBc0IsRUFBRTtRQUV2RixJQUFJLENBQUNnQixXQUFXLEdBQUcsSUFBSXBHLGlCQUFzQixDQUFDLElBQUksQ0FBQztRQUNuRCxJQUFJLENBQUNxRyxhQUFhLEdBQUcsSUFBSWxKLGlCQUF3QixDQUFDLElBQUksQ0FBQztRQUN2RCxJQUFJLENBQUNtSixpQkFBaUIsR0FBRyxJQUFJLENBQUNBLGlCQUFpQixJQUFJLElBQUksQ0FBQ0QsYUFBYTtRQUNyRSxJQUFNc0MsYUFBYSxHQUFHLElBQUlyL0IsZUFBZSxFQUFFO1FBQzNDLElBQU1zL0IsU0FBUyxHQUFHQyw0QkFBbUIsQ0FBQyxJQUFJLENBQUMxQyxRQUFRLEVBQUU7VUFDbkR6eUIsRUFBRSxFQUFFLElBQUksQ0FBQ3l5QixRQUFRLENBQUNpQjtRQUNwQixDQUFDLENBQUM7UUFFRnVCLGFBQWEsQ0FBQzMvQixPQUFPLENBQ2xCMkIsSUFBSSxDQUFDLFlBQU07VUFDVnNULFFBQVEsQ0FBQ25WLE9BQU8sQ0FBQyxNQUFJLENBQUM7VUFDdEIsTUFBSSxDQUFDeTlCLGlCQUFpQixHQUFHLEtBQUs7VUFDOUIsTUFBSSxDQUFDNVosT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ3RDLGVBQWUsRUFBRSxNQUFJLENBQUMsQ0FBQztRQUMvRSxDQUFDLENBQUMsQ0FDRGxZLEtBQUssQ0FBQyxVQUFDbEMsS0FBSyxFQUFLO1VBQ2hCc1YsUUFBUSxDQUFDbFYsTUFBTSxDQUFDSixLQUFLLENBQUM7VUFDdEIsTUFBSSxDQUFDZ2tCLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUNyQyxlQUFlLEVBQUUsTUFBSSxFQUFFcmEsS0FBSyxDQUFDLENBQUM7UUFDdEYsQ0FBQyxDQUFDO1FBRUosSUFBSSxDQUFDMDlCLGFBQWEsQ0FBQ2xLLEtBQUssQ0FBQ3lNLFNBQVMsRUFBRUQsYUFBYSxDQUFDO01BQ3BEO01BQ0EsT0FBTzFxQixRQUFRLENBQUNqVixPQUFPO0lBQ3pCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUxFO0lBQUE7SUFBQSxPQU1BLGlCQUFRd21CLElBQUksRUFBRTtNQUNaLElBQUksQ0FBQzBXLEtBQUssR0FBRzFXLElBQUk7TUFDakIsSUFBSSxDQUFDa1gsYUFBYSxDQUFDNTlCLE9BQU8sQ0FBQyxJQUFJLENBQUNvOUIsS0FBSyxDQUFDO01BQ3RDLE9BQU8sSUFBSTtJQUNiOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0EscUJBQVk7TUFBQTtNQUNWLHFCQUF5RSxJQUFJLENBQUNDLFFBQVE7UUFBOUUvSixVQUFVLGtCQUFWQSxVQUFVO1FBQUVtSixjQUFjLGtCQUFkQSxjQUFjO1FBQUVDLGdCQUFnQixrQkFBaEJBLGdCQUFnQjtRQUFFdE8sY0FBYyxrQkFBZEEsY0FBYztNQUNwRSxzQkFBd0QsSUFBSSxDQUFDaVAsUUFBUTtRQUEvRE4sbUJBQW1CLG1CQUFuQkEsbUJBQW1CO1FBQUV2Ryx3QkFBd0IsbUJBQXhCQSx3QkFBd0I7TUFDbkQ7TUFDQTtNQUNBLElBQU13SixrQkFBa0IsR0FBR2pELG1CQUFtQixJQUFJN0csMEJBQTBCLEVBQUU7TUFDOUUsSUFBSThKLGtCQUFrQixJQUFJLENBQUN4Six3QkFBd0IsRUFBRTtRQUNuREEsd0JBQXdCLEdBQUc7VUFDekJqNUIsSUFBSTtRQUNOLENBQUM7TUFDSDtNQUNBLElBQUksQ0FBQzgvQixRQUFRLENBQUNOLG1CQUFtQixHQUFHaUQsa0JBQWtCO01BRXRELElBQUksQ0FBQ0MsdUJBQXVCLEVBQUUsQ0FDM0JwK0IsSUFBSSxDQUFDLFVBQUM2a0IsSUFBSSxFQUFLO1FBQ2QsSUFBSTBILGNBQWMsRUFBRTtVQUNsQixJQUFJN2UsT0FBVyxDQUFDekYsV0FBVyxFQUFFLElBQUl5RixPQUFXLENBQUNyRixvQkFBb0IsRUFBRSxFQUFFO1lBQ25FLE1BQUksQ0FBQ3d6QixjQUFjLEdBQUcsSUFBSW5SLG1DQUF3QixDQUFDN0YsSUFBSSxDQUFDQSxJQUFJLEVBQUUsTUFBSSxDQUFDd1osT0FBTyxFQUFFLENBQUM7VUFDL0UsQ0FBQyxNQUFNO1lBQ0xyZ0MsU0FBSyxDQUNIb2hCLGdCQUFJLCtIQUVMO1lBQ0QsTUFBSSxDQUFDeWMsY0FBYyxHQUFHLElBQUkxVSwwQkFBZ0IsQ0FBQ3RDLElBQUksQ0FBQ0EsSUFBSSxFQUFFLE1BQUksQ0FBQ3daLE9BQU8sRUFBRSxDQUFDO1VBQ3ZFO1FBQ0YsQ0FBQyxNQUFNO1VBQ0wsTUFBSSxDQUFDeEMsY0FBYyxHQUFHLElBQUkxVSwwQkFBZ0IsQ0FBQ3RDLElBQUksQ0FBQ0EsSUFBSSxFQUFFLE1BQUksQ0FBQ3daLE9BQU8sRUFBRSxDQUFDO1FBQ3ZFO1FBQ0EsTUFBSSxDQUFDQyxxQkFBcUIsQ0FBQyxNQUFJLENBQUN6QyxjQUFjLENBQUM7UUFDL0MsTUFBSSxDQUFDMEMsWUFBWSxDQUFDLE1BQUksQ0FBQy9DLFFBQVEsRUFBRSxNQUFJLENBQUNLLGNBQWMsQ0FBQztNQUN2RCxDQUFDLENBQUMsQ0FDRDM3QixLQUFLLENBQUMsWUFBTTtRQUNYO01BQUEsQ0FDRCxDQUFDO01BQ0osSUFBSSxDQUFDcytCLCtCQUErQixFQUFFLENBQ25DeCtCLElBQUksQ0FBQyxZQUFNO1FBQ1YsTUFBSSxDQUFDeStCLFFBQVEsQ0FBQzVELGdCQUFnQixFQUFFbEcsd0JBQXdCLEVBQUUsTUFBSSxDQUFDNkcsUUFBUSxDQUFDMUgsVUFBVSxDQUFDO01BQ3JGLENBQUMsQ0FBQyxDQUNENXpCLEtBQUssQ0FBQyxZQUFNO1FBQ1g7TUFBQSxDQUNELENBQUM7TUFDSixJQUFJLENBQUN3K0Isa0JBQWtCLENBQUMsSUFBSSxDQUFDbkQsS0FBSyxFQUFFWCxjQUFjLENBQUM7TUFDbkQsSUFBSSxJQUFJLENBQUNZLFFBQVEsQ0FBQ0osZUFBZSxFQUFFO1FBQ2pDLElBQUksQ0FBQ1kscUJBQXFCLENBQUM3OUIsT0FBTyxDQUFDLElBQUksQ0FBQztNQUMxQyxDQUFDLE1BQU07UUFDTCxJQUFJLENBQUN3Z0Msb0JBQW9CLENBQUNsTixVQUFVLENBQUM7TUFDdkM7TUFDQSxPQUFPLElBQUksQ0FBQ21OLCtCQUErQixFQUFFO0lBQy9DOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUxFO0lBQUE7SUFBQSxPQU1BLHVCQUFjO01BQ1o5Z0MsU0FBSyxDQUFDc2hCLGdCQUFJLEVBQUUsZUFBZSxDQUFDO01BQzVCLElBQU05TCxRQUFRLEdBQUcsSUFBSTNVLGVBQWUsRUFBRTtNQUN0QyxJQUFJLENBQUMyckIsSUFBSSxFQUFFO01BQ1gsSUFBSSxDQUFDeVQsV0FBVyxFQUFFO01BQ2xCLElBQUksQ0FBQ2pDLFlBQVksR0FBRy8rQixTQUFTO01BQzdCdVcsUUFBUSxDQUFDblYsT0FBTyxDQUFDLElBQUksQ0FBQztNQUN0QixJQUFJLENBQUM2akIsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ0UsY0FBYyxFQUFFLElBQUksQ0FBQyxDQUFDO01BQzVFLE9BQU90SCxRQUFRLENBQUNqVixPQUFPO0lBQ3pCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSwyQkFBa0J3Z0MsT0FBTyxFQUFFO01BQ3pCL2dDLFNBQUssQ0FBQ3NoQixnQkFBSSxFQUFFLHVCQUF1QixHQUFHL2MsSUFBSSxDQUFDNE8sU0FBUyxDQUFDNHRCLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7TUFDdkUsSUFBSSxDQUFDN0MscUJBQXFCLENBQUM3OUIsT0FBTyxDQUFDLElBQUksQ0FBQztJQUMxQzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsNkJBQW9CMGdDLE9BQU8sRUFBRTtNQUMzQi9nQyxTQUFLLENBQUNzaEIsZ0JBQUksbUJBQVksSUFBSSxDQUFDb2MsUUFBUSxDQUFDL0osVUFBVSxzQkFBbUI7TUFDakUzekIsU0FBSyxDQUFDc2hCLGdCQUFJLEVBQUUseUJBQXlCLEdBQUcvYyxJQUFJLENBQUM0TyxTQUFTLENBQUM0dEIsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztNQUN6RSxJQUFJLENBQUM3YyxPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDSSxzQkFBc0IsRUFBRSxJQUFJLENBQUMsQ0FBQztNQUNwRixJQUFJLENBQUNraEIscUJBQXFCLENBQUM1OUIsTUFBTSxrQkFBVyxJQUFJLENBQUNvOUIsUUFBUSxDQUFDL0osVUFBVSxzQkFBbUI7TUFDdkYsSUFBSSxDQUFDd0sscUJBQXFCLENBQUM3OUIsTUFBTSxrQkFBVyxJQUFJLENBQUNvOUIsUUFBUSxDQUFDL0osVUFBVSxzQkFBbUI7TUFDdkYsSUFBSSxDQUFDLElBQUksQ0FBQytKLFFBQVEsQ0FBQ1AsbUNBQW1DLEVBQUU7UUFDdEQsSUFBSSxDQUFDOEMsV0FBVyxFQUFFO01BQ3BCLENBQUMsTUFBTTtRQUNMO1FBQ0EsSUFBSSxDQUFDL0IscUJBQXFCLEdBQUcsSUFBSXI5QixlQUFlLEVBQUU7UUFDbEQsSUFBSSxDQUFDczlCLHFCQUFxQixHQUFHLElBQUl0OUIsZUFBZSxFQUFFO01BQ3BEO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORTtJQUFBO0lBQUEsT0FPQSxzQkFBYWtnQyxPQUFPLEVBQUU7TUFDcEIvZ0MsU0FBSyxDQUFDc2hCLGdCQUFJLEVBQUUsa0JBQWtCLEdBQUcvYyxJQUFJLENBQUM0TyxTQUFTLENBQUM0dEIsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNwRTs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEsb0JBQVdBLE9BQU8sRUFBRTtNQUNsQi9nQyxTQUFLLENBQUNzaEIsZ0JBQUksRUFBRSxnQkFBZ0IsR0FBRy9jLElBQUksQ0FBQzRPLFNBQVMsQ0FBQzR0QixPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO01BQ2hFO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO01BRUksSUFBTTdKLGtCQUFrQixHQUFHLElBQUlYLHFCQUE0QixDQUFDd0ssT0FBTyxDQUFDdnFCLEdBQUcsQ0FBQztNQUN4RSxJQUFJLENBQUMwTixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQy9CLHVCQUF1QixDQUFDdEMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO01BQzFFLElBQUksQ0FBQ2tsQixjQUFjLENBQUM5SixrQkFBa0IsQ0FBQztJQUN6Qzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEsb0JBQVc2SixPQUFPLEVBQUU7TUFDbEIsSUFBSSxDQUFDN2MsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ0csY0FBYyxFQUFFLElBQUksRUFBRWdrQixPQUFPLENBQUMsQ0FBQztNQUNyRixJQUFJLENBQUM1QyxxQkFBcUIsQ0FBQzc5QixNQUFNLENBQUMsY0FBYyxDQUFDO01BQ2pESixTQUFLLENBQUNvaEIsZ0JBQUksRUFBRSxjQUFjLENBQUM7TUFDM0JwaEIsU0FBSyxDQUFDb2hCLGdCQUFJLEVBQUV5ZixPQUFPLENBQUM7SUFDdEI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLCtCQUF3QztNQUFBLElBQXBCM2hDLE1BQU0sdUVBQUdILFNBQVM7TUFDcEM7TUFDQSxJQUFJLENBQUNpbEIsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUMvQix1QkFBdUIsQ0FBQ0UsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzdFOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQRTtJQUFBO0lBQUEsT0FRQSx3QkFBZXVWLFNBQVMsRUFBRTtNQUN4Qjd6QixTQUFLLENBQUNzaEIsZ0JBQUksRUFBRSxrQkFBa0IsQ0FBQztNQUMvQixJQUFJLENBQUM0QyxPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQy9CLHVCQUF1QixDQUFDSSxhQUFhLEVBQUUsSUFBSSxDQUFDLENBQUM7TUFDOUUsSUFBSSxDQUFDeWlCLGNBQWMsQ0FBQ3BOLFNBQVMsQ0FBQztJQUNoQzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEsa0NBQXlCejBCLE1BQU0sRUFBRTtNQUFBO01BQy9CWSxTQUFLLENBQUNzaEIsZ0JBQUksRUFBRSxtQkFBbUIsQ0FBQztNQUNoQyxJQUFJLENBQUNnZix1QkFBdUIsRUFBRSxDQUFDcCtCLElBQUksQ0FBQyxVQUFDNmtCLElBQUksRUFBSztRQUM1Q0EsSUFBSSxDQUFDbWEsWUFBWSxDQUFDOWhDLE1BQU0sQ0FBQztRQUN6QixNQUFJLENBQUM0K0IsWUFBWSxHQUFHNStCLE1BQU07UUFDMUIsTUFBSSxDQUFDOGtCLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDL0IsdUJBQXVCLENBQUNLLGFBQWEsRUFBRSxNQUFJLEVBQUUsTUFBSSxDQUFDdWYsWUFBWSxDQUFDLENBQUM7TUFDbkcsQ0FBQyxDQUFDO0lBQ0o7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORTtJQUFBO0lBQUEsT0FPQSwyQkFBa0JuSyxTQUFTLEVBQUU7TUFDM0I3ekIsU0FBSyxDQUFDc2hCLGdCQUFJLEVBQUUscUJBQXFCLENBQUM7TUFDbEMsSUFBSSxDQUFDcWMsV0FBVyxDQUFDdEcsZUFBZSxDQUFDeEQsU0FBUyxDQUFDO0lBQzdDOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSw0QkFBbUI7TUFDakI3ekIsU0FBSyxDQUFDc2hCLGdCQUFJLEVBQUUsNkJBQTZCLENBQUM7TUFDMUMsSUFBSSxDQUFDNEMsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUMvQix1QkFBdUIsQ0FBQ3JDLGtCQUFrQixDQUFDLENBQUM7SUFDL0U7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLG1DQUEwQjtNQUN4Qi9iLFNBQUssQ0FBQ3NoQixnQkFBSSxFQUFFLDZCQUE2QixDQUFDO01BQzFDLElBQUksSUFBSSxDQUFDc2MsYUFBYSxFQUFFO1FBQ3RCLElBQUksQ0FBQ0EsYUFBYSxDQUFDdUQsbUJBQW1CLENBQUMsSUFBSSxDQUFDekQsUUFBUSxDQUFDL0osVUFBVSxDQUFDO01BQ2xFO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLG1DQUEwQjtNQUN4QjN6QixTQUFLLENBQUNzaEIsZ0JBQUksRUFBRSwyQkFBMkIsQ0FBQztNQUN4QyxJQUFJLENBQUM0QyxPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQy9CLHVCQUF1QixDQUFDcEMsb0JBQW9CLEVBQUUsSUFBSSxDQUFDLENBQUM7TUFDckYsSUFBSSxDQUFDb2xCLGNBQWMsRUFBRTtJQUN2Qjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EseUJBQWdCeE8sTUFBTSxFQUFFeDBCLE9BQU8sRUFBRTtNQUMvQixJQUFJLENBQUM4bEIsT0FBTyxDQUNWLElBQUkvRCxlQUFlLENBQUMvQix1QkFBdUIsQ0FBQ25DLGNBQWMsRUFBRSxJQUFJLEVBQUU7UUFDaEUyVyxNQUFNLEVBQUVBLE1BQU07UUFDZHgwQixPQUFPLEVBQUVBO01BQ1gsQ0FBQyxDQUFDLENBQ0g7SUFDSDs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFSRTtJQUFBO0lBQUEsT0FTQSw4QkFBcUJBLE9BQU8sRUFBc0I7TUFBQSxJQUFwQmkxQixNQUFNLHVFQUFHcDBCLFNBQVM7TUFDOUNpQixTQUFLLENBQUNvaEIsZ0JBQUksMENBQW1DbGpCLE9BQU8sbUNBQXlCaTFCLE1BQU0sRUFBRztNQUN0RixJQUFJLENBQUM4SyxxQkFBcUIsQ0FBQzc5QixNQUFNLHlDQUFrQ2xDLE9BQU8sT0FBSTtNQUM5RSxJQUFJLENBQUM4bEIsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ0csY0FBYyxFQUFFLElBQUksRUFBRTNlLE9BQU8sQ0FBQyxDQUFDO0lBQ3ZGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0EsdUJBQWNpakMsVUFBVSxFQUFFO01BQ3hCcmhDLFNBQUssQ0FBQ3NoQixnQkFBSSxFQUFFLGlCQUFpQixDQUFDO01BQzlCLElBQUksSUFBSSxDQUFDcWMsV0FBVyxFQUFFO1FBQ3BCLElBQUksQ0FBQ0EsV0FBVyxDQUFDcEwsUUFBUSxFQUFFO01BQzdCO01BQ0EsSUFBSSxDQUFDeUMsa0JBQWtCLENBQUNxTSxVQUFVLENBQUM7SUFDckM7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLGdDQUF1QjtNQUNyQnJoQyxTQUFLLENBQUNzaEIsZ0JBQUksRUFBRSx3QkFBd0IsQ0FBQztNQUNyQyxJQUFJLENBQUM0QyxPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDRyxjQUFjLEVBQUUsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO01BQ3BGLElBQUksQ0FBQ29oQixxQkFBcUIsQ0FBQzc5QixNQUFNLENBQUMseUJBQXlCLENBQUM7SUFDOUQ7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORTtJQUFBO0lBQUEsT0FPQSwrQkFBc0J5QyxLQUFLLEVBQUU7TUFDM0IvQyxTQUFLLENBQUNzaEIsZ0JBQUksRUFBRSx5QkFBeUIsQ0FBQztNQUN0QyxJQUFJLElBQUksQ0FBQ3NjLGFBQWEsRUFBRTtRQUN0QixJQUFJLENBQUNBLGFBQWEsQ0FBQ3JMLFFBQVEsRUFBRTtNQUMvQjtNQUNBLElBQUksQ0FBQ1ksYUFBYSxDQUFDcHdCLEtBQUssQ0FBQztJQUMzQjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsZ0NBQXVCO01BQ3JCL0MsU0FBSyxDQUFDc2hCLGdCQUFJLEVBQUUsd0JBQXdCLENBQUM7TUFDckMsSUFBSSxDQUFDNEMsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUMvQix1QkFBdUIsQ0FBQzdCLG9CQUFvQixDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQytrQixpQkFBaUIsRUFBRSxDQUFDO0lBQ2pIOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSx1QkFBYztNQUNadGhDLFNBQUssQ0FBQ3NoQixnQkFBSSxFQUFFLGVBQWUsQ0FBQztNQUM1QixJQUFJLElBQUksQ0FBQ3ljLGNBQWMsRUFBRTtRQUN2QixJQUFJLENBQUNBLGNBQWMsQ0FBQ3dELFNBQVMsRUFBRTtNQUNqQztNQUNBLElBQUksQ0FBQ3JkLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUNVLGNBQWMsRUFBRSxJQUFJLENBQUMsQ0FBQztNQUM1RSxJQUFJLENBQUNra0IsV0FBVyxFQUFFO0lBQ3BCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSw4QkFBc0M7TUFBQSxJQUFuQnorQixLQUFLLHVFQUFHOUQsU0FBUztNQUNsQyxJQUFJLENBQUMsSUFBSSxDQUFDNitCLGlCQUFpQixFQUFFO1FBQzNCOTlCLFNBQUssQ0FBQ3NoQixnQkFBSSxFQUFFLHNCQUFzQixDQUFDO1FBQ25DLElBQUksQ0FBQzJlLFdBQVcsRUFBRTtRQUNsQixJQUFJLENBQUMvYixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDekIsaUJBQWlCLEVBQUUsSUFBSSxFQUFFcFksS0FBSyxDQUFDLENBQUM7TUFDeEY7SUFDRjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVRFO0lBQUE7SUFBQSxPQVVBLHdCQUFlNEssVUFBVSxFQUFFL0osSUFBSSxFQUFFO01BQy9CLElBQUkrSixVQUFVLEtBQUssWUFBWSxFQUFFO1FBQy9CLElBQUksQ0FBQ3luQixVQUFVLENBQUN4eEIsSUFBSSxDQUFDO01BQ3ZCLENBQUMsTUFBTSxJQUFJK0osVUFBVSxLQUFLLDhCQUE4QixFQUFFO1FBQ3hELElBQUksQ0FBQzh6Qiw0QkFBNEIsQ0FBQzc5QixJQUFJLENBQUM7TUFDekMsQ0FBQyxNQUFNLElBQUkrSixVQUFVLEtBQUssNEJBQTRCLEVBQUU7UUFDdEQsSUFBSSxDQUFDK3pCLDBCQUEwQixDQUFDOTlCLElBQUksQ0FBQztNQUN2QyxDQUFDLE1BQU07UUFDTDtRQUNBLElBQUksQ0FBQ3NnQixPQUFPLENBQ1YsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDTyxxQkFBcUIsRUFBRSxJQUFJLEVBQUU7VUFDcEV4UCxVQUFVLEVBQUVBLFVBQVU7VUFDdEIvSixJQUFJLEVBQUVBO1FBQ1IsQ0FBQyxDQUFDLENBQ0g7TUFDSDtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQRTtJQUFBO0lBQUEsT0FRQSw0QkFBbUJzeEIsTUFBTSxFQUFFO01BQ3pCbDFCLFNBQUssQ0FBQ3NoQixnQkFBSSxFQUFFLHVCQUF1QixHQUFHL2MsSUFBSSxDQUFDNE8sU0FBUyxDQUFDK2hCLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7TUFDdEUsSUFBTXlNLFdBQVcsR0FBR2pGLGFBQWEsQ0FBQy8zQixJQUFJLENBQUN1d0IsTUFBTSxDQUFDOTJCLE9BQU8sQ0FBQztNQUN0RCxJQUFJdWpDLFdBQVcsSUFBSUEsV0FBVyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQ2pFLFFBQVEsQ0FBQy9KLFVBQVUsRUFBRTtRQUM5RCxJQUFJLENBQUN3SyxxQkFBcUIsQ0FBQzk5QixPQUFPLENBQUMsSUFBSSxDQUFDO1FBQ3hDLElBQUksQ0FBQzZqQixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDQyxlQUFlLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDN0UsSUFBSSxDQUFDK2tCLGtCQUFrQixDQUFDLElBQUksQ0FBQ2xFLFFBQVEsRUFBRSxJQUFJLENBQUNELEtBQUssQ0FBQztRQUNsRCxJQUFJLENBQUNvRSxjQUFjLENBQUMsSUFBSSxDQUFDbkUsUUFBUSxFQUFFLElBQUksQ0FBQ0QsS0FBSyxDQUFDO01BQ2hELENBQUMsTUFBTTtRQUNMLElBQUksQ0FBQ3ZaLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUNNLGdCQUFnQixFQUFFLElBQUksRUFBRWdZLE1BQU0sQ0FBQyxDQUFDO01BQ3hGO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLGdDQUF1QjRNLFdBQVcsRUFBRTtNQUFBO01BQ2xDOWhDLFNBQUssQ0FBQyw0QkFBNEIsQ0FBQztNQUNuQyxJQUFJLENBQUNzK0IscUJBQXFCLEdBQUc7UUFDM0J5RCxhQUFhLEVBQUVELFdBQVcsSUFBSTtNQUNoQyxDQUFDO01BQ0QsSUFBSSxJQUFJLENBQUNwRSxRQUFRLENBQUNOLG1CQUFtQixFQUFFO1FBQ3JDLElBQUlqYSxDQUFDLEdBQUd2YSxVQUFVLENBQ2hCLFlBQU07VUFDSnNlLFlBQVksQ0FBQy9ELENBQUMsQ0FBQztVQUNmLElBQUksTUFBSSxDQUFDeWEsYUFBYSxFQUFFO1lBQ3RCLE1BQUksQ0FBQ0EsYUFBYSxDQUFDb0UsS0FBSyxDQUFDLE1BQUksQ0FBQzFELHFCQUFxQixDQUFDO1VBQ3REO1VBQ0EsTUFBSSxDQUFDVCxpQkFBaUIsR0FBRyxNQUFJLENBQUNGLFdBQVc7VUFDekMsTUFBSSxDQUFDelosT0FBTyxDQUNWLElBQUl6RCwwQkFBMEIsQ0FBQ3BCLCtCQUErQixDQUFDRyxNQUFNLEVBQUUsTUFBSSxFQUFFO1lBQzNFeWlCLFVBQVUsRUFBRSxNQUFJO1lBQ2hCckQsU0FBUyxFQUFFLE1BQUksQ0FBQ2Y7VUFDbEIsQ0FBQyxDQUFDLENBQ0g7UUFDSCxDQUFDLEVBQ0QsSUFBSSxDQUFDRCxhQUFhLEdBQUcsSUFBSSxDQUFDRixRQUFRLENBQUNMLGlCQUFpQixHQUFHLEdBQUcsQ0FDM0Q7TUFDSDtNQUNBLElBQUksQ0FBQ25aLE9BQU8sQ0FDVixJQUFJL0QsZUFBZSxDQUFDL0IsdUJBQXVCLENBQUNqQyxzQkFBc0IsRUFBRSxJQUFJLEVBQUU7UUFDeEV2ZSxJQUFJLEVBQUVra0MsV0FBVztRQUNqQm5NLFdBQVcsRUFBRSxJQUFJLENBQUN1TSxjQUFjO01BQ2xDLENBQUMsQ0FBQyxDQUNIO0lBQ0g7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLDRCQUFtQnZNLFdBQVcsRUFBRXoxQixLQUFLLEVBQUU7TUFDckMsSUFBSSxDQUFDZ2tCLE9BQU8sQ0FDVixJQUFJL0QsZUFBZSxDQUFDL0IsdUJBQXVCLENBQUM5QixrQkFBa0IsRUFBRSxJQUFJLEVBQUU7UUFDcEVxWixXQUFXLEVBQUVBLFdBQVc7UUFDeEJ6MUIsS0FBSyxFQUFFQTtNQUNULENBQUMsQ0FBQyxDQUNIO0lBQ0g7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLDhCQUFxQnkxQixXQUFXLEVBQUV3TSxXQUFXLEVBQUU7TUFDN0MsSUFBSSxDQUFDamUsT0FBTyxDQUNWLElBQUkvRCxlQUFlLENBQUMvQix1QkFBdUIsQ0FBQy9CLG9CQUFvQixFQUFFLElBQUksRUFBRTtRQUN0RXNaLFdBQVcsRUFBRUEsV0FBVztRQUN4QnYzQixPQUFPLEVBQUUrakM7TUFDWCxDQUFDLENBQUMsQ0FDSDtJQUNIOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0EsMkJBQWtCeE0sV0FBVyxFQUFFO01BQzdCLElBQUksQ0FBQ3pSLE9BQU8sQ0FDVixJQUFJL0QsZUFBZSxDQUFDL0IsdUJBQXVCLENBQUNsQyxpQkFBaUIsRUFBRSxJQUFJLEVBQUU7UUFDbkV5WixXQUFXLEVBQUVBO01BQ2YsQ0FBQyxDQUFDLENBQ0g7SUFDSDs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQU5FO0lBQUE7SUFBQSxPQU9BLDRCQUFtQkEsV0FBVyxFQUFFO01BQzlCLElBQUksQ0FBQ3pSLE9BQU8sQ0FDVixJQUFJL0QsZUFBZSxDQUFDL0IsdUJBQXVCLENBQUNoQyxrQkFBa0IsRUFBRSxJQUFJLEVBQUU7UUFDcEV1WixXQUFXLEVBQUVBO01BQ2YsQ0FBQyxDQUFDLENBQ0g7SUFDSDs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQU5FO0lBQUE7SUFBQSxPQU9BLG9CQUFXTixRQUFRLEVBQUU7TUFDbkIsSUFBUXZ3QixXQUFXLEdBQW9CdXdCLFFBQVEsQ0FBdkN2d0IsV0FBVztRQUFFRyxhQUFhLEdBQUtvd0IsUUFBUSxDQUExQnB3QixhQUFhO01BQ2xDLElBQU1tOUIscUJBQXFCLEdBQUcsSUFBSSxDQUFDL0QsY0FBYztNQUNqRCxJQUFJLE9BQU92NUIsV0FBVyxLQUFLLFdBQVcsSUFBSUEsV0FBVyxLQUFLLElBQUksQ0FBQ3M1QixZQUFZLEVBQUU7UUFDM0UsSUFBSSxDQUFDQSxZQUFZLEdBQUd0NUIsV0FBVztRQUMvQixJQUFJLElBQUksQ0FBQzQ0QixRQUFRLENBQUNiLHFCQUFxQixFQUFFO1VBQ3ZDNXJCLGdCQUFnQixDQUFDLElBQUksQ0FBQ3dzQixLQUFLLENBQUMxVyxJQUFJLEVBQUVoaUIsUUFBUSxDQUFDRCxXQUFXLEVBQUUsRUFBRSxDQUFDLEVBQUVzTywwQkFBMEIsQ0FBQ2lpQixRQUFRLENBQUNua0IsVUFBVSxDQUFDLENBQUM7VUFDN0csSUFBSSxJQUFJLENBQUM2c0IsY0FBYyxFQUFFO1lBQ3ZCLElBQUksQ0FBQ0EsY0FBYyxDQUFDc0UsdUJBQXVCLENBQUN0OUIsUUFBUSxDQUFDRCxXQUFXLEVBQUUsRUFBRSxDQUFDLENBQUM7VUFDeEU7UUFDRjtRQUNBLElBQUksQ0FBQ29mLE9BQU8sQ0FDVixJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUNXLGtCQUFrQixFQUFFLElBQUksRUFBRTtVQUNqRXpZLFdBQVcsRUFBRUMsUUFBUSxDQUFDRCxXQUFXLEVBQUUsRUFBRSxDQUFDO1VBQ3RDdzlCLFdBQVcsRUFBRSxJQUFJLENBQUM3RSxLQUFLLENBQUMxVztRQUMxQixDQUFDLENBQUMsQ0FDSDtNQUNIO01BQ0EsSUFBSSxPQUFPOWhCLGFBQWEsS0FBSyxXQUFXLElBQUlBLGFBQWEsS0FBS205QixxQkFBcUIsRUFBRTtRQUNuRixJQUFJLENBQUMvRCxjQUFjLEdBQUdwNUIsYUFBYTtRQUNuQyxJQUFJLENBQUNpZixPQUFPLENBQ1YsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDWSxxQkFBcUIsRUFBRSxJQUFJLEVBQUU7VUFDcEV2WSxhQUFhLEVBQUVBLGFBQWE7VUFDNUJtOUIscUJBQXFCLEVBQUVBLHFCQUFxQjtVQUM1Q0UsV0FBVyxFQUFFLElBQUksQ0FBQzdFLEtBQUssQ0FBQzFXO1FBQzFCLENBQUMsQ0FBQyxDQUNIO01BQ0g7TUFDQSxJQUFJLENBQUM3QyxPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDSyxrQkFBa0IsRUFBRSxJQUFJLEVBQUVvWSxRQUFRLENBQUMsQ0FBQztJQUM1Rjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQU5FO0lBQUE7SUFBQSxPQU9BLHNDQUE2Qnp4QixJQUFJLEVBQUU7TUFDakMsSUFBSSxDQUFDc2dCLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUNRLDhCQUE4QixFQUFFLElBQUksRUFBRXhaLElBQUksQ0FBQyxDQUFDO0lBQ3BHOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0Esb0NBQTJCQSxJQUFJLEVBQUU7TUFDL0IsSUFBSSxDQUFDc2dCLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUNTLDRCQUE0QixFQUFFLElBQUksRUFBRXpaLElBQUksQ0FBQyxDQUFDO0lBQ2xHOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVJFO0lBQUE7SUFBQSxPQVNBLG9CQUFXK0osVUFBVSxFQUFFK0QsSUFBSSxFQUFFO01BQzNCLE9BQU8sSUFBSSxDQUFDNndCLG1CQUFtQixFQUFFLENBQUNDLFNBQVMsQ0FBQztRQUMxQ0MsV0FBVyxFQUFFO1VBQ1hsUixNQUFNLEVBQUU1akIsVUFBVTtVQUNsQmtFLFNBQVMsRUFBRUg7UUFDYjtNQUNGLENBQUMsQ0FBQztJQUNKOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQRTtJQUFBO0lBQUEsT0FRQSxpQkFBUTVULEtBQUssRUFBRU0sT0FBTyxFQUFFO01BQ3RCLElBQUk7UUFDRixJQUFNc2tDLFFBQVEsR0FBR252QixNQUFNLENBQUNDLElBQUksQ0FBQ2pWLE1BQU0sQ0FBQyxDQUFDa0QsSUFBSSxDQUFDLFVBQUMrWCxDQUFDO1VBQUEsT0FBS0EsQ0FBQyxDQUFDalEsV0FBVyxFQUFFLEtBQUt6TCxLQUFLLENBQUN5TCxXQUFXLEVBQUU7UUFBQSxFQUFDLEdBQUd6TCxLQUFLLEdBQUdTLE1BQU0sQ0FBQ0csS0FBSztRQUNoSCxJQUFNaWtDLFVBQVUsR0FBRyxPQUFPdmtDLE9BQU8sS0FBSyxRQUFRLEdBQUdBLE9BQU8sR0FBR21HLElBQUksQ0FBQzRPLFNBQVMsQ0FBQy9VLE9BQU8sQ0FBQztRQUNsRixJQUFJLENBQUNta0MsbUJBQW1CLEVBQUUsQ0FBQ3RSLElBQUksQ0FBQztVQUM5Qnh6QixHQUFHLEVBQUVpbEMsUUFBUSxDQUFDRSxXQUFXLEVBQUU7VUFDM0J4a0MsT0FBTyxFQUFFdWtDO1FBQ1gsQ0FBQyxDQUFDO01BQ0osQ0FBQyxDQUFDLE9BQU9sK0IsQ0FBQyxFQUFFO1FBQ1YsSUFBTXJHLFFBQU8sR0FBR3FHLENBQUMsQ0FBQ3JHLE9BQU8sSUFBSXFHLENBQUM7UUFDOUJ2RSxTQUFLLENBQUNvaEIsZ0JBQUksdUdBQXVHO1FBQ2pIcGhCLFNBQUssQ0FBQ29oQixnQkFBSSxFQUFFbGpCLFFBQU8sQ0FBQztNQUN0QjtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtFQUZFO0lBQUE7SUFBQSxPQUdBLHlCQUFnQjtNQUNkLElBQUksQ0FBQ21rQyxtQkFBbUIsRUFBRSxDQUFDdFIsSUFBSSxDQUFDO1FBQzlCO1FBQ0FuSixJQUFJLEVBQUU7VUFDSithLFNBQVMsRUFBRSxJQUFJO1VBQ2ZDLFNBQVMsRUFBRTtRQUNiO01BQ0YsQ0FBQyxDQUFDO0lBQ0o7O0lBRUE7QUFDRjtBQUNBO0VBRkU7SUFBQTtJQUFBLE9BR0EsMEJBQWlCO01BQ2YsSUFBSSxDQUFDUCxtQkFBbUIsRUFBRSxDQUFDdFIsSUFBSSxDQUFDO1FBQzlCO1FBQ0FuSixJQUFJLEVBQUU7VUFDSithLFNBQVMsRUFBRSxLQUFLO1VBQ2hCQyxTQUFTLEVBQUU7UUFDYjtNQUNGLENBQUMsQ0FBQztJQUNKOztJQUVBO0FBQ0Y7QUFDQTtFQUZFO0lBQUE7SUFBQSxPQUdBLHFCQUFZO01BQ1YsSUFBSSxDQUFDUCxtQkFBbUIsRUFBRSxDQUFDdFIsSUFBSSxDQUFDO1FBQzlCbkosSUFBSSxFQUFFO1VBQ0orYSxTQUFTLEVBQUU7UUFDYjtNQUNGLENBQUMsQ0FBQztJQUNKOztJQUVBO0FBQ0Y7QUFDQTtFQUZFO0lBQUE7SUFBQSxPQUdBLHVCQUFjO01BQ1osSUFBSSxDQUFDTixtQkFBbUIsRUFBRSxDQUFDdFIsSUFBSSxDQUFDO1FBQzlCbkosSUFBSSxFQUFFO1VBQ0orYSxTQUFTLEVBQUU7UUFDYjtNQUNGLENBQUMsQ0FBQztJQUNKOztJQUVBO0FBQ0Y7QUFDQTtFQUZFO0lBQUE7SUFBQSxPQUdBLHFCQUFZO01BQ1YsSUFBSSxDQUFDTixtQkFBbUIsRUFBRSxDQUFDdFIsSUFBSSxDQUFDO1FBQzlCbkosSUFBSSxFQUFFO1VBQ0pnYixTQUFTLEVBQUU7UUFDYjtNQUNGLENBQUMsQ0FBQztJQUNKOztJQUVBO0FBQ0Y7QUFDQTtFQUZFO0lBQUE7SUFBQSxPQUdBLHVCQUFjO01BQ1osSUFBSSxDQUFDUCxtQkFBbUIsRUFBRSxDQUFDdFIsSUFBSSxDQUFDO1FBQzlCbkosSUFBSSxFQUFFO1VBQ0pnYixTQUFTLEVBQUU7UUFDYjtNQUNGLENBQUMsQ0FBQztJQUNKOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQRTtJQUFBO0lBQUEsT0FRQSwrQkFBc0I7TUFDcEIsT0FBTyxJQUFJLENBQUNqRixpQkFBaUI7SUFDL0I7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLHlCQUFnQjtNQUNkLE9BQU8sSUFBSSxDQUFDRCxhQUFhO0lBQzNCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSw2QkFBb0I7TUFDbEIsT0FBTyxJQUFJLENBQUNELFdBQVcsR0FBRyxJQUFJLENBQUNBLFdBQVcsQ0FBQzVILFVBQVUsR0FBRzkyQixTQUFTO0lBQ25FOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSwwQkFBaUI7TUFDZixPQUFPLElBQUksQ0FBQzArQixXQUFXLEdBQUcsSUFBSSxDQUFDQSxXQUFXLENBQUNoSSxXQUFXLEdBQUcxMkIsU0FBUztJQUNwRTs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsMEJBQWlCO01BQ2YsT0FBTyxJQUFJLENBQUMrK0IsWUFBWTtJQUMxQjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsdUJBQWM7TUFDWixPQUFPLElBQUksQ0FBQ0QsY0FBYyxHQUFHLElBQUksQ0FBQ0EsY0FBYyxDQUFDeFQsV0FBVyxFQUFFLEdBQUd0ckIsU0FBUztJQUM1RTs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EscUJBQVk7TUFDVixPQUFPLElBQUksQ0FBQ3crQixLQUFLLENBQUMxVyxJQUFJO0lBQ3hCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxzQkFBYTtNQUNYLE9BQU8sSUFBSSxDQUFDMlcsUUFBUTtJQUN0Qjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsbUJBQVU7TUFDUixPQUFPaEMsYUFBYSxDQUFDQyxHQUFHLENBQUNpSCxXQUFXLEVBQUU7SUFDeEM7RUFBQztFQUFBO0FBQUEsRUFscEN5QjFaLGtCQUFrQjtBQXFwQy9Cc1UseUVBQWEsRTs7QUN6dENoQjs7QUFFdUI7QUFDYzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU11Rix3QkFBa0IsR0FBRyxTQUFyQkEsa0JBQWtCLENBQUlDLGFBQWEsRUFBRUMsWUFBWSxFQUFLO0VBQ2pFLElBQUloM0IsR0FBRyxHQUFHLElBQUlwTCxlQUFlLEVBQUU7RUFDL0IsSUFBTXU0QixTQUFTLEdBQUc0SixhQUFhLENBQUMvM0IsRUFBRTtFQUNsQyxJQUFJKzNCLGFBQWEsQ0FBQ0UsUUFBUSxDQUFDMzVCLFdBQVcsRUFBRSxLQUFLLE9BQU8sRUFBRTtJQUNwRCxJQUFJeWdCLEdBQUcsR0FBR3BhLE9BQVcsQ0FBQ3ZGLGFBQWEsQ0FBQyxLQUFLLENBQUM7SUFDMUMyZixHQUFHLENBQUMvZSxFQUFFLEdBQUdtdUIsU0FBUyxHQUFHLE9BQU87SUFDNUI2SixZQUFZLENBQUMxMkIsV0FBVyxDQUFDeWQsR0FBRyxDQUFDO0lBQzdCLElBQUlnWixhQUFhLENBQUNHLGFBQWEsRUFBRTtNQUMvQkgsYUFBYSxDQUFDRyxhQUFhLENBQUNsYSxXQUFXLENBQUMrWixhQUFhLENBQUM7SUFDeEQ7SUFDQS8yQixHQUFHLENBQUM1TCxPQUFPLENBQUMycEIsR0FBRyxDQUFDL2UsRUFBRSxDQUFDO0VBQ3JCLENBQUMsTUFBTTtJQUNMZ0IsR0FBRyxDQUFDNUwsT0FBTyxDQUFDKzRCLFNBQVMsQ0FBQztFQUN4QjtFQUNBLE9BQU9udEIsR0FBRyxDQUFDMUwsT0FBTztBQUNwQixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTTZpQyxvQkFBYyxHQUFHLFNBQWpCQSxjQUFjLENBQUlDLE1BQU0sRUFBRTFoQyxPQUFPLEVBQUUyaEMsU0FBUyxFQUFFejJCLFNBQVMsRUFBRXVzQixTQUFTLEVBQUs7RUFDbEYsSUFBSW50QixHQUFHLEdBQUcsSUFBSXBMLGVBQWUsRUFBRTtFQUMvQixJQUFJazVCLE1BQU0sR0FBRztJQUNYd0osT0FBTyxFQUFFLE1BQU07SUFDZkMsS0FBSyxFQUFFLFFBQVE7SUFDZkMsT0FBTyxFQUFFOWhDLE9BQU8sQ0FBQytoQyxlQUFlLElBQUksTUFBTTtJQUMxQ0MsaUJBQWlCLEVBQUUsUUFBUTtJQUMzQkMsZUFBZSxFQUFFLE1BQU07SUFDdkJDLGVBQWUsRUFBRTtFQUNuQixDQUFDO0VBQ0QsSUFBSUMsVUFBVSxHQUFHO0lBQ2Y3NEIsRUFBRSxFQUFFbzRCLE1BQU07SUFDVnpsQyxJQUFJLEVBQUV5bEMsTUFBTTtJQUNaVSxLQUFLLEVBQUU7RUFDVCxDQUFDO0VBQ0QsSUFBSWwzQixTQUFTLENBQUNtM0IscUJBQXFCLENBQUNyaUMsT0FBTyxDQUFDc2lDLGVBQWUsQ0FBQyxFQUFFO0lBQzVEcDNCLFNBQVMsQ0FBQ3EzQixRQUFRLENBQ2hCdmlDLE9BQU8sQ0FBQ3dpQyxHQUFHLEVBQ1gvSyxTQUFTLEVBQ1R6M0IsT0FBTyxDQUFDeWlDLFVBQVUsSUFBSSxHQUFHLEVBQ3pCemlDLE9BQU8sQ0FBQzBpQyxXQUFXLElBQUksR0FBRyxFQUMxQjFpQyxPQUFPLENBQUNzaUMsZUFBZSxFQUN2QnRpQyxPQUFPLENBQUMyaUMsaUJBQWlCLEVBQ3pCaEIsU0FBUyxFQUNUdkosTUFBTSxFQUNOK0osVUFBVSxFQUNWLFVBQUMvL0IsTUFBTSxFQUFLO01BQ1YsSUFBSUEsTUFBTSxDQUFDd2dDLE9BQU8sRUFBRTtRQUNsQnQ0QixHQUFHLENBQUM1TCxPQUFPLEVBQUU7TUFDZixDQUFDLE1BQ0k7UUFDSDRMLEdBQUcsQ0FBQzNMLE1BQU0sQ0FBQyw0QkFBNEIsQ0FBQztNQUMxQztJQUNGLENBQUMsQ0FBQztFQUNOLENBQUMsTUFBTTtJQUNMMkwsR0FBRyxDQUFDM0wsTUFBTSxDQUFDLHdDQUF3QyxDQUFDO0VBQ3REO0VBQ0EsT0FBTzJMLEdBQUcsQ0FBQzFMLE9BQU87QUFDcEIsQ0FBQyxDOztBQ3BGVzs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFNEI7QUFDSjtBQUVwQyxJQUFNK2dCLDZCQUFJLEdBQUcsOEJBQThCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkEsSUFLTWtqQixnREFBdUI7RUFFM0IsbUNBQWU7SUFBQTtJQUNiLElBQUksQ0FBQ0MsUUFBUSxHQUFHeGxDLFNBQVM7SUFDekIsSUFBSSxDQUFDMHhCLGlCQUFpQixHQUFHLEVBQUU7RUFDN0I7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLDRCQUFvQnpqQixPQUFPLEVBQUU7TUFDM0IsSUFBSSxDQUFDeWpCLGlCQUFpQixDQUFDeHhCLElBQUksQ0FBQytOLE9BQU8sQ0FBQztJQUN0Qzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsK0JBQXVCQSxPQUFPLEVBQUU7TUFDOUIsSUFBSWxLLENBQUMsR0FBRyxJQUFJLENBQUMydEIsaUJBQWlCLENBQUNwdkIsTUFBTTtNQUNyQyxJQUFJMnZCLFFBQVE7TUFDWixPQUFNLEVBQUVsdUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO1FBQ2RrdUIsUUFBUSxHQUFHLElBQUksQ0FBQ1AsaUJBQWlCLENBQUMzdEIsQ0FBQyxDQUFDO1FBQ3BDLElBQUlrdUIsUUFBUSxLQUFLaGtCLE9BQU8sRUFBRTtVQUN4QixJQUFJLENBQUN5akIsaUJBQWlCLENBQUN2dEIsTUFBTSxDQUFDSixDQUFDLEVBQUUsQ0FBQyxDQUFDO1VBQ25DO1FBQ0Y7TUFDRjtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxpQ0FBeUJELEtBQUssRUFBRTtNQUM5Qi9DLFNBQUssQ0FBQ3NoQiw2QkFBSSxFQUFFLHNCQUFzQixDQUFDO01BQ25DLElBQUl0ZSxDQUFDO01BQ0wsSUFBSXpCLE1BQU0sR0FBRyxJQUFJLENBQUNvdkIsaUJBQWlCLENBQUNwdkIsTUFBTTtNQUMxQyxJQUFJMkwsT0FBTztNQUNYLEtBQUtsSyxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUd6QixNQUFNLEVBQUV5QixDQUFDLEVBQUUsRUFBRTtRQUMzQmtLLE9BQU8sR0FBRyxJQUFJLENBQUN5akIsaUJBQWlCLENBQUMzdEIsQ0FBQyxDQUFDO1FBQ25DLElBQUlrSyxPQUFPLENBQUNpa0IsT0FBTyxDQUFDNXNCLElBQUksQ0FBQ0MsS0FBSyxDQUFDekIsS0FBSyxDQUFDLENBQUMsRUFBRTtVQUN0QztRQUNGO01BQ0Y7SUFDRjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQU5FO0lBQUE7SUFBQSxPQU9BLHFDQUE2Qm5GLElBQUksRUFBRXdNLEVBQUUsRUFBRTtNQUNyQyxJQUFNczZCLHdCQUF3QixHQUFHLElBQUksQ0FBQ0MsdUJBQXVCLENBQUN0aUIsSUFBSSxDQUFDLElBQUksQ0FBQztNQUN4RSxJQUFNdWlCLElBQUksR0FBR3g2QixFQUFFLENBQUNhLEVBQUUsQ0FBQzNDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzRNLElBQUksQ0FBQyxHQUFHLENBQUM7TUFDdkMsSUFBTTJ2QixXQUFXLEdBQUcsQ0FBQyx5QkFBeUIsRUFBRUQsSUFBSSxDQUFDLENBQUMxdkIsSUFBSSxDQUFDLEdBQUcsQ0FBQztNQUMvRGxWLFNBQUssQ0FBQ3NoQiw2QkFBSSwrQ0FBd0NzakIsSUFBSSxFQUFHO01BQ3pENWtDLFNBQUssQ0FBQ3NoQiw2QkFBSSx1Q0FBZ0N1akIsV0FBVyxFQUFHO01BQ3hEejZCLEVBQUUsQ0FBQzA2Qix3QkFBd0IsQ0FBQ2xuQyxJQUFJLEVBQUVpbkMsV0FBVyxDQUFDO01BQzlDajFCLE9BQVcsQ0FBQ2xELFNBQVMsQ0FBQ200QixXQUFXLEVBQUVILHdCQUF3QixDQUFDO0lBQzlEOztJQUVBO0FBQ0Y7QUFDQTtFQUZFO0lBQUE7SUFBQSxPQUdBLGlCQUFTSyxLQUFLLEVBQUU7TUFDZCxJQUFJLENBQUNOLFFBQVEsR0FBRzcwQixPQUFXLENBQUM5QyxjQUFjLENBQUNpNEIsS0FBSyxDQUFDO01BQ2pELElBQUksQ0FBQyxJQUFJLENBQUNOLFFBQVEsRUFBRTtRQUNsQnhrQyxRQUFJLDBEQUFtRDhrQyxLQUFLLEVBQUc7TUFDakU7SUFDRjs7SUFFQTtBQUNGO0FBQ0E7RUFGRTtJQUFBO0lBQUEsT0FHQSxzQkFBYztNQUNaLE9BQU8sSUFBSSxDQUFDcFUsaUJBQWlCLENBQUNwdkIsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUN4QyxJQUFJLENBQUNvdkIsaUJBQWlCLENBQUNudkIsS0FBSyxFQUFFO01BQ2hDO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLDRCQUFvQjVELElBQUksRUFBRStQLFVBQVUsRUFBRXZQLE9BQU8sRUFBRTtNQUM3QzRCLFNBQUssQ0FBQ3NoQiw2QkFBSSxFQUFFLHNCQUFzQixDQUFDO01BQ25DLElBQUk7UUFDRixJQUFJLENBQUNtakIsUUFBUSxDQUFDblQsZ0JBQWdCLENBQUMxekIsSUFBSSxFQUFFK1AsVUFBVSxFQUFFLE9BQU92UCxPQUFPLEtBQUssUUFBUSxHQUFHQSxPQUFPLEdBQUdtRyxJQUFJLENBQUM0TyxTQUFTLENBQUMvVSxPQUFPLENBQUMsQ0FBQztNQUNuSCxDQUFDLENBQ0QsT0FBT3FHLENBQUMsRUFBRTtRQUNSeEUsUUFBSSxDQUFDLG1DQUFtQyxHQUFHckMsSUFBSSxHQUFHLFlBQVksR0FBRzZHLENBQUMsQ0FBQ3JHLE9BQU8sQ0FBQztNQUM3RTtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0Esb0NBQTRCUixJQUFJLEVBQUUwRSxHQUFHLEVBQUVFLEtBQUssRUFBRTtNQUM1Q3hDLFNBQUssQ0FBQ3NoQiw2QkFBSSxFQUFFLDhCQUE4QixDQUFDO01BQzNDLElBQUk7UUFDRixJQUFJLENBQUNtakIsUUFBUSxDQUFDTyx3QkFBd0IsQ0FBQ3BuQyxJQUFJLEVBQUUwRSxHQUFHLEVBQUVFLEtBQUssQ0FBQztNQUMxRCxDQUFDLENBQ0QsT0FBT2lDLENBQUMsRUFBRTtRQUNSeEUsUUFBSSxDQUFDLG1DQUFtQyxHQUFHckMsSUFBSSxHQUFHLFlBQVksR0FBRzZHLENBQUMsQ0FBQ3JHLE9BQU8sQ0FBQztNQUM3RTtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSwrQkFBdUJtaUIsZ0JBQWdCLEVBQUU7TUFDdkN2Z0IsU0FBSyxDQUFDc2hCLDZCQUFJLEVBQUUseUJBQXlCLENBQUM7TUFDdEMsSUFBSTtRQUNGLElBQUksQ0FBQzJqQiwyQkFBMkIsQ0FBQzFrQixnQkFBZ0IsRUFBRSxJQUFJLENBQUNra0IsUUFBUSxDQUFDO1FBQ2pFLElBQUksQ0FBQ0EsUUFBUSxDQUFDUyxxQkFBcUIsQ0FBQzNrQixnQkFBZ0IsQ0FBQztNQUN2RCxDQUFDLENBQ0QsT0FBTzliLENBQUMsRUFBRTtRQUNSeEUsUUFBSSxDQUFDLHNDQUFzQyxHQUFHckMsSUFBSSxHQUFHLFlBQVksR0FBRzZHLENBQUMsQ0FBQ3JHLE9BQU8sQ0FBQztNQUNoRjtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSwrQkFBdUJtaUIsZ0JBQWdCLEVBQUU7TUFDdkN2Z0IsU0FBSyxDQUFDc2hCLDZCQUFJLEVBQUUseUJBQXlCLENBQUM7TUFDdEMsSUFBSTtRQUNGLElBQUksQ0FBQ21qQixRQUFRLENBQUNVLHFCQUFxQixDQUFDNWtCLGdCQUFnQixDQUFDO01BQ3ZELENBQUMsQ0FDRCxPQUFPOWIsQ0FBQyxFQUFFO1FBQ1J4RSxRQUFJLENBQUMsc0NBQXNDLEdBQUdyQyxJQUFJLEdBQUcsWUFBWSxHQUFHNkcsQ0FBQyxDQUFDckcsT0FBTyxDQUFDO01BQ2hGO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLDJCQUFtQm1pQixnQkFBZ0IsRUFBRTtNQUNuQ3ZnQixTQUFLLENBQUNzaEIsNkJBQUksRUFBRSw0QkFBNEIsQ0FBQztNQUN6QyxJQUFJO1FBQ0YsSUFBSSxDQUFDbWpCLFFBQVEsQ0FBQ1csMEJBQTBCLENBQUM3a0IsZ0JBQWdCLENBQUM7TUFDNUQsQ0FBQyxDQUNELE9BQU85YixDQUFDLEVBQUU7UUFDUnhFLFFBQUksQ0FBQyx5Q0FBeUMsR0FBR3JDLElBQUksR0FBRyxZQUFZLEdBQUc2RyxDQUFDLENBQUNyRyxPQUFPLENBQUM7TUFDbkY7SUFDRjtFQUFDO0VBQUE7QUFBQTtBQUlZb21DLDZHQUF1QixFOztBQ3RMMUI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFeUI7QUFDRztBQUNnQztBQUNIO0FBQ0U7QUFDUDtBQUNmO0FBQ2I7QUFFcEMsSUFBTWxqQixnQ0FBSSxHQUFHLG1CQUFtQjs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFNblAsaUNBQUssR0FBRyxTQUFSQSxLQUFLLENBQUkzUCxLQUFLLEVBQUs7RUFDdkIsSUFBSSxPQUFPQSxLQUFLLEtBQUssUUFBUSxFQUFFO0lBQzdCLE9BQU91QyxRQUFRLENBQUN2QyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLENBQUMsTUFDSTtJQUNILE9BQU80UCxJQUFJLENBQUNDLEtBQUssQ0FBQzdQLEtBQUssQ0FBQztFQUMxQjtBQUNGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTTZpQyxlQUFlLEdBQUcsU0FBbEJBLGVBQWUsQ0FBSTFSLFVBQVUsRUFBSztFQUN0QyxPQUFPLG9CQUFvQixDQUFDMlIsSUFBSSxDQUFDM1IsVUFBVSxDQUFDO0FBQzlDLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBLElBUU00Uiw2Q0FBaUI7RUFBQTtFQUFBO0VBRXJCLDJCQUFhQyxrQkFBa0IsRUFBRXZ3QixLQUFLLEVBQUU1VixJQUFJLEVBQTJCO0lBQUE7SUFBQSxJQUF6Qm9tQyxXQUFXLHVFQUFHeG1DLFNBQVM7SUFBQTtJQUNuRTtJQUNBLE1BQUtnVyxLQUFLLEdBQUdBLEtBQUs7SUFDbEIsTUFBS3NVLEtBQUssR0FBRyxNQUFLdFUsS0FBSyxDQUFDdVUsU0FBUyxDQUFDLElBQUksQ0FBQztJQUN2QyxNQUFLblosTUFBTSxHQUFHLE1BQUs0RSxLQUFLLENBQUN6RixVQUFVO0lBQ25DLE1BQUtpYSxNQUFNLEdBQUcsTUFBS0MsZ0JBQWdCLENBQUMsTUFBS3pVLEtBQUssQ0FBQztJQUMvQyxNQUFLMFUsVUFBVSxHQUFHdHFCLElBQUk7SUFDdEIsTUFBS3FtQyxNQUFNLEdBQUd6bUMsU0FBUztJQUN2QixNQUFLNHFCLFNBQVMsR0FBRzVxQixTQUFTO0lBQzFCLE1BQUswbUMsWUFBWSxHQUFHRixXQUFXLElBQUksSUFBSWpCLHdCQUF1QixFQUFFO0lBQ2hFLE1BQUsxYSwyQkFBMkIsR0FBRzBiLGtCQUFrQjtJQUNyRDUxQixPQUFXLENBQUM1Qix1QkFBdUIsQ0FBQyxNQUFLK2IsdUJBQXVCLENBQUMxSCxJQUFJLENBQUMseURBQUssQ0FBQztJQUFBO0VBQzlFOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQRTtJQUFBO0lBQUEsT0FRQSwwQkFBa0JwTixLQUFLLEVBQUU7TUFDdkIsSUFBSUEsS0FBSyxDQUFDekYsVUFBVSxDQUFDaEIsU0FBUyxDQUFDQyxRQUFRLENBQUMseUJBQXlCLENBQUMsRUFBRTtRQUNsRSxPQUFPd0csS0FBSyxDQUFDekYsVUFBVTtNQUN6QixDQUFDLE1BQ0k7UUFDSCxJQUFNYSxNQUFNLEdBQUc0RSxLQUFLLENBQUN6RixVQUFVO1FBQy9CLElBQU13YSxHQUFHLEdBQUdwYSxPQUFXLENBQUN2RixhQUFhLENBQUMsS0FBSyxDQUFDO1FBQzVDMmYsR0FBRyxDQUFDeGIsU0FBUyxDQUFDZ1csR0FBRyxDQUFDLHlCQUF5QixDQUFDO1FBQzVDblUsTUFBTSxDQUFDNFosWUFBWSxDQUFDRCxHQUFHLEVBQUUvVSxLQUFLLENBQUM7UUFDL0I1RSxNQUFNLENBQUM0WSxXQUFXLENBQUNoVSxLQUFLLENBQUM7UUFDekIrVSxHQUFHLENBQUN6ZCxXQUFXLENBQUMwSSxLQUFLLENBQUM7UUFDdEIsT0FBTytVLEdBQUc7TUFDWjtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxvQkFBWTtNQUNWO01BQ0EsSUFBSTVmLEVBQUUsR0FBRyxJQUFJLENBQUN3N0IsZUFBZSxFQUFFO01BQy9CLElBQUkxYixRQUFRLEdBQUc5ZixFQUFFLENBQUNvRixVQUFVO01BQzVCLElBQUkyYSxXQUFXLEdBQUcsSUFBSSxDQUFDVixNQUFNO01BQzdCLElBQUlTLFFBQVEsRUFBRTtRQUNaQSxRQUFRLENBQUNqQixXQUFXLENBQUM3ZSxFQUFFLENBQUM7UUFDeEI7UUFDQSxJQUFJOGYsUUFBUSxLQUFLLElBQUksQ0FBQzdaLE1BQU0sRUFBRTtVQUM1QjZaLFFBQVEsQ0FBQzFhLFVBQVUsQ0FBQ3laLFdBQVcsQ0FBQ2lCLFFBQVEsQ0FBQztVQUN6Q0MsV0FBVyxHQUFHLElBQUksQ0FBQzlaLE1BQU07UUFDM0I7TUFDRixDQUFDLE1BQU07UUFDTCxJQUFJO1VBQ0ZqRyxFQUFFLENBQUNxYSxNQUFNLEVBQUU7UUFDYixDQUFDLENBQUMsT0FBT2hnQixDQUFDLEVBQUU7VUFDVnhFLFFBQUksQ0FBQ3FoQixnQ0FBSSx3REFBaUQ3YyxDQUFDLENBQUNyRyxPQUFPLEVBQUc7UUFDeEU7TUFDRjtNQUNBLElBQUksQ0FBQzZXLEtBQUssR0FBRyxJQUFJLENBQUNzVSxLQUFLLENBQUNDLFNBQVMsQ0FBQyxJQUFJLENBQUM7TUFDdkNXLFdBQVcsQ0FBQzVkLFdBQVcsQ0FBQyxJQUFJLENBQUMwSSxLQUFLLENBQUM7TUFDbkMsSUFBSSxJQUFJLENBQUM0VSxTQUFTLEVBQUU7UUFDbEIsSUFBSSxDQUFDQSxTQUFTLENBQUNPLE1BQU0sRUFBRTtNQUN6QjtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0EsOEJBQXNCQyxRQUFRLEVBQUU7TUFDOUIsSUFBTUMsUUFBUSxHQUFHLElBQUksQ0FBQ0MsV0FBVyxFQUFFO01BQ25DLElBQUksT0FBT0QsUUFBUSxLQUFLLFdBQVcsRUFBRTtRQUNuQztNQUNGO01BQ0FELFFBQVEsQ0FBQ3JDLEVBQUUsQ0FBQ3BMLG9CQUFvQixDQUFDQyxlQUFlLEVBQUUsWUFBTTtRQUN0RHlOLFFBQVEsQ0FBQ25ELFFBQVEsQ0FBQ3RDLGFBQWEsQ0FBQ0ksT0FBTyxDQUFDO01BQzFDLENBQUMsQ0FBQztNQUNGb0YsUUFBUSxDQUFDckMsRUFBRSxDQUFDcEwsb0JBQW9CLENBQUNFLGNBQWMsRUFBRSxZQUFNO1FBQ3JEd04sUUFBUSxDQUFDbkQsUUFBUSxDQUFDdEMsYUFBYSxDQUFDRyxJQUFJLENBQUM7TUFDdkMsQ0FBQyxDQUFDO01BQ0ZxRixRQUFRLENBQUNyQyxFQUFFLENBQUNwTCxvQkFBb0IsQ0FBQ1UsY0FBYyxFQUFFLFlBQU07UUFDckRnTixRQUFRLENBQUNuRCxRQUFRLENBQUN0QyxhQUFhLENBQUNHLElBQUksQ0FBQztNQUN2QyxDQUFDLENBQUM7TUFDRnFGLFFBQVEsQ0FBQ3JDLEVBQUUsQ0FBQ3BMLG9CQUFvQixDQUFDSyxrQkFBa0IsRUFBRSxVQUFDbGEsS0FBSyxFQUFLO1FBQzlELElBQUlBLEtBQUssQ0FBQ2EsSUFBSSxDQUFDeWhCLFFBQVEsRUFBRTtVQUN2QmlGLFFBQVEsQ0FBQ1EsbUJBQW1CLENBQUMvbkIsS0FBSyxDQUFDYSxJQUFJLENBQUN5aEIsUUFBUSxDQUFDO1FBQ25EO01BQ0YsQ0FBQyxDQUFDO01BQ0ZnRixRQUFRLENBQUNyQyxFQUFFLENBQUNwTCxvQkFBb0IsQ0FBQ2MsYUFBYSxFQUFFLFVBQUMzYSxLQUFLLEVBQUs7UUFDekR1bkIsUUFBUSxDQUFDcEMsU0FBUyxDQUFDbmxCLEtBQUssQ0FBQ2EsSUFBSSxDQUFDK21CLE1BQU0sQ0FBQztNQUN2QyxDQUFDLENBQUM7TUFDRk4sUUFBUSxDQUFDckMsRUFBRSxDQUFDcEwsb0JBQW9CLENBQUNpQixxQkFBcUIsRUFBRSxVQUFDOWEsS0FBSyxFQUFLO1FBQ2pFLElBQUlBLEtBQUssQ0FBQ2EsSUFBSSxDQUFDOG1CLElBQUksS0FBSzdGLGFBQWEsQ0FBQ0UsU0FBUyxFQUFFO1VBQy9DdUYsUUFBUSxDQUFDaEQsTUFBTSxDQUFDLElBQUksQ0FBQztRQUN2QjtRQUNBZ0QsUUFBUSxDQUFDbkQsUUFBUSxDQUFDcGtCLEtBQUssQ0FBQ2EsSUFBSSxDQUFDOG1CLElBQUksQ0FBQztNQUNwQyxDQUFDLENBQUM7TUFDRkwsUUFBUSxDQUFDckMsRUFBRSxDQUFDcEwsb0JBQW9CLENBQUNnQixvQkFBb0IsRUFBRSxVQUFDN2EsS0FBSyxFQUFLO1FBQ2hFdW5CLFFBQVEsQ0FBQ2pELFdBQVcsQ0FBQ3RrQixLQUFLLENBQUNhLElBQUksQ0FBQ2xHLElBQUksRUFBRXFGLEtBQUssQ0FBQ2EsSUFBSSxDQUFDeWhCLFFBQVEsQ0FBQztNQUM1RCxDQUFDLENBQUM7TUFDRmdGLFFBQVEsQ0FBQ3JDLEVBQUUsQ0FBQ3BMLG9CQUFvQixDQUFDa0Isd0JBQXdCLEVBQUUsVUFBQy9hLEtBQUssRUFBSztRQUNwRXVuQixRQUFRLENBQUNsRCxrQkFBa0IsQ0FBQ3JrQixLQUFLLENBQUNhLElBQUksQ0FBQztNQUN6QyxDQUFDLENBQUM7SUFDSjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQU5FO0lBQUE7SUFBQSxPQU9BLGlDQUF5QmtsQixZQUFZLEVBQUU7TUFDckMsSUFBTWpjLFNBQVMsR0FBRyxJQUFJLENBQUMrNEIsZUFBZSxFQUFFO01BQ3hDLElBQUk5YyxZQUFZLEVBQUU7UUFDaEIsSUFBSSxDQUFDVyxNQUFNLENBQUNqYixTQUFTLENBQUNnVyxHQUFHLENBQUMscUNBQXFDLENBQUM7UUFDaEUzWCxTQUFTLENBQUMyQixTQUFTLENBQUNnVyxHQUFHLENBQUMscUNBQXFDLENBQUM7TUFDaEUsQ0FBQyxNQUNJO1FBQ0gsSUFBSSxDQUFDaUYsTUFBTSxDQUFDamIsU0FBUyxDQUFDaVcsTUFBTSxDQUFDLHFDQUFxQyxDQUFDO1FBQ25FNVgsU0FBUyxDQUFDMkIsU0FBUyxDQUFDaVcsTUFBTSxDQUFDLHFDQUFxQyxDQUFDO01BQ25FO01BQ0QsSUFBSSxDQUFDUCxPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDa0Isd0JBQXdCLEVBQUU3ZSxTQUFTLEVBQUU2cEIsWUFBWSxDQUFDLENBQUM7SUFDM0c7O0lBRUM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLDRCQUFvQnZvQixPQUFPLEVBQUU7TUFDM0IsSUFBTW1uQixJQUFJLEdBQUcsSUFBSTtNQUNqQjlYLE9BQVcsQ0FBQ2QsZ0NBQWdDLENBQUMsVUFBQSsyQixTQUFTLEVBQUk7UUFDeEQ3bEMsU0FBSyxDQUFDc2hCLGdDQUFJLG9FQUE2RHVrQixTQUFTLFFBQUs7UUFDckZ0bEMsT0FBTyxDQUFDRixPQUFPLENBQUN3bEMsU0FBUyxDQUFDO1FBQzFCbmUsSUFBSSxDQUFDb2UscUJBQXFCLEVBQUU7TUFDOUIsQ0FBQyxDQUFDO0lBQ0o7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLGlDQUF5QixDQUFDOztJQUUzQjtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBYkM7SUFBQTtJQUFBLE9BY0MsbUJBQVdmLEtBQUssRUFBRXBqQyxPQUFPLEVBQXlDO01BQUE7TUFBQSxJQUF2Q29rQyxNQUFNLHVFQUFHLElBQUk7TUFBQSxJQUFFOUIsZUFBZSx1RUFBRyxJQUFJO01BQzlEamtDLFNBQUssQ0FBQ3NoQixnQ0FBSSxFQUFFLGFBQWEsQ0FBQztNQUMxQixJQUFJLENBQUNva0IsTUFBTSxHQUFHWCxLQUFLO01BQ25CLElBQUksQ0FBQ3RiLE1BQU0sR0FBRyxJQUFJLENBQUNDLGdCQUFnQixDQUFDLElBQUksQ0FBQ3pVLEtBQUssQ0FBQztNQUMvQyxJQUFNd3dCLFdBQVcsR0FBRyxJQUFJLENBQUNFLFlBQVk7TUFDckMsSUFBTW53QixRQUFRLEdBQUcsSUFBSTNVLGVBQWUsRUFBRTtNQUN0QyxJQUFNc3JCLGtCQUFrQixHQUFHeHFCLE9BQU8sQ0FBQzJvQixRQUFRO01BQzNDLElBQU04QixPQUFPLEdBQUd4YyxPQUFXLENBQUMxQixtQkFBbUIsQ0FBQyxJQUFJLENBQUMrRyxLQUFLLEVBQUUsT0FBTyxDQUFDO01BQ3BFLElBQU1xVSxtQkFBbUIsR0FBRzFaLE9BQVcsQ0FBQzFCLG1CQUFtQixDQUFDLElBQUksQ0FBQytHLEtBQUssRUFBRSxVQUFVLENBQUMsSUFBSXJGLE9BQVcsQ0FBQ3RCLGVBQWUsQ0FBQyxJQUFJLENBQUMyRyxLQUFLLEVBQUUsZUFBZSxDQUFDO01BQy9JdFQsT0FBTyxDQUFDd2lDLEdBQUcsR0FBRzRCLE1BQU0sSUFBSXBrQyxPQUFPLENBQUN3aUMsR0FBRztNQUNuQ3hpQyxPQUFPLENBQUNzaUMsZUFBZSxHQUFHQSxlQUFlLElBQUl0aUMsT0FBTyxDQUFDc2lDLGVBQWU7TUFDcEUsSUFBSSxDQUFDK0Isa0JBQWtCLENBQUN4d0IsUUFBUSxDQUFDO01BQ2pDLElBQU1oSCxTQUFTLEdBQUcsSUFBSSxDQUFDeUcsS0FBSyxDQUFDekcsU0FBUztNQUN0Q3kzQix3QkFBd0IsQ0FBQyxJQUFJLENBQUNoeEIsS0FBSyxFQUFFLElBQUksQ0FBQ3dVLE1BQU0sQ0FBQyxDQUM5Q3ZuQixJQUFJLENBQUMsVUFBQWszQixTQUFTLEVBQUk7UUFDakIsSUFBSWtLLFNBQVMsR0FBRztVQUNkbGtDLE1BQU0sRUFBRXVDLE9BQU8sQ0FBQ2d5QixVQUFVO1VBQzFCMEcsR0FBRyxFQUFFMTRCLE9BQU8sQ0FBQ3k0QixPQUFPLGFBQU16NEIsT0FBTyxDQUFDMDRCLEdBQUcsY0FBSTE0QixPQUFPLENBQUN5NEIsT0FBTyxJQUFLejRCLE9BQU8sQ0FBQzA0QixHQUFHO1VBQ3hFRSxJQUFJLEVBQUU1NEIsT0FBTyxDQUFDNDRCLElBQUk7VUFDbEIzUixLQUFLLEVBQUVoWixPQUFXLENBQUMxQixtQkFBbUIsQ0FBQyxNQUFJLENBQUMrRyxLQUFLLEVBQUUsT0FBTyxDQUFDO1VBQzNEekosUUFBUSxFQUFFb0UsT0FBVyxDQUFDMUIsbUJBQW1CLENBQUMsTUFBSSxDQUFDK0csS0FBSyxFQUFFLFVBQVUsQ0FBQztVQUNqRWl4Qiw0QkFBNEIsRUFBRXZrQyxPQUFPLENBQUN1a0M7UUFDeEMsQ0FBQztRQUNELElBQUl2a0MsT0FBTyxDQUFDK2hDLGVBQWUsRUFBRTtVQUMzQkosU0FBUyxDQUFDSSxlQUFlLEdBQUcvaEMsT0FBTyxDQUFDK2hDLGVBQWU7UUFDckQ7UUFDQSxJQUFJL2hDLE9BQU8sQ0FBQ3drQyxNQUFNLElBQUksQ0FBQzF6QixLQUFLLENBQUN3VixNQUFNLENBQUN0bUIsT0FBTyxDQUFDd2tDLE1BQU0sQ0FBQyxDQUFDLEVBQUU7VUFDcEQ3QyxTQUFTLENBQUM2QyxNQUFNLEdBQUd4a0MsT0FBTyxDQUFDd2tDLE1BQU07UUFDbkM7UUFDQSxJQUFJeGtDLE9BQU8sQ0FBQ2dQLEtBQUssSUFBSSxDQUFDOEIsS0FBSyxDQUFDOVEsT0FBTyxDQUFDZ1AsS0FBSyxDQUFDLEVBQUU7VUFDMUMyeUIsU0FBUyxDQUFDM3lCLEtBQUssR0FBR3dCLGlDQUFLLENBQUN4USxPQUFPLENBQUNnUCxLQUFLLENBQUM7UUFDeEM7UUFDQSxJQUFJaFAsT0FBTyxDQUFDd1AsTUFBTSxJQUFJLENBQUNzQixLQUFLLENBQUM5USxPQUFPLENBQUN3UCxNQUFNLENBQUMsRUFBRTtVQUM1Q215QixTQUFTLENBQUNueUIsTUFBTSxHQUFHZ0IsaUNBQUssQ0FBQ3hRLE9BQU8sQ0FBQ3dQLE1BQU0sQ0FBQztRQUMxQztRQUNBLElBQUl4UCxPQUFPLENBQUN5aUMsVUFBVSxLQUFLLE1BQU0sSUFBSXppQyxPQUFPLENBQUMwaUMsV0FBVyxLQUFLLE1BQU0sRUFBRTtVQUNuRWYsU0FBUyxDQUFDOEMsUUFBUSxHQUFHLElBQUk7UUFDM0I7UUFDQSxNQUFJLENBQUNWLE1BQU0sR0FBR1gsS0FBSztRQUNuQixJQUFJLE9BQU9wakMsT0FBTyxDQUFDNjRCLGdCQUFnQixLQUFLLFdBQVcsRUFBRTtVQUNuRDhJLFNBQVMsQ0FBQzlJLGdCQUFnQixHQUFHWCxrQkFBa0IsQ0FBQ3QxQixJQUFJLENBQUM0TyxTQUFTLENBQUN4UixPQUFPLENBQUM2NEIsZ0JBQWdCLENBQUMsQ0FBQztRQUMzRjtRQUNBLElBQUksT0FBTzc0QixPQUFPLENBQUMwa0MsV0FBVyxLQUFLLFdBQVcsRUFBRTtVQUM5Qy9DLFNBQVMsQ0FBQytDLFdBQVcsR0FBR3hNLGtCQUFrQixDQUFDdDFCLElBQUksQ0FBQzRPLFNBQVMsQ0FBQ3hSLE9BQU8sQ0FBQzBrQyxXQUFXLENBQUMsQ0FBQztRQUNqRjtRQUNBLElBQUksT0FBTzFrQyxPQUFPLENBQUMya0MseUJBQXlCLEtBQUssV0FBVyxFQUFFO1VBQzVEaEQsU0FBUyxDQUFDZ0QseUJBQXlCLEdBQUd6TSxrQkFBa0IsQ0FBQ3QxQixJQUFJLENBQUM0TyxTQUFTLENBQUN4UixPQUFPLENBQUMya0MseUJBQXlCLENBQUMsQ0FBQztRQUM3RztRQUNBLE9BQU9MLG9CQUFvQixDQUFDbEIsS0FBSyxFQUFFcGpDLE9BQU8sRUFBRTJoQyxTQUFTLEVBQUUxekIsT0FBVyxDQUFDaEQsWUFBWSxFQUFFLEVBQUV3c0IsU0FBUyxDQUFDO01BQy9GLENBQUMsQ0FBQyxDQUNEbDNCLElBQUksQ0FBRSxZQUFNO1FBQ1gsSUFBSWlxQixrQkFBa0IsSUFBSTdDLG1CQUFtQixFQUFFO1VBQzdDLElBQUk2QyxrQkFBa0IsRUFBRTtZQUN0QixNQUFJLENBQUN0QyxTQUFTLEdBQUdsb0IsT0FBTyxDQUFDMm9CLFFBQVE7VUFDbkMsQ0FBQyxNQUNJO1lBQ0gsTUFBSSxDQUFDVCxTQUFTLEdBQUcsSUFBSVQsb0JBQW9CLENBQUMsTUFBSSxFQUFFLE1BQUksQ0FBQ0ssTUFBTSxDQUFDO1VBQzlEO1VBQ0EsTUFBSSxDQUFDeFUsS0FBSyxDQUFDcVYsUUFBUSxHQUFHLEtBQUs7VUFDM0IsTUFBSSxDQUFDVCxTQUFTLENBQUN3QyxRQUFRLENBQUNnWixlQUFlLENBQUMxakMsT0FBTyxDQUFDZ3lCLFVBQVUsQ0FBQyxDQUFDO1VBQzVELE1BQUksQ0FBQzlKLFNBQVMsQ0FBQ2hDLGFBQWEsQ0FBQ3VFLE9BQU8sQ0FBQztVQUNyQyxJQUFNbWEsUUFBUSxHQUFHLE1BQUksQ0FBQ1gsZUFBZSxFQUFFO1VBQ3ZDLElBQUl6aUMsS0FBSyxHQUFHcUwsU0FBUyxDQUFDak4sTUFBTTtZQUFFaWxDLEtBQUs7VUFDbkMsT0FBTyxFQUFFcmpDLEtBQUssR0FBRyxDQUFDLENBQUMsRUFBRTtZQUNuQnFqQyxLQUFLLEdBQUdoNEIsU0FBUyxDQUFDaFAsSUFBSSxDQUFDMkQsS0FBSyxDQUFDO1lBQzdCb2pDLFFBQVEsQ0FBQy8zQixTQUFTLENBQUNnVyxHQUFHLENBQUNnaUIsS0FBSyxDQUFDO1VBQy9CO1FBQ0Y7UUFDQSxNQUFJLENBQUNsYSxvQkFBb0IsQ0FBQyxNQUFJLENBQUN4QywyQkFBMkIsQ0FBQztRQUMzRCxNQUFJLENBQUM1RixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDaUIscUJBQXFCLEVBQUU1ZSxTQUFTLEVBQUU7VUFDdEZ5ckIsSUFBSSxFQUFFN0YsYUFBYSxDQUFDRSxTQUFTO1VBQzdCUSxLQUFLLEVBQUVKLHFCQUFxQixDQUFDTixhQUFhLENBQUNFLFNBQVM7UUFDdEQsQ0FBQyxDQUFDLENBQUM7UUFDSCxPQUFPLElBQUk7TUFDYixDQUFDLENBQUMsQ0FDRDdpQixJQUFJLENBQUUsWUFBTTtRQUNYdWpDLFdBQVcsQ0FBQ2dCLE9BQU8sQ0FBQzFCLEtBQUssQ0FBQztRQUMxQixPQUFPLElBQUk7TUFDYixDQUFDLENBQUMsQ0FDRDNpQyxLQUFLLENBQUMsVUFBQXFDLENBQUM7UUFBQSxPQUFJK1EsUUFBUSxDQUFDbFYsTUFBTSxDQUFDbUUsQ0FBQyxDQUFDO01BQUEsRUFBQztNQUNqQyxPQUFPK1EsUUFBUSxDQUFDalYsT0FBTztJQUN6Qjs7SUFFQTtBQUNGO0FBQ0E7RUFGRTtJQUFBO0lBQUEsT0FHQSxtQkFBVztNQUNUUCxTQUFLLENBQUNzaEIsZ0NBQUksRUFBRSxXQUFXLENBQUM7TUFDeEIsSUFBSTtRQUNGLElBQUksQ0FBQ3NrQixlQUFlLEVBQUUsQ0FBQ2EsT0FBTyxFQUFFO01BQ2xDLENBQUMsQ0FDRCxPQUFPaGlDLENBQUMsRUFBRTtRQUNSLE1BQU1BLENBQUM7TUFDVDtJQUNGO0VBQUM7SUFBQTtJQUFBLE9BRUQsZ0JBQVE7TUFDTixJQUFJO1FBQ0YsSUFBSSxDQUFDbWhDLGVBQWUsRUFBRSxDQUFDLzVCLElBQUksRUFBRTtNQUMvQixDQUFDLENBQ0QsT0FBT3BILENBQUMsRUFBRTtRQUNSLE1BQU1BLENBQUM7TUFDVDtJQUNGO0VBQUM7SUFBQTtJQUFBLE9BR0QsaUJBQVM7TUFDUCxJQUFJO1FBQ0YsSUFBSSxDQUFDbWhDLGVBQWUsRUFBRSxDQUFDNzVCLEtBQUssRUFBRTtNQUNoQyxDQUFDLENBQ0QsT0FBT3RILENBQUMsRUFBRTtRQUNSLE1BQU1BLENBQUM7TUFDVDtJQUNGO0VBQUM7SUFBQTtJQUFBLE9BRUQsa0JBQVU7TUFDUixJQUFJO1FBQ0YsSUFBSSxDQUFDbWhDLGVBQWUsRUFBRSxDQUFDcGUsTUFBTSxFQUFFO01BQ2pDLENBQUMsQ0FDRCxPQUFPL2lCLENBQUMsRUFBRTtRQUNSLE1BQU1BLENBQUM7TUFDVDtJQUNGO0VBQUM7SUFBQTtJQUFBLE9BRUQsZ0JBQVE7TUFDTixJQUFJO1FBQ0YsSUFBSSxDQUFDbWhDLGVBQWUsRUFBRSxDQUFDcFosSUFBSSxFQUFFO01BQy9CLENBQUMsQ0FDRCxPQUFPL25CLENBQUMsRUFBRTtRQUNSLE1BQU1BLENBQUM7TUFDVDtJQUNGO0VBQUM7SUFBQTtJQUFBLE9BRUQsZ0JBQVE7TUFDTixJQUFJO1FBQ0YsSUFBSSxDQUFDbWhDLGVBQWUsRUFBRSxDQUFDOWQsSUFBSSxFQUFFO01BQy9CLENBQUMsQ0FDRCxPQUFPcmpCLENBQUMsRUFBRTtRQUNSLE1BQU1BLENBQUM7TUFDVDtJQUNGO0VBQUM7SUFBQTtJQUFBLE9BRUQsa0JBQVU7TUFDUixJQUFJO1FBQ0YsSUFBSSxDQUFDbWhDLGVBQWUsRUFBRSxDQUFDaGUsTUFBTSxFQUFFO01BQ2pDLENBQUMsQ0FDRCxPQUFPbmpCLENBQUMsRUFBRTtRQUNSLE1BQU1BLENBQUM7TUFDVDtJQUNGO0VBQUM7SUFBQTtJQUFBLE9BRUQsbUJBQVdqQyxLQUFLLEVBQUU7TUFDaEIsSUFBSTtRQUNGLElBQUksQ0FBQ29qQyxlQUFlLEVBQUUsQ0FBQzFkLFNBQVMsQ0FBQzFsQixLQUFLLENBQUM7TUFDekMsQ0FBQyxDQUNELE9BQU9pQyxDQUFDLEVBQUU7UUFDUixNQUFNQSxDQUFDO01BQ1Q7SUFDRjtFQUFDO0lBQUE7SUFBQSxPQUVELGdCQUFRakMsS0FBSyxFQUF3QjtNQUFBLElBQXRCNmlCLFFBQVEsdUVBQUdwbUIsU0FBUztNQUNqQyxJQUFJO1FBQ0YsSUFBSSxDQUFDMm1DLGVBQWUsRUFBRSxDQUFDemQsTUFBTSxDQUFDM2xCLEtBQUssRUFBRTZpQixRQUFRLENBQUM7TUFDaEQsQ0FBQyxDQUNELE9BQU81Z0IsQ0FBQyxFQUFFO1FBQ1IsTUFBTUEsQ0FBQztNQUNUO0lBQ0Y7RUFBQztJQUFBO0lBQUEsT0FFRCw0QkFBb0I7TUFDbEIsSUFBSTtRQUNGbUwsT0FBVyxDQUFDL0IsZ0JBQWdCLENBQUMsSUFBSSxDQUFDNGIsTUFBTSxDQUFDO01BQzNDLENBQUMsQ0FDRCxPQUFPaGxCLENBQUMsRUFBRTtRQUNSLE1BQU1BLENBQUM7TUFDVDtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0VBSEU7SUFBQTtJQUFBLE9BSUEscUJBQWE7TUFDWCxJQUFJLENBQUMrbkIsSUFBSSxFQUFFO0lBQ2I7O0lBRUE7QUFDRjtBQUNBO0VBRkU7SUFBQTtJQUFBLE9BR0Esc0JBQWM7TUFDWixJQUFJO1FBQ0YsSUFBSSxDQUFDb1osZUFBZSxFQUFFLENBQUMvRixVQUFVLEVBQUU7UUFDbkM3L0IsU0FBSyxDQUFDc2hCLGdDQUFJLEVBQUUsY0FBYyxDQUFDO01BQzdCLENBQUMsQ0FBQyxPQUFPN2MsQ0FBQyxFQUFFO1FBQ1Y7TUFBQTtNQUVGLElBQUksQ0FBQ2dvQixRQUFRLEVBQUU7TUFDZixJQUFJLENBQUNrWixZQUFZLENBQUM5RixVQUFVLEVBQUU7SUFDaEM7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORTtJQUFBO0lBQUEsT0FPQSx3Q0FBZ0MzeUIsT0FBTyxFQUFFO01BQ3ZDLElBQUksQ0FBQ3k0QixZQUFZLENBQUNlLGtCQUFrQixDQUFDeDVCLE9BQU8sQ0FBQztJQUMvQzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQU5FO0lBQUE7SUFBQSxPQU9BLDJDQUFtQ0EsT0FBTyxFQUFFO01BQzFDLElBQUksQ0FBQ3k0QixZQUFZLENBQUNnQixxQkFBcUIsQ0FBQ3o1QixPQUFPLENBQUM7SUFDbEQ7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBWEU7SUFBQTtJQUFBLE9BWUEsNEJBQW9CdFAsSUFBSSxFQUFFOHVCLFFBQVEsRUFBRXR1QixPQUFPLEVBQUU7TUFDM0MsSUFBSSxDQUFDdW5DLFlBQVksQ0FBQ2lCLGtCQUFrQixDQUFDaHBDLElBQUksRUFBRTh1QixRQUFRLEVBQUV0dUIsT0FBTyxDQUFDO0lBQy9EOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVhFO0lBQUE7SUFBQSxPQVlBLG9DQUE0QlIsSUFBSSxFQUFFMEUsR0FBRyxFQUFFRSxLQUFLLEVBQUU7TUFDNUMsSUFBSSxDQUFDbWpDLFlBQVksQ0FBQ2tCLDBCQUEwQixDQUFDanBDLElBQUksRUFBRTBFLEdBQUcsRUFBRUUsS0FBSyxDQUFDO0lBQ2hFOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0EsK0JBQXVCK2QsZ0JBQWdCLEVBQUU7TUFDdkMsSUFBSSxDQUFDb2xCLFlBQVksQ0FBQ1QscUJBQXFCLENBQUMza0IsZ0JBQWdCLENBQUM7SUFDM0Q7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORTtJQUFBO0lBQUEsT0FPQSwrQkFBdUJBLGdCQUFnQixFQUFFO01BQ3ZDLElBQUksQ0FBQ29sQixZQUFZLENBQUNSLHFCQUFxQixDQUFDNWtCLGdCQUFnQixDQUFDO0lBQzNEOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0EsMkJBQW1CQSxnQkFBZ0IsRUFBRTtNQUNuQyxJQUFJLENBQUNvbEIsWUFBWSxDQUFDbUIsaUJBQWlCLENBQUN2bUIsZ0JBQWdCLENBQUM7SUFDdkQ7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEsOEJBQXNCO01BQ3BCLElBQUk7UUFDRixJQUFJLENBQUNxbEIsZUFBZSxFQUFFLENBQUNtQixrQkFBa0IsRUFBRTtNQUM3QyxDQUFDLENBQ0QsT0FBT3RpQyxDQUFDLEVBQUU7UUFDUnpFLFNBQUssQ0FBQ3NoQixnQ0FBSSw2REFBc0Q3YyxDQUFDLENBQUNyRyxPQUFPLEVBQUc7TUFDOUU7SUFDRjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsNkJBQXFCO01BQ25CLElBQUk7UUFDRixJQUFJLENBQUN3bkMsZUFBZSxFQUFFLENBQUNvQixpQkFBaUIsRUFBRTtNQUM1QyxDQUFDLENBQ0QsT0FBT3ZpQyxDQUFDLEVBQUU7UUFDUnpFLFNBQUssQ0FBQ3NoQixnQ0FBSSw0REFBcUQ3YyxDQUFDLENBQUNyRyxPQUFPLEVBQUc7TUFDN0U7SUFDRjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVRFO0lBQUE7SUFBQSxPQVVBLHdCQUFnQmlvQyxXQUFXLEVBQUV2b0MsS0FBSyxFQUFFO01BQ2xDLElBQUk7UUFDRixJQUFNMEUsS0FBSyxHQUFHLE9BQU82akMsV0FBVyxLQUFLLFFBQVEsR0FBR3hNLGtCQUFrQixDQUFDd00sV0FBVyxDQUFDLEdBQUd4TSxrQkFBa0IsQ0FBQ3QxQixJQUFJLENBQUM0TyxTQUFTLENBQUNrekIsV0FBVyxDQUFDLENBQUM7UUFDakksSUFBSSxDQUFDVCxlQUFlLEVBQUUsQ0FBQ3FCLGNBQWMsQ0FBQ3prQyxLQUFLLEVBQUUxRSxLQUFLLElBQUksQ0FBQyxDQUFDO01BQzFELENBQUMsQ0FBQyxPQUFPMkcsQ0FBQyxFQUFFO1FBQ1Z6RSxTQUFLLENBQUNzaEIsZ0NBQUksd0NBQWlDN2MsQ0FBQyxDQUFDckcsT0FBTyxFQUFHO01BQ3pEO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFURTtJQUFBO0lBQUEsT0FVQSxxQkFBYU4sS0FBSyxFQUFFb3BDLElBQUksRUFBRTtNQUN4QixJQUFJO1FBQ0YsSUFBSSxDQUFDdEIsZUFBZSxFQUFFLENBQUN1QixXQUFXLENBQUNycEMsS0FBSyxFQUFFLENBQUMsQ0FBQ29wQyxJQUFJLENBQUM7TUFDbkQsQ0FBQyxDQUFDLE9BQU96aUMsQ0FBQyxFQUFFO1FBQ1Z6RSxTQUFLLENBQUNzaEIsZ0NBQUkscUNBQThCN2MsQ0FBQyxDQUFDckcsT0FBTyxFQUFHO01BQ3REO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQXpCRTtJQUFBO0lBQUEsT0EwQkEsc0NBQThCZ3BDLGtCQUFrQixFQUFFO01BQ2hELElBQUk7UUFDRixJQUFNNWtDLEtBQUssR0FBRyxPQUFPNmpDLFdBQVcsS0FBSyxRQUFRLEdBQUd4TSxrQkFBa0IsQ0FBQ3VOLGtCQUFrQixDQUFDLEdBQUd2TixrQkFBa0IsQ0FBQ3QxQixJQUFJLENBQUM0TyxTQUFTLENBQUNpMEIsa0JBQWtCLENBQUMsQ0FBQztRQUMvSSxJQUFJLENBQUN4QixlQUFlLEVBQUUsQ0FBQ3lCLDRCQUE0QixDQUFDN2tDLEtBQUssQ0FBQztNQUM1RCxDQUFDLENBQUMsT0FBT2lDLENBQUMsRUFBRTtRQUNWekUsU0FBSyxDQUFDc2hCLGdDQUFJLHdDQUFpQzdjLENBQUMsQ0FBQ3JHLE9BQU8sRUFBRztNQUN6RDtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSwyQkFBbUI7TUFDakIsT0FBT3dSLE9BQVcsQ0FBQzlDLGNBQWMsQ0FBQyxJQUFJLENBQUM0NEIsTUFBTSxDQUFDO0lBQ2hEOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSx1QkFBZTtNQUNiLE9BQU8sSUFBSSxDQUFDN2IsU0FBUztJQUN2Qjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsbUJBQVc7TUFDVCxPQUFPLElBQUksQ0FBQ0YsVUFBVTtJQUN4QjtFQUFDO0VBQUE7QUFBQSxFQXhrQjZCVCxrQkFBa0I7QUE0a0JuQ3FjLDZHQUFpQixFOztBQ3huQnBCOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRTRCO0FBQ3FCO0FBQ2xCO0FBQ0k7QUFDTDtBQUNNO0FBSS9CO0FBQ3VDO0FBQ0M7QUFDZDtBQUUzQyxJQUFNamtCLGlCQUFJLEdBQUcsZUFBZTtBQUU1QixJQUFNc2IsMkJBQWMsR0FBRztFQUNyQjVDLFFBQVEsRUFBRSxNQUFNO0VBQ2hCUCxJQUFJLEVBQUUsSUFBSTtFQUNWOW9CLEtBQUssRUFBRSxHQUFHO0VBQUU7RUFDWlEsTUFBTSxFQUFFLEdBQUc7RUFBRTtFQUNiaXpCLFVBQVUsRUFBRSxNQUFNO0VBQUU7RUFDcEJDLFdBQVcsRUFBRSxNQUFNO0VBQUU7RUFDckJKLGVBQWUsRUFBRSxRQUFRO0VBQ3pCRSxHQUFHLEVBQUUsb0NBQW9DO0VBQ3pDbUQsWUFBWSxFQUFFLDRCQUE0QjtFQUMxQ2hELGlCQUFpQixFQUFFLHdDQUF3QztFQUMzRHhILGNBQWMsRUFBRSxvQkFBb0I7RUFDcEM7RUFDQW9KLDRCQUE0QixFQUFFLEtBQUs7RUFDbkNHLFdBQVcsRUFBRXBuQyxTQUFTO0VBQ3RCcW5DLHlCQUF5QixFQUFFO0lBQ3pCaUIsNEJBQTRCLEVBQUUsS0FBSztJQUFFO0lBQ3JDQyxPQUFPLEVBQUUsQ0FDUDtNQUNFMXBDLEtBQUssRUFBRSxDQUFDO01BQ1IycEMsWUFBWSxFQUFFO0lBQ2hCLENBQUMsRUFDRDtNQUNFM3BDLEtBQUssRUFBRSxDQUFDO01BQ1IycEMsWUFBWSxFQUFFLEtBQUssQ0FBQztJQUN0QixDQUFDLEVBQ0Q7TUFDRTNwQyxLQUFLLEVBQUUsQ0FBQztNQUNSMnBDLFlBQVksRUFBRSxLQUFLLENBQUM7SUFDdEIsQ0FBQztFQUVMO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQSxJQU1NQywyQkFBYztFQUFBO0VBQUE7RUFFbEIsMEJBQWU7SUFBQTtJQUFBO0lBQ2I7SUFDQSxNQUFLaEssUUFBUSxHQUFHeitCLFNBQVM7SUFDekIsTUFBS3crQixLQUFLLEdBQUd4K0IsU0FBUztJQUN0QixNQUFLOCtCLGNBQWMsR0FBRzkrQixTQUFTO0lBQy9CLE1BQUswb0MsVUFBVSxHQUFHMW9DLFNBQVM7SUFDM0IsTUFBSzJvQyxhQUFhLEdBQUczb0MsU0FBUztJQUM5QixNQUFLNG9DLGdCQUFnQixFQUFFLENBQ3BCM2xDLElBQUksQ0FBQyxZQUFNO01BQ1YsTUFBSzRsQyxlQUFlLEVBQUU7SUFDeEIsQ0FBQyxDQUFDLENBQ0QxbEMsS0FBSyxDQUFDLFVBQUFpRyxHQUFHO01BQUEsT0FBSSxNQUFLMC9CLGNBQWMsQ0FBQzEvQixHQUFHLENBQUM7SUFBQSxFQUFDO0lBQ3pDLE1BQUs0MUIsYUFBYSxHQUFHLElBQUlwOUIsZUFBZSxFQUFFO0lBQzFDLE1BQUtzOUIscUJBQXFCLEdBQUcsSUFBSXQ5QixlQUFlLEVBQUU7SUFDbEQsTUFBS3U5QixZQUFZLEdBQUcsQ0FBQztJQUNyQixNQUFLQyxjQUFjLEdBQUcsYUFBYTtJQUFBO0VBQ3JDO0VBQUM7SUFBQTtJQUFBLE9BRUQsbUNBQTJCO01BQ3pCLE9BQU8sSUFBSSxDQUFDSixhQUFhLENBQUMxOUIsT0FBTztJQUNuQztFQUFDO0lBQUE7SUFBQSxPQUVELDJDQUFrQztNQUNoQyxPQUFPLElBQUksQ0FBQzQ5QixxQkFBcUIsQ0FBQzU5QixPQUFPO0lBQzNDO0VBQUM7SUFBQTtJQUFBLE9BRUQsNEJBQW9CO01BQ2xCLElBQUksQ0FBQ3FuQyxhQUFhLEdBQUc5bUMsTUFBTSxDQUFDSixnQkFBZ0IsQ0FBQyxJQUFJLENBQUNrbkMsYUFBYSxDQUFDO01BQ2hFLE9BQU8sSUFBSSxDQUFDQSxhQUFhLENBQUNybkMsT0FBTztJQUNuQzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEsK0JBQXVCMk0sT0FBTyxFQUFFO01BQUE7TUFDOUI7QUFDSjtBQUNBO0FBQ0E7O01BRUksSUFBSSxDQUFDbkIsS0FBSyxHQUFHbUIsT0FBTyxDQUFDbkIsS0FBSyxDQUFDc1csSUFBSSxDQUFDblYsT0FBTyxDQUFDO01BQ3hDLElBQUksQ0FBQ3NhLE1BQU0sR0FBR3RhLE9BQU8sQ0FBQ3NhLE1BQU0sQ0FBQ25GLElBQUksQ0FBQ25WLE9BQU8sQ0FBQztNQUMxQyxJQUFJLENBQUNzZixJQUFJLEdBQUd0ZixPQUFPLENBQUNzZixJQUFJLENBQUNuSyxJQUFJLENBQUNuVixPQUFPLENBQUM7TUFDdEMsSUFBSSxDQUFDNGEsSUFBSSxHQUFHNWEsT0FBTyxDQUFDNGEsSUFBSSxDQUFDekYsSUFBSSxDQUFDblYsT0FBTyxDQUFDO01BQ3RDLElBQUksQ0FBQzBhLE1BQU0sR0FBRzFhLE9BQU8sQ0FBQzBhLE1BQU0sQ0FBQ3ZGLElBQUksQ0FBQ25WLE9BQU8sQ0FBQztNQUMxQyxJQUFJLENBQUNnYixTQUFTLEdBQUdoYixPQUFPLENBQUNnYixTQUFTLENBQUM3RixJQUFJLENBQUNuVixPQUFPLENBQUM7TUFDaEQsSUFBSSxDQUFDaWIsTUFBTSxHQUFHamIsT0FBTyxDQUFDaWIsTUFBTSxDQUFDOUYsSUFBSSxDQUFDblYsT0FBTyxDQUFDO01BQzFDLElBQUksQ0FBQ1csZ0JBQWdCLEdBQUdYLE9BQU8sQ0FBQ1csZ0JBQWdCLENBQUN3VSxJQUFJLENBQUNuVixPQUFPLENBQUM7O01BRTlEO01BQ0EsSUFBSSxDQUFDaTZCLFdBQVcsR0FBR2o2QixPQUFPLENBQUNpNkIsV0FBVyxDQUFDOWtCLElBQUksQ0FBQ25WLE9BQU8sQ0FBQztNQUNwRCxJQUFJLENBQUMrNUIsY0FBYyxHQUFHLzVCLE9BQU8sQ0FBQys1QixjQUFjLENBQUM1a0IsSUFBSSxDQUFDblYsT0FBTyxDQUFDO01BQzFELElBQUksQ0FBQzg1QixpQkFBaUIsR0FBRzk1QixPQUFPLENBQUM4NUIsaUJBQWlCLENBQUMza0IsSUFBSSxDQUFDblYsT0FBTyxDQUFDO01BQ2hFLElBQUksQ0FBQzY1QixrQkFBa0IsR0FBRzc1QixPQUFPLENBQUM2NUIsa0JBQWtCLENBQUMxa0IsSUFBSSxDQUFDblYsT0FBTyxDQUFDO01BQ2xFLElBQUksQ0FBQ202Qiw0QkFBNEIsR0FBR242QixPQUFPLENBQUNtNkIsNEJBQTRCLENBQUNobEIsSUFBSSxDQUFDblYsT0FBTyxDQUFDO01BRXRGQSxPQUFPLENBQUM4YSxFQUFFLENBQUMsR0FBRyxFQUFFLFVBQUNqbEIsS0FBSyxFQUFLO1FBQ3pCLE1BQUksQ0FBQ21oQixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3BkLEtBQUssQ0FBQzFELElBQUksRUFBRSxNQUFJLEVBQUUwRCxLQUFLLENBQUNhLElBQUksQ0FBQyxDQUFDO01BQ2pFLENBQUMsQ0FBQztJQUNKOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUxFO0lBQUE7SUFBQSxPQU1BLDRCQUFvQjI2QixXQUFXLEVBQThCO01BQUEsSUFBNUJ6QixjQUFjLHVFQUFHNzlCLFNBQVM7TUFDdkQsSUFBSSxPQUFPcy9CLFdBQVcsS0FBSyxXQUFXLElBQUl6QixjQUFjLEtBQUs3OUIsU0FBUyxFQUFFO1FBQ3RFLElBQUk4bkIsSUFBSSxHQUFHLElBQUlvUyxRQUFZLENBQUMyRCxjQUFjLENBQUM7UUFDM0MvVixJQUFJLENBQUN5WCxnQkFBZ0IsQ0FBQyxJQUFJLENBQUM7TUFDN0I7SUFDSjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0Esa0NBQTBCdnpCLEVBQUUsRUFBRTtNQUFBO01BQzVCakwsU0FBSyxDQUFDc2hCLGlCQUFJLCtDQUF3Q3JXLEVBQUUsUUFBSztNQUN6RCxJQUFNKzhCLFFBQVEsR0FBRyxTQUFYQSxRQUFRLENBQUlyMEIsS0FBSyxFQUFLO1FBQzFCLE9BQU8sQ0FBQyxZQUFZLEVBQUVBLEtBQUssRUFBRTFJLEVBQUUsQ0FBQzNDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzRNLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDQSxJQUFJLENBQUMsR0FBRyxDQUFDO01BQ2pFLENBQUM7TUFDRHZPLE1BQU0sQ0FBQ3FoQyxRQUFRLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxHQUFHO1FBQUEsT0FBTSxNQUFJLENBQUM5akIsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ3pCLGlCQUFpQixFQUFFLE1BQUksQ0FBQyxDQUFDO01BQUE7TUFDOUh4VSxNQUFNLENBQUNxaEMsUUFBUSxDQUFDLHFCQUFxQixDQUFDLENBQUMsR0FBRztRQUFBLE9BQU0sTUFBSSxDQUFDOWpCLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUN0QyxlQUFlLEVBQUUsTUFBSSxDQUFDLENBQUM7TUFBQTtNQUM3SDNULE1BQU0sQ0FBQ3FoQyxRQUFRLENBQUMscUJBQXFCLENBQUMsQ0FBQyxHQUFHLFlBQU07UUFDOUMsTUFBSSxDQUFDOWpCLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUNyQyxlQUFlLEVBQUUsTUFBSSxDQUFDLENBQUM7TUFDL0UsQ0FBQztNQUNENVQsTUFBTSxDQUFDcWhDLFFBQVEsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLEdBQUc7UUFBQSxPQUFNLE1BQUksQ0FBQzlqQixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDRSxjQUFjLEVBQUUsTUFBSSxDQUFDLENBQUM7TUFBQTtNQUMzSG5XLE1BQU0sQ0FBQ3FoQyxRQUFRLENBQUMsd0JBQXdCLENBQUMsQ0FBQyxHQUFHLFVBQUMzUyxRQUFRLEVBQUs7UUFDekQsa0JBR0k5d0IsSUFBSSxDQUFDQyxLQUFLLENBQUM2d0IsUUFBUSxDQUFDO1VBRnRCdndCLFdBQVcsZUFBWEEsV0FBVztVQUNYRyxhQUFhLGVBQWJBLGFBQWE7UUFFZixJQUFNZ2pDLGNBQWMsR0FBR2xqQyxRQUFRLENBQUNELFdBQVcsRUFBRSxFQUFFLENBQUM7UUFDaEQsSUFBTXM5QixxQkFBcUIsR0FBRyxNQUFJLENBQUMvRCxjQUFjO1FBQ2pELElBQUksTUFBSSxDQUFDRCxZQUFZLEtBQUs2SixjQUFjLEVBQUU7VUFDeEMsTUFBSSxDQUFDN0osWUFBWSxHQUFHNkosY0FBYztVQUNsQyxNQUFJLENBQUMvakIsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ1csa0JBQWtCLEVBQUUsTUFBSSxFQUFFO1lBQUV6WSxXQUFXLEVBQUVtakM7VUFBZSxDQUFDLENBQUMsQ0FBQztRQUNuSDtRQUNBLElBQUk3RixxQkFBcUIsS0FBS245QixhQUFhLEVBQUU7VUFDM0MsTUFBSSxDQUFDbzVCLGNBQWMsR0FBR3A1QixhQUFhO1VBQ25DLE1BQUksQ0FBQ2lmLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUNZLHFCQUFxQixFQUFFLE1BQUksRUFBRTtZQUNqRnZZLGFBQWEsRUFBRUEsYUFBYTtZQUM1Qm05QixxQkFBcUIsRUFBRUE7VUFDekIsQ0FBQyxDQUFDLENBQUM7UUFDTDtRQUNBLE1BQUksQ0FBQ2xlLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUNLLGtCQUFrQixFQUFFLE1BQUksRUFBRTFZLElBQUksQ0FBQ0MsS0FBSyxDQUFDNndCLFFBQVEsQ0FBQyxDQUFDLENBQUM7TUFDeEcsQ0FBQztNQUNEMXVCLE1BQU0sQ0FBQ3FoQyxRQUFRLENBQUMseUJBQXlCLENBQUMsQ0FBQyxHQUFHLFlBQU07UUFDbEQsTUFBSSxDQUFDalQsV0FBVyxFQUFFO01BQ3BCLENBQUM7TUFDRHB1QixNQUFNLENBQUNxaEMsUUFBUSxDQUFDLG1DQUFtQyxDQUFDLENBQUMsR0FBRyxVQUFDcGtDLElBQUk7UUFBQSxPQUFLLE1BQUksQ0FBQ3NnQixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDUSw4QkFBOEIsRUFBRSxNQUFJLEVBQUU3WSxJQUFJLENBQUNDLEtBQUssQ0FBQ1osSUFBSSxDQUFDLENBQUMsQ0FBQztNQUFBO01BQ2hMK0MsTUFBTSxDQUFDcWhDLFFBQVEsQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDLEdBQUcsVUFBQ3BrQyxJQUFJO1FBQUEsT0FBSyxNQUFJLENBQUNzZ0IsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ1MsNEJBQTRCLEVBQUUsTUFBSSxFQUFFOVksSUFBSSxDQUFDQyxLQUFLLENBQUNaLElBQUksQ0FBQyxDQUFDLENBQUM7TUFBQTtNQUM1SytDLE1BQU0sQ0FBQ3FoQyxRQUFRLENBQUMsMEJBQTBCLENBQUMsQ0FBQyxHQUFHLFVBQUNFLE9BQU8sRUFBSztRQUMxRCxNQUFJLENBQUNoa0IsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ08scUJBQXFCLEVBQUUsTUFBSSxFQUFFLE9BQU8rcUIsT0FBTyxLQUFLLFFBQVEsR0FBRzNqQyxJQUFJLENBQUNDLEtBQUssQ0FBQzBqQyxPQUFPLENBQUMsR0FBR0EsT0FBTyxDQUFDLENBQUM7TUFDbEosQ0FBQztNQUNEdmhDLE1BQU0sQ0FBQ3FoQyxRQUFRLENBQUMsMkJBQTJCLENBQUMsQ0FBQyxHQUFHLFlBQU07UUFDcEQsTUFBSSxDQUFDbjhCLElBQUksRUFBRTtNQUNiLENBQUM7TUFDRGxGLE1BQU0sQ0FBQ3FoQyxRQUFRLENBQUMscUJBQXFCLENBQUMsQ0FBQyxHQUFHLFlBQU07UUFDOUMsTUFBSSxDQUFDN0oscUJBQXFCLENBQUM5OUIsT0FBTyxDQUFDLE1BQUksQ0FBQztRQUN4QyxNQUFJLENBQUM2akIsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ0MsZUFBZSxFQUFFLE1BQUksQ0FBQyxDQUFDO01BQy9FLENBQUM7TUFDRGxXLE1BQU0sQ0FBQ3FoQyxRQUFRLENBQUMsMkJBQTJCLENBQUMsQ0FBQyxHQUFHLFlBQU07UUFDcEQsTUFBSSxDQUFDN0oscUJBQXFCLENBQUM3OUIsTUFBTSxDQUFDLCtCQUErQixFQUFFLE1BQUksQ0FBQztRQUN4RSxNQUFJLENBQUM0akIsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ0ksc0JBQXNCLEVBQUUsTUFBSSxDQUFDLENBQUM7TUFDdEYsQ0FBQztNQUNEclcsTUFBTSxDQUFDcWhDLFFBQVEsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLEdBQUcsWUFBTTtRQUM3QyxNQUFJLENBQUM3SixxQkFBcUIsQ0FBQzc5QixNQUFNLENBQUMsa0JBQWtCLEVBQUUsTUFBSSxDQUFDO1FBQzNELE1BQUksQ0FBQzRqQixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDRyxjQUFjLEVBQUUsTUFBSSxDQUFDLENBQUM7TUFDOUUsQ0FBQztNQUNEcFcsTUFBTSxDQUFDcWhDLFFBQVEsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDLEdBQUcsVUFBQ0UsT0FBTyxFQUFLO1FBQzVELE1BQUksQ0FBQ2hrQixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDYyxhQUFhLEVBQUUsTUFBSSxFQUFFO1VBQ3pFaU4sTUFBTSxFQUFFcG1CLElBQUksQ0FBQ0MsS0FBSyxDQUFDMGpDLE9BQU8sQ0FBQyxDQUFDdmQ7UUFDOUIsQ0FBQyxDQUFDLENBQUM7TUFDTCxDQUFDO01BQ0Roa0IsTUFBTSxDQUFDcWhDLFFBQVEsQ0FBQywrQkFBK0IsQ0FBQyxDQUFDLEdBQUcsWUFBTTtRQUN4RGhvQyxTQUFLLENBQUNzaEIsaUJBQUksRUFBRSx5QkFBeUIsQ0FBQztNQUN4QyxDQUFDO01BQ0QzYSxNQUFNLENBQUNxaEMsUUFBUSxDQUFDLGtDQUFrQyxDQUFDLENBQUMsR0FBRyxVQUFDRSxPQUFPLEVBQUs7UUFDbEUsSUFBTXRrQyxJQUFJLEdBQUdXLElBQUksQ0FBQ0MsS0FBSyxDQUFDMGpDLE9BQU8sQ0FBQztRQUNoQyxNQUFJLENBQUNoa0IsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ2dCLG9CQUFvQixFQUFFLE1BQUksRUFBRTtVQUNoRmxnQixJQUFJLEVBQUVrRyxJQUFJLENBQUNwQixLQUFLO1VBQ2hCNmlCLFFBQVEsRUFBRXpoQixJQUFJLENBQUN5aEI7UUFDakIsQ0FBQyxDQUFDLENBQUM7TUFDTCxDQUFDO01BQ0QxZSxNQUFNLENBQUNxaEMsUUFBUSxDQUFDLG1DQUFtQyxDQUFDLENBQUMsR0FBRyxVQUFDRSxPQUFPLEVBQUs7UUFDbkUsSUFBTXhkLElBQUksR0FBR25tQixJQUFJLENBQUNDLEtBQUssQ0FBQzBqQyxPQUFPLENBQUMsQ0FBQ3hkLElBQUk7UUFDckMsTUFBSSxDQUFDeEcsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ2lCLHFCQUFxQixFQUFFLE1BQUksRUFBRTtVQUNqRjZNLElBQUksRUFBRUEsSUFBSTtVQUNWbkYsS0FBSyxFQUFFSixxQkFBcUIsQ0FBQ3VGLElBQUk7UUFDbkMsQ0FBQyxDQUFDLENBQUM7TUFDTCxDQUFDO01BQ0QvakIsTUFBTSxDQUFDcWhDLFFBQVEsQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDLEdBQUcsVUFBQ0UsT0FBTyxFQUFLO1FBQzlELElBQU10a0MsSUFBSSxHQUFHVyxJQUFJLENBQUNDLEtBQUssQ0FBQzBqQyxPQUFPLENBQUM7UUFDaEMsSUFBUXBxQyxLQUFLLEdBQWE4RixJQUFJLENBQXRCOUYsS0FBSztVQUFFc0IsTUFBTSxHQUFLd0UsSUFBSSxDQUFmeEUsTUFBTTtRQUNyQixJQUFNK29DLFFBQVEsR0FBRzVqQyxJQUFJLENBQUNDLEtBQUssQ0FBQzRqQyxrQkFBa0IsQ0FBQ2hwQyxNQUFNLENBQUMsQ0FBQztRQUN2RCxNQUFJLENBQUM4a0IsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUNwQix3QkFBd0IsQ0FBQ0MsZ0JBQWdCLEVBQUUsTUFBSSxFQUFFO1VBQ2hGbGhCLEtBQUssRUFBRUEsS0FBSztVQUNac0IsTUFBTSxFQUFFK29DO1FBQ1YsQ0FBQyxDQUFDLENBQUM7TUFDTCxDQUFDO0lBQ0g7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLGNBQU14bUMsT0FBTyxFQUFFO01BQUE7TUFDYixJQUFNNlQsUUFBUSxHQUFHLElBQUkzVSxlQUFlLEVBQUU7TUFDdEMsSUFBTStHLE9BQU8sR0FBR2pHLE9BQU8sQ0FBQ3NpQyxlQUFlLElBQUlySCwyQkFBYyxDQUFDcUgsZUFBZTtNQUN6RSxJQUFJLENBQUNyMEIsT0FBVyxDQUFDOUUsb0JBQW9CLENBQUNsRCxPQUFPLENBQUMsRUFBRTtRQUM5QzNILFFBQUksQ0FBQ3FoQixpQkFBSSxnR0FBeUYxWixPQUFPLE9BQUk7UUFDN0c0TixRQUFRLENBQUNsVixNQUFNLCtGQUF3RnNILE9BQU8sT0FBSTtNQUNwSCxDQUFDLE1BQ0k7UUFDSCxJQUFJLENBQUM4MUIsUUFBUSxHQUFHbnFCLE1BQU0sQ0FBQ21uQixNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUVrQywyQkFBYyxFQUFFajdCLE9BQU8sQ0FBQztRQUMxRCxJQUFNMG1DLHNCQUFzQixHQUFHLFNBQXpCQSxzQkFBc0IsR0FBUztVQUNwQyxNQUFJLENBQUMvSCx1QkFBdUIsRUFBRSxDQUM1QnArQixJQUFJLENBQUMsVUFBQTZrQixJQUFJLEVBQUk7WUFDWixNQUFJLENBQUNnWCxjQUFjLEdBQUcsSUFBSXdILDJCQUFpQixDQUFDLE1BQUksRUFBRXhlLElBQUksQ0FBQ0EsSUFBSSxFQUFFLE1BQUksQ0FBQ3daLE9BQU8sRUFBRSxDQUFDO1lBQzVFLE1BQUksQ0FBQ0MscUJBQXFCLENBQUMsTUFBSSxDQUFDekMsY0FBYyxDQUFDO1lBQy9DLElBQUksTUFBSSxDQUFDTCxRQUFRLEVBQUU7Y0FDakIsSUFBTXp4QixHQUFHLEdBQUcsTUFBSSxDQUFDMjdCLGFBQWE7Y0FDOUIsTUFBSSxDQUFDN0osY0FBYyxDQUFDVyxTQUFTLENBQUMsTUFBSSxDQUFDaUosVUFBVSxFQUFFLE1BQUksQ0FBQ2pLLFFBQVEsQ0FBQyxDQUMxRHg3QixJQUFJLENBQUMsVUFBQW9tQyxZQUFZLEVBQUk7Z0JBQ3BCLE1BQUksQ0FBQ0Msd0JBQXdCLENBQUNELFlBQVksQ0FBQztnQkFDM0NyOEIsR0FBRyxDQUFDNUwsT0FBTyxDQUFDLE1BQUksQ0FBQztjQUNuQixDQUFDLENBQUMsQ0FDRCtCLEtBQUssQ0FBQyxVQUFBaUcsR0FBRztnQkFBQSxPQUFJNEQsR0FBRyxDQUFDM0wsTUFBTSxDQUFDK0gsR0FBRyxDQUFDO2NBQUEsRUFBQztZQUNsQztVQUNGLENBQUMsQ0FBQztRQUNKLENBQUM7UUFFRCxJQUFJO1VBQ0Z1SCxPQUFXLENBQUM1RCxZQUFZLENBQUMsSUFBSSxDQUFDMHhCLFFBQVEsQ0FBQzRKLFlBQVksQ0FBQyxDQUNqRHBsQyxJQUFJLENBQUMsWUFBTTtZQUNWLElBQU1zbUMsUUFBUSxHQUFHLE1BQUksQ0FBQ1osYUFBYTtZQUNuQzVuQyxTQUFLLENBQUNzaEIsaUJBQUksRUFBRSxxQkFBcUIsQ0FBQztZQUNsQyxJQUFJLE1BQUksQ0FBQ3ljLGNBQWMsRUFBRTtjQUN2QixNQUFJLENBQUNBLGNBQWMsQ0FBQ1csU0FBUyxDQUFDLE1BQUksQ0FBQ2lKLFVBQVUsRUFBRSxNQUFJLENBQUNqSyxRQUFRLENBQUMsQ0FDMUR4N0IsSUFBSSxDQUFDLFVBQUFvbUMsWUFBWSxFQUFJO2dCQUNwQixNQUFJLENBQUNDLHdCQUF3QixDQUFDRCxZQUFZLENBQUM7Z0JBQzNDRSxRQUFRLENBQUNub0MsT0FBTyxDQUFDLE1BQUksQ0FBQztjQUN4QixDQUFDLENBQUMsQ0FDRCtCLEtBQUssQ0FBQyxVQUFBaUcsR0FBRyxFQUFJO2dCQUNabWdDLFFBQVEsQ0FBQ2xvQyxNQUFNLENBQUMrSCxHQUFHLENBQUM7Y0FDdEIsQ0FBQyxDQUFDO2NBQ0osT0FBTyxNQUFJLENBQUN3L0IsZ0JBQWdCLEVBQUU7WUFDaEM7WUFDQVEsc0JBQXNCLEVBQUU7WUFDeEIsT0FBTyxJQUFJO1VBQ2IsQ0FBQyxDQUFDLENBQ0RubUMsSUFBSSxDQUFDLFlBQU07WUFDVixNQUFJLENBQUMwK0Isa0JBQWtCLENBQUMsTUFBSSxDQUFDbkQsS0FBSyxFQUFFLE1BQUksQ0FBQ0MsUUFBUSxDQUFDWixjQUFjLENBQUM7WUFDakV0bkIsUUFBUSxDQUFDblYsT0FBTyxDQUFDLE1BQUksQ0FBQztVQUN4QixDQUFDLENBQUMsQ0FDRCtCLEtBQUssQ0FBQyxVQUFBaUcsR0FBRyxFQUFJO1lBQ1puSSxTQUFLLENBQUNvaEIsaUJBQUksNkRBQXNEalosR0FBRyxFQUFHO1lBQ3RFLElBQUksTUFBSSxDQUFDMDFCLGNBQWMsRUFBRTtjQUN2QixNQUFJLENBQUNBLGNBQWMsQ0FBQzhCLFVBQVUsRUFBRTtZQUNsQztZQUNEcnFCLFFBQVEsQ0FBQ2xWLE1BQU0sQ0FBQytILEdBQUcsQ0FBQztZQUNuQixNQUFJLENBQUM2YixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3BCLHdCQUF3QixDQUFDcEMsYUFBYSxFQUFFLE1BQUksQ0FBQyxDQUFDO1VBQ2pGLENBQUMsQ0FBQztRQUNOLENBQUMsQ0FBQyxPQUFPbFksQ0FBQyxFQUFFO1VBQ1YrUSxRQUFRLENBQUNsVixNQUFNLHNFQUErRG1FLENBQUMsQ0FBQ3JHLE9BQU8sRUFBRztVQUMxRixJQUFJLENBQUM4bEIsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUNwQix3QkFBd0IsQ0FBQ3BDLGFBQWEsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNqRjtNQUNGO01BQ0EsT0FBT25ILFFBQVEsQ0FBQ2pWLE9BQU87SUFDekI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEsaUJBQVN3bUIsSUFBSSxFQUFFcVMsU0FBUyxFQUFFO01BQ3hCLElBQUksQ0FBQ3FFLEtBQUssR0FBRzFXLElBQUk7TUFDakIsSUFBSSxDQUFDNGdCLFVBQVUsR0FBR3ZPLFNBQVM7TUFDM0IsSUFBSSxDQUFDNkUsYUFBYSxDQUFDNTlCLE9BQU8sQ0FBQyxJQUFJLENBQUNvOUIsS0FBSyxDQUFDO01BQ3RDLE9BQU8sSUFBSTtJQUNiOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUxFO0lBQUE7SUFBQSxPQU1BLHFCQUFhO01BQ1gsT0FBTyxJQUFJLENBQUNxRCwrQkFBK0IsRUFBRTtJQUMvQzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFMRTtJQUFBO0lBQUEsT0FNQSx1QkFBZTtNQUFBO01BQ2I5Z0MsU0FBSyxDQUFDc2hCLGlCQUFJLEVBQUUsZUFBZSxDQUFDO01BQzVCLElBQU1yVCxFQUFFLEdBQUcsU0FBTEEsRUFBRSxDQUFJNU4sT0FBTyxFQUFFQyxNQUFNLEVBQUs7UUFDOUIsSUFBSTtVQUNGLE1BQUksQ0FBQ3k5QixjQUFjLENBQUM4QixVQUFVLEVBQUU7VUFDaEN4L0IsT0FBTyxFQUFFO1FBQ1gsQ0FBQyxDQUFDLE9BQU9vRSxDQUFDLEVBQUU7VUFDVm5FLE1BQU0sQ0FBQ21FLENBQUMsQ0FBQ3JHLE9BQU8sQ0FBQztRQUNuQjtNQUNGLENBQUM7TUFDRCxPQUFPLElBQUlvQyxPQUFPLENBQUN5TixFQUFFLENBQUM7SUFDeEI7O0lBRUE7QUFDRjtBQUNBO0VBRkU7SUFBQTtJQUFBLE9BR0EsZ0JBQVE7TUFBQTtNQUNOak8sU0FBSyxDQUFDc2hCLGlCQUFJLEVBQUUsUUFBUSxDQUFDO01BQ3JCLElBQUksQ0FBQ3VtQixnQkFBZ0IsRUFBRSxDQUFDM2xDLElBQUksQ0FBQyxZQUFNO1FBQ2pDLE1BQUksQ0FBQzY3QixjQUFjLENBQUNseUIsSUFBSSxFQUFFO01BQzVCLENBQUMsQ0FBQztJQUNKOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSwyQkFBbUI7TUFDakI3TCxTQUFLLENBQUNzaEIsaUJBQUksRUFBRSxrQkFBa0IsQ0FBQztNQUMvQixJQUFJLENBQUM0QyxPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3BCLHdCQUF3QixDQUFDckMsYUFBYSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2pGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSx3QkFBZ0JyVSxHQUFHLEVBQUU7TUFDbkJySSxTQUFLLENBQUNzaEIsaUJBQUksOEJBQXVCalosR0FBRyxFQUFHO01BQ3ZDLElBQUksQ0FBQzZiLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDcEIsd0JBQXdCLENBQUNwQyxhQUFhLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDakY7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLHVCQUFlO01BQ2IzYyxTQUFLLENBQUNzaEIsaUJBQUksRUFBRSxlQUFlLENBQUM7TUFDNUIsSUFBSSxJQUFJLENBQUN5YyxjQUFjLEVBQUU7UUFDdkIsSUFBSSxDQUFDQSxjQUFjLENBQUN3RCxTQUFTLEVBQUU7TUFDakM7TUFDQSxJQUFJLENBQUNyZCxPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDVSxjQUFjLEVBQUUsSUFBSSxDQUFDLENBQUM7TUFDNUUsSUFBSSxJQUFJLENBQUN5Z0IsY0FBYyxFQUFFO1FBQ3ZCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLElBQUksQ0FBQ0EsY0FBYyxDQUFDOEIsVUFBVSxFQUFFO01BQ2xDO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLHlCQUFpQjtNQUNmLE9BQU8sSUFBSSxDQUFDOUIsY0FBYztJQUM1Qjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsdUJBQWU7TUFDYixPQUFPLElBQUksQ0FBQ0EsY0FBYyxHQUFHLElBQUksQ0FBQ0EsY0FBYyxDQUFDeFQsV0FBVyxFQUFFLEdBQUd0ckIsU0FBUztJQUM1RTs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0Esc0JBQWM7TUFDWixPQUFPLElBQUksQ0FBQ3krQixRQUFRO0lBQ3RCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxxQkFBYTtNQUNYLE9BQU8sSUFBSSxDQUFDSyxjQUFjLEdBQUcsSUFBSSxDQUFDQSxjQUFjLENBQUM2SCxlQUFlLEVBQUUsR0FBRzNtQyxTQUFTO0lBQ2hGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxtQkFBVztNQUNULE9BQU95OEIsYUFBYSxDQUFDRSxJQUFJLENBQUNnSCxXQUFXLEVBQUU7SUFDekM7RUFBQztFQUFBO0FBQUEsRUFsWTBCMVosa0JBQWtCO0FBc1loQ3dlLDRFQUFjLEU7O0FDaGNqQjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUU0QjtBQUNrQjtBQUNDO0FBQ1U7QUFDRTtBQUNQO0FBQ2Y7QUFDTjtBQUUzQyxJQUFNcG1CLCtCQUFJLEdBQUcsa0JBQWtCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEEsSUFRTW1uQiwyQ0FBZ0I7RUFBQTtFQUFBO0VBRXBCLDBCQUFheHpCLEtBQUssRUFBRTVWLElBQUksRUFBRTtJQUFBO0lBQUE7SUFDeEI7SUFDQSxNQUFLNFYsS0FBSyxHQUFHQSxLQUFLO0lBQ2xCLE1BQUtzVSxLQUFLLEdBQUcsTUFBS3RVLEtBQUssQ0FBQ3VVLFNBQVMsQ0FBQyxJQUFJLENBQUM7SUFDdkMsTUFBS25aLE1BQU0sR0FBRyxNQUFLNEUsS0FBSyxDQUFDekYsVUFBVTtJQUNuQyxNQUFLaWEsTUFBTSxHQUFHLE1BQUtDLGdCQUFnQixDQUFDelUsS0FBSyxDQUFDO0lBQzFDLE1BQUswVSxVQUFVLEdBQUd0cUIsSUFBSTtJQUN0QixNQUFLcXBDLFlBQVksR0FBR3pwQyxTQUFTO0lBQzdCLE1BQUsycUIsTUFBTSxHQUFHLEtBQUs7SUFDbkIsTUFBS0MsU0FBUyxHQUFHNXFCLFNBQVM7SUFDMUIsTUFBS20vQixZQUFZLEdBQUcsQ0FBQztJQUNyQixNQUFLQyxjQUFjLEdBQUcsYUFBYTtJQUNuQyxNQUFLc0ssc0JBQXNCLEdBQUcsSUFBSTtJQUNsQyxNQUFLN2UsMkJBQTJCLEdBQUcsTUFBSzdVLEtBQUs7SUFDN0MsTUFBSzJ6Qix3QkFBd0IsR0FBRyxNQUFLQSx3QkFBd0IsQ0FBQ3ZtQixJQUFJLENBQUMsd0RBQUs7SUFDeEUsTUFBS3dtQixzQkFBc0IsR0FBRyxNQUFLQSxzQkFBc0IsQ0FBQ3htQixJQUFJLENBQUMsd0RBQUs7SUFDcEUsTUFBS3ltQix3QkFBd0IsR0FBRyxNQUFLQSx3QkFBd0IsQ0FBQ3ptQixJQUFJLENBQUMsd0RBQUs7SUFDeEV6UyxPQUFXLENBQUM1Qix1QkFBdUIsQ0FBQyxNQUFLK2IsdUJBQXVCLENBQUMxSCxJQUFJLENBQUMsd0RBQUssQ0FBQztJQUFBO0VBQzlFOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQRTtJQUFBO0lBQUEsT0FRQSwwQkFBa0JwTixLQUFLLEVBQUU7TUFDdkIsSUFBSUEsS0FBSyxDQUFDekYsVUFBVSxDQUFDaEIsU0FBUyxDQUFDQyxRQUFRLENBQUMseUJBQXlCLENBQUMsRUFBRTtRQUNsRSxPQUFPd0csS0FBSyxDQUFDekYsVUFBVTtNQUN6QixDQUFDLE1BQ0k7UUFDSCxJQUFNYSxNQUFNLEdBQUc0RSxLQUFLLENBQUN6RixVQUFVO1FBQy9CLElBQU13YSxHQUFHLEdBQUdwYSxPQUFXLENBQUN2RixhQUFhLENBQUMsS0FBSyxDQUFDO1FBQzVDMmYsR0FBRyxDQUFDeGIsU0FBUyxDQUFDZ1csR0FBRyxDQUFDLHlCQUF5QixDQUFDO1FBQzVDblUsTUFBTSxDQUFDNFosWUFBWSxDQUFDRCxHQUFHLEVBQUUvVSxLQUFLLENBQUM7UUFDL0I1RSxNQUFNLENBQUM0WSxXQUFXLENBQUNoVSxLQUFLLENBQUM7UUFDekIrVSxHQUFHLENBQUN6ZCxXQUFXLENBQUMwSSxLQUFLLENBQUM7UUFDdEIsT0FBTytVLEdBQUc7TUFDWjtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxvQkFBWTtNQUNWO01BQ0EsSUFBSTVmLEVBQUUsR0FBRyxJQUFJLENBQUM2SyxLQUFLO01BQ25CLElBQUloVCxHQUFHLEdBQUcsSUFBSSxDQUFDeW1DLFlBQVk7TUFDM0IsSUFBSXhlLFFBQVEsR0FBRzlmLEVBQUUsQ0FBQ29GLFVBQVU7TUFDNUIsSUFBSTJhLFdBQVcsR0FBRyxJQUFJLENBQUNWLE1BQU07TUFDN0IsSUFBSXhuQixHQUFHLEVBQUU7UUFDUG1JLEVBQUUsQ0FBQzZlLFdBQVcsQ0FBQ2huQixHQUFHLENBQUM7TUFDckI7TUFDQSxJQUFJaW9CLFFBQVEsRUFBRTtRQUNaQSxRQUFRLENBQUNqQixXQUFXLENBQUM3ZSxFQUFFLENBQUM7UUFDeEI7UUFDQSxJQUFJOGYsUUFBUSxLQUFLLElBQUksQ0FBQzdaLE1BQU0sRUFBRTtVQUM1QjZaLFFBQVEsQ0FBQzFhLFVBQVUsQ0FBQ3laLFdBQVcsQ0FBQ2lCLFFBQVEsQ0FBQztVQUN6Q0MsV0FBVyxHQUFHLElBQUksQ0FBQzlaLE1BQU07UUFDM0I7TUFDRixDQUFDLE1BQU07UUFDTCxJQUFJO1VBQ0ZqRyxFQUFFLENBQUNxYSxNQUFNLEVBQUU7UUFDYixDQUFDLENBQUMsT0FBT2hnQixDQUFDLEVBQUU7VUFDVnhFLFFBQUksQ0FBQ3FoQiwrQkFBSSxzREFBK0M3YyxDQUFDLENBQUNyRyxPQUFPLEVBQUc7UUFDdEU7TUFDRjtNQUNBLElBQUksQ0FBQzZXLEtBQUssR0FBRyxJQUFJLENBQUNzVSxLQUFLLENBQUNDLFNBQVMsQ0FBQyxJQUFJLENBQUM7TUFDdkNXLFdBQVcsQ0FBQzVkLFdBQVcsQ0FBQyxJQUFJLENBQUMwSSxLQUFLLENBQUM7TUFDbkMsSUFBSSxJQUFJLENBQUM0VSxTQUFTLEVBQUU7UUFDbEIsSUFBSSxDQUFDQSxTQUFTLENBQUNPLE1BQU0sRUFBRTtNQUN6QjtNQUNBLElBQUksQ0FBQ25WLEtBQUssQ0FBQ25KLFlBQVksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDO01BQ3pDLElBQUksQ0FBQ3lkLEtBQUssR0FBRyxJQUFJLENBQUN0VSxLQUFLLENBQUN1VSxTQUFTLENBQUMsSUFBSSxDQUFDO01BQ3ZDLElBQUksQ0FBQ25aLE1BQU0sR0FBRyxJQUFJLENBQUM0RSxLQUFLLENBQUN6RixVQUFVO01BQ25DLElBQUksQ0FBQ2lhLE1BQU0sR0FBRyxJQUFJLENBQUNDLGdCQUFnQixDQUFDLElBQUksQ0FBQ3pVLEtBQUssQ0FBQztNQUMvQyxJQUFJLENBQUNtcEIsWUFBWSxHQUFHLENBQUM7TUFDckIsSUFBSSxDQUFDclYsS0FBSyxHQUFHLEtBQUs7SUFDcEI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORTtJQUFBO0lBQUEsT0FPQSw4QkFBc0JzQixRQUFRLEVBQUU7TUFBQTtNQUM5QixJQUFNQyxRQUFRLEdBQUcsSUFBSSxDQUFDQyxXQUFXLEVBQUU7TUFDbkMsSUFBTUMsV0FBVyxHQUFHLE9BQU9GLFFBQVEsS0FBSyxXQUFXO01BRW5ERCxRQUFRLENBQUNJLFNBQVMsR0FBRyxZQUFNO1FBQ3pCLElBQUlILFFBQVEsRUFBRTtVQUNaQSxRQUFRLENBQUNoRCxNQUFNLENBQUMsSUFBSSxDQUFDO1FBQ3ZCO1FBQ0EsTUFBSSxDQUFDcEQsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ2lCLHFCQUFxQixFQUFFNWUsU0FBUyxFQUFFO1VBQ3RGeXJCLElBQUksRUFBRTdGLGFBQWEsQ0FBQ0UsU0FBUztVQUM3QlEsS0FBSyxFQUFFSixxQkFBcUIsQ0FBQ04sYUFBYSxDQUFDRSxTQUFTO1FBQ3RELENBQUMsQ0FBQyxDQUFDO1FBQ0gsTUFBSSxDQUFDYixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDYyxhQUFhLEVBQUV6ZSxTQUFTLEVBQUU7VUFDOUUwckIsTUFBTSxFQUFFTixRQUFRLENBQUNNO1FBQ25CLENBQUMsQ0FBQyxDQUFDO01BQ0wsQ0FBQztNQUNETixRQUFRLENBQUNPLGdCQUFnQixHQUFHLFVBQUM3bkIsS0FBSyxFQUFLO1FBQUU7UUFDdkMsSUFBSSxDQUFDMFAsS0FBSyxDQUFDNFgsUUFBUSxDQUFDaEYsUUFBUSxDQUFDLElBQUk0QyxNQUFNLENBQUM0QyxRQUFRLENBQUNSLFFBQVEsQ0FBQ2hGLFFBQVEsQ0FBQyxFQUFFO1VBQ25FLE1BQUksQ0FBQzBELEtBQUssR0FBRyxJQUFJO1FBQ25CO1FBQ0EsSUFBSSxDQUFDLE1BQUksQ0FBQ0EsS0FBSyxJQUFJeUIsV0FBVyxFQUFFO1VBQzlCRixRQUFRLENBQUNRLG1CQUFtQixDQUFDLENBQUMsQ0FBQztRQUNqQyxDQUFDLE1BQU0sSUFBSU4sV0FBVyxFQUFFO1VBQ3RCRixRQUFRLENBQUNRLG1CQUFtQixDQUFDVCxRQUFRLENBQUNoRixRQUFRLENBQUM7UUFDakQ7TUFDRixDQUFDO01BQ0RnRixRQUFRLENBQUNVLE9BQU8sR0FBRyxZQUFNO1FBQ3ZCL3FCLFNBQUssQ0FBQ3NoQiwrQkFBSSxFQUFFLHdCQUF3QixDQUFDO1FBQ3JDLElBQUlrSixXQUFXLEVBQUU7VUFDZkYsUUFBUSxDQUFDbkQsUUFBUSxDQUFDdEMsYUFBYSxDQUFDRyxJQUFJLENBQUM7UUFDdkM7UUFDQSxNQUFJLENBQUNkLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUNpQixxQkFBcUIsRUFBRTVlLFNBQVMsRUFBRTtVQUN0RnlyQixJQUFJLEVBQUU3RixhQUFhLENBQUNHLElBQUk7VUFDeEJPLEtBQUssRUFBRUoscUJBQXFCLENBQUNOLGFBQWEsQ0FBQ0csSUFBSTtRQUNqRCxDQUFDLENBQUMsQ0FBQztNQUNMLENBQUM7TUFDRHFGLFFBQVEsQ0FBQ1csWUFBWSxHQUFHLFVBQUNqb0IsS0FBSyxFQUFLO1FBQUU7UUFDbkMsSUFBSXluQixXQUFXLEVBQUU7VUFDZixJQUFJLENBQUM5QyxJQUFJLENBQUNxQixLQUFLLEVBQUU7WUFDZnVCLFFBQVEsQ0FBQ2pELFdBQVcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1VBQzVCLENBQUMsTUFBTTtZQUNMaUQsUUFBUSxDQUFDakQsV0FBVyxDQUFDZ0QsUUFBUSxDQUFDWSxXQUFXLEVBQUV2RCxJQUFJLENBQUNxQixLQUFLLEdBQUdzQixRQUFRLENBQUNoRixRQUFRLEdBQUdwbUIsU0FBUyxDQUFDO1VBQ3hGO1FBQ0Y7UUFDQSxNQUFJLENBQUNpbEIsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ2dCLG9CQUFvQixFQUFFM2UsU0FBUyxFQUFFO1VBQ3JGdkIsSUFBSSxFQUFFMnNCLFFBQVEsQ0FBQ1ksV0FBVztVQUMxQjVGLFFBQVEsRUFBRWdGLFFBQVEsQ0FBQ2hGO1FBQ3JCLENBQUMsQ0FBQyxDQUFDO01BQ0wsQ0FBQztNQUNEZ0YsUUFBUSxDQUFDYSxRQUFRLEdBQUcsVUFBQ25vQixLQUFLLEVBQUssQ0FBRTtRQUNyQztNQUFBLENBQ0s7TUFDRHNuQixRQUFRLENBQUNjLFNBQVMsR0FBRyxVQUFDcG9CLEtBQUssRUFBSyxDQUFFO1FBQ3RDO01BQUEsQ0FDSztNQUNEc25CLFFBQVEsQ0FBQ2UsTUFBTSxHQUFHLFlBQU07UUFDdEIsSUFBSVosV0FBVyxFQUFFO1VBQ2ZGLFFBQVEsQ0FBQ25ELFFBQVEsQ0FBQ3RDLGFBQWEsQ0FBQ0ksT0FBTyxDQUFDO1FBQzFDO1FBQ0EsTUFBSSxDQUFDZixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDaUIscUJBQXFCLEVBQUU1ZSxTQUFTLEVBQUU7VUFDdEZ5ckIsSUFBSSxFQUFFN0YsYUFBYSxDQUFDSSxPQUFPO1VBQzNCTSxLQUFLLEVBQUVKLHFCQUFxQixDQUFDTixhQUFhLENBQUNJLE9BQU87UUFDcEQsQ0FBQyxDQUFDLENBQUM7TUFDTCxDQUFDO01BQ0RvRixRQUFRLENBQUNnQixPQUFPLEdBQUcsWUFBTTtRQUN2QixJQUFJYixXQUFXLEVBQUU7VUFDZkYsUUFBUSxDQUFDbkQsUUFBUSxDQUFDdEMsYUFBYSxDQUFDSyxNQUFNLENBQUM7UUFDekM7UUFDQSxNQUFJLENBQUNoQixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDaUIscUJBQXFCLEVBQUU1ZSxTQUFTLEVBQUU7VUFDdEZ5ckIsSUFBSSxFQUFFN0YsYUFBYSxDQUFDSyxNQUFNO1VBQzFCSyxLQUFLLEVBQUVKLHFCQUFxQixDQUFDTixhQUFhLENBQUNLLE1BQU07UUFDbkQsQ0FBQyxDQUFDLENBQUM7TUFDTCxDQUFDO01BQ0RtRixRQUFRLENBQUNpQixjQUFjLEdBQUcsVUFBQ3ZvQixLQUFLLEVBQUs7UUFBRTtRQUNyQyxJQUFJeW5CLFdBQVcsSUFBSUYsUUFBUSxDQUFDaUIsU0FBUyxFQUFFLEtBQUssTUFBSSxDQUFDdFcsS0FBSyxDQUFDMFYsTUFBTSxFQUFFO1VBQzdETCxRQUFRLENBQUNwQyxTQUFTLENBQUMsTUFBSSxDQUFDalQsS0FBSyxDQUFDMFYsTUFBTSxDQUFDO1FBQ3ZDO1FBQ0EsTUFBSSxDQUFDekcsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ2MsYUFBYSxFQUFFemUsU0FBUyxFQUFFO1VBQzlFMHJCLE1BQU0sRUFBRU4sUUFBUSxDQUFDekIsS0FBSyxHQUFHLENBQUMsR0FBR3lCLFFBQVEsQ0FBQ007UUFDeEMsQ0FBQyxDQUFDLENBQUM7TUFDTCxDQUFDO01BQ0Q7TUFDQU4sUUFBUSxDQUFDbUIsV0FBVyxHQUFHLFlBQU07UUFBRXhyQixTQUFLLENBQUNzaEIsK0JBQUksRUFBRSxnQ0FBZ0MsQ0FBQztNQUFDLENBQUM7TUFDOUUrSSxRQUFRLENBQUNvQixTQUFTLEdBQUcsWUFBTTtRQUFFenJCLFNBQUssQ0FBQ3NoQiwrQkFBSSxFQUFFLDhCQUE4QixDQUFDO01BQUMsQ0FBQztNQUMxRStJLFFBQVEsQ0FBQ3FCLFlBQVksR0FBRyxZQUFNO1FBQzVCMXJCLFNBQUssQ0FBQ3NoQiwrQkFBSSxFQUFFLGlDQUFpQyxDQUFDO1FBQzlDO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtNQUNJLENBQUM7O01BQ0QrSSxRQUFRLENBQUN3QixRQUFRLEdBQUcsWUFBTTtRQUN4QjdyQixTQUFLLENBQUNzaEIsK0JBQUksRUFBRSw2QkFBNkIsQ0FBQztRQUMxQyxNQUFJLENBQUM0QyxPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDYSx1QkFBdUIsRUFBRXhlLFNBQVMsRUFBRTtVQUN4RjBSLEtBQUssRUFBRSxNQUFJLENBQUNzRSxLQUFLLENBQUMwVyxVQUFVO1VBQzVCeGEsTUFBTSxFQUFFLE1BQUksQ0FBQzhELEtBQUssQ0FBQzJXO1FBQ3JCLENBQUMsQ0FBQyxDQUFDO01BQ0wsQ0FBQztNQUNEdkIsUUFBUSxDQUFDeUIsZ0JBQWdCLEdBQUcsWUFBTTtRQUNoQzlyQixTQUFLLENBQUNzaEIsK0JBQUksRUFBRSxxQ0FBcUMsQ0FBQztRQUNsRCxNQUFJLENBQUM0QyxPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDQyxlQUFlLEVBQUU1ZCxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztNQUN4RixDQUFDO01BQ0RvckIsUUFBUSxDQUFDMEIsV0FBVyxHQUFHLFlBQU07UUFBRS9yQixTQUFLLENBQUNzaEIsK0JBQUksRUFBRSxrQ0FBa0MsQ0FBQztNQUFDLENBQUM7TUFDaEYrSSxRQUFRLENBQUMyQixTQUFTLEdBQUcsWUFBTTtRQUFFaHNCLFNBQUssQ0FBQ3NoQiwrQkFBSSxFQUFFLDhCQUE4QixDQUFDO01BQUMsQ0FBQztNQUMxRStJLFFBQVEsQ0FBQzRCLFNBQVMsR0FBRyxZQUFNO1FBQUVqc0IsU0FBSyxDQUFDc2hCLCtCQUFJLEVBQUUsOEJBQThCLENBQUM7TUFBQyxDQUFDO01BQzFFK0ksUUFBUSxDQUFDNkIsU0FBUyxHQUFHLFlBQU07UUFBRWxzQixTQUFLLENBQUNzaEIsK0JBQUksRUFBRSw4QkFBOEIsQ0FBQztNQUFDLENBQUM7TUFDMUU7SUFDRjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQU5FO0lBQUE7SUFBQSxPQU9BLGlDQUF5QndILFlBQVksRUFBRTtNQUNyQyxJQUFJQSxZQUFZLEVBQUU7UUFDaEIsSUFBSSxDQUFDVyxNQUFNLENBQUNqYixTQUFTLENBQUNnVyxHQUFHLENBQUMscUNBQXFDLENBQUM7UUFDaEUsSUFBSSxDQUFDdlAsS0FBSyxDQUFDekcsU0FBUyxDQUFDZ1csR0FBRyxDQUFDLHFDQUFxQyxDQUFDO01BQ2pFLENBQUMsTUFDSTtRQUNILElBQUksQ0FBQ2lGLE1BQU0sQ0FBQ2piLFNBQVMsQ0FBQ2lXLE1BQU0sQ0FBQyxxQ0FBcUMsQ0FBQztRQUNuRSxJQUFJLENBQUN4UCxLQUFLLENBQUN6RyxTQUFTLENBQUNpVyxNQUFNLENBQUMscUNBQXFDLENBQUM7TUFDcEU7TUFDQSxJQUFJLENBQUNQLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUNrQix3QkFBd0IsRUFBRTdlLFNBQVMsRUFBRTZwQixZQUFZLENBQUMsQ0FBQztJQUMzRzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFYRTtJQUFBO0lBQUEsT0FZQSwyQkFBbUIxZCxHQUFHLEVBQUUvTCxJQUFJLEVBQUVzQyxPQUFPLEVBQUU7TUFBRTtNQUN2QyxJQUFNNlQsUUFBUSxHQUFHLElBQUkzVSxlQUFlLEVBQUU7TUFDdEMsSUFBSTtRQUNGLElBQUl2QyxNQUFNLEdBQUdzUixPQUFXLENBQUN2RixhQUFhLENBQUMsUUFBUSxDQUFDO1FBQ2hEL0wsTUFBTSxDQUFDZSxJQUFJLEdBQUdBLElBQUk7UUFDbEJmLE1BQU0sQ0FBQzJELEdBQUcsR0FBR21KLEdBQUc7UUFDaEIsSUFBSSxDQUFDNkosS0FBSyxDQUFDNVYsSUFBSSxHQUFHQSxJQUFJO1FBQ3RCLElBQUksSUFBSSxDQUFDNFYsS0FBSyxDQUFDOHpCLFVBQVUsRUFBRTtVQUN6QixJQUFJLENBQUM5ekIsS0FBSyxDQUFDZ1YsWUFBWSxDQUFDM3JCLE1BQU0sRUFBRSxJQUFJLENBQUMyVyxLQUFLLENBQUM4ekIsVUFBVSxDQUFDO1FBQ3hELENBQUMsTUFDSTtVQUNILElBQUksQ0FBQzl6QixLQUFLLENBQUMxSSxXQUFXLENBQUNqTyxNQUFNLENBQUM7UUFDaEM7UUFDQSxJQUFJLENBQUNvcUMsWUFBWSxHQUFHcHFDLE1BQU07UUFDMUIsSUFBSSxDQUFDcXFDLHNCQUFzQixHQUFHaG5DLE9BQU8sQ0FBQ2s3QixxQkFBcUI7UUFDM0RqdEIsT0FBVyxDQUFDM0oscUJBQXFCLENBQUMsSUFBSSxDQUFDZ1AsS0FBSyxFQUFFLElBQUksQ0FBQzR6QixzQkFBc0IsQ0FBQztRQUMxRWo1QixPQUFXLENBQUN4Six1QkFBdUIsQ0FBQyxJQUFJLENBQUM2TyxLQUFLLEVBQUUsSUFBSSxDQUFDNnpCLHdCQUF3QixDQUFDO1FBQzlFdHpCLFFBQVEsQ0FBQ25WLE9BQU8sRUFBRTtNQUNwQixDQUFDLENBQ0QsT0FBT29FLENBQUMsRUFBRTtRQUNSK1EsUUFBUSxDQUFDbFYsTUFBTSxDQUFDbUUsQ0FBQyxDQUFDckcsT0FBTyxDQUFDO01BQzVCO01BQ0EsT0FBT29YLFFBQVEsQ0FBQ2pWLE9BQU87SUFDekI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORTtJQUFBO0lBQUEsT0FPQSxnQ0FBd0I4MEIsUUFBUSxFQUFFO01BQ2hDLElBQ0V2d0IsV0FBVyxHQUVUdXdCLFFBQVEsQ0FGVnZ3QixXQUFXO1FBQ1hvTSxVQUFVLEdBQ1Jta0IsUUFBUSxDQURWbmtCLFVBQVU7TUFFWixJQUFNKzJCLGNBQWMsR0FBR2xqQyxRQUFRLENBQUNELFdBQVcsRUFBRSxFQUFFLENBQUM7TUFDaEQsSUFBSUEsV0FBVyxJQUFJLElBQUksQ0FBQ3M1QixZQUFZLEtBQUs2SixjQUFjLEVBQUU7UUFDdkRqb0MsU0FBSyxDQUFDc2hCLCtCQUFJLEVBQUUscUJBQXFCLEdBQUcvYyxJQUFJLENBQUM0TyxTQUFTLENBQUNraUIsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN0RSxJQUFJLENBQUMrSSxZQUFZLEdBQUc2SixjQUFjO1FBQ2xDLElBQUksSUFBSSxDQUFDVSxzQkFBc0IsRUFBRTtVQUMvQjEzQixnQkFBZ0IsQ0FBQyxJQUFJLENBQUNnRSxLQUFLLEVBQUUsSUFBSSxDQUFDbXBCLFlBQVksRUFBRWhyQiwwQkFBMEIsQ0FBQ2xDLFVBQVUsQ0FBQyxDQUFDO1VBQ3ZGLElBQUksQ0FBQzAzQix3QkFBd0IsQ0FBQyxJQUFJLENBQUN4SyxZQUFZLENBQUM7UUFDbEQ7UUFDQSxJQUFJLENBQUNsYSxPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDVyxrQkFBa0IsRUFBRXRlLFNBQVMsRUFBRTtVQUNuRjZGLFdBQVcsRUFBRSxJQUFJLENBQUNzNUIsWUFBWTtVQUM5QmtFLFdBQVcsRUFBRSxJQUFJLENBQUNydEI7UUFDcEIsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUNpUCxPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDSyxrQkFBa0IsRUFBRWhlLFNBQVMsRUFBRW8yQixRQUFRLENBQUMsQ0FBQztNQUNqRztJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0Esa0NBQTBCQSxRQUFRLEVBQUU7TUFDbEMsSUFBUXB3QixhQUFhLEdBQUtvd0IsUUFBUSxDQUExQnB3QixhQUFhO01BQ3JCLElBQU1tOUIscUJBQXFCLEdBQUcsSUFBSSxDQUFDL0QsY0FBYztNQUNqRCxJQUFJcDVCLGFBQWEsSUFBSW05QixxQkFBcUIsS0FBS245QixhQUFhLEVBQUU7UUFDNURqRixTQUFLLENBQUNzaEIsK0JBQUksRUFBRSxxQkFBcUIsR0FBRy9jLElBQUksQ0FBQzRPLFNBQVMsQ0FBQ2tpQixRQUFRLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3RFLElBQUksQ0FBQ2dKLGNBQWMsR0FBR3A1QixhQUFhO1FBQ25DLElBQUksQ0FBQ2lmLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUNZLHFCQUFxQixFQUFFdmUsU0FBUyxFQUFFO1VBQ3RGZ0csYUFBYSxFQUFFLElBQUksQ0FBQ281QixjQUFjO1VBQ2xDK0QscUJBQXFCLEVBQUVBLHFCQUFxQjtVQUM1Q0UsV0FBVyxFQUFFLElBQUksQ0FBQ3J0QjtRQUNwQixDQUFDLENBQUMsQ0FBQztRQUNILElBQUksQ0FBQ2lQLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUNLLGtCQUFrQixFQUFFaGUsU0FBUyxFQUFFbzJCLFFBQVEsQ0FBQyxDQUFDO01BQ2pHO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBWEU7SUFBQTtJQUFBLE9BWUEsbUJBQVdqcUIsR0FBRyxFQUFFL0wsSUFBSSxFQUFFc0MsT0FBTyxFQUFFO01BQUE7TUFDN0IzQixTQUFLLENBQUNzaEIsK0JBQUksRUFBRSxhQUFhLENBQUM7TUFDMUIsSUFBSSxDQUFDbUksTUFBTSxHQUFHLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUMsSUFBSSxDQUFDelUsS0FBSyxDQUFDO01BQy9DLElBQU1PLFFBQVEsR0FBRyxJQUFJM1UsZUFBZSxFQUFFO01BQ3RDLElBQU1zckIsa0JBQWtCLEdBQUd4cUIsT0FBTyxDQUFDMm9CLFFBQVE7TUFDM0MsSUFBTThCLE9BQU8sR0FBR3hjLE9BQVcsQ0FBQzFCLG1CQUFtQixDQUFDLElBQUksQ0FBQytHLEtBQUssRUFBRSxPQUFPLENBQUM7TUFDcEUsSUFBTXNrQixVQUFVLEdBQUczcEIsT0FBVyxDQUFDMUIsbUJBQW1CLENBQUMsSUFBSSxDQUFDK0csS0FBSyxFQUFFLFVBQVUsQ0FBQztNQUMxRTtNQUNBLElBQUksQ0FBQ21YLE9BQU8sRUFBRTtRQUNaLElBQUksQ0FBQ25YLEtBQUssQ0FBQ25KLFlBQVksQ0FBQyxVQUFVLEVBQUUsS0FBSyxDQUFDO01BQzVDO01BQ0EsSUFBTXdkLG1CQUFtQixHQUFHMVosT0FBVyxDQUFDMUIsbUJBQW1CLENBQUMsSUFBSSxDQUFDK0csS0FBSyxFQUFFLFVBQVUsQ0FBQyxJQUFJckYsT0FBVyxDQUFDdEIsZUFBZSxDQUFDLElBQUksQ0FBQzJHLEtBQUssRUFBRSxlQUFlLENBQUM7TUFDL0ksSUFBSSxDQUFDK3pCLGlCQUFpQixDQUFDNTlCLEdBQUcsRUFBRS9MLElBQUksRUFBRXNDLE9BQU8sQ0FBQyxDQUN2Q08sSUFBSSxDQUFFLFlBQU07UUFDWCxJQUFJaXFCLGtCQUFrQixJQUFJN0MsbUJBQW1CLEVBQUU7VUFDN0MsSUFBSTZDLGtCQUFrQixFQUFFO1lBQ3RCLE1BQUksQ0FBQ3RDLFNBQVMsR0FBR2xvQixPQUFPLENBQUMyb0IsUUFBUTtVQUNuQyxDQUFDLE1BQ0k7WUFDSCxNQUFJLENBQUNULFNBQVMsR0FBRyxJQUFJVCxvQkFBb0IsQ0FBQyxNQUFJLEVBQUUsTUFBSSxDQUFDSyxNQUFNLENBQUM7VUFDOUQ7VUFDQSxNQUFJLENBQUN4VSxLQUFLLENBQUNxVixRQUFRLEdBQUcsS0FBSztVQUMzQixNQUFJLENBQUNULFNBQVMsQ0FBQ3dDLFFBQVEsQ0FBQyxNQUFJLENBQUN0RCxLQUFLLENBQUM7VUFDbkMsTUFBSSxDQUFDYyxTQUFTLENBQUNoQyxhQUFhLENBQUN1RSxPQUFPLENBQUM7UUFDdkM7UUFDQSxNQUFJLENBQUNFLG9CQUFvQixDQUFDLE1BQUksQ0FBQ3hDLDJCQUEyQixDQUFDO1FBQzNELElBQUl5UCxVQUFVLEVBQUU7VUFDZCxNQUFJLENBQUN1RyxlQUFlLENBQUNuK0IsT0FBTyxDQUFDdTdCLHlCQUF5QixDQUFDO1FBQ3pEO1FBQ0ExbkIsUUFBUSxDQUFDblYsT0FBTyxFQUFFO01BQ3BCLENBQUMsQ0FBQyxDQUNEK0IsS0FBSyxDQUFDLFVBQUFxQyxDQUFDO1FBQUEsT0FBSStRLFFBQVEsQ0FBQ2xWLE1BQU0sQ0FBQ21FLENBQUMsQ0FBQztNQUFBLEVBQUM7TUFDakMsT0FBTytRLFFBQVEsQ0FBQ2pWLE9BQU87SUFDekI7O0lBRUE7QUFDRjtBQUNBO0VBRkU7SUFBQTtJQUFBLE9BR0EsbUJBQVc7TUFDVFAsU0FBSyxDQUFDc2hCLCtCQUFJLEVBQUUsV0FBVyxDQUFDO0lBQzFCO0VBQUM7SUFBQTtJQUFBLE9BRUQsMkJBQXlDO01BQUE7TUFBQSxJQUF4QmlMLGNBQWMsdUVBQUcsS0FBSztNQUNyQyxJQUFJLENBQUMxZ0IsSUFBSSxFQUFFLENBQ1J6SixLQUFLLENBQUMsVUFBQXFDLENBQUMsRUFBSTtRQUNWLElBQUk4bkIsY0FBYyxFQUFFO1VBQ2xCLE1BQUksQ0FBQ3pFLElBQUksRUFBRTtVQUNYLE1BQUksQ0FBQ2pjLElBQUksRUFBRSxDQUNSM0osSUFBSSxDQUFDLFlBQU07WUFDVixNQUFJLENBQUNnaUIsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ29CLG1CQUFtQixFQUFFL2UsU0FBUyxFQUFFO2NBQUM2TyxPQUFPLEVBQUUsTUFBSSxDQUFDbUg7WUFBSyxDQUFDLENBQUMsQ0FBQztVQUMvRyxDQUFDLENBQUMsQ0FDRDdTLEtBQUssQ0FBQyxVQUFBaUcsR0FBRyxFQUFJO1lBQ1osTUFBSSxDQUFDNmIsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ21CLHFCQUFxQixFQUFFOWUsU0FBUyxFQUFFO2NBQ3RGaUIsS0FBSyxFQUFHbUksR0FBRyxDQUFDakssT0FBTyxHQUFHaUssR0FBRyxDQUFDakssT0FBTyxHQUFHaUssR0FBSTtjQUN4Q3lGLE9BQU8sRUFBRSxNQUFJLENBQUNtSDtZQUNoQixDQUFDLENBQUMsQ0FBQztVQUNMLENBQUMsQ0FBQztRQUNOLENBQUMsTUFBTTtVQUNMLE1BQUksQ0FBQ2lQLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUNtQixxQkFBcUIsRUFBRTllLFNBQVMsRUFBRTtZQUN0RmlCLEtBQUssRUFBR3VFLENBQUMsQ0FBQ3JHLE9BQU8sR0FBR3FHLENBQUMsQ0FBQ3JHLE9BQU8sR0FBR3FHLENBQUU7WUFDbENxSixPQUFPLEVBQUUsTUFBSSxDQUFDbUg7VUFDaEIsQ0FBQyxDQUFDLENBQUM7UUFDTDtNQUNGLENBQUMsQ0FBQztJQUNOO0VBQUM7SUFBQTtJQUFBLE9BRUQsZ0JBQVE7TUFDTmpWLFNBQUssQ0FBQ3NoQiwrQkFBSSxFQUFFLDRCQUE0QixDQUFDO01BQ3pDLElBQU05TCxRQUFRLEdBQUcsSUFBSTNVLGVBQWUsRUFBRTtNQUN0QyxJQUFJO1FBQ0YsSUFBSStLLFlBQVksR0FBRyxJQUFJLENBQUNxSixLQUFLLENBQUNwSixJQUFJLEVBQUU7UUFDcEMsSUFBSUQsWUFBWSxFQUFFO1VBQ2hCQSxZQUFZLENBQ1QxSixJQUFJLENBQUMsWUFBTTtZQUNWbEMsU0FBSyxDQUFDc2hCLCtCQUFJLEVBQUUsb0NBQW9DLENBQUM7WUFDakQ5TCxRQUFRLENBQUNuVixPQUFPLEVBQUU7VUFDcEIsQ0FBQyxDQUFDLENBQ0QrQixLQUFLLENBQUNvVCxRQUFRLENBQUNsVixNQUFNLENBQUM7UUFDM0IsQ0FBQyxNQUFNO1VBQ0xOLFNBQUssQ0FBQ3NoQiwrQkFBSSxFQUFFLG9DQUFvQyxDQUFDO1VBQ2pEOUwsUUFBUSxDQUFDblYsT0FBTyxFQUFFO1FBQ3BCO01BQ0YsQ0FBQyxDQUFDLE9BQU9vRSxDQUFDLEVBQUU7UUFDVnZFLFNBQUssQ0FBQ29oQiwrQkFBSSxFQUFFLHVDQUF1QyxHQUFHN2MsQ0FBQyxDQUFDckcsT0FBTyxDQUFDO1FBQ2hFb1gsUUFBUSxDQUFDbFYsTUFBTSxDQUFDbUUsQ0FBQyxDQUFDO01BQ3BCO01BQ0EsT0FBTytRLFFBQVEsQ0FBQ2pWLE9BQU87SUFDekI7RUFBQztJQUFBO0lBQUEsT0FFRCxpQkFBUztNQUNQUCxTQUFLLENBQUNzaEIsK0JBQUksRUFBRSw2QkFBNkIsQ0FBQztNQUMxQyxJQUFJO1FBQ0YsSUFBSSxDQUFDck0sS0FBSyxDQUFDbEosS0FBSyxFQUFFO01BQ3BCLENBQUMsQ0FDRCxPQUFPdEgsQ0FBQyxFQUFFO1FBQ1J6RSxTQUFLLENBQUNzaEIsK0JBQUksRUFBRSx3Q0FBd0MsR0FBRzdjLENBQUMsQ0FBQ3JHLE9BQU8sQ0FBQztNQUNuRTtJQUNGO0VBQUM7SUFBQTtJQUFBLE9BRUQsa0JBQVU7TUFDUjRCLFNBQUssQ0FBQ3NoQiwrQkFBSSxFQUFFLDhCQUE4QixDQUFDO01BQzNDLElBQUk7UUFDRixJQUFJMVYsWUFBWSxHQUFHLElBQUksQ0FBQ3FKLEtBQUssQ0FBQ3BKLElBQUksRUFBRTtRQUNwQyxJQUFJRCxZQUFZLEVBQUU7VUFDaEJBLFlBQVksQ0FBQzFKLElBQUksQ0FBQztZQUFBLE9BQU1sQyxTQUFLLENBQUNzaEIsK0JBQUksRUFBRSxvQ0FBb0MsQ0FBQztVQUFBLEVBQUMsQ0FDN0RsZixLQUFLLENBQUMsVUFBQ2lHLEdBQUc7WUFBQSxPQUFLbkksU0FBSyxDQUFDb2hCLCtCQUFJLEVBQUUscUNBQXFDLElBQUlqWixHQUFHLENBQUNqSyxPQUFPLEdBQUdpSyxHQUFHLENBQUNqSyxPQUFPLEdBQUdpSyxHQUFHLENBQUMsQ0FBQztVQUFBLEVBQUM7UUFDckg7TUFDRixDQUFDLENBQ0QsT0FBTzVELENBQUMsRUFBRTtRQUNSdkUsU0FBSyxDQUFDb2hCLCtCQUFJLEVBQUUseUNBQXlDLEdBQUc3YyxDQUFDLENBQUNyRyxPQUFPLENBQUM7TUFDcEU7SUFDRjtFQUFDO0lBQUE7SUFBQSxPQUVELGdCQUFRO01BQ04sSUFBSTtRQUNGLElBQUksQ0FBQzZXLEtBQUssQ0FBQ3VYLElBQUksRUFBRTtNQUNuQixDQUFDLENBQ0QsT0FBTy9uQixDQUFDLEVBQUU7UUFDUjtNQUFBO0lBRUo7RUFBQztJQUFBO0lBQUEsT0FFRCxnQkFBUTtNQUNOLElBQUksQ0FBQ3dRLEtBQUssQ0FBQzJULEtBQUssR0FBRyxJQUFJO01BQ3ZCLElBQU0wQixRQUFRLEdBQUcsSUFBSSxDQUFDQyxXQUFXLEVBQUU7TUFDbkMsSUFBSUQsUUFBUSxFQUFFO1FBQ1pBLFFBQVEsQ0FBQ3pDLGFBQWEsQ0FBQyxJQUFJLENBQUM7TUFDOUI7SUFDRjtFQUFDO0lBQUE7SUFBQSxPQUVELGtCQUFVO01BQ1IsSUFBSSxDQUFDNVMsS0FBSyxDQUFDMlQsS0FBSyxHQUFHLEtBQUs7TUFDeEIsSUFBTTBCLFFBQVEsR0FBRyxJQUFJLENBQUNDLFdBQVcsRUFBRTtNQUNuQyxJQUFJRCxRQUFRLEVBQUU7UUFDWkEsUUFBUSxDQUFDekMsYUFBYSxDQUFDLEtBQUssQ0FBQztNQUMvQjtJQUNGO0VBQUM7SUFBQTtJQUFBLE9BRUQsbUJBQVdybEIsS0FBSyxFQUFFO01BQ2hCLElBQUksQ0FBQ29sQixNQUFNLEVBQUU7TUFDYixJQUFJLENBQUMzUyxLQUFLLENBQUMwVixNQUFNLEdBQUdub0IsS0FBSztJQUMzQjtFQUFDO0lBQUE7SUFBQSxPQUVELGdCQUFROGhCLFVBQVUsRUFBd0I7TUFBQSxJQUF0QmUsUUFBUSx1RUFBR3BtQixTQUFTO01BQ3RDLElBQUksQ0FBQ2dXLEtBQUssQ0FBQ2dXLFdBQVcsR0FBRzVGLFFBQVEsR0FBR2YsVUFBVSxHQUFHZSxRQUFRLEdBQUdmLFVBQVU7SUFDeEU7RUFBQztJQUFBO0lBQUEsT0FFRCw0QkFBb0I7TUFDbEIsSUFBSTtRQUNGMVUsT0FBVyxDQUFDL0IsZ0JBQWdCLENBQUMsSUFBSSxDQUFDNGIsTUFBTSxDQUFDO01BQzNDLENBQUMsQ0FDRCxPQUFPaGxCLENBQUMsRUFBRTtRQUNSLE1BQU1BLENBQUM7UUFDUDtNQUNGO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7RUFIRTtJQUFBO0lBQUEsT0FJQSxxQkFBYTtNQUNYLElBQUk7UUFDRixJQUFJLENBQUMrbkIsSUFBSSxFQUFFO1FBQ1gsSUFBSSxDQUFDdlgsS0FBSyxDQUFDOFYsT0FBTyxDQUFDbmQsSUFBSSxDQUFDLElBQUksQ0FBQ3FILEtBQUssQ0FBQztNQUNyQyxDQUFDLENBQ0QsT0FBT3hRLENBQUMsRUFBRTtRQUNSO01BQUE7SUFFSjs7SUFFQTtBQUNGO0FBQ0E7RUFGRTtJQUFBO0lBQUEsT0FHQSxzQkFBYztNQUNaLElBQUksQ0FBQ2dvQixRQUFRLEVBQUU7SUFDakI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLGtDQUEwQjNuQixXQUFXLEVBQUU7TUFDckMsSUFBSSxJQUFJLENBQUMra0IsU0FBUyxJQUFLL2tCLFdBQVcsR0FBRyxHQUFHLEtBQUssQ0FBRSxFQUFFO1FBQy9DLElBQUksQ0FBQzJrQixNQUFNLENBQUNqYixTQUFTLENBQUNnVyxHQUFHLENBQUMsMEJBQTBCLENBQUM7UUFDckQsSUFBSSxDQUFDdlAsS0FBSyxDQUFDekcsU0FBUyxDQUFDaVcsTUFBTSxDQUFDLDBCQUEwQixDQUFDO01BQ3pEO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0lBQ0U7RUFBQTtJQUFBO0lBQUEsT0FDQSx3Q0FBZ0N2WCxPQUFPLEVBQUUsQ0FBQzs7SUFFMUM7RUFBQTtJQUFBO0lBQUEsT0FDQSwyQ0FBbUNBLE9BQU8sRUFBRSxDQUFDOztJQUU3QztFQUFBO0lBQUE7SUFBQSxPQUNBLDRCQUFvQnRQLElBQUksRUFBRTh1QixRQUFRLEVBQUV0dUIsT0FBTyxFQUFFLENBQUM7O0lBRTlDO0VBQUE7SUFBQTtJQUFBLE9BQ0Esb0NBQTRCUixJQUFJLEVBQUUwRSxHQUFHLEVBQUVFLEtBQUssRUFBRSxDQUFDOztJQUUvQztFQUFBO0lBQUE7SUFBQSxPQUNBLCtCQUF1QitkLGdCQUFnQixFQUFFLENBQUM7O0lBRTFDO0VBQUE7SUFBQTtJQUFBLE9BQ0EsK0JBQXVCQSxnQkFBZ0IsRUFBRSxDQUFDOztJQUUxQztFQUFBO0lBQUE7SUFBQSxPQUNBLDJCQUFtQkEsZ0JBQWdCLEVBQUUsQ0FBQzs7SUFFdEM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLHVCQUFlO01BQ2IsT0FBTyxJQUFJLENBQUNzSixTQUFTO0lBQ3ZCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxtQkFBVztNQUNULE9BQU8sSUFBSSxDQUFDRixVQUFVO0lBQ3hCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsS0FLQSxlQUFhO01BQ1gsT0FBTyxJQUFJLENBQUNDLE1BQU07SUFDcEI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQSxPQUpFO0lBQUEsS0FLQSxhQUFXcG5CLEtBQUssRUFBRTtNQUNoQixJQUFJLENBQUNvbkIsTUFBTSxHQUFHcG5CLEtBQUs7TUFDbkIsSUFBSSxJQUFJLENBQUNxbkIsU0FBUyxFQUFFO1FBQ2xCLElBQUksQ0FBQ0EsU0FBUyxDQUFDd0MsUUFBUSxDQUFDN3BCLEtBQUssQ0FBQztNQUNoQztJQUNGO0VBQUM7RUFBQTtBQUFBLEVBaGtCNEIwbUIsa0JBQWtCO0FBb2tCbEN1ZiwwR0FBZ0IsRTs7QUN6bEJuQjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUU0QjtBQUNTO0FBQ0M7QUFDUztBQUNoQjtBQUNVO0FBQ1g7QUFDSztBQUNDO0FBQ0M7QUFDSztBQUNYO0FBQytDO0FBRTFGLElBQU1ubkIsZ0JBQUksR0FBRyxlQUFlOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQU1xYixrQ0FBc0IsR0FBRyxTQUF6QkEsc0JBQXNCLEdBQVM7RUFDbkMsSUFBTTF4QixFQUFFLEdBQUdtSCxJQUFJLENBQUNzVyxLQUFLLENBQUN0VyxJQUFJLENBQUMyZSxNQUFNLEVBQUUsR0FBRyxPQUFPLENBQUMsQ0FBQ2xpQixRQUFRLENBQUMsRUFBRSxDQUFDO0VBQzNELDRCQUFxQjVELEVBQUU7QUFDekIsQ0FBQzs7QUFFRDtBQUNBLElBQU0yeEIsMEJBQWMsR0FBRztFQUNyQjVDLFFBQVEsRUFBRSxPQUFPO0VBQ2pCUCxJQUFJLEVBQUUsR0FBRztFQUNUWSxHQUFHLEVBQUUsTUFBTTtFQUNYNE8sUUFBUSxFQUFFLHVCQUF1QjtFQUNqQ25NLGNBQWMsRUFBRSxvQkFBb0I7RUFDcENELHFCQUFxQixFQUFFLElBQUk7RUFDM0JLLHlCQUF5QixFQUFFLElBQUk7RUFDL0J5QixjQUFjLEVBQUVoQyxrQ0FBc0I7QUFDeEMsQ0FBQztBQUVELElBQU11TSxRQUFRLEdBQUcsb0JBQW9COztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQSxJQU1NQyx5QkFBYTtFQUFBO0VBQUE7RUFFakIseUJBQWU7SUFBQTtJQUFBO0lBQ2I7SUFDQSxNQUFLekwsUUFBUSxHQUFHeitCLFNBQVM7SUFDekIsTUFBS3crQixLQUFLLEdBQUd4K0IsU0FBUztJQUN0QixNQUFLOCtCLGNBQWMsR0FBRzkrQixTQUFTO0lBQy9CLE1BQUsyK0IsYUFBYSxHQUFHMytCLFNBQVM7SUFDOUIsTUFBS2cvQixhQUFhLEdBQUcsSUFBSXA5QixlQUFlLEVBQUU7SUFDMUMsTUFBS3M5QixxQkFBcUIsR0FBRyxJQUFJdDlCLGVBQWUsRUFBRTtJQUNsRCxNQUFLNDlCLDRCQUE0QixHQUFHLE1BQUsySyxzQkFBc0IsQ0FBQy9tQixJQUFJLENBQUMseUNBQUs7SUFBQTtFQUM1RTtFQUFDO0lBQUE7SUFBQSxPQUVELG1DQUEyQjtNQUN6QixPQUFPLElBQUksQ0FBQzRiLGFBQWEsQ0FBQzE5QixPQUFPO0lBQ25DO0VBQUM7SUFBQTtJQUFBLE9BRUQsMkNBQWtDO01BQ2hDLE9BQU8sSUFBSSxDQUFDNDlCLHFCQUFxQixDQUFDNTlCLE9BQU87SUFDM0M7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLGdDQUF3QndDLEtBQUssRUFBRTtNQUM3QixJQUFJQSxLQUFLLENBQUMxRCxJQUFJLEtBQUt1ZCxvQkFBb0IsQ0FBQ0MsZUFBZSxFQUFFO1FBQ3ZELElBQUksQ0FBQ3NoQixxQkFBcUIsQ0FBQzk5QixPQUFPLENBQUMsSUFBSSxDQUFDO01BQzFDO01BQ0EsSUFBSSxDQUFDNmpCLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDcGQsS0FBSyxDQUFDMUQsSUFBSSxFQUFFLElBQUksRUFBRTBELEtBQUssQ0FBQ2EsSUFBSSxDQUFDLENBQUM7SUFDakU7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLCtCQUF1QnNKLE9BQU8sRUFBRTtNQUFBO01BQzlCLElBQUksQ0FBQ3JCLElBQUksR0FBR3FCLE9BQU8sQ0FBQ3JCLElBQUksQ0FBQ3dXLElBQUksQ0FBQ25WLE9BQU8sQ0FBQztNQUN0QyxJQUFJLENBQUNuQixLQUFLLEdBQUdtQixPQUFPLENBQUNuQixLQUFLLENBQUNzVyxJQUFJLENBQUNuVixPQUFPLENBQUM7TUFDeEMsSUFBSSxDQUFDc2EsTUFBTSxHQUFHdGEsT0FBTyxDQUFDc2EsTUFBTSxDQUFDbkYsSUFBSSxDQUFDblYsT0FBTyxDQUFDO01BQzFDLElBQUksQ0FBQ3NmLElBQUksR0FBR3RmLE9BQU8sQ0FBQ3NmLElBQUksQ0FBQ25LLElBQUksQ0FBQ25WLE9BQU8sQ0FBQztNQUN0QyxJQUFJLENBQUM0YSxJQUFJLEdBQUc1YSxPQUFPLENBQUM0YSxJQUFJLENBQUN6RixJQUFJLENBQUNuVixPQUFPLENBQUM7TUFDdEMsSUFBSSxDQUFDMGEsTUFBTSxHQUFHMWEsT0FBTyxDQUFDMGEsTUFBTSxDQUFDdkYsSUFBSSxDQUFDblYsT0FBTyxDQUFDO01BQzFDLElBQUksQ0FBQ2diLFNBQVMsR0FBR2hiLE9BQU8sQ0FBQ2diLFNBQVMsQ0FBQzdGLElBQUksQ0FBQ25WLE9BQU8sQ0FBQztNQUNoRCxJQUFJLENBQUNpYixNQUFNLEdBQUdqYixPQUFPLENBQUNpYixNQUFNLENBQUM5RixJQUFJLENBQUNuVixPQUFPLENBQUM7TUFDMUMsSUFBSSxDQUFDVyxnQkFBZ0IsR0FBR1gsT0FBTyxDQUFDVyxnQkFBZ0IsQ0FBQ3dVLElBQUksQ0FBQ25WLE9BQU8sQ0FBQztNQUM5REEsT0FBTyxDQUFDOGEsRUFBRSxDQUFDLEdBQUcsRUFBRSxVQUFDamxCLEtBQUssRUFBSztRQUN6QixNQUFJLENBQUNtaEIsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUNwZCxLQUFLLENBQUMxRCxJQUFJLEVBQUUsTUFBSSxFQUFFMEQsS0FBSyxDQUFDYSxJQUFJLENBQUMsQ0FBQztNQUNqRSxDQUFDLENBQUM7SUFDSjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFMRTtJQUFBO0lBQUEsT0FNQSw0QkFBb0IyNkIsV0FBVyxFQUE4QjtNQUFBLElBQTVCekIsY0FBYyx1RUFBRzc5QixTQUFTO01BQ3ZELElBQUksT0FBT3MvQixXQUFXLEtBQUssV0FBVyxJQUFJekIsY0FBYyxLQUFLNzlCLFNBQVMsRUFBRTtRQUN0RSxJQUFJOG5CLElBQUksR0FBRyxJQUFJb1MsUUFBWSxDQUFDMkQsY0FBYyxDQUFDO1FBQzNDL1YsSUFBSSxDQUFDeVgsZ0JBQWdCLENBQUMsSUFBSSxDQUFDO01BQzdCO0lBQ0o7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFURTtJQUFBO0lBQUEsT0FVQSxzQkFBYzc4QixPQUFPLEVBQUU7TUFBQTtNQUNyQixxQkFHSSxJQUFJLENBQUMrN0IsUUFBUTtRQUZmL0osVUFBVSxrQkFBVkEsVUFBVTtRQUNWc1YsUUFBUSxrQkFBUkEsUUFBUTtNQUVWLElBQUk3OUIsR0FBRyxHQUFHdW9CLFVBQVUsQ0FBQ2p2QixLQUFLLENBQUN3a0MsUUFBUSxDQUFDLEdBQUd2VixVQUFVLEdBQUdtSCxlQUFlLENBQUMsSUFBSSxDQUFDNEMsUUFBUSxDQUFDO01BQ2xGLElBQUksQ0FBQ0ssY0FBYyxDQUFDL1YsRUFBRSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUN5Vyw0QkFBNEIsQ0FBQztNQUM5RCxJQUFJLENBQUNWLGNBQWMsQ0FBQ1csU0FBUyxDQUFDdHpCLEdBQUcsRUFBRTY5QixRQUFRLEVBQUV0bkMsT0FBTyxDQUFDLENBQ2xETyxJQUFJLENBQUMsWUFBTTtRQUNWLE1BQUksQ0FBQ2dpQixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDdEMsZUFBZSxDQUFDLENBQUM7UUFDdkUsTUFBSSxDQUFDK3VCLHdCQUF3QixDQUFDLE1BQUksQ0FBQ3RMLGNBQWMsQ0FBQztNQUNwRCxDQUFDLENBQUMsQ0FDRDM3QixLQUFLLENBQUMsVUFBQWlHLEdBQUcsRUFBSTtRQUNabkksU0FBSyxDQUFDb2hCLGdCQUFJLEVBQUUseUNBQXlDLEdBQUdqWixHQUFHLENBQUM7UUFDNUQsTUFBSSxDQUFDNmIsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ3JDLGVBQWUsQ0FBQyxDQUFDO01BQ3pFLENBQUMsQ0FBQztJQUNOOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0Esa0NBQTBCOFAsUUFBUSxFQUFFO01BQUE7TUFDbENBLFFBQVEsQ0FBQ3JDLEVBQUUsQ0FBQ3BMLG9CQUFvQixDQUFDWSxxQkFBcUIsRUFBRSxVQUFBemEsS0FBSyxFQUFJO1FBQy9ELGtCQUtJQSxLQUFLLENBSlBhLElBQUk7VUFDRnFCLGFBQWEsZUFBYkEsYUFBYTtVQUNibTlCLHFCQUFxQixlQUFyQkEscUJBQXFCO1FBR3pCLElBQUluOUIsYUFBYSxLQUFLLE9BQU8sSUFBSW05QixxQkFBcUIsS0FBSyxPQUFPLEVBQUU7VUFDbEUsTUFBSSxDQUFDckUsY0FBYyxDQUFDOEIsVUFBVSxFQUFFO1VBQ2hDLHNCQUdJLE1BQUksQ0FBQ25DLFFBQVE7WUFGZi9KLFVBQVUsbUJBQVZBLFVBQVU7WUFDVnNWLFFBQVEsbUJBQVJBLFFBQVE7VUFFVixJQUFNNzlCLEdBQUcsR0FBR3VvQixVQUFVLENBQUNqdkIsS0FBSyxDQUFDd2tDLFFBQVEsQ0FBQyxHQUFHdlYsVUFBVSxHQUFHbUgsZUFBZSxDQUFDLE1BQUksQ0FBQzRDLFFBQVEsQ0FBQztVQUNwRixNQUFJLENBQUNLLGNBQWMsQ0FBQ1csU0FBUyxDQUFDdHpCLEdBQUcsRUFBRTY5QixRQUFRLEVBQUUsTUFBSSxDQUFDdkwsUUFBUSxDQUFDLENBQ3hEeDdCLElBQUksQ0FBQyxZQUFNO1lBQ1YsT0FBTyxNQUFJLENBQUM4OUIsU0FBUyxFQUFFO1VBQ3pCLENBQUMsQ0FBQyxDQUNENTlCLEtBQUssQ0FBQyxVQUFBbEMsS0FBSztZQUFBLE9BQUlBLEtBQUssQ0FBQ29oQixnQkFBSSxFQUFFcGhCLEtBQUssQ0FBQztVQUFBLEVBQUM7UUFDdkM7TUFDRixDQUFDLENBQUM7SUFDSjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEsY0FBTXlCLE9BQU8sRUFBRTtNQUFBO01BQ2IsSUFBTTZULFFBQVEsR0FBRyxJQUFJM1UsZUFBZSxFQUFFO01BQ3RDLElBQUksQ0FBQytPLE9BQVcsQ0FBQ3pGLFdBQVcsRUFBRSxFQUFFO1FBQzlCbEssUUFBSSxDQUFDcWhCLGdCQUFJLDhDQUE4QztRQUN2RDlMLFFBQVEsQ0FBQ2xWLE1BQU0sNkNBQTZDO01BQzlELENBQUMsTUFBTSxJQUFJcUIsT0FBTyxDQUFDNjRCLGdCQUFnQixJQUFJLENBQUNoSCxxQkFBcUIsRUFBRSxFQUFFO1FBQy9EO1FBQ0E7UUFDQTtRQUNBdnpCLFFBQUksQ0FBQ3FoQixnQkFBSSxvR0FBb0c7UUFDN0c5TCxRQUFRLENBQUNsVixNQUFNLENBQUNnaEIsZ0JBQUksb0dBQW9HO01BQzFILENBQUMsTUFBTTtRQUNMLElBQUksQ0FBQ29jLFFBQVEsR0FBR25xQixNQUFNLENBQUNtbkIsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFa0MsMEJBQWMsRUFBRWo3QixPQUFPLENBQUM7UUFDMUQsSUFBTXUrQixhQUFhLEdBQUcsSUFBSXIvQixlQUFlLEVBQUU7UUFDM0MsSUFBSSxJQUFJLENBQUM2OEIsUUFBUSxDQUFDbEQsZ0JBQWdCLEVBQUU7VUFDbEMsSUFBSTtZQUNGLElBQUksQ0FBQ29ELGFBQWEsR0FBRyxJQUFJbE0sYUFBWSxDQUFDLElBQUksRUFBRSx1QkFBdUIsQ0FBQztZQUNwRSxJQUFNeU8sU0FBUyxHQUFHQyw0QkFBbUIsQ0FBQyxJQUFJLENBQUMxQyxRQUFRLEVBQUU7Y0FDbkR6eUIsRUFBRSxFQUFFLElBQUksQ0FBQ3l5QixRQUFRLENBQUNpQjtZQUNwQixDQUFDLENBQUM7WUFDRixJQUFJLENBQUNmLGFBQWEsQ0FBQ2xLLEtBQUssQ0FBQ3lNLFNBQVMsRUFBRUQsYUFBYSxDQUFDO1VBQ3BELENBQUMsQ0FBQyxPQUFPejdCLENBQUMsRUFBRTtZQUNWdkUsU0FBSyxDQUFDb2hCLGdCQUFJLEVBQUU3YyxDQUFDLENBQUNyRyxPQUFPLENBQUM7WUFDdEJvWCxRQUFRLENBQUNsVixNQUFNLENBQUNnaEIsZ0JBQUksaUZBQTBFN2MsQ0FBQyxDQUFDckcsT0FBTyxFQUFHO1VBQzVHO1FBQ0YsQ0FBQyxNQUFNO1VBQ0w4aEMsYUFBYSxDQUFDNy9CLE9BQU8sRUFBRTtRQUN6QjtRQUNBNi9CLGFBQWEsQ0FBQzMvQixPQUFPLENBQ2xCMkIsSUFBSSxDQUFDLFlBQU07VUFDVjtVQUNBO1VBQ0EsSUFBSSxNQUFJLENBQUMwN0IsYUFBYSxFQUFFO1lBQ3RCLE1BQUksQ0FBQ0EsYUFBYSxDQUFDckwsUUFBUSxFQUFFO1lBQzdCLE1BQUksQ0FBQ3FMLGFBQWEsR0FBRzMrQixTQUFTO1VBQ2hDO1VBQ0EsTUFBSSxDQUFDMmhDLGtCQUFrQixDQUFDLE1BQUksQ0FBQ25ELEtBQUssRUFBRSxNQUFJLENBQUNDLFFBQVEsQ0FBQ1osY0FBYyxDQUFDO1VBQ2pFLE1BQUksQ0FBQ3dELHVCQUF1QixFQUFFLENBQzNCcCtCLElBQUksQ0FBQyxVQUFBNmtCLElBQUksRUFBSTtZQUNaLE1BQUksQ0FBQ2dYLGNBQWMsR0FBRyxJQUFJMEssMEJBQWdCLENBQUMxaEIsSUFBSSxDQUFDQSxJQUFJLEVBQUUsTUFBSSxDQUFDd1osT0FBTyxFQUFFLENBQUM7WUFDckUsTUFBSSxDQUFDQyxxQkFBcUIsQ0FBQyxNQUFJLENBQUN6QyxjQUFjLENBQUM7WUFDL0MsSUFBSSxNQUFJLENBQUNMLFFBQVEsRUFBRTtjQUNqQixNQUFJLENBQUMrQyxZQUFZLENBQUMsTUFBSSxDQUFDL0MsUUFBUSxDQUFDO1lBQ2xDO1VBQ0YsQ0FBQyxDQUFDO1VBQ0psb0IsUUFBUSxDQUFDblYsT0FBTyxDQUFDLE1BQUksQ0FBQztRQUN4QixDQUFDLENBQUMsQ0FDRCtCLEtBQUssQ0FBQyxVQUFBbEMsS0FBSyxFQUFJO1VBQ2RzVixRQUFRLENBQUNsVixNQUFNLENBQUNKLEtBQUssQ0FBQztVQUN0QixNQUFJLENBQUNna0IsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUN2RCxvQkFBb0IsQ0FBQ3JDLGVBQWUsRUFBRSxNQUFJLEVBQUVyYSxLQUFLLENBQUMsQ0FBQztRQUN0RixDQUFDLENBQUM7TUFDTjtNQUNBLE9BQU9zVixRQUFRLENBQUNqVixPQUFPO0lBQ3pCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUxFO0lBQUE7SUFBQSxPQU1BLGlCQUFTd21CLElBQUksRUFBRTtNQUNiLElBQUksQ0FBQzBXLEtBQUssR0FBRzFXLElBQUk7TUFDakIsSUFBSSxDQUFDa1gsYUFBYSxDQUFDNTlCLE9BQU8sQ0FBQzBtQixJQUFJLENBQUM7TUFDaEMsT0FBTyxJQUFJO0lBQ2I7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEscUJBQWE7TUFDWCxPQUFPLElBQUksQ0FBQytaLCtCQUErQixFQUFFO0lBQy9DOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUxFO0lBQUE7SUFBQSxPQU1BLHVCQUFlO01BQ2I5Z0MsU0FBSyxDQUFDc2hCLGdCQUFJLEVBQUUsZ0JBQWdCLENBQUM7TUFDN0IsSUFBTTlMLFFBQVEsR0FBRyxJQUFJM1UsZUFBZSxFQUFFO01BQ3RDLElBQUksSUFBSSxDQUFDKzhCLGFBQWEsRUFBRTtRQUN0QixJQUFJLENBQUNBLGFBQWEsQ0FBQ3JMLFFBQVEsRUFBRTtNQUMvQjtNQUNBLElBQUk7UUFDRixJQUFJLENBQUN3TCxjQUFjLENBQUN2UixJQUFJLEVBQUU7UUFDMUIsSUFBSSxDQUFDdVIsY0FBYyxDQUFDOEIsVUFBVSxFQUFFO1FBQ2hDcnFCLFFBQVEsQ0FBQ25WLE9BQU8sRUFBRTtNQUNwQixDQUFDLENBQUMsT0FBT29FLENBQUMsRUFBRTtRQUNWK1EsUUFBUSxDQUFDbFYsTUFBTSxDQUFDbUUsQ0FBQyxDQUFDckcsT0FBTyxDQUFDO01BQzVCO01BQ0EsT0FBT29YLFFBQVEsQ0FBQ2pWLE9BQU87SUFDekI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLHlCQUFpQjtNQUNmLE9BQU8sSUFBSSxDQUFDdzlCLGNBQWM7SUFDNUI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLHVCQUFlO01BQ2IsT0FBTyxJQUFJLENBQUNBLGNBQWMsR0FBRyxJQUFJLENBQUNBLGNBQWMsQ0FBQ3hULFdBQVcsRUFBRSxHQUFHdHJCLFNBQVM7SUFDNUU7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLHNCQUFjO01BQ1osT0FBTyxJQUFJLENBQUN5K0IsUUFBUTtJQUN0Qjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EscUJBQWE7TUFDWCxPQUFPLElBQUksQ0FBQ0QsS0FBSyxDQUFDMVcsSUFBSTtJQUN4Qjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsbUJBQVc7TUFDVCxPQUFPMlUsYUFBYSxDQUFDRyxHQUFHLENBQUMrRyxXQUFXLEVBQUU7SUFDeEM7RUFBQztFQUFBO0FBQUEsRUF0UnlCMVosa0JBQWtCO0FBMFIvQmlnQix5RUFBYSxFOzs7d0VDM1U1QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRHFDO0FBRXJDLElBQU03bkIsOEJBQUksR0FBRyx5QkFBeUI7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTWdvQixrQkFBa0IsR0FBRyxTQUFyQkEsa0JBQWtCLENBQUlDLElBQUksRUFBSztFQUNuQyxJQUFJQyxJQUFJLEdBQUdELElBQUksQ0FBQ2poQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMvSSxHQUFHLENBQUMsVUFBQ21YLENBQUM7SUFBQSxPQUFLQSxDQUFDLENBQUMreUIsSUFBSSxFQUFFO0VBQUEsRUFBQztFQUMvQyxJQUFJQyxLQUFLLEdBQUdGLElBQUksQ0FBQ2pxQyxHQUFHLENBQUMsVUFBQ21YLENBQUMsRUFBSztJQUMxQixJQUFJQSxDQUFDLENBQUNpekIsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsRUFBRTtNQUN2QixPQUFPLENBQUMsS0FBSyxFQUFFanpCLENBQUMsQ0FBQ2t6QixTQUFTLENBQUMsQ0FBQyxFQUFFbHpCLENBQUMsQ0FBQ25WLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztJQUM5QztJQUNBLE9BQU9tVixDQUFDLENBQUNwTyxLQUFLLENBQUMsR0FBRyxDQUFDO0VBQ3JCLENBQUMsQ0FBQztFQUNGLE9BQU9vaEMsS0FBSyxDQUFDRyxNQUFNLENBQUMsVUFBQ0MsR0FBRyxFQUFFQyxJQUFJO0lBQUEsT0FBS0QsR0FBRyxDQUFDM29DLEdBQUcsQ0FBQzRvQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUVBLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUFBLEdBQUUsSUFBSUMsR0FBRyxFQUFFLENBQUM7QUFDMUUsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQU1DLDZCQUE2QixHQUFHLFNBQWhDQSw2QkFBNkIsQ0FBSTcrQixHQUFHLEVBQUs7RUFDN0MsSUFBTTgrQixLQUFLLEdBQUc5K0IsR0FBRyxDQUFDOUMsS0FBSyxDQUFDLEdBQUcsQ0FBQztFQUM1QixJQUFJNGhDLEtBQUssQ0FBQzNvQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO0lBQ3BCLE9BQU87TUFBRXk0QixRQUFRLEVBQUVrUSxLQUFLLENBQUMsQ0FBQyxDQUFDO01BQUUzUCxJQUFJLEVBQUUyUCxLQUFLLENBQUMsQ0FBQztJQUFFLENBQUM7RUFDL0M7RUFDQSxPQUFPO0lBQUVsUSxRQUFRLEVBQUUvNkIsU0FBUztJQUFFczdCLElBQUksRUFBRW52QjtFQUFJLENBQUM7QUFDM0MsQ0FBQztBQUFBLElBRUsrK0IsaURBQXVCO0VBQzNCLGlDQUFZLytCLEdBQUcsRUFBRTtJQUFBO0lBQ2YsSUFBSSxDQUFDZy9CLElBQUksR0FBR2gvQixHQUFHO0lBQ2Y7SUFDQSxJQUFJLENBQUNpL0IsU0FBUyxHQUFHcHJDLFNBQVM7RUFDNUI7RUFBQztJQUFBO0lBQUE7TUFBQSxzR0FFRDtRQUFBO1FBQUE7VUFBQTtZQUFBO2NBQ0VlLFNBQUssQ0FBQ3NoQiw4QkFBSSwrQkFBd0IsSUFBSSxDQUFDOG9CLElBQUksRUFBRztjQUFBO2NBQUE7Y0FBQSxPQUVyQkUsS0FBSyxDQUFDLElBQUksQ0FBQ0YsSUFBSSxFQUFFO2dCQUN0QzdZLE1BQU0sRUFBRSxTQUFTO2dCQUNqQjdyQixJQUFJLEVBQUU7Y0FDUixDQUFDLENBQUM7WUFBQTtjQUhJNmtDLFFBQVE7Y0FJTnJWLE1BQU0sR0FBY3FWLFFBQVEsQ0FBNUJyVixNQUFNLEVBQUVzVixPQUFPLEdBQUtELFFBQVEsQ0FBcEJDLE9BQU87Y0FBQSxNQUNuQnRWLE1BQU0sS0FBSyxHQUFHLElBQUlBLE1BQU0sS0FBSyxHQUFHO2dCQUFBO2dCQUFBO2NBQUE7Y0FDNUJ1VixTQUFTLEdBQUcsV0FBVztjQUN2QkMsS0FBSyxHQUFHLEVBQUU7Y0FDaEJGLE9BQU8sQ0FBQ3hrQyxPQUFPLENBQUMsVUFBQzFELEdBQUcsRUFBRUUsS0FBSyxFQUFLO2dCQUM5QixJQUFJaW9DLFNBQVMsQ0FBQzlsQyxJQUFJLENBQUNuQyxLQUFLLENBQUMsRUFBRTtrQkFDekIsSUFBSUYsR0FBRyxDQUFDWSxPQUFPLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtvQkFDeEMsSUFBTXFtQyxJQUFJLEdBQUdELGtCQUFrQixDQUFDaG5DLEdBQUcsQ0FBQztvQkFDcEMsSUFBTThJLEdBQUcsR0FBR20rQixJQUFJLENBQUNub0MsR0FBRyxDQUFDLEtBQUssQ0FBQztvQkFDM0IsNEJBQTJCNm9DLDZCQUE2QixDQUFDNytCLEdBQUcsQ0FBQztzQkFBckQ0dUIsUUFBUSx5QkFBUkEsUUFBUTtzQkFBRU8sSUFBSSx5QkFBSkEsSUFBSTtvQkFDdEIsSUFBTW9RLFFBQVEsR0FBR3BCLElBQUksQ0FBQ25vQyxHQUFHLENBQUMsVUFBVSxDQUFDO29CQUNyQyxJQUFNd3BDLFFBQVEsR0FBR3JCLElBQUksQ0FBQ25vQyxHQUFHLENBQUMsWUFBWSxDQUFDO29CQUN2QyxJQUFJNDRCLFFBQVEsSUFBSU8sSUFBSSxJQUFJb1EsUUFBUSxJQUFJQyxRQUFRLEVBQUU7c0JBQzVDRixLQUFLLENBQUN2ckMsSUFBSSxXQUFJNjZCLFFBQVEsZ0JBQU0yUSxRQUFRLGNBQUlDLFFBQVEsY0FBSXJRLElBQUksRUFBRztvQkFDN0QsQ0FBQyxNQUFNLElBQUludkIsR0FBRyxFQUFFO3NCQUNkcy9CLEtBQUssQ0FBQ3ZyQyxJQUFJLENBQUNpTSxHQUFHLENBQUM7b0JBQ2pCO2tCQUNGO2dCQUNGO2NBQ0YsQ0FBQyxDQUFDO2NBQ0ZwTCxTQUFLLENBQUNzaEIsOEJBQUksOEJBQXVCb3BCLEtBQUssRUFBRztjQUFBLGlDQUNsQztnQkFBRUEsS0FBSyxFQUFFQSxLQUFLLENBQUNucEMsTUFBTSxHQUFHLENBQUMsR0FBRyxDQUFDO2tCQUFFeTdCLElBQUksRUFBRTBOLEtBQUssQ0FBQ25wQyxNQUFNLEdBQUcsQ0FBQyxHQUFHbXBDLEtBQUssR0FBR0EsS0FBSyxDQUFDLENBQUM7Z0JBQUUsQ0FBQyxDQUFDLEdBQUd6ckM7Y0FBVSxDQUFDO1lBQUE7Y0FBQTtjQUFBO1lBQUE7Y0FBQTtjQUFBO2NBR2xHaUIsU0FBSyxDQUFDb2hCLDhCQUFJLEVBQUUsWUFBRWxqQixPQUFPLENBQUM7Y0FBQTtZQUFBO1lBQUE7Y0FBQTtVQUFBO1FBQUE7TUFBQSxDQUd6QjtNQUFBO1FBQUE7TUFBQTtNQUFBO0lBQUE7SUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFMRTtJQUFBO0lBQUE7TUFBQSx3R0FNQSxrQkFBbUJvWSxHQUFHO1FBQUE7UUFBQTtVQUFBO1lBQUE7Y0FDcEJ4VyxTQUFLLENBQUNzaEIsOEJBQUksRUFBRSwwQkFBbUIsSUFBSSxDQUFDOG9CLElBQUksVUFBTzdsQyxJQUFJLENBQUM0TyxTQUFTLENBQUNxRCxHQUFHLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO2NBQUE7Y0FBQTtjQUFBLE9BRW5EOHpCLEtBQUssQ0FBQyxJQUFJLENBQUNGLElBQUksRUFBRTtnQkFDdEM3WSxNQUFNLEVBQUUsTUFBTTtnQkFDZDdyQixJQUFJLEVBQUUsTUFBTTtnQkFDWjhrQyxPQUFPLEVBQUU7a0JBQ1AsY0FBYyxFQUFFO2dCQUNsQixDQUFDO2dCQUNEcjdCLElBQUksRUFBRXFIO2NBQ1IsQ0FBQyxDQUFDO1lBQUE7Y0FQSSt6QixRQUFRO2NBUU5yVixNQUFNLEdBQWNxVixRQUFRLENBQTVCclYsTUFBTSxFQUFFc1YsT0FBTyxHQUFLRCxRQUFRLENBQXBCQyxPQUFPO2NBQUEsTUFDbkJ0VixNQUFNLElBQUksR0FBRyxJQUFJQSxNQUFNLEdBQUcsR0FBRztnQkFBQTtnQkFBQTtjQUFBO2NBQUE7Y0FBQSxPQUNUcVYsUUFBUSxDQUFDbG1DLElBQUksRUFBRTtZQUFBO2NBQWpDd21DLFNBQVM7Y0FDUEMsUUFBUSxHQUFHTixPQUFPLENBQUNwcEMsR0FBRyxDQUFDLFVBQVUsQ0FBQztjQUFBLEtBQ3BDMHBDLFFBQVE7Z0JBQUE7Z0JBQUE7Y0FBQTtjQUNWLElBQUlBLFFBQVEsQ0FBQ3BtQyxLQUFLLENBQUMsZUFBZSxDQUFDLEVBQUU7Z0JBQ25DLElBQUksQ0FBQzJsQyxTQUFTLEdBQUdTLFFBQVE7Y0FDM0IsQ0FBQyxNQUFNO2dCQUNDQyxNQUFNLEdBQUcsSUFBSXIvQixHQUFHLENBQUMsSUFBSSxDQUFDMCtCLElBQUksQ0FBQyxFQUNqQztnQkFDQSxJQUFJLENBQUNDLFNBQVMsR0FBR1UsTUFBTSxDQUFDbDhCLFFBQVEsRUFBRTtjQUNwQztjQUNBN08sU0FBSyxDQUFDc2hCLDhCQUFJLGdDQUF5QixJQUFJLENBQUMrb0IsU0FBUyxlQUFLUSxTQUFTLEVBQUc7Y0FBQSxrQ0FDM0Q7Z0JBQUVyMEIsR0FBRyxFQUFFcTBCLFNBQVM7Z0JBQUVDLFFBQVEsRUFBRSxJQUFJLENBQUNUO2NBQVUsQ0FBQztZQUFBO2NBQUEsTUFFN0MsSUFBSXRLLEtBQUssQ0FBQyxvREFBb0QsQ0FBQztZQUFBO2NBQUE7Y0FBQTtZQUFBO2NBQUEsTUFFOUQ3SyxNQUFNLEtBQUssR0FBRztnQkFBQTtnQkFBQTtjQUFBO2NBQUEsTUFFakIsSUFBSTZLLEtBQUssQ0FBQyxpRUFBaUUsQ0FBQztZQUFBO2NBQUEsTUFDekU3SyxNQUFNLEtBQUssR0FBRztnQkFBQTtnQkFBQTtjQUFBO2NBQUEsTUFFakIsSUFBSTZLLEtBQUssQ0FBQyx5REFBeUQsQ0FBQztZQUFBO2NBQUEsTUFDakU3SyxNQUFNLEtBQUssR0FBRztnQkFBQTtnQkFBQTtjQUFBO2NBQUEsTUFFakIsSUFBSTZLLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQztZQUFBO2NBQUE7Y0FBQSxPQUVSd0ssUUFBUSxDQUFDbG1DLElBQUksRUFBRTtZQUFBO2NBQXBDMm1DLFlBQVk7Y0FBQSxNQUNaakwsS0FBSyxDQUFDaUwsWUFBWSxDQUFDO1lBQUE7Y0FBQTtjQUFBO1lBQUE7Y0FBQTtjQUFBO2NBRzNCOXFDLFNBQUssQ0FBQ29oQiw4QkFBSSxFQUFFLGFBQUVsakIsT0FBTyxDQUFDO2NBQUE7WUFBQTtZQUFBO2NBQUE7VUFBQTtRQUFBO01BQUEsQ0FHekI7TUFBQTtRQUFBO01BQUE7TUFBQTtJQUFBO0VBQUE7SUFBQTtJQUFBO01BQUEsbUdBRUQsa0JBQWNvWSxHQUFHO1FBQUE7UUFBQTtVQUFBO1lBQUE7Y0FDZnhXLFNBQUssQ0FBQ3NoQiw4QkFBSSxFQUFFLDZCQUFzQixJQUFJLENBQUMrb0IsU0FBUyxVQUFPOWxDLElBQUksQ0FBQzRPLFNBQVMsQ0FBQ3FELEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7Y0FBQTtjQUFBO2NBQUEsT0FFM0Q4ekIsS0FBSyxDQUFDLElBQUksQ0FBQ0QsU0FBUyxFQUFFO2dCQUMzQzlZLE1BQU0sRUFBRSxPQUFPO2dCQUNmN3JCLElBQUksRUFBRSxNQUFNO2dCQUNaOGtDLE9BQU8sRUFBRTtrQkFDUCxjQUFjLEVBQUU7Z0JBQ2xCLENBQUM7Z0JBQ0RyN0IsSUFBSSxFQUFFcUg7Y0FDUixDQUFDLENBQUM7WUFBQTtjQVBJK3pCLFFBQVE7Y0FRTnJWLE1BQU0sR0FBY3FWLFFBQVEsQ0FBNUJyVixNQUFNLEVBQUVzVixPQUFPLEdBQUtELFFBQVEsQ0FBcEJDLE9BQU87Y0FBQSxNQUNuQnRWLE1BQU0sSUFBSSxHQUFHLElBQUlBLE1BQU0sR0FBRyxHQUFHO2dCQUFBO2dCQUFBO2NBQUE7Y0FBQTtjQUFBLE9BRVRxVixRQUFRLENBQUNsbUMsSUFBSSxFQUFFO1lBQUE7Y0FBakN3dkIsU0FBUztjQUNiN3pCLFNBQUssQ0FBQ3NoQiw4QkFBSSxnQ0FBeUIsSUFBSSxDQUFDK29CLFNBQVMsZUFBS3hXLFNBQVMsRUFBRztjQUFBLGtDQUMzRDtnQkFBRUEsU0FBUyxFQUFUQTtjQUFVLENBQUM7WUFBQTtjQUFBLE1BQ1hxQixNQUFNLEtBQUssR0FBRztnQkFBQTtnQkFBQTtjQUFBO2NBQ3ZCMTNCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLGdFQUFnRSxDQUFDO2NBQUEsTUFDdkUsSUFBSXNpQyxLQUFLLENBQUMsZ0VBQWdFLENBQUM7WUFBQTtjQUFBO2NBQUEsT0FFdER3SyxRQUFRLENBQUNsbUMsSUFBSSxFQUFFO1lBQUE7Y0FBcEMybUMsWUFBWTtjQUFBLE1BQ1pqTCxLQUFLLENBQUNpTCxZQUFZLENBQUM7WUFBQTtjQUFBO2NBQUE7WUFBQTtjQUFBO2NBQUE7Y0FHM0J4dEMsT0FBTyxDQUFDMEMsS0FBSyxjQUFHO2NBQUE7WUFBQTtZQUFBO2NBQUE7VUFBQTtRQUFBO01BQUEsQ0FHbkI7TUFBQTtRQUFBO01BQUE7TUFBQTtJQUFBO0VBQUE7SUFBQTtJQUFBO01BQUEsb0dBRUQ7UUFBQTtVQUFBO1lBQUE7Y0FBQSxJQUNPLElBQUksQ0FBQ21xQyxTQUFTO2dCQUFBO2dCQUFBO2NBQUE7Y0FBQTtZQUFBO2NBR25CcnFDLFNBQUssQ0FBQ3NoQiw4QkFBSSx3QkFBd0I7Y0FBQTtjQUFBLE9BQzVCZ3BCLEtBQUssQ0FBQyxJQUFJLENBQUNELFNBQVMsRUFBRTtnQkFDMUI5WSxNQUFNLEVBQUUsUUFBUTtnQkFDaEI3ckIsSUFBSSxFQUFFO2NBQ1IsQ0FBQyxDQUFDO1lBQUE7Y0FDRixJQUFJLENBQUMwa0MsSUFBSSxHQUFHbnJDLFNBQVM7Y0FDckIsSUFBSSxDQUFDb3JDLFNBQVMsR0FBR3ByQyxTQUFTO1lBQUE7WUFBQTtjQUFBO1VBQUE7UUFBQTtNQUFBLENBQzNCO01BQUE7UUFBQTtNQUFBO01BQUE7SUFBQTtFQUFBO0VBQUE7QUFBQTtBQUdZa3JDLCtHQUF1QixFOzs7Ozs7MkRDaEx0QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRHdDO0FBQ0c7QUFDa0I7QUFDcEI7QUFDVTtBQUNEO0FBQzBCO0FBQ2pCO0FBQzhCO0FBQ3pCO0FBQ1M7QUFFekUsSUFBTTdvQixpQkFBSSxHQUFHLFlBQVk7QUFDekIsSUFBTTJwQixrQkFBa0IsR0FBRyxJQUFJOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQU10TyxtQ0FBc0IsR0FBRyxTQUF6QkEsc0JBQXNCLEdBQVM7RUFDbkMsSUFBTTF4QixFQUFFLEdBQUdtSCxJQUFJLENBQUNzVyxLQUFLLENBQUN0VyxJQUFJLENBQUMyZSxNQUFNLEVBQUUsR0FBRyxPQUFPLENBQUMsQ0FBQ2xpQixRQUFRLENBQUMsRUFBRSxDQUFDO0VBQzNELDRCQUFxQjVELEVBQUU7QUFDekIsQ0FBQzs7QUFFRDtBQUNBLElBQU0yeEIsMkJBQWMsR0FBRztFQUNyQjVDLFFBQVEsRUFBRSxLQUFLO0VBQ2ZQLElBQUksRUFBRSxHQUFHO0VBQ1RZLEdBQUcsRUFBRSxNQUFNO0VBQ1h3QyxxQkFBcUIsRUFBRSxJQUFJO0VBQzNCQyxjQUFjLEVBQUUsb0JBQW9CO0VBQ3BDQyxnQkFBZ0IsRUFBRTtJQUNoQi9HLFVBQVUsRUFBRSxDQUFDO01BQUVnSCxJQUFJLEVBQUU7SUFBZ0MsQ0FBQyxDQUFDO0lBQ3ZENUcsb0JBQW9CLEVBQUUsQ0FBQztJQUN2QkMsWUFBWSxFQUFFO0VBQ2hCLENBQUM7RUFBRTtFQUNITCxVQUFVLEVBQUUvMkIsU0FBUztFQUFFO0VBQ3ZCZytCLFlBQVksRUFBRVYsaUJBQWlCLENBQUNDLEdBQUc7RUFDbkNVLHlCQUF5QixFQUFFLElBQUk7RUFDL0JDLG1DQUFtQyxFQUFFLEtBQUs7RUFDMUNDLG1CQUFtQixFQUFFLEtBQUs7RUFBRTtFQUM1QnZHLHdCQUF3QixFQUFFNTNCLFNBQVM7RUFDbkNvK0IsaUJBQWlCLEVBQUUsSUFBSTtFQUN2QkMsZUFBZSxFQUFFLEtBQUs7RUFDdEJDLHFCQUFxQixFQUFFLEtBQUs7RUFDNUI5TyxjQUFjLEVBQUUsS0FBSztFQUNyQnljLFVBQVUsRUFBRSxLQUFLLENBQUU7QUFDckIsQ0FBQztBQUFBLElBRUtDLHVCQUFVO0VBQUE7RUFBQTtFQUNkO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0Usb0JBQVkvL0IsR0FBRyxFQUFFMEMsT0FBTyxFQUFzQjtJQUFBO0lBQUEsSUFBcEJvOUIsVUFBVSx1RUFBRyxLQUFLO0lBQUE7SUFDMUM7SUFDQSxJQUFNRSxjQUFjLEdBQUdoZ0MsR0FBRyxHQUFHa3dCLHNCQUFzQixDQUFDbHdCLEdBQUcsQ0FBQyxHQUFHd3hCLDJCQUFjO0lBQ3pFd08sY0FBYyxDQUFDdE8sY0FBYyxHQUFHaHZCLE9BQU8sR0FBR0EsT0FBTyxDQUFDN0MsRUFBRSxHQUFHMnhCLDJCQUFjLENBQUNFLGNBQWM7SUFDcEZzTyxjQUFjLENBQUNGLFVBQVUsR0FBR0EsVUFBVTtJQUV0QyxNQUFLRyxXQUFXLEdBQUdwc0MsU0FBUztJQUU1QixJQUFJbU0sR0FBRyxFQUFFO01BQ1AsTUFBS2tnQyxnQkFBZ0IsQ0FBQ0YsY0FBYyxDQUFDO0lBQ3ZDO0lBQUM7RUFDSDs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBO01BQUEsMkdBUUEsaUJBQXVCenBDLE9BQU87UUFBQTtVQUFBO1lBQUE7Y0FBQTtjQUFBLE9BQ3RCLElBQUksQ0FBQzRwQyxJQUFJLENBQUM1cEMsT0FBTyxDQUFDO1lBQUE7Y0FBQTtjQUFBLE9BQ2xCLElBQUksQ0FBQ3ErQixTQUFTLEVBQUU7WUFBQTtZQUFBO2NBQUE7VUFBQTtRQUFBO01BQUEsQ0FDdkI7TUFBQTtRQUFBO01BQUE7TUFBQTtJQUFBO0lBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQTtNQUFBLDBHQVFBLGtCQUFzQmpLLFVBQVU7UUFBQTtRQUFBO1VBQUE7WUFBQTtjQUM5QkEsVUFBVSxDQUFDeVYsY0FBYyxDQUFDLE9BQU8sRUFBRTtnQkFBRUMsU0FBUyxFQUFFO2NBQVcsQ0FBQyxDQUFDO2NBQzdEMVYsVUFBVSxDQUFDeVYsY0FBYyxDQUFDLE9BQU8sRUFBRTtnQkFBRUMsU0FBUyxFQUFFO2NBQVcsQ0FBQyxDQUFDO2NBQUE7Y0FBQSxPQUV6QzFWLFVBQVUsQ0FBQzJWLFdBQVcsRUFBRTtZQUFBO2NBQXRDek0sS0FBSztjQUNYbEosVUFBVSxDQUFDb0IsbUJBQW1CLENBQUM4SCxLQUFLLENBQUM7Y0FBQSxrQ0FDOUIsSUFBSXorQixPQUFPLENBQUMsVUFBQ0gsT0FBTyxFQUFFQyxNQUFNLEVBQUs7Z0JBQ3RDLElBQUl5MUIsVUFBVSxDQUFDMkMsaUJBQWlCLEtBQUssVUFBVSxFQUFFO2tCQUMvQ3I0QixPQUFPLENBQUM7b0JBQUU0K0IsS0FBSyxFQUFMQSxLQUFLO29CQUFFME0sS0FBSyxFQUFFNVYsVUFBVSxDQUFDNlY7a0JBQWlCLENBQUMsQ0FBQztnQkFDeEQsQ0FBQyxNQUFNO2tCQUNMaGpDLFVBQVUsQ0FBQyxZQUFZO29CQUNyQnZJLE9BQU8sQ0FBQztzQkFBRTQrQixLQUFLLEVBQUxBLEtBQUs7c0JBQUUwTSxLQUFLLEVBQUU1VixVQUFVLENBQUM2VjtvQkFBaUIsQ0FBQyxDQUFDO2tCQUN4RCxDQUFDLEVBQUVYLGtCQUFrQixDQUFDO2tCQUN0QmxWLFVBQVUsQ0FBQzBDLHlCQUF5QixHQUFHLFlBQU07b0JBQzNDMUMsVUFBVSxDQUFDMkMsaUJBQWlCLEtBQUssVUFBVSxJQUFJcjRCLE9BQU8sQ0FBQztzQkFBRTQrQixLQUFLLEVBQUxBLEtBQUs7c0JBQUUwTSxLQUFLLEVBQUU1VixVQUFVLENBQUM2VjtvQkFBaUIsQ0FBQyxDQUFDO2tCQUN2RyxDQUFDO2dCQUNIO2NBQ0YsQ0FBQyxDQUFDO1lBQUE7WUFBQTtjQUFBO1VBQUE7UUFBQTtNQUFBLENBQ0g7TUFBQTtRQUFBO01BQUE7TUFBQTtJQUFBO0lBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLHdCQUFlL1gsU0FBUyxFQUFFO01BQ3hCN3pCLFNBQUssQ0FBQ3NoQixpQkFBSSxFQUFFLGlCQUFpQixDQUFDO01BQzlCLElBQUksQ0FBQzRDLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDL0IsdUJBQXVCLENBQUNHLGVBQWUsRUFBRSxJQUFJLEVBQUVzVixTQUFTLENBQUMsQ0FBQztJQUM3Rjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFSRTtJQUFBO0lBQUE7TUFBQSxxR0FTQSxrQkFBaUJxRCxrQkFBa0I7UUFBQTtVQUFBO1lBQUE7Y0FBQTtjQUFBO2NBQUEsT0FFbEIsSUFBSSxDQUFDbVUsV0FBVyxDQUFDUSxZQUFZLENBQUMzVSxrQkFBa0IsQ0FBQzFnQixHQUFHLENBQUM7WUFBQTtjQUFBO1lBQUE7Y0FBQTtjQUFBO2NBRWxFdFcsU0FBSyxDQUFDb2hCLGlCQUFJLEVBQUUsYUFBRWxqQixPQUFPLGdCQUFLLENBQUM7Y0FDM0IsSUFBSSxDQUFDaTJCLG1CQUFtQixjQUFHO2NBQUE7WUFBQTtZQUFBO2NBQUE7VUFBQTtRQUFBO01BQUEsQ0FHOUI7TUFBQTtRQUFBO01BQUE7TUFBQTtJQUFBO0lBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORTtJQUFBO0lBQUE7TUFBQSxrSEFPQSxrQkFBOEI3ZCxHQUFHO1FBQUE7UUFBQTtRQUFBO1VBQUE7WUFBQTtjQUN6QnMxQixRQUFRLEdBQUd2Vix3QkFBK0IsQ0FBQy9mLEdBQUcsRUFBRSxNQUFNLENBQUM7Y0FDdkR1MUIsU0FBUyxHQUFHeFYsd0JBQStCLENBQUMvZixHQUFHLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQztjQUFBO2NBQUEsT0FDL0QsSUFBSSxDQUFDNjBCLFdBQVcsQ0FBQ1csT0FBTyxDQUFDRixRQUFRLENBQUM7WUFBQTtjQUFBLGtDQUNqQyxJQUFJdHJDLE9BQU8sQ0FBQyxVQUFDSCxPQUFPLEVBQUVDLE1BQU0sRUFBSztnQkFDdEMsSUFBTTJyQyxTQUFTLEdBQUcsU0FBWkEsU0FBUyxHQUFTO2tCQUN0QnJqQyxVQUFVLGtHQUFDO29CQUFBO3NCQUFBO3dCQUFBOzBCQUFBOzBCQUFBLE9BQ0gsTUFBSSxDQUFDeWlDLFdBQVcsQ0FBQ1csT0FBTyxDQUFDRCxTQUFTLENBQUM7d0JBQUE7MEJBQ3pDMXJDLE9BQU8sRUFBRTt3QkFBQTt3QkFBQTswQkFBQTtzQkFBQTtvQkFBQTtrQkFBQSxDQUNWLElBQUUsR0FBRyxDQUFDO2dCQUNULENBQUM7Z0JBQ0Q0ckMsU0FBUyxFQUFFO2NBQ2IsQ0FBQyxDQUFDO1lBQUE7WUFBQTtjQUFBO1VBQUE7UUFBQTtNQUFBLENBQ0g7TUFBQTtRQUFBO01BQUE7TUFBQTtJQUFBO0lBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQTtNQUFBLHdHQUtBO1FBQUE7UUFBQTtVQUFBO1lBQUE7Y0FDVWYsVUFBVSxHQUFLLElBQUksQ0FBQ3hOLFFBQVEsQ0FBNUJ3TixVQUFVO2NBQ1puVixVQUFVLEdBQUcsSUFBSSxDQUFDdUwsaUJBQWlCLEVBQUUsRUFDM0M7Y0FDQTtjQUFBO2NBQUEsT0FDNkIsSUFBSSxDQUFDNEssZUFBZSxDQUFDblcsVUFBVSxDQUFDO1lBQUE7Y0FBQTtjQUF2RGtKLEtBQUsseUJBQUxBLEtBQUs7Y0FBRTBNLEtBQUsseUJBQUxBLEtBQUs7Y0FDbEIsSUFBSSxDQUFDem5CLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDL0IsdUJBQXVCLENBQUN2QyxXQUFXLEVBQUUsSUFBSSxDQUFDLENBQUM7Y0FBQTtjQUFBLE9BQ3RELElBQUksQ0FBQ3N3QixVQUFVLENBQUNqQixVQUFVLEdBQUdqTSxLQUFLLEdBQUcwTSxLQUFLLENBQUM7WUFBQTtjQUFBO2NBQXpEbjFCLEdBQUcseUJBQUhBLEdBQUc7Y0FDWCxJQUFJLENBQUMwTixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQy9CLHVCQUF1QixDQUFDdEMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO2NBQUE7Y0FBQSxPQUNwRWlhLFVBQVUsQ0FBQ3FCLG9CQUFvQixDQUFDLElBQUliLHFCQUE0QixDQUFDO2dCQUFFbDNCLElBQUksRUFBRSxRQUFRO2dCQUFFbVgsR0FBRyxFQUFIQTtjQUFJLENBQUMsQ0FBQyxDQUFDO1lBQUE7Y0FBQSxLQUM1RjAwQixVQUFVO2dCQUFBO2dCQUFBO2NBQUE7Y0FDSjEwQixJQUFHLEdBQUttMUIsS0FBSyxDQUFibjFCLEdBQUc7Y0FBQTtjQUFBLE9BQ0wsSUFBSSxDQUFDNDFCLHVCQUF1QixDQUFDNTFCLElBQUcsQ0FBQztZQUFBO1lBQUE7Y0FBQTtVQUFBO1FBQUE7TUFBQSxDQUUxQztNQUFBO1FBQUE7TUFBQTtNQUFBO0lBQUE7SUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsdUJBQWM7TUFDWixJQUFJLElBQUksQ0FBQzYwQixXQUFXLEVBQUU7UUFDcEIsSUFBSSxDQUFDQSxXQUFXLENBQUM5WSxRQUFRLEVBQUU7TUFDN0I7TUFDQSxJQUFJLENBQUM4WSxXQUFXLEdBQUdwc0MsU0FBUztNQUM1QjtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQRTtJQUFBO0lBQUE7TUFBQSwrRkFRQSxrQkFBVzBDLE9BQU87UUFBQTtRQUFBO1VBQUE7WUFBQTtjQUFBLElBQ1g0MEIsa0JBQWtCLEVBQUU7Z0JBQUE7Z0JBQUE7Y0FBQTtjQUFBLE1BQ2pCLElBQUl3SixLQUFLLENBQ2IscUdBQXFHLENBQ3RHO1lBQUE7Y0FFRCxJQUFJLENBQUNFLFdBQVcsRUFBRTtjQUNsQixJQUFJLENBQUN2QyxRQUFRLG1DQUFRZCwyQkFBYyxHQUFLajdCLE9BQU8sQ0FBRTtjQUNqRCxJQUFJLENBQUMrN0IsUUFBUSxDQUFDaUIsY0FBYyxHQUFHLElBQUksQ0FBQ2pCLFFBQVEsQ0FBQ2lCLGNBQWMsSUFBSWhDLG1DQUFzQixFQUFFO2NBQUEsaUJBQ3JCLElBQUksQ0FBQ2UsUUFBUSxFQUF2RTFELFFBQVEsa0JBQVJBLFFBQVEsRUFBRU8sSUFBSSxrQkFBSkEsSUFBSSxFQUFFZCxJQUFJLGtCQUFKQSxJQUFJLEVBQUVZLEdBQUcsa0JBQUhBLEdBQUcsRUFBRTFHLFVBQVUsa0JBQVZBLFVBQVUsRUFBRWdMLGNBQWMsa0JBQWRBLGNBQWM7Y0FDdkQwTixLQUFLLEdBQUdyUyxRQUFRLEtBQUssSUFBSSxHQUFHLE1BQU0sR0FBRyxPQUFPO2NBQ2xELElBQUksQ0FBQ3NTLFFBQVEsYUFBTUQsS0FBSyxnQkFBTTlSLElBQUksY0FBSWQsSUFBSSxjQUFJWSxHQUFHLDRCQUFrQjFHLFVBQVUsd0JBQWNnTCxjQUFjLENBQUU7Y0FDM0csSUFBSSxDQUFDME0sV0FBVyxHQUFHLElBQUlsQix5QkFBdUIsQ0FBQyxJQUFJLENBQUNtQyxRQUFRLENBQUM7Y0FDN0QsSUFBSSxDQUFDM08sV0FBVyxHQUFHLElBQUlwRyxpQkFBc0IsQ0FBQyxJQUFJLENBQUM7Y0FDbkQsSUFBSSxDQUFDc0csaUJBQWlCLEdBQUcsSUFBSSxDQUFDd04sV0FBVztjQUFBLGtDQUNsQyxJQUFJO1lBQUE7WUFBQTtjQUFBO1VBQUE7UUFBQTtNQUFBLENBRWQ7TUFBQTtRQUFBO01BQUE7TUFBQTtJQUFBO0lBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORTtJQUFBO0lBQUE7TUFBQSxvR0FPQTtRQUFBO1FBQUE7VUFBQTtZQUFBO2NBQUEsa0JBQzJFLElBQUksQ0FBQzNOLFFBQVEsRUFBOUUvSixVQUFVLG1CQUFWQSxVQUFVLEVBQUVtSixjQUFjLG1CQUFkQSxjQUFjLEVBQUVDLGdCQUFnQixtQkFBaEJBLGdCQUFnQixFQUFFdE8sY0FBYyxtQkFBZEEsY0FBYztjQUFBLGtCQUNaLElBQUksQ0FBQ2lQLFFBQVEsRUFBL0ROLG1CQUFtQixtQkFBbkJBLG1CQUFtQixFQUFFdkcsd0JBQXdCLG1CQUF4QkEsd0JBQXdCLEVBQ25EO2NBQ0E7Y0FDTXdKLGtCQUFrQixHQUFHakQsbUJBQW1CLElBQUk3RywwQkFBMEIsRUFBRTtjQUM5RSxJQUFJOEosa0JBQWtCLElBQUksQ0FBQ3hKLHdCQUF3QixFQUFFO2dCQUNuREEsd0JBQXdCLEdBQUc7a0JBQ3pCajVCLElBQUk7Z0JBQ04sQ0FBQztjQUNIO2NBQ0E7O2NBRUE7Y0FDQSxJQUFJLENBQUM4L0IsUUFBUSxDQUFDTixtQkFBbUIsR0FBRyxLQUFLO2NBQUE7Y0FHdkMsSUFBSSxDQUFDd0Qsa0JBQWtCLENBQUMsSUFBSSxDQUFDbkQsS0FBSyxFQUFFWCxjQUFjLENBQUM7Y0FBQTtjQUFBLE9BQ2hDLElBQUksQ0FBQ3dELHVCQUF1QixFQUFFO1lBQUE7Y0FBM0N2WixJQUFJO2NBQ1YsSUFBSTBILGNBQWMsRUFBRTtnQkFDbEIsSUFBSTdlLE9BQVcsQ0FBQ3pGLFdBQVcsRUFBRSxJQUFJeUYsT0FBVyxDQUFDckYsb0JBQW9CLEVBQUUsRUFBRTtrQkFDbkUsSUFBSSxDQUFDd3pCLGNBQWMsR0FBRyxJQUFJblIsbUNBQXdCLENBQUM3RixJQUFJLENBQUNBLElBQUksRUFBRSxJQUFJLENBQUN3WixPQUFPLEVBQUUsQ0FBQztnQkFDL0UsQ0FBQyxNQUFNO2tCQUNMcmdDLFNBQUssQ0FDSG9oQixpQkFBSSwrSEFFTDtrQkFDRCxJQUFJLENBQUN5YyxjQUFjLEdBQUcsSUFBSTFVLDBCQUFnQixDQUFDdEMsSUFBSSxDQUFDQSxJQUFJLEVBQUUsSUFBSSxDQUFDd1osT0FBTyxFQUFFLENBQUM7Z0JBQ3ZFO2NBQ0YsQ0FBQyxNQUFNO2dCQUNMLElBQUksQ0FBQ3hDLGNBQWMsR0FBRyxJQUFJMVUsMEJBQWdCLENBQUN0QyxJQUFJLENBQUNBLElBQUksRUFBRSxJQUFJLENBQUN3WixPQUFPLEVBQUUsQ0FBQztjQUN2RTtjQUNBLElBQUksQ0FBQ0MscUJBQXFCLENBQUMsSUFBSSxDQUFDekMsY0FBYyxDQUFDO2NBQy9DLElBQUksQ0FBQzBDLFlBQVksQ0FBQyxJQUFJLENBQUMvQyxRQUFRLEVBQUUsSUFBSSxDQUFDSyxjQUFjLENBQUM7Y0FDckQsSUFBSSxDQUFDMkMsK0JBQStCLEVBQUUsQ0FBQ3QrQixLQUFLLENBQUMsWUFBTTtnQkFDakQ7Y0FBQSxDQUNELENBQUM7Y0FBQTtjQUFBLE9BRXNCLElBQUksQ0FBQ2lwQyxXQUFXLENBQUNrQixVQUFVLEVBQUU7WUFBQTtjQUFBO2NBQTdDN0IsS0FBSyx5QkFBTEEsS0FBSztjQUNiLElBQUlBLEtBQUssRUFBRTtnQkFDVCxJQUFJLENBQUNoTixRQUFRLENBQUMxSCxVQUFVLEdBQUcwVSxLQUFLO2NBQ2xDOztjQUVBO2NBQ0E7Y0FDQSxJQUFJLENBQUMvSixRQUFRLENBQUM1RCxnQkFBZ0IsRUFBRTk5QixTQUFTLEVBQUUsSUFBSSxDQUFDeStCLFFBQVEsQ0FBQzFILFVBQVUsQ0FBQztjQUNwRSxJQUFJLENBQUM4SCxpQkFBaUIsR0FBRyxLQUFLO2NBQUEsa0NBQ3ZCLElBQUksQ0FBQ2dELCtCQUErQixFQUFFO1lBQUE7Y0FBQTtjQUFBO2NBRTdDLElBQUksQ0FBQzVjLE9BQU8sQ0FBQyxJQUFJL0QsZUFBZSxDQUFDdkQsb0JBQW9CLENBQUNyQyxlQUFlLENBQUMsRUFBRSxJQUFJLGVBQVE7Y0FBQTtZQUFBO1lBQUE7Y0FBQTtVQUFBO1FBQUE7TUFBQSxDQUd2RjtNQUFBO1FBQUE7TUFBQTtNQUFBO0lBQUE7SUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBO01BQUEseURBUUE7UUFBQTtRQUFBLElBQTBCbmIsTUFBTSx1RUFBR0gsU0FBUztRQUFBO1VBQUE7VUFBQTtZQUFBO2NBQUE7Z0JBQzFDO2dCQUNBLE1BQUksQ0FBQ2lsQixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQy9CLHVCQUF1QixDQUFDRSxVQUFVLEVBQUUsTUFBSSxDQUFDLENBQUM7Z0JBQUE7Z0JBQUEsT0FDeEQsTUFBSSxDQUFDZ2lCLHVCQUF1QixFQUFFO2NBQUE7Z0JBQTNDdlosSUFBSTtnQkFDVkEsSUFBSSxDQUFDbWEsWUFBWSxDQUFDOWhDLE1BQU0sQ0FBQztnQkFDekIsTUFBSSxDQUFDNCtCLFlBQVksR0FBRzUrQixNQUFNO2dCQUMxQixNQUFJLENBQUM4a0IsT0FBTyxDQUFDLElBQUkvRCxlQUFlLENBQUMvQix1QkFBdUIsQ0FBQ0ssYUFBYSxFQUFFLE1BQUksRUFBRSxNQUFJLENBQUN1ZixZQUFZLENBQUMsQ0FBQztjQUFBO2NBQUE7Z0JBQUE7WUFBQTtVQUFBO1FBQUE7TUFBQSxDQUNsRztNQUFBO1FBQUE7TUFBQTtNQUFBO0lBQUE7SUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsZ0NBQXVCO01BQ3JCO01BQ0EsSUFBSSxDQUFDRyxxQkFBcUIsQ0FBQzk5QixPQUFPLENBQUMsSUFBSSxDQUFDO01BQ3hDLElBQUksQ0FBQzZqQixPQUFPLENBQUMsSUFBSS9ELGVBQWUsQ0FBQ3ZELG9CQUFvQixDQUFDQyxlQUFlLEVBQUUsSUFBSSxDQUFDLENBQUM7TUFDN0UsSUFBSSxDQUFDK2tCLGtCQUFrQixDQUFDLElBQUksQ0FBQ2xFLFFBQVEsRUFBRSxJQUFJLENBQUNELEtBQUssQ0FBQztNQUNsRCxJQUFJLENBQUNvRSxjQUFjLENBQUMsSUFBSSxDQUFDbkUsUUFBUSxFQUFFLElBQUksQ0FBQ0QsS0FBSyxDQUFDO0lBQ2hEOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0EseUJBQWdCO01BQ2QsT0FBT3grQixTQUFTO0lBQ2xCO0VBQUM7RUFBQTtBQUFBLEVBclJzQnUrQixXQUFhO0FBd1J2QjJOLHdFQUFVLEU7O0FDNVViOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRTZDO0FBQ1Q7QUFDUDtBQUNFO0FBQ0Y7QUFDRjtBQUVVO0FBQ0Q7QUFDWjtBQUVwQyxJQUFNN3BCLGVBQUksR0FBRyxtQkFBbUI7QUFFaEMsSUFBTWtyQixlQUFlLEdBQUcsSUFBSW5yQyxrQkFBZ0IsRUFBRTtBQUM5QyxJQUFNb3JDLFlBQVksR0FBSSxZQUFZO0VBQ2hDLElBQUlsdEMsR0FBRyxHQUFHLElBQUl5cUMsR0FBRyxFQUFFO0VBQ25CenFDLEdBQUcsQ0FBQzRCLEdBQUcsQ0FBQ3U2QixhQUFhLENBQUNDLEdBQUcsRUFBRTZCLFdBQWEsQ0FBQztFQUN6Q2orQixHQUFHLENBQUM0QixHQUFHLENBQUN1NkIsYUFBYSxDQUFDRSxJQUFJLEVBQUU4TCxZQUFjLENBQUM7RUFDM0Nub0MsR0FBRyxDQUFDNEIsR0FBRyxDQUFDdTZCLGFBQWEsQ0FBQ0csR0FBRyxFQUFFc04sV0FBYSxDQUFDO0VBQ3pDLE9BQU81cEMsR0FBRztBQUNaLENBQUMsRUFBRzs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkEsSUFLTW10Qyw0QkFBaUI7RUFBQTtFQUFBO0VBRXJCLDZCQUFlO0lBQUE7SUFBQTtJQUNiO0lBQ0EsTUFBS2hQLFFBQVEsR0FBR3orQixTQUFTO0lBQ3pCLE1BQUswdEMsTUFBTSxHQUFHLENBQ1pqUixhQUFhLENBQUNDLEdBQUcsRUFDakJELGFBQWEsQ0FBQ0UsSUFBSSxFQUNsQkYsYUFBYSxDQUFDRyxHQUFHLENBQ2xCO0lBQUE7RUFDSDs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQU5FO0lBQUE7SUFBQSxPQU9BLCtCQUF1Qng1QixLQUFLLEVBQUVWLE9BQU8sRUFBRTtNQUNyQyxPQUFPNnFDLGVBQWUsQ0FBQ3J5QixNQUFNLENBQUM5WCxLQUFLLEVBQUVvcUMsWUFBWSxFQUFFOXFDLE9BQU8sRUFBRSxNQUFNLENBQUM7SUFDckU7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEsNEJBQW9CO01BQ2xCLE9BQU8sSUFBSSxDQUFDZ3JDLE1BQU07SUFDcEI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEsMEJBQWtCdHFDLEtBQUssRUFBRTtNQUN2QjtNQUNBQSxLQUFLLEdBQUcsT0FBT0EsS0FBSyxLQUFLLFFBQVEsR0FBRyxDQUFDQSxLQUFLLENBQUMsR0FBR0EsS0FBSzs7TUFFbkQ7TUFDQSxJQUFNOGdCLENBQUMsR0FBRzlnQixLQUFLLENBQUM0UCxNQUFNLENBQUMsVUFBQTZGLEtBQUssRUFBSTtRQUM5QixJQUFJeFYsR0FBRztRQUNQLEtBQUtBLEdBQUcsSUFBSW81QixhQUFhLEVBQUU7VUFDekIsSUFBSUEsYUFBYSxDQUFDcDVCLEdBQUcsQ0FBQyxDQUFDaUgsV0FBVyxFQUFFLEtBQUt1TyxLQUFLLENBQUN2TyxXQUFXLEVBQUUsRUFBRTtZQUM1RCxPQUFPLElBQUk7VUFDYjtRQUNGO1FBQ0EsT0FBTyxLQUFLO01BQ2QsQ0FBQyxDQUFDLENBQUNoSyxHQUFHLENBQUMsVUFBQXVZLEtBQUs7UUFBQSxPQUFJQSxLQUFLLENBQUN2TyxXQUFXLEVBQUU7TUFBQSxFQUFDOztNQUVwQztNQUNBLElBQUksQ0FBQ29qQyxNQUFNLHNCQUFPLElBQUlDLEdBQUcsQ0FBQ3pwQixDQUFDLENBQUMsQ0FBQztNQUM3Qm5qQixTQUFLLENBQUNzaEIsZUFBSSwyQkFBb0IsSUFBSSxDQUFDcXJCLE1BQU0sRUFBRztNQUM1QyxPQUFPLElBQUk7SUFDYjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFSRTtJQUFBO0lBQUEsT0FTQSxjQUFNaHJDLE9BQU8sRUFBRTtNQUNiLElBQUksQ0FBQys3QixRQUFRLEdBQUcvN0IsT0FBTztNQUN2QixJQUFNNlQsUUFBUSxHQUFHLElBQUkzVSxlQUFlLEVBQUU7TUFDdENiLFNBQUssQ0FBQ3NoQixlQUFJLEVBQUUsUUFBUSxDQUFDO01BQ3JCLElBQUksQ0FBQ3VyQixxQkFBcUIsQ0FBQyxJQUFJLENBQUNGLE1BQU0sRUFBRSxJQUFJLENBQUNqUCxRQUFRLENBQUMsQ0FDbkR4N0IsSUFBSSxDQUFDLFVBQUFrZSxVQUFVLEVBQUk7UUFDbEJwZ0IsU0FBSyxDQUFDc2hCLGVBQUksNkNBQXNDbEIsVUFBVSxDQUFDbWdCLE9BQU8sRUFBRSxFQUFHO1FBQ3ZFL3FCLFFBQVEsQ0FBQ25WLE9BQU8sQ0FBQytmLFVBQVUsQ0FBQztNQUM5QixDQUFDLENBQUMsQ0FDRGhlLEtBQUssQ0FBQyxVQUFBaUcsR0FBRyxFQUFJO1FBQ1pwSSxRQUFJLENBQUNxaEIsZUFBSSwyREFBb0RqWixHQUFHLEVBQUc7UUFDbkVtTixRQUFRLENBQUNsVixNQUFNLENBQUMrSCxHQUFHLENBQUM7TUFDdEIsQ0FBQyxDQUFDO01BQ0osT0FBT21OLFFBQVEsQ0FBQ2pWLE9BQU87SUFDekI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7RUFIRTtJQUFBO0lBQUEsS0FJQSxlQUFxQjtNQUNuQixPQUFPbTdCLGFBQWE7SUFDdEI7RUFBQztFQUFBO0FBQUEsRUEzRjZCOTRCLGFBQVk7OztBQzdCaEM7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRXlCO0FBQ0c7QUFDZ0M7QUFDekM7QUFDVTtBQUNEO0FBQ0o7QUFFcEMsSUFBTTBlLHVCQUFJLEdBQUcsNkJBQTZCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQU13ckIsdUJBQXVCLEdBQUcsU0FBMUJBLHVCQUF1QixDQUFJQyxFQUFFLEVBQUs7RUFDdEMsT0FBT0EsRUFBRSxDQUFDaDVCLEtBQUssSUFBSWc1QixFQUFFLENBQUMvNEIsS0FBSyxJQUFJKzRCLEVBQUUsQ0FBQzk0QixHQUFHLElBQUk4NEIsRUFBRSxDQUFDNzRCLEdBQUcsSUFBSTY0QixFQUFFO0FBQ3ZELENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQU1DLDhDQUEyQixHQUFHLFNBQTlCQSwyQkFBMkIsQ0FBSXZnQyxXQUFXLEVBQUU2MkIsU0FBUyxFQUFLO0VBQzlELElBQUkySixFQUFFLEdBQUdqNkIsUUFBUSxDQUFDc3dCLFNBQVMsQ0FBQztFQUM1QixJQUFJLE9BQU83MkIsV0FBVyxDQUFDb0gsS0FBSyxLQUFLLFNBQVMsRUFBRTtJQUMxQ281QixFQUFFLENBQUNwNUIsS0FBSyxHQUFHcEgsV0FBVyxDQUFDb0gsS0FBSztFQUM5QixDQUFDLE1BQ0k7SUFDSCxJQUFJdlIsR0FBRztJQUNQLEtBQUtBLEdBQUcsSUFBSW1LLFdBQVcsQ0FBQ29ILEtBQUssRUFBRTtNQUM3Qm81QixFQUFFLENBQUMzcUMsR0FBRyxDQUFDLEdBQUd3cUMsdUJBQXVCLENBQUNyZ0MsV0FBVyxDQUFDb0gsS0FBSyxDQUFDdlIsR0FBRyxDQUFDLENBQUM7SUFDM0Q7SUFDQTJxQyxFQUFFLENBQUNwNUIsS0FBSyxHQUFHLElBQUk7RUFDakI7RUFDQW81QixFQUFFLENBQUN2MEIsS0FBSyxHQUFHLE9BQU9qTSxXQUFXLENBQUNpTSxLQUFLLEtBQUssU0FBUyxHQUFHak0sV0FBVyxDQUFDaU0sS0FBSyxHQUFHLElBQUk7RUFDNUUsT0FBT3UwQixFQUFFO0FBQ1gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUhBLElBSU1DLHlDQUFzQjtFQUUxQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxnQ0FBYXI1QixLQUFLLEVBQUV4VSxJQUFJLEVBQTJCO0lBQUEsSUFBekJvbUMsV0FBVyx1RUFBR3htQyxTQUFTO0lBQUE7SUFDL0MsSUFBSSxDQUFDNFUsS0FBSyxHQUFHQSxLQUFLO0lBQ2xCLElBQUksQ0FBQzBWLEtBQUssR0FBRyxJQUFJLENBQUMxVixLQUFLLENBQUMyVixTQUFTLENBQUMsSUFBSSxDQUFDO0lBQ3ZDLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUksQ0FBQzVWLEtBQUssQ0FBQ3JFLFVBQVU7SUFDbkMsSUFBSSxDQUFDMjlCLGNBQWMsR0FBRzl0QyxJQUFJO0lBQzFCLElBQUksQ0FBQ3FtQyxNQUFNLEdBQUcsSUFBSTtJQUNsQixJQUFJLENBQUMwSCxZQUFZLEdBQUdudUMsU0FBUztJQUM3QixJQUFJLENBQUMwbUMsWUFBWSxHQUFHRixXQUFXLElBQUksSUFBSWpCLHdCQUF1QixFQUFFO0VBQ2xFOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUxFO0lBQUE7SUFBQSxPQU1BLDZCQUFxQjtNQUNuQixJQUFJLENBQUM0SSxZQUFZLEdBQUd0c0MsTUFBTSxDQUFDSixnQkFBZ0IsQ0FBQyxJQUFJLENBQUMwc0MsWUFBWSxDQUFDO01BQzlELE9BQU8sSUFBSSxDQUFDQSxZQUFZLENBQUM3c0MsT0FBTztJQUNsQzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUhFO0lBQUE7SUFBQSxPQUlBLG1CQUFXO01BQ1Q7TUFDQSxJQUFJLENBQUNzVCxLQUFLLENBQUM0USxNQUFNLEVBQUU7TUFDbkIsSUFBSSxDQUFDNVEsS0FBSyxHQUFHLElBQUksQ0FBQzBWLEtBQUssQ0FBQ0MsU0FBUyxDQUFDLElBQUksQ0FBQztNQUN2QyxJQUFJLENBQUNDLE1BQU0sQ0FBQ2xkLFdBQVcsQ0FBQyxJQUFJLENBQUNzSCxLQUFLLENBQUM7TUFDbkMsSUFBSSxDQUFDdTVCLFlBQVksR0FBR251QyxTQUFTO0lBQy9COztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQWRFO0lBQUE7SUFBQSxPQWVBLG1CQUFXOGxDLEtBQUssRUFBRXBqQyxPQUFPLEVBQXlDO01BQUEsSUFBdkNva0MsTUFBTSx1RUFBRyxJQUFJO01BQUEsSUFBRTlCLGVBQWUsdUVBQUcsSUFBSTtNQUM5RGprQyxTQUFLLENBQUNzaEIsdUJBQUksRUFBRSxhQUFhLENBQUM7TUFDMUIsSUFBTW9HLElBQUksR0FBRyxJQUFJO01BQ2pCLElBQUksQ0FBQ2dlLE1BQU0sR0FBR1gsS0FBSztNQUNuQixJQUFJLENBQUNxSSxZQUFZLEdBQUd0c0MsTUFBTSxDQUFDSixnQkFBZ0IsQ0FBQyxJQUFJLENBQUMwc0MsWUFBWSxDQUFDO01BQzlELElBQU01M0IsUUFBUSxHQUFHLElBQUksQ0FBQzQzQixZQUFZO01BQ2xDenJDLE9BQU8sQ0FBQ3dpQyxHQUFHLEdBQUc0QixNQUFNLElBQUlwa0MsT0FBTyxDQUFDd2lDLEdBQUc7TUFDbkN4aUMsT0FBTyxDQUFDc2lDLGVBQWUsR0FBR0EsZUFBZSxJQUFJdGlDLE9BQU8sQ0FBQ3NpQyxlQUFlO01BQ3BFZ0Msd0JBQXdCLENBQUMsSUFBSSxDQUFDcHlCLEtBQUssRUFBRSxJQUFJLENBQUM0VixNQUFNLENBQUMsQ0FDOUN2bkIsSUFBSSxDQUFDLFVBQUFrM0IsU0FBUyxFQUFJO1FBQ2pCcDVCLFNBQUssQ0FBQ3NoQix1QkFBSSxFQUFFLG9CQUFvQixDQUFDO1FBQ2pDLElBQUlnaUIsU0FBUyxHQUFHO1VBQ2Q2QyxNQUFNLEVBQUV4a0MsT0FBTyxDQUFDd2tDLE1BQU0sSUFBSSxJQUFJLEdBQUd4a0MsT0FBTyxDQUFDd2tDLE1BQU0sR0FBRyxDQUFDO1VBQ25Ea0gsVUFBVSxFQUFFMXJDLE9BQU8sQ0FBQzByQyxVQUFVO1VBQzlCMVosVUFBVSxFQUFFaHlCLE9BQU8sQ0FBQ2d5QixVQUFVO1VBQzlCMlosT0FBTyxFQUFFM3JDLE9BQU8sQ0FBQzA0QixHQUFHO1VBQ3BCRSxJQUFJLEVBQUU1NEIsT0FBTyxDQUFDNDRCO1FBQ2hCLENBQUM7UUFDRCxJQUFJNTRCLE9BQU8sQ0FBQytoQyxlQUFlLEVBQUU7VUFDM0JKLFNBQVMsQ0FBQ0ksZUFBZSxHQUFHL2hDLE9BQU8sQ0FBQytoQyxlQUFlO1FBQ3JEO1FBQ0EsSUFBSS9oQyxPQUFPLENBQUN5NEIsT0FBTyxFQUFFO1VBQ25Ca0osU0FBUyxDQUFDaUssUUFBUSxHQUFHNXJDLE9BQU8sQ0FBQ3k0QixPQUFPO1FBQ3RDO1FBQ0EsSUFBSXo0QixPQUFPLENBQUN5aUMsVUFBVSxLQUFLLE1BQU0sSUFBSXppQyxPQUFPLENBQUMwaUMsV0FBVyxLQUFLLE1BQU0sRUFBRTtVQUNuRWYsU0FBUyxDQUFDOEMsUUFBUSxHQUFHLElBQUk7UUFDM0I7UUFDQSxJQUFJLE9BQU96a0MsT0FBTyxDQUFDNjRCLGdCQUFnQixLQUFLLFdBQVcsRUFBRTtVQUNuRDhJLFNBQVMsQ0FBQzlJLGdCQUFnQixHQUFHWCxrQkFBa0IsQ0FBQ3QxQixJQUFJLENBQUM0TyxTQUFTLENBQUN4UixPQUFPLENBQUM2NEIsZ0JBQWdCLENBQUMsQ0FBQztRQUMzRjtRQUNBOEksU0FBUyxHQUFHMEosOENBQTJCLENBQUNyckMsT0FBTyxDQUFDNnJDLGdCQUFnQixFQUFFbEssU0FBUyxDQUFDO1FBQzVFLE9BQU8yQyxvQkFBb0IsQ0FBQ2xCLEtBQUssRUFBRXBqQyxPQUFPLEVBQUUyaEMsU0FBUyxFQUFFMXpCLE9BQVcsQ0FBQ2hELFlBQVksRUFBRSxFQUFFd3NCLFNBQVMsQ0FBQztNQUMvRixDQUFDLENBQUMsQ0FDRGwzQixJQUFJLENBQUMsWUFBTTtRQUNWbEMsU0FBSyxDQUFDc2hCLHVCQUFJLEVBQUUsa0JBQWtCLENBQUM7UUFDL0I5TCxRQUFRLENBQUNuVixPQUFPLENBQUNxbkIsSUFBSSxDQUFDO01BQ3hCLENBQUMsQ0FBQyxDQUNEdGxCLEtBQUssQ0FBQyxVQUFBaUcsR0FBRztRQUFBLE9BQUltTixRQUFRLENBQUNsVixNQUFNLENBQUMrSCxHQUFHLENBQUM7TUFBQSxFQUFDO01BQ3JDLE9BQU9tTixRQUFRLENBQUNqVixPQUFPO0lBQ3pCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUxFO0lBQUE7SUFBQSxPQU1BLGlCQUFTa3RDLGNBQWMsRUFBRTtNQUN2Qnp0QyxTQUFLLENBQUNzaEIsdUJBQUksRUFBRSxXQUFXLENBQUM7TUFDeEIsSUFBTWxYLEVBQUUsR0FBR3dGLE9BQVcsQ0FBQzlDLGNBQWMsQ0FBQyxJQUFJLENBQUM0NEIsTUFBTSxDQUFDO01BQ2xELElBQUl0N0IsRUFBRSxFQUFFO1FBQ05BLEVBQUUsQ0FBQ3E4QixPQUFPLENBQUNnSCxjQUFjLENBQUM7UUFDMUIsSUFBSSxDQUFDOUgsWUFBWSxDQUFDYyxPQUFPLENBQUMsSUFBSSxDQUFDZixNQUFNLENBQUM7TUFDeEMsQ0FBQyxNQUNJO1FBQ0h6bEMsUUFBSSxDQUFDcWhCLHVCQUFJLEVBQUUsb0RBQW9ELEdBQUcsSUFBSSxDQUFDb2tCLE1BQU0sR0FBRyxHQUFHLENBQUM7TUFDdEY7SUFDRjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0Esc0JBQWM7TUFDWjFsQyxTQUFLLENBQUNzaEIsdUJBQUksRUFBRSxjQUFjLENBQUM7TUFDM0IsSUFBSTtRQUNGLElBQU1sWCxFQUFFLEdBQUd3RixPQUFXLENBQUM5QyxjQUFjLENBQUMsSUFBSSxDQUFDNDRCLE1BQU0sQ0FBQztRQUNsRCxJQUFJdDdCLEVBQUUsRUFBRTtVQUNOQSxFQUFFLENBQUN5MUIsVUFBVSxFQUFFO1FBQ2pCO01BQ0YsQ0FBQyxDQUFDLE9BQU9wN0IsQ0FBQyxFQUFFO1FBQ1Y7TUFBQTtNQUVGLElBQUksQ0FBQ2lwQyxPQUFPLEVBQUU7TUFDZCxJQUFJLENBQUMvSCxZQUFZLENBQUM5RixVQUFVLEVBQUU7SUFDaEM7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUkU7SUFBQTtJQUFBLE9BU0EsY0FBTWx5QixVQUFVLEVBQUUvSixJQUFJLEVBQUU7TUFDdEIsSUFBTXdHLEVBQUUsR0FBR3dGLE9BQVcsQ0FBQzlDLGNBQWMsQ0FBQyxJQUFJLENBQUM0NEIsTUFBTSxDQUFDO01BQ2xELElBQUl0N0IsRUFBRSxFQUFFO1FBQ05BLEVBQUUsQ0FBQzBwQixJQUFJLENBQUNubUIsVUFBVSxFQUFFL0osSUFBSSxDQUFDO01BQzNCO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7RUFIRTtJQUFBO0lBQUEsT0FJQSx3Q0FBZ0NzSixPQUFPLEVBQUU7TUFDdkMsSUFBSSxDQUFDeTRCLFlBQVksQ0FBQ2Usa0JBQWtCLENBQUN4NUIsT0FBTyxDQUFDO0lBQy9DOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0VBSEU7SUFBQTtJQUFBLE9BSUEsMkNBQW1DQSxPQUFPLEVBQUU7TUFDMUMsSUFBSSxDQUFDeTRCLFlBQVksQ0FBQ2dCLHFCQUFxQixDQUFDejVCLE9BQU8sQ0FBQztJQUNsRDs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBVkU7SUFBQTtJQUFBLE9BV0EsNEJBQW9CdFAsSUFBSSxFQUFFOHVCLFFBQVEsRUFBRXR1QixPQUFPLEVBQUU7TUFDM0MsSUFBSSxDQUFDdW5DLFlBQVksQ0FBQ2lCLGtCQUFrQixDQUFDaHBDLElBQUksRUFBRTh1QixRQUFRLEVBQUV0dUIsT0FBTyxDQUFDO0lBQy9EOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFWRTtJQUFBO0lBQUEsT0FXQSxvQ0FBNEJSLElBQUksRUFBRTBFLEdBQUcsRUFBRUUsS0FBSyxFQUFFO01BQzVDLElBQUksQ0FBQ21qQyxZQUFZLENBQUNrQiwwQkFBMEIsQ0FBQ2pwQyxJQUFJLEVBQUUwRSxHQUFHLEVBQUVFLEtBQUssQ0FBQztJQUNoRTs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUhFO0lBQUE7SUFBQSxPQUlBLCtCQUF1QitkLGdCQUFnQixFQUFFO01BQ3ZDLElBQUksQ0FBQ29sQixZQUFZLENBQUNULHFCQUFxQixDQUFDM2tCLGdCQUFnQixDQUFDO0lBQzNEOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0EsK0JBQXVCQSxnQkFBZ0IsRUFBRTtNQUN2QyxJQUFJLENBQUNvbEIsWUFBWSxDQUFDUixxQkFBcUIsQ0FBQzVrQixnQkFBZ0IsQ0FBQztJQUMzRDs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQU5FO0lBQUE7SUFBQSxPQU9BLDJCQUFtQkEsZ0JBQWdCLEVBQUU7TUFDbkMsSUFBSSxDQUFDb2xCLFlBQVksQ0FBQ21CLGlCQUFpQixDQUFDdm1CLGdCQUFnQixDQUFDO0lBQ3ZEOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0EseUJBQWlCZ2pCLE9BQU8sRUFBRTtNQUN4QixJQUFNbjVCLEVBQUUsR0FBR3dGLE9BQVcsQ0FBQzlDLGNBQWMsQ0FBQyxJQUFJLENBQUM0NEIsTUFBTSxDQUFDO01BQ2xELElBQUl0N0IsRUFBRSxFQUFFO1FBQ04sSUFBSW01QixPQUFPLENBQUMxdkIsS0FBSyxJQUFJLE9BQU8wdkIsT0FBTyxDQUFDMXZCLEtBQUssS0FBSyxTQUFTLEVBQUU7VUFDdkQsSUFBTVEsQ0FBQyxHQUFHLENBQUM1QixLQUFLLENBQUM4d0IsT0FBTyxDQUFDMXZCLEtBQUssQ0FBQ2xELEtBQUssQ0FBQyxHQUFHd0IsS0FBSyxDQUFDb3hCLE9BQU8sQ0FBQzF2QixLQUFLLENBQUNsRCxLQUFLLENBQUMsR0FBR3NYLE1BQU0sQ0FBQ3hWLEtBQUs7VUFDakYsSUFBTTZCLENBQUMsR0FBRyxDQUFDN0IsS0FBSyxDQUFDOHdCLE9BQU8sQ0FBQzF2QixLQUFLLENBQUMxQyxNQUFNLENBQUMsR0FBR2dCLEtBQUssQ0FBQ294QixPQUFPLENBQUMxdkIsS0FBSyxDQUFDMUMsTUFBTSxDQUFDLEdBQUc4VyxNQUFNLENBQUN4VixLQUFLO1VBQ25GckksRUFBRSxDQUFDdWpDLGdCQUFnQixDQUFDdDVCLENBQUMsRUFBRUMsQ0FBQyxDQUFDO1FBQzNCO01BQ0Y7SUFDRjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFMRTtJQUFBO0lBQUEsT0FNQSxtQkFBVztNQUNULE9BQU8sSUFBSSxDQUFDNjRCLGNBQWM7SUFDNUI7RUFBQztFQUFBO0FBQUE7QUFJWUQsZ0dBQXNCLEU7O0FDaFR6Qjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFNEI7QUFDSDtBQUVyQyxJQUFNNXJCLFlBQUksR0FBRyxrQkFBa0I7QUFDL0IsSUFBTXNzQixXQUFXLEdBQUcsbUJBQW1COztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQSxJQU1NQyxtQkFBVztFQUVmO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFDRSx1QkFBc0M7SUFBQSxJQUF6QnpVLFNBQVMsdUVBQUd3VSxXQUFXO0lBQUE7SUFDbEMsSUFBSTtNQUNGLElBQUksQ0FBQ3ZVLGNBQWMsR0FBR3pwQixPQUFXLENBQUM1RSxjQUFjLENBQUNvdUIsU0FBUyxDQUFDO0lBQzdELENBQUMsQ0FBQyxPQUFPMzBCLENBQUMsRUFBRTtNQUNWdkUsU0FBSyxDQUFDb2hCLFlBQUksOEVBQXVFN2MsQ0FBQyxDQUFDckcsT0FBTyxFQUFHO01BQzdGLE1BQU1xRyxDQUFDO0lBQ1Q7RUFDRjtFQUFDO0lBQUE7SUFBQSxPQUVELHlCQUFpQndiLFNBQVMsRUFBRTtNQUMxQmpnQixTQUFLLENBQUNzaEIsWUFBSSxFQUFFLG1CQUFtQixDQUFDO01BQ2hDckIsU0FBUyxDQUFDcVosT0FBTyxDQUFDLElBQUksRUFBRTFwQixPQUFXLENBQUM3QyxZQUFZLENBQUMsSUFBSSxDQUFDc3NCLGNBQWMsQ0FBQyxDQUFDO0lBQ3hFO0VBQUM7SUFBQTtJQUFBLE9BRUQsaUJBQVM5dEIsV0FBVyxFQUFFO01BQ3BCLElBQUlDLFFBQVEsR0FBRyxJQUFJLENBQUMrdEIsVUFBVTtNQUM5QnY1QixTQUFLLENBQUNzaEIsWUFBSSxnQ0FBeUI5VixRQUFRLE9BQUk7TUFDL0NvRSxPQUFXLENBQUN2RSxjQUFjLENBQUMsSUFBSSxDQUFDZ3VCLGNBQWMsRUFBRTl0QixXQUFXLEVBQUVDLFFBQVEsQ0FBQztJQUN4RTtFQUFDO0lBQUE7SUFBQSxPQUVELHFCQUFhO01BQ1hvRSxPQUFXLENBQUN2RSxjQUFjLENBQUMsSUFBSSxDQUFDZ3VCLGNBQWMsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDRSxVQUFVLENBQUM7SUFDeEU7RUFBQztJQUFBO0lBQUEsS0FFRCxlQUFrQjtNQUNoQixPQUFPM3BCLE9BQVcsQ0FBQzFCLG1CQUFtQixDQUFDLElBQUksQ0FBQ21yQixjQUFjLEVBQUUsVUFBVSxDQUFDO0lBQ3pFO0VBQUM7SUFBQTtJQUFBLEtBRUQsZUFBWTtNQUNWLE9BQU8sSUFBSSxDQUFDQSxjQUFjO0lBQzVCO0VBQUM7RUFBQTtBQUFBO0FBSVl3VSxvRUFBVyxFOztBQ3ZEZDs7QUFFTCxJQUFNQyxZQUFZLEdBQUd2NkIsTUFBTSxDQUFDOEcsTUFBTSxDQUFDO0VBQ3hDdWhCLElBQUksRUFBRSxNQUFNO0VBQ1pELEdBQUcsRUFBRTtBQUNQLENBQUMsQ0FBQztBQUVLLElBQU1vUyxnQkFBZ0IsR0FBR3g2QixNQUFNLENBQUM4RyxNQUFNLENBQUM7RUFDNUMyekIsSUFBSSxFQUFFLE1BQU07RUFDWkMsTUFBTSxFQUFFLFFBQVE7RUFDaEJDLE1BQU0sRUFBRTtBQUNWLENBQUMsQ0FBQyxDOztBQ1hVOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQSxJQUFNQyxPQUFPLEdBQUcsU0FBVkEsT0FBTyxDQUFJbDdCLEdBQUcsRUFBRXRHLElBQUksRUFBRW5LLEtBQUssRUFBSztFQUNwQytRLE1BQU0sQ0FBQzY2QixjQUFjLENBQUNuN0IsR0FBRyxFQUFFdEcsSUFBSSxFQUFFO0lBQy9CbkssS0FBSyxFQUFFQSxLQUFLO0lBQ1o2ckMsUUFBUSxFQUFFLElBQUk7SUFDZEMsVUFBVSxFQUFFO0VBQ2QsQ0FBQyxDQUFDO0FBQ0osQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkEsSUFLTUMsdUJBQXVCLHVDQUUzQixtQ0FBZTtFQUFBO0VBQ2JKLE9BQU8sQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFO0lBQ3JCcDZCLEtBQUssRUFBRTtFQUNULENBQUMsQ0FBQztFQUNGbzZCLE9BQU8sQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFO0lBQ3RCcDZCLEtBQUssRUFBRTtFQUNULENBQUMsQ0FBQztBQUNKLENBQUM7QUFJSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkEsSUFLTXk2Qix3QkFBd0IsdUNBRTVCLG9DQUFlO0VBQUE7RUFDYkwsT0FBTyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsR0FBRyxDQUFDO0VBQzNCQSxPQUFPLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxHQUFHLENBQUM7RUFDNUJBLE9BQU8sQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLEtBQUssQ0FBQztFQUM3QkEsT0FBTyxDQUFDLElBQUksRUFBRSxXQUFXLEVBQUUsRUFBRSxDQUFDO0VBQzlCQSxPQUFPLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxLQUFLLENBQUM7RUFDakNBLE9BQU8sQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLEVBQUUsQ0FBQztFQUM1QkEsT0FBTyxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsVUFBVSxDQUFDO0VBQ3BDQSxPQUFPLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxHQUFHLENBQUM7QUFDN0IsQ0FBQztBQUlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQSxJQUtNTSxrQkFBa0IsdUNBRXRCLDhCQUE4QztFQUFBLElBQWpDLzFCLEtBQUssdUVBQUcsSUFBSTtFQUFBLElBQUU3RSxLQUFLLHVFQUFHNVUsU0FBUztFQUFBO0VBQzFDa3ZDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFejFCLEtBQUssQ0FBQztFQUM3QnkxQixPQUFPLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRXQ2QixLQUFLLElBQUksSUFBSTA2Qix1QkFBdUIsRUFBRSxDQUFDO0FBQ2hFLENBQUM7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkEsSUFLTUcsbUJBQW1CLHVDQUV2QiwrQkFBOEM7RUFBQSxJQUFqQ2gyQixLQUFLLHVFQUFHLElBQUk7RUFBQSxJQUFFN0UsS0FBSyx1RUFBRzVVLFNBQVM7RUFBQTtFQUMxQ2t2QyxPQUFPLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRXoxQixLQUFLLENBQUM7RUFDN0J5MUIsT0FBTyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUV0NkIsS0FBSyxJQUFJLElBQUkyNkIsd0JBQXdCLEVBQUUsQ0FBQztBQUNqRSxDQUFDOzs7QUM1RVM7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFb0M7QUFDUjtBQUNpQjtBQUNoQjtBQUNBO0FBQ1E7QUFDSDtBQUN5QjtBQUNyQjtBQUNiO0FBRXJDLElBQU1sdEIsMkJBQUksR0FBRyxlQUFlO0FBQzVCLElBQU1zYixxQ0FBYyxHQUFHO0VBQ3JCNUMsUUFBUSxFQUFFLE1BQU07RUFDaEJQLElBQUksRUFBRSxJQUFJO0VBQ1Y0VCxVQUFVLEVBQUUsTUFBTTtFQUNsQnZRLGNBQWMsRUFBRSxtQkFBbUI7RUFDbkNzSCxVQUFVLEVBQUUsTUFBTTtFQUFFO0VBQ3BCQyxXQUFXLEVBQUUsTUFBTTtFQUFFO0VBQ3JCSixlQUFlLEVBQUUsUUFBUTtFQUN6QkUsR0FBRyxFQUFFLG1DQUFtQztFQUN4Q21ELFlBQVksRUFBRSw0QkFBNEI7RUFDMUNoRCxpQkFBaUIsRUFBRSx3Q0FBd0M7RUFDM0RrSixnQkFBZ0IsRUFBRSxJQUFJa0IsbUJBQW1CO0FBQzNDLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBLElBS01DLDBCQUFhO0VBQUE7RUFBQTtFQUVqQix5QkFBZTtJQUFBO0lBQUE7SUFDYjtJQUNBLE1BQUtqUixRQUFRLEdBQUd6K0IsU0FBUztJQUN6QixNQUFLdytCLEtBQUssR0FBR3grQixTQUFTO0lBQ3RCLE1BQUs4K0IsY0FBYyxHQUFHOStCLFNBQVM7SUFDL0IsTUFBSzBvQyxVQUFVLEdBQUcxb0MsU0FBUztJQUMzQixNQUFLMnZDLGNBQWMsR0FBRzN2QyxTQUFTO0lBQUE7RUFDakM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLDRCQUFvQnMvQixXQUFXLEVBQThCO01BQUEsSUFBNUJ6QixjQUFjLHVFQUFHNzlCLFNBQVM7TUFDdkQsSUFBSSxPQUFPcy9CLFdBQVcsS0FBSyxXQUFXLElBQUl6QixjQUFjLEtBQUs3OUIsU0FBUyxFQUFFO1FBQ3RFLElBQUk4bkIsSUFBSSxHQUFHLElBQUk4bUIsWUFBVyxDQUFDL1EsY0FBYyxDQUFDO1FBQzFDL1YsSUFBSSxDQUFDOG5CLGVBQWUsQ0FBQyxJQUFJLENBQUM7TUFDNUI7SUFDSjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFMRTtJQUFBO0lBQUEsT0FNQSxpQkFBUzluQixJQUFJLEVBQUVxUyxTQUFTLEVBQUU7TUFBQTtNQUN4QixJQUFJLENBQUNxRSxLQUFLLEdBQUcxVyxJQUFJO01BQ2pCLElBQUksQ0FBQzRnQixVQUFVLEdBQUd2TyxTQUFTO01BQzNCLElBQUksSUFBSSxDQUFDMkUsY0FBYyxLQUFLOStCLFNBQVMsRUFBRTtRQUNyQyxJQUFJLENBQUM4K0IsY0FBYyxDQUFDOEIsVUFBVSxFQUFFO1FBQ2hDLElBQUksQ0FBQzlCLGNBQWMsR0FBRzkrQixTQUFTO01BQ2pDO01BQ0EsSUFBSSxJQUFJLENBQUN3K0IsS0FBSyxFQUFFO1FBQ2QsSUFBSSxDQUFDTSxjQUFjLEdBQUcsSUFBSW1QLGtCQUFzQixDQUFDLElBQUksQ0FBQ3pQLEtBQUssQ0FBQzFXLElBQUksRUFBRSxJQUFJLENBQUN3WixPQUFPLEVBQUUsQ0FBQztNQUNuRjtNQUNBLElBQUksSUFBSSxDQUFDN0MsUUFBUSxJQUFJLElBQUksQ0FBQ0ssY0FBYyxFQUFFO1FBQ3hDLElBQUksQ0FBQ0EsY0FBYyxDQUFDVyxTQUFTLENBQUMsSUFBSSxDQUFDaUosVUFBVSxFQUFFLElBQUksQ0FBQ2pLLFFBQVEsQ0FBQyxDQUMxRHQ3QixLQUFLLENBQUMsVUFBQWlHLEdBQUcsRUFBSTtVQUNabkksU0FBSyxDQUFDb2hCLDJCQUFJLHVEQUFnRGpaLEdBQUcsRUFBRztVQUNoRSxNQUFJLENBQUM2YixPQUFPLENBQUMsSUFBSWxFLGNBQWMsQ0FBQ3ZELHVCQUF1QixDQUFDRSxhQUFhLEVBQUUsTUFBSSxDQUFDLENBQUM7UUFDL0UsQ0FBQyxDQUFDO01BQ047TUFDQSxPQUFPLElBQUk7SUFDYjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsK0JBQXVCcGMsT0FBTyxFQUFFO01BQUE7TUFDOUJvRyxNQUFNLENBQUNtb0MsV0FBVyxHQUFHLFVBQUNqSixTQUFTLEVBQUs7UUFDbEM7UUFDQTdsQyxTQUFLLENBQUNzaEIsMkJBQUksc0VBQStEdWtCLFNBQVMsUUFBSztRQUN2RnRsQyxPQUFPLENBQUNGLE9BQU8sQ0FBQyxNQUFJLENBQUM7UUFDckIsTUFBSSxDQUFDNmpCLE9BQU8sQ0FBQyxJQUFJbEUsY0FBYyxDQUFDdkQsdUJBQXVCLENBQUNDLGFBQWEsRUFBRSxNQUFJLENBQUMsQ0FBQztRQUM3RSxNQUFJLENBQUNxeUIsd0JBQXdCLEVBQUU7TUFDakMsQ0FBQztNQUNEO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLG9DQUE0QjtNQUMxQnBvQyxNQUFNLENBQUNtb0MsV0FBVyxHQUFHN3ZDLFNBQVM7SUFDaEM7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLG9DQUE0QjtNQUFBO01BQzFCLElBQU1nTSxFQUFFLEdBQUcsSUFBSSxDQUFDeXlCLFFBQVEsQ0FBQy9KLFVBQVU7TUFDbkMsSUFBTXFVLFFBQVEsR0FBRyxTQUFYQSxRQUFRLENBQUlyMEIsS0FBSyxFQUFLO1FBQzFCLE9BQU8sQ0FBQyxXQUFXLEVBQUVBLEtBQUssRUFBRTFJLEVBQUUsQ0FBQzNDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzRNLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDQSxJQUFJLENBQUMsR0FBRyxDQUFDO01BQ2hFLENBQUM7TUFDRHZPLE1BQU0sQ0FBQ3FoQyxRQUFRLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxHQUFHLFlBQU07UUFDN0MsTUFBSSxDQUFDOWpCLE9BQU8sQ0FBQyxJQUFJbEUsY0FBYyxDQUFDNUYsbUJBQW1CLENBQUNlLGlCQUFpQixFQUFFLE1BQUksQ0FBQyxDQUFDO01BQy9FLENBQUM7TUFDRHhVLE1BQU0sQ0FBQ3FoQyxRQUFRLENBQUMscUJBQXFCLENBQUMsQ0FBQyxHQUFHO1FBQUEsT0FBTSxNQUFJLENBQUM5akIsT0FBTyxDQUFDLElBQUlsRSxjQUFjLENBQUM1RixtQkFBbUIsQ0FBQ0UsZUFBZSxFQUFFLE1BQUksQ0FBQyxDQUFDO01BQUE7TUFDM0gzVCxNQUFNLENBQUNxaEMsUUFBUSxDQUFDLHVCQUF1QixDQUFDLENBQUMsR0FBRztRQUFBLE9BQU0sTUFBSSxDQUFDOWpCLE9BQU8sQ0FBQyxJQUFJbEUsY0FBYyxDQUFDNUYsbUJBQW1CLENBQUNPLGlCQUFpQixFQUFFLE1BQUksQ0FBQyxDQUFDO01BQUE7TUFDL0hoVSxNQUFNLENBQUNxaEMsUUFBUSxDQUFDLG1CQUFtQixDQUFDLENBQUMsR0FBRyxZQUFNO1FBQzVDLE1BQUksQ0FBQzRHLGNBQWMsQ0FBQ3Z1QyxPQUFPLENBQUMsTUFBSSxDQUFDO1FBQ2pDLE1BQUksQ0FBQzZqQixPQUFPLENBQUMsSUFBSWxFLGNBQWMsQ0FBQzVGLG1CQUFtQixDQUFDSSxhQUFhLEVBQUUsTUFBSSxDQUFDLENBQUM7TUFDM0UsQ0FBQztNQUNEN1QsTUFBTSxDQUFDcWhDLFFBQVEsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLEdBQUcsVUFBQzNTLFFBQVE7UUFBQSxPQUFLLE1BQUksQ0FBQ25SLE9BQU8sQ0FBQyxJQUFJbEUsY0FBYyxDQUFDNUYsbUJBQW1CLENBQUNRLGdCQUFnQixFQUFFLE1BQUksRUFBRXlhLFFBQVEsQ0FBQyxDQUFDO01BQUE7TUFDL0kxdUIsTUFBTSxDQUFDcWhDLFFBQVEsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDLEdBQUcsVUFBQ3BrQyxJQUFJO1FBQUEsT0FBSyxNQUFJLENBQUNzZ0IsT0FBTyxDQUFDLElBQUlsRSxjQUFjLENBQUM1RixtQkFBbUIsQ0FBQ1csOEJBQThCLEVBQUUsTUFBSSxFQUFFblgsSUFBSSxDQUFDLENBQUM7TUFBQTtNQUMzSitDLE1BQU0sQ0FBQ3FoQyxRQUFRLENBQUMsMEJBQTBCLENBQUMsQ0FBQyxHQUFHLFVBQUNwa0MsSUFBSTtRQUFBLE9BQUssTUFBSSxDQUFDc2dCLE9BQU8sQ0FBQyxJQUFJbEUsY0FBYyxDQUFDNUYsbUJBQW1CLENBQUNZLDRCQUE0QixFQUFFLE1BQUksRUFBRXBYLElBQUksQ0FBQyxDQUFDO01BQUE7TUFDdkorQyxNQUFNLENBQUNxaEMsUUFBUSxDQUFDLDBCQUEwQixDQUFDLENBQUMsR0FBRyxVQUFDcGtDLElBQUk7UUFBQSxPQUFLLE1BQUksQ0FBQ3NnQixPQUFPLENBQUMsSUFBSWxFLGNBQWMsQ0FBQzVGLG1CQUFtQixDQUFDYSw0QkFBNEIsRUFBRSxNQUFJLEVBQUVyWCxJQUFJLENBQUMsQ0FBQztNQUFBO01BQ3ZKK0MsTUFBTSxDQUFDcWhDLFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLEdBQUcsWUFBTTtRQUM5QyxNQUFJLENBQUM0RyxjQUFjLENBQUN0dUMsTUFBTSxDQUFDOFosbUJBQW1CLENBQUNHLGVBQWUsQ0FBQztRQUMvRCxNQUFJLENBQUMySixPQUFPLENBQUMsSUFBSWxFLGNBQWMsQ0FBQzVGLG1CQUFtQixDQUFDRyxlQUFlLEVBQUUsTUFBSSxDQUFDLENBQUM7TUFDN0UsQ0FBQztNQUNENVQsTUFBTSxDQUFDcWhDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLEdBQUcsWUFBTTtRQUMzQyxNQUFJLENBQUM0RyxjQUFjLENBQUN0dUMsTUFBTSxDQUFDOFosbUJBQW1CLENBQUNLLFlBQVksQ0FBQztRQUM1RCxNQUFJLENBQUN5SixPQUFPLENBQUMsSUFBSWxFLGNBQWMsQ0FBQzVGLG1CQUFtQixDQUFDSyxZQUFZLEVBQUUsTUFBSSxDQUFDLENBQUM7TUFDMUUsQ0FBQztNQUNEOVQsTUFBTSxDQUFDcWhDLFFBQVEsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDLEdBQUUsWUFBTTtRQUNqRCxNQUFJLENBQUM0RyxjQUFjLENBQUN0dUMsTUFBTSxDQUFDOFosbUJBQW1CLENBQUNNLG9CQUFvQixDQUFDO1FBQ3BFLE1BQUksQ0FBQ3dKLE9BQU8sQ0FBQyxJQUFJbEUsY0FBYyxDQUFDNUYsbUJBQW1CLENBQUNNLG9CQUFvQixFQUFFLE1BQUksQ0FBQyxDQUFDO01BQ2xGLENBQUM7SUFDSDs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEsY0FBTS9ZLE9BQU8sRUFBRTtNQUNiLElBQU0rbEIsSUFBSSxHQUFHLElBQUk7TUFDakIsSUFBTWxTLFFBQVEsR0FBRyxJQUFJM1UsZUFBZSxFQUFFO01BQ3RDLElBQU0rRyxPQUFPLEdBQUdqRyxPQUFPLENBQUNzaUMsZUFBZSxJQUFJckgscUNBQWMsQ0FBQ3FILGVBQWU7TUFDekUsSUFBSSxDQUFDcjBCLE9BQVcsQ0FBQzlFLG9CQUFvQixDQUFDbEQsT0FBTyxDQUFDLEVBQUU7UUFDOUM0TixRQUFRLENBQUNsVixNQUFNLDhGQUF1RnNILE9BQU8sRUFBRztNQUNsSCxDQUFDLE1BQ0k7UUFDSCxJQUFJLENBQUM4MUIsUUFBUSxHQUFHbnFCLE1BQU0sQ0FBQ21uQixNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUVrQyxxQ0FBYyxFQUFFajdCLE9BQU8sQ0FBQztRQUMxRCxJQUFJO1VBQ0ZpTyxPQUFXLENBQUM1RCxZQUFZLENBQUMsSUFBSSxDQUFDMHhCLFFBQVEsQ0FBQzRKLFlBQVksQ0FBQyxDQUNqRHBsQyxJQUFJLENBQUMsWUFBTTtZQUNWbEMsU0FBSyxDQUFDc2hCLDJCQUFJLEVBQUUscUJBQXFCLENBQUM7WUFDbEMsSUFBSW9HLElBQUksQ0FBQ3FXLGNBQWMsRUFBRTtjQUN2Qi85QixTQUFLLENBQUNzaEIsMkJBQUksRUFBRSw4QkFBOEIsQ0FBQztjQUMzQyxPQUFPb0csSUFBSSxDQUFDcVcsY0FBYyxDQUFDVyxTQUFTLENBQUNoWCxJQUFJLENBQUNpZ0IsVUFBVSxFQUFFamdCLElBQUksQ0FBQ2dXLFFBQVEsQ0FBQztZQUN0RSxDQUFDLE1BQU07Y0FDTDE5QixTQUFLLENBQUNzaEIsMkJBQUksRUFBRSxrQ0FBa0MsQ0FBQztjQUMvQyxPQUFPLElBQUk7WUFDYjtVQUNGLENBQUMsQ0FBQyxDQUNEcGYsSUFBSSxDQUFDLFlBQU07WUFDVndsQixJQUFJLENBQUNrWixrQkFBa0IsQ0FBQ2xaLElBQUksQ0FBQytWLEtBQUssRUFBRS9WLElBQUksQ0FBQ2dXLFFBQVEsQ0FBQ1osY0FBYyxDQUFDO1lBQ2pFdG5CLFFBQVEsQ0FBQ25WLE9BQU8sQ0FBQ3FuQixJQUFJLENBQUM7VUFDeEIsQ0FBQyxDQUFDLENBQ0R0bEIsS0FBSyxDQUFDLFVBQUFpRyxHQUFHLEVBQUk7WUFDWm5JLFNBQUssQ0FBQ29oQiwyQkFBSSxnRUFBeURqWixHQUFHLEVBQUc7WUFDekUsSUFBSXFmLElBQUksQ0FBQ3FXLGNBQWMsRUFBRTtjQUN2QnJXLElBQUksQ0FBQ3FXLGNBQWMsQ0FBQzhCLFVBQVUsRUFBRTtZQUNsQztZQUNBcnFCLFFBQVEsQ0FBQ2xWLE1BQU0sQ0FBQytILEdBQUcsQ0FBQztZQUNwQnFmLElBQUksQ0FBQ3hELE9BQU8sQ0FBQyxJQUFJbEUsY0FBYyxDQUFDdkQsdUJBQXVCLENBQUNFLGFBQWEsRUFBRStLLElBQUksQ0FBQyxDQUFDO1VBQy9FLENBQUMsQ0FBQztRQUNOLENBQUMsQ0FBQyxPQUFPampCLENBQUMsRUFBRTtVQUNWK1EsUUFBUSxDQUFDbFYsTUFBTSx5RUFBa0VtRSxDQUFDLENBQUNyRyxPQUFPLEVBQUc7VUFDN0ZzcEIsSUFBSSxDQUFDeEQsT0FBTyxDQUFDLElBQUlsRSxjQUFjLENBQUN2RCx1QkFBdUIsQ0FBQ0UsYUFBYSxFQUFFK0ssSUFBSSxDQUFDLENBQUM7UUFDL0U7TUFDRjtNQUNBLE9BQU9sUyxRQUFRLENBQUNqVixPQUFPO0lBQ3pCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFWRTtJQUFBO0lBQUEsT0FXQSxtQkFBc0Q7TUFBQTtNQUFBLElBQTdDb3pCLFVBQVUsdUVBQUcxMEIsU0FBUztNQUFBLElBQUVzQixPQUFPLHVFQUFHdEIsU0FBUztNQUFJO01BQ3RELElBQU1nTixHQUFHLEdBQUcxTCxPQUFPLElBQUksSUFBSU0sZUFBZSxFQUFFO01BQzVDLElBQUksQ0FBQ211QyxxQkFBcUIsQ0FBQy9pQyxHQUFHLENBQUM7TUFDL0IsSUFBSSxDQUFDeXhCLFFBQVEsQ0FBQy9KLFVBQVUsR0FBR0EsVUFBVSxJQUFJLElBQUksQ0FBQytKLFFBQVEsQ0FBQy9KLFVBQVU7TUFDakUsSUFBTThaLGNBQWMsR0FBRyxJQUFJLENBQUMvUCxRQUFRO01BQ3BDLElBQUk7UUFDRixJQUFJdVIsVUFBVSxHQUFHLElBQUksQ0FBQ2xSLGNBQWM7UUFDcEMsSUFBSSxDQUFDQSxjQUFjLENBQUNtUixpQkFBaUIsRUFBRSxDQUNwQ2h0QyxJQUFJLENBQUMsWUFBTTtVQUNWbEMsU0FBSyxDQUFDc2hCLDJCQUFJLEVBQUUsMEJBQTBCLENBQUM7VUFDdkMsSUFBTWxYLEVBQUUsR0FBR3dGLE9BQVcsQ0FBQzlDLGNBQWMsQ0FBQyxNQUFJLENBQUM2NkIsVUFBVSxDQUFDO1VBQ3RELElBQUl2OUIsRUFBRSxFQUFFO1lBQ04sTUFBSSxDQUFDbStCLHdCQUF3QixFQUFFO1VBQ2pDO1VBQ0EsSUFBSTRHLEtBQUssR0FBRyxDQUFDO1VBQ2IsSUFBTUMsS0FBSyxHQUFHLEdBQUc7VUFDakIsSUFBSUMsVUFBVSxHQUFHLFNBQWJBLFVBQVUsR0FBZTtZQUMzQixJQUFJM2MsT0FBTztZQUNYQSxPQUFPLEdBQUc5cEIsVUFBVSxDQUFDLFlBQU07Y0FDekIsSUFBSTtnQkFDRnNlLFlBQVksQ0FBQ3dMLE9BQU8sQ0FBQztnQkFDckJ1YyxVQUFVLENBQUN4SSxPQUFPLENBQUNsaUMsSUFBSSxDQUFDNE8sU0FBUyxDQUFDczZCLGNBQWMsQ0FBQyxDQUFDO2NBQ3BELENBQUMsQ0FBQyxPQUFPaHBDLENBQUMsRUFBRTtnQkFDVixJQUFJMHFDLEtBQUssRUFBRSxHQUFHQyxLQUFLLEVBQUU7a0JBQ25CLE1BQU0zcUMsQ0FBQztnQkFDVCxDQUFDLE1BQU07a0JBQ0w0cUMsVUFBVSxFQUFFO2dCQUNkO2NBQ0Y7WUFDRixDQUFDLEVBQUUsR0FBRyxDQUFDO1VBQ1QsQ0FBQztVQUNEQSxVQUFVLEVBQUU7UUFDZCxDQUFDLENBQUMsQ0FDRGp0QyxLQUFLLENBQUMsVUFBQWlHLEdBQUcsRUFBSTtVQUNaNEQsR0FBRyxDQUFDM0wsTUFBTSxDQUFDK0gsR0FBRyxDQUFDO1VBQ2YsTUFBSSxDQUFDNmIsT0FBTyxDQUFDLElBQUlsRSxjQUFjLENBQUM1RixtQkFBbUIsQ0FBQ0csZUFBZSxFQUFFLE1BQUksQ0FBQyxDQUFDO1FBQzdFLENBQUMsQ0FBQztNQUNOLENBQUMsQ0FBQyxPQUFPOVYsQ0FBQyxFQUFFO1FBQ1Z2RSxTQUFLLENBQUNvaEIsMkJBQUksRUFBRSx1QkFBdUIsQ0FBQztRQUNwQ3JWLEdBQUcsQ0FBQzNMLE1BQU0sMkRBQW9EbUUsQ0FBQyxDQUFDckcsT0FBTyxFQUFHO1FBQzFFLElBQUksQ0FBQzhsQixPQUFPLENBQUMsSUFBSWxFLGNBQWMsQ0FBQzVGLG1CQUFtQixDQUFDRyxlQUFlLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDM0UsSUFBSSxDQUFDdzBCLHdCQUF3QixFQUFFO01BQ2pDO01BQ0EsSUFBSSxDQUFDSCxjQUFjLEdBQUczaUMsR0FBRztNQUN6QixPQUFPQSxHQUFHLENBQUMxTCxPQUFPO0lBQ3BCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUxFO0lBQUE7SUFBQSxPQU1BLHFCQUFhO01BQ1gsSUFBTWlWLFFBQVEsR0FBRyxJQUFJM1UsZUFBZSxFQUFFO01BQ3RDLElBQUk7UUFDRitPLE9BQVcsQ0FBQzlDLGNBQWMsQ0FBQyxJQUFJLENBQUM2NkIsVUFBVSxDQUFDLENBQUNwRyxTQUFTLEVBQUU7UUFDdkQvckIsUUFBUSxDQUFDblYsT0FBTyxFQUFFO01BQ3BCLENBQUMsQ0FDRCxPQUFPb0UsQ0FBQyxFQUFFO1FBQ1J2RSxTQUFLLENBQUNvaEIsMkJBQUkseURBQWtEN2MsQ0FBQyxDQUFDckcsT0FBTyxFQUFHO1FBQ3hFb1gsUUFBUSxDQUFDbFYsTUFBTSxDQUFDbUUsQ0FBQyxDQUFDckcsT0FBTyxDQUFDO01BQzVCO01BQ0EsSUFBSSxDQUFDd3dDLGNBQWMsR0FBRzN2QyxTQUFTO01BQy9CLE9BQU91VyxRQUFRLENBQUNqVixPQUFPO0lBQ3pCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQRTtJQUFBO0lBQUEsT0FRQSxjQUFNb04sVUFBVSxFQUFFL0osSUFBSSxFQUFFO01BQ3RCLElBQUksQ0FBQ202QixjQUFjLENBQUNqSyxJQUFJLENBQUNubUIsVUFBVSxFQUFFLE9BQU8vSixJQUFJLEtBQUssUUFBUSxHQUFHQSxJQUFJLEdBQUdXLElBQUksQ0FBQzRPLFNBQVMsQ0FBQ3ZQLElBQUksQ0FBQyxDQUFDO0lBQzlGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQRTtJQUFBO0lBQUEsT0FRQSx5QkFBaUIyL0IsT0FBTyxFQUFFO01BQ3hCLElBQUksSUFBSSxDQUFDeEYsY0FBYyxFQUFFO1FBQ3ZCLElBQUksQ0FBQ0EsY0FBYyxDQUFDdVIsZUFBZSxDQUFDL0wsT0FBTyxDQUFDO01BQzlDO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLHdCQUFnQmdNLFVBQVUsRUFBRTtNQUMxQixJQUFJLENBQUM3UixRQUFRLEdBQUducUIsTUFBTSxDQUFDbW5CLE1BQU0sQ0FBQyxJQUFJLENBQUNnRCxRQUFRLEVBQUU2UixVQUFVLENBQUM7SUFDMUQ7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLHlCQUFpQjtNQUNmLE9BQU8sSUFBSSxDQUFDeFIsY0FBYztJQUM1Qjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0Esc0JBQWM7TUFDWixPQUFPLElBQUksQ0FBQ0wsUUFBUTtJQUN0Qjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsbUJBQVc7TUFDVCxPQUFPb1EsWUFBWSxDQUFDbFMsSUFBSSxDQUFDZ0gsV0FBVyxFQUFFO0lBQ3hDO0VBQUM7RUFBQTtBQUFBLEVBaFR5QmhnQyxhQUFZO0FBb1R6QityQyxxRkFBYSxFOztBQ3JWaEI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRThCO0FBQ0k7QUFDVjtBQUVwQyxJQUFNcnRCLHNCQUFJLEdBQUcsc0JBQXNCOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BLElBT01rdUIsdUNBQXFCO0VBQUE7RUFBQTtFQUV6QiwrQkFBYTdkLFNBQVMsRUFBRTtJQUFBO0lBQUEseUJBQ2hCQSxTQUFTLEVBQUVyUSxzQkFBSTtFQUN2Qjs7RUFFQTtBQUNGO0FBQ0E7RUFGRTtJQUFBO0lBQUEsT0FHQSxpQkFBU2xqQixPQUFPLEVBQUU7TUFDaEIsSUFBSUEsT0FBTyxDQUFDd0YsSUFBSSxFQUFFO1FBQ2hCLElBQUlxd0IsSUFBSSxHQUFHLElBQUksQ0FBQ0Msd0JBQXdCLENBQUM5MUIsT0FBTyxDQUFDO1FBQ2pELElBQUksQ0FBQyxxSEFBY0EsT0FBTyxDQUFDLEVBQUU7VUFDM0IsSUFBSTYxQixJQUFJLENBQUNyd0IsSUFBSSxLQUFLM0UsU0FBUyxFQUFFO1lBQzNCLElBQUlnMUIsSUFBSSxDQUFDcndCLElBQUksQ0FBQzRTLEdBQUcsS0FBS3ZYLFNBQVMsRUFBRTtjQUMvQixJQUFJZzFCLElBQUksQ0FBQ3J3QixJQUFJLENBQUM0UyxHQUFHLENBQUNuWCxJQUFJLEtBQUssUUFBUSxFQUFFO2dCQUNuQyxJQUFJLENBQUN1eUIsVUFBVSxDQUFDNmQsV0FBVyxDQUFDeGIsSUFBSSxDQUFDcndCLElBQUksQ0FBQztnQkFDdEMsT0FBTyxJQUFJO2NBQ2I7WUFDRjtZQUNBLElBQUlxd0IsSUFBSSxDQUFDcndCLElBQUksQ0FBQ2l3QixTQUFTLEtBQUs1MEIsU0FBUyxFQUFFO2NBQ3JDLElBQUlxVSxhQUFhLENBQUMyZ0IsSUFBSSxDQUFDcndCLElBQUksQ0FBQ2l3QixTQUFTLENBQUMsRUFBRTtnQkFDdEMsSUFBSSxDQUFDakMsVUFBVSxDQUFDZ0QsZ0JBQWdCLEVBQUU7Z0JBQ2xDLE9BQU8sSUFBSTtjQUNiLENBQUMsTUFBTTtnQkFDTCxJQUFJLENBQUNoRCxVQUFVLENBQUNpRCxpQkFBaUIsQ0FBQ1osSUFBSSxDQUFDcndCLElBQUksQ0FBQ2l3QixTQUFTLENBQUM7Z0JBQ3RELE9BQU8sSUFBSTtjQUNiO1lBQ0Y7WUFDQSxJQUFJSSxJQUFJLENBQUNyd0IsSUFBSSxDQUFDdkUsSUFBSSxLQUFLLFFBQVEsRUFBRTtjQUMvQixJQUFJNDBCLElBQUksQ0FBQ3J3QixJQUFJLENBQUM4bUIsSUFBSSxLQUFLLG1DQUFtQyxJQUN2RHVKLElBQUksQ0FBQ3J3QixJQUFJLENBQUM4bUIsSUFBSSxLQUFLLG9DQUFvQyxFQUFFO2dCQUMxRCxJQUFJLENBQUNrSCxVQUFVLENBQUNrRCx1QkFBdUIsRUFBRTtjQUMzQyxDQUFDLE1BQU0sSUFBSWIsSUFBSSxDQUFDcndCLElBQUksQ0FBQzhtQixJQUFJLEtBQUssc0NBQXNDLEVBQUU7Z0JBQ3BFLElBQUksQ0FBQ2tILFVBQVUsQ0FBQzhkLHVCQUF1QixDQUFDemIsSUFBSSxDQUFDcndCLElBQUksQ0FBQztjQUNwRCxDQUFDLE1BQU0sSUFBSXF3QixJQUFJLENBQUNyd0IsSUFBSSxDQUFDOG1CLElBQUksS0FBSyxvQ0FBb0MsRUFBRTtnQkFDbEUsSUFBSSxDQUFDa0gsVUFBVSxDQUFDK2QscUJBQXFCLENBQUMxYixJQUFJLENBQUNyd0IsSUFBSSxDQUFDO2NBQ2xELENBQUMsTUFBTSxJQUFJcXdCLElBQUksQ0FBQ3J3QixJQUFJLENBQUM4bUIsSUFBSSxLQUFLLG9DQUFvQyxFQUFFO2dCQUNsRSxJQUFJLENBQUNrSCxVQUFVLENBQUNnZSxxQkFBcUIsQ0FBQzNiLElBQUksQ0FBQ3J3QixJQUFJLENBQUM7Y0FDbEQsQ0FBQyxNQUFNO2dCQUNMLElBQUksQ0FBQ2d1QixVQUFVLENBQUNpZSxpQkFBaUIsQ0FBQzViLElBQUksQ0FBQ3J3QixJQUFJLENBQUM7Z0JBQzVDLE9BQU8sSUFBSTtjQUNiO1lBQ0Y7WUFDQSxJQUFJcXdCLElBQUksQ0FBQzUwQixJQUFJLEtBQUtKLFNBQVMsSUFBSWcxQixJQUFJLENBQUM1MEIsSUFBSSxDQUFDa0ssV0FBVyxFQUFFLEtBQUssVUFBVSxFQUFFO2NBQ25FO2NBQ0EsSUFBSTBxQixJQUFJLENBQUMxQyxNQUFNLEtBQUt0eUIsU0FBUyxFQUFFO2dCQUM3QixJQUFJLENBQUMyeUIsVUFBVSxDQUFDdUQsY0FBYyxDQUFDbEIsSUFBSSxDQUFDMUMsTUFBTSxFQUFFMEMsSUFBSSxDQUFDcndCLElBQUksQ0FBQztnQkFDdEQsT0FBTyxJQUFJO2NBQ2IsQ0FBQyxNQUFNO2dCQUNMLElBQUksQ0FBQ2d1QixVQUFVLENBQUN3RCxVQUFVLENBQUNuQixJQUFJLENBQUNyd0IsSUFBSSxDQUFDO2dCQUNyQyxPQUFPLElBQUk7Y0FDYjtZQUNKO1VBQ0Y7VUFDQSxJQUFJLENBQUNndUIsVUFBVSxDQUFDMEQsZUFBZSxDQUFDLElBQUksRUFBRWwzQixPQUFPLENBQUM7UUFDaEQ7TUFDRixDQUFDLE1BQU07UUFDTDZCLFFBQUksQ0FBQ3FoQixzQkFBSSxFQUFFLG1DQUFtQyxDQUFDO01BQ2pEO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEsdUJBQWVxUyxVQUFVLEVBQUU7TUFDekIsSUFBSSxJQUFJLENBQUM3QixVQUFVLEtBQUs3eUIsU0FBUyxJQUFJLElBQUksQ0FBQ296QixVQUFVLEtBQUssQ0FBQyxFQUFFO1FBQzFELE9BQU8sS0FBSztNQUNkO01BQ0EsSUFBSSxDQUFDcEIsSUFBSSxDQUFDO1FBQ1JzUSxTQUFTLEVBQUU1TjtNQUNiLENBQUMsQ0FBQztNQUNGLE9BQU8sSUFBSTtJQUNiOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUxFO0lBQUE7SUFBQSxPQU1BLG9CQUFZbWMsS0FBSyxFQUFFbmMsVUFBVSxFQUFFO01BQzdCLElBQUksSUFBSSxDQUFDN0IsVUFBVSxLQUFLN3lCLFNBQVMsSUFBSSxJQUFJLENBQUNvekIsVUFBVSxLQUFLLENBQUMsRUFBRTtRQUMxRCxPQUFPLEtBQUs7TUFDZDtNQUNBcnlCLFNBQUssQ0FBQ3NoQixzQkFBSSxnQ0FBZ0M7TUFDMUMsT0FBTyxJQUFJLENBQUMyUCxJQUFJLENBQUM7UUFDZjhlLFVBQVUsRUFBRUQsS0FBSztRQUNqQm5jLFVBQVUsRUFBRUE7TUFDZCxDQUFDLENBQUM7SUFDSjtFQUFDO0VBQUE7QUFBQSxFQTdGaUNqQyxhQUFZO0FBaUdqQzhkLDZGQUFxQixFOztBQ2hIeEI7O0FBQUE7QUFBQSxnRUFDWjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTJDO0FBQ0g7QUFDTTtBQUNHO0FBQ2I7QUFFcEMsSUFBTWx1QixzQkFBSSxHQUFHLGtCQUFrQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBLElBS00wdUIscUNBQW1CO0VBQUE7RUFBQTtFQUN2Qiw2QkFBWXJlLFNBQVMsRUFBRTtJQUFBO0lBQUEseUJBQ2ZBLFNBQVMsRUFBRXJRLHNCQUFJO0VBQ3ZCOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0EsbUNBQTBCeVUsVUFBVSxFQUFFO01BQ3BDQSxVQUFVLENBQUN5Qix1QkFBdUIsR0FBR3Y0QixTQUFTO01BQzlDODJCLFVBQVUsQ0FBQzBCLDBCQUEwQixHQUFHeDRCLFNBQVM7TUFDakQ4MkIsVUFBVSxDQUFDMkIsY0FBYyxHQUFHejRCLFNBQVM7TUFDckM4MkIsVUFBVSxDQUFDNEIsT0FBTyxHQUFHMTRCLFNBQVM7SUFDaEM7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORTtJQUFBO0lBQUEsT0FPQSxnQ0FBdUI4MkIsVUFBVSxFQUFFeDFCLE9BQU8sRUFBRTtNQUFBO01BQzFDLElBQUlzM0IsZ0JBQWdCO01BQ3BCLElBQU1DLFlBQVksR0FBRyxJQUFJO01BRXpCL0IsVUFBVSxDQUFDNEIsT0FBTyxHQUFHLFVBQUM1MEIsS0FBSyxFQUFLO1FBQzlCL0MsU0FBSyxDQUFDc2hCLHNCQUFJLG1CQUFtQjtRQUM3QjlqQixPQUFPLENBQUNDLEdBQUcsQ0FBQ3NGLEtBQUssQ0FBQztRQUNsQixLQUFJLENBQUM2dUIsVUFBVSxDQUFDcWUsd0JBQXdCLENBQUNsdEMsS0FBSyxDQUFDMEMsS0FBSyxDQUFDO01BQ3ZELENBQUM7TUFFRHN3QixVQUFVLENBQUN5Qix1QkFBdUIsR0FBRyxZQUFNO1FBQ3pDeDNCLFNBQUssQ0FBQ3NoQixzQkFBSSxvREFBNkN5VSxVQUFVLENBQUNnQyxlQUFlLEVBQUc7UUFDcEYsSUFBSWhDLFVBQVUsQ0FBQ2dDLGVBQWUsS0FBSyxXQUFXLEVBQUU7VUFDOUMvM0IsU0FBSyxDQUFDc2hCLHNCQUFJLEVBQUUsdUJBQXVCLENBQUM7VUFDcEMsSUFBSS9nQixPQUFPLEVBQUU7WUFDWEEsT0FBTyxDQUFDRixPQUFPLENBQUMsS0FBSSxDQUFDO1VBQ3ZCLENBQUMsTUFBTTtZQUNMLEtBQUksQ0FBQ3V4QixVQUFVLENBQUNvRyxvQkFBb0IsRUFBRTtVQUN4QztRQUNGLENBQUMsTUFBTSxJQUFJakMsVUFBVSxDQUFDZ0MsZUFBZSxLQUFLLFFBQVEsSUFBSWhDLFVBQVUsQ0FBQ2dDLGVBQWUsS0FBSyxjQUFjLEVBQUU7VUFDbkc5M0IsUUFBSSxDQUFDcWhCLHNCQUFJLEVBQUUsd0JBQXdCLENBQUM7VUFDcEMsSUFBSS9nQixPQUFPLEVBQUU7WUFDWEEsT0FBTyxDQUFDRCxNQUFNLEVBQUU7VUFDbEI7VUFDQSxJQUFJeTFCLFVBQVUsQ0FBQ2dDLGVBQWUsS0FBSyxRQUFRLEVBQUU7WUFDM0MsS0FBSSxDQUFDbkcsVUFBVSxDQUFDMkcsb0JBQW9CLEVBQUU7VUFDeEM7UUFDRjtNQUNGLENBQUM7TUFFRHhDLFVBQVUsQ0FBQzJCLGNBQWMsR0FBRyxVQUFDMzBCLEtBQUssRUFBSztRQUNyQy9DLFNBQUssQ0FBQ3NoQixzQkFBSSxvREFBNkN2ZSxLQUFLLENBQUM4d0IsU0FBUyxFQUFHO1FBQ3pFLElBQUk5d0IsS0FBSyxDQUFDOHdCLFNBQVMsRUFBRTtVQUNuQixLQUFJLENBQUNqQyxVQUFVLENBQUNxRyxjQUFjLENBQUNsMUIsS0FBSyxDQUFDOHdCLFNBQVMsQ0FBQztRQUNqRCxDQUFDLE1BQU0sSUFBSTl3QixLQUFLLENBQUM4d0IsU0FBUyxLQUFLLElBQUksRUFBRTtVQUNuQztVQUNBO1FBQUE7TUFFSixDQUFDO01BRURrQyxVQUFVLENBQUMwQiwwQkFBMEIsR0FBRyxVQUFDMTBCLEtBQUssRUFBSztRQUNqRCxJQUFNd2lCLEtBQUssR0FBR3dRLFVBQVUsQ0FBQ3NDLGtCQUFrQjtRQUMzQ3I0QixTQUFLLENBQUNzaEIsc0JBQUksdURBQWdEaUUsS0FBSyxFQUFHO1FBQ2xFLElBQUlBLEtBQUssS0FBSyxXQUFXLElBQUkzVixPQUFXLENBQUM1RixTQUFTLEVBQUUsRUFBRTtVQUNwRDtVQUNBO1VBQ0E7VUFDQWhLLFNBQUssQ0FBQ3NoQixzQkFBSSxFQUFFLDZCQUE2QixDQUFDO1VBQzFDLEtBQUksQ0FBQ3NRLFVBQVUsQ0FBQzBHLHVCQUF1QixFQUFFO1FBQzNDLENBQUMsTUFBTSxJQUFJL1MsS0FBSyxLQUFLLFFBQVEsRUFBRTtVQUM3QixJQUFJc1MsZ0JBQWdCLEVBQUU7WUFDcEIzUSxZQUFZLENBQUMyUSxnQkFBZ0IsQ0FBQztVQUNoQztVQUNBLEtBQUksQ0FBQ2pHLFVBQVUsQ0FBQzRHLHFCQUFxQixDQUFDejFCLEtBQUssQ0FBQztRQUM5QyxDQUFDLE1BQU0sSUFBSXdpQixLQUFLLEtBQUssY0FBYyxFQUFFO1VBQ25DO1VBQ0FzUyxnQkFBZ0IsR0FBR2p2QixVQUFVLENBQUMsWUFBTTtZQUNsQzVJLFNBQUssQ0FBQ3NoQixzQkFBSSwyRkFBMkY7WUFDckc0RixZQUFZLENBQUMyUSxnQkFBZ0IsQ0FBQztZQUM5QixLQUFJLENBQUNqRyxVQUFVLENBQUM0RyxxQkFBcUIsQ0FBQ3oxQixLQUFLLENBQUM7VUFDOUMsQ0FBQyxFQUFFKzBCLFlBQVksQ0FBQztRQUNsQixDQUFDLE1BQU07VUFDTCxJQUFJRCxnQkFBZ0IsRUFBRTtZQUNwQjczQixTQUFLLENBQUNzaEIsc0JBQUksd0VBQXdFO1lBQ2xGNEYsWUFBWSxDQUFDMlEsZ0JBQWdCLENBQUM7VUFDaEM7UUFDRjtNQUNGLENBQUM7TUFFRDlCLFVBQVUsQ0FBQ21hLHNCQUFzQixHQUFHLFVBQUNudEMsS0FBSyxFQUFLO1FBQzdDO1FBQ0EsSUFBTXdpQixLQUFLLEdBQUd3USxVQUFVLENBQUNvYSxjQUFjO1FBQ3ZDbndDLFNBQUssQ0FBQ3NoQixzQkFBSSxtREFBNENpRSxLQUFLLEVBQUc7TUFDaEUsQ0FBQztNQUVEd1EsVUFBVSxDQUFDMEMseUJBQXlCLEdBQUcsWUFBTTtRQUMzQyxJQUFNbFQsS0FBSyxHQUFHd1EsVUFBVSxDQUFDMkMsaUJBQWlCO1FBQzFDMTRCLFNBQUssQ0FBQ3NoQixzQkFBSSxzREFBK0NpRSxLQUFLLEVBQUc7UUFDakUsSUFBSUEsS0FBSyxLQUFLLFVBQVUsRUFBRTtVQUN4QixLQUFJLENBQUNxTSxVQUFVLENBQUMwRyx1QkFBdUIsRUFBRTtRQUMzQztNQUNGLENBQUM7TUFFRHZDLFVBQVUsQ0FBQzRDLGNBQWMsR0FBRyxZQUFNO1FBQ2hDMzRCLFNBQUssQ0FBQ3NoQixzQkFBSSwwQkFBMEI7TUFDdEMsQ0FBQztJQUNIOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0EsK0JBQXNCdmUsS0FBSyxFQUFFO01BQzNCLElBQU0zRSxPQUFPLEdBQUcyRSxLQUFLO01BQ3JCLElBQUksaUlBQTRCQSxLQUFLLEdBQUc7UUFDdEMsT0FBTyxJQUFJO01BQ2I7TUFDQSxJQUFJa3hCLElBQUksR0FBRyxJQUFJLENBQUNDLHdCQUF3QixDQUFDOTFCLE9BQU8sQ0FBQztNQUNqRCxJQUFJNjFCLElBQUksS0FBSyxJQUFJLEVBQUU7UUFDakJoMEIsUUFBSSxDQUFDLElBQUksQ0FBQ3VnQixLQUFLLEVBQUUsK0VBQStFLENBQUM7UUFDakcsT0FBTyxJQUFJO01BQ2I7TUFDQXhnQixTQUFLLENBQUMsSUFBSSxDQUFDd2dCLEtBQUssRUFBRSwwQkFBMEIsR0FBR2pjLElBQUksQ0FBQzRPLFNBQVMsQ0FBQzhnQixJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO01BQzdFLElBQVFyd0IsSUFBSSxHQUFLcXdCLElBQUksQ0FBYnJ3QixJQUFJO01BQ1osSUFBSUEsSUFBSSxJQUFJQSxJQUFJLENBQUN2RSxJQUFJLEtBQUssUUFBUSxFQUFFO1FBQ2xDLElBQUl1RSxJQUFJLENBQUM4bUIsSUFBSSxLQUFLLGdDQUFnQyxFQUFFO1VBQ2xELElBQUksQ0FBQ2tILFVBQVUsQ0FBQ21ELFdBQVcsRUFBRTtVQUM3QixPQUFPLElBQUk7UUFDYjtRQUNBLzBCLFNBQUssQ0FBQ3NoQixzQkFBSSw0Q0FBcUMxZCxJQUFJLENBQUM4bUIsSUFBSSxFQUFHO1FBQzNELElBQUksQ0FBQ2tILFVBQVUsQ0FBQ2llLGlCQUFpQixDQUFDanNDLElBQUksQ0FBQztRQUN2QyxPQUFPLElBQUk7TUFDYjtNQUNBLElBQUksQ0FBQ2d1QixVQUFVLENBQUNnSCxvQkFBb0IsQ0FBQyxJQUFJLENBQUNwRCxZQUFZLEVBQUVwM0IsT0FBTyxDQUFDO01BQ2hFLE9BQU8sS0FBSztJQUNkOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVJFO0lBQUE7SUFBQSxPQVNBLHNCQUFhcU8sV0FBVyxFQUFFd0osV0FBVyxFQUFFO01BQ3JDLE9BQU9zZ0IsbUJBQW1CLENBQUM5cEIsV0FBVyxFQUFFd0osV0FBVyxDQUFDO0lBQ3REOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0Esd0JBQWV4SixXQUFXLEVBQUU7TUFDMUIsT0FBTzhwQixxQkFBcUIsQ0FBQzlwQixXQUFXLENBQUM7SUFDM0M7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFaRTtJQUFBO0lBQUEsT0FhQSx1QkFBNEY7TUFBQTtNQUFBLElBQWhGMmpDLFNBQVMsdUVBQUcsSUFBSTtNQUFBLElBQUVDLFFBQVEsdUVBQUcsS0FBSztNQUFBLElBQUVDLGFBQWEsdUVBQUcsS0FBSztNQUFBLElBQUVDLFlBQVksdUVBQUcsSUFBSTtNQUN4RnZ3QyxTQUFLLENBQUNzaEIsc0JBQUksRUFBRSxlQUFlLENBQUM7TUFDNUIsSUFBTXRmLENBQUMsR0FBR3V1QyxZQUFZLElBQUksSUFBSTF2QyxlQUFlLEVBQUU7TUFDL0MsSUFBSSxDQUFDNDBCLGVBQWUsQ0FDakJpVyxXQUFXLEVBQUUsQ0FDYnhwQyxJQUFJLENBQUMsVUFBQ2cxQixrQkFBa0IsRUFBSztRQUM1QixNQUFJLENBQUNDLG1CQUFtQixDQUFDRCxrQkFBa0IsRUFBRWtaLFNBQVMsQ0FBQyxDQUNwRGx1QyxJQUFJLENBQUMsWUFBTTtVQUNWLElBQU1zVSxHQUFHLEdBQUswZ0Isa0JBQWtCLENBQTFCMWdCLEdBQUc7VUFDVCxJQUFJNDVCLFNBQVMsRUFBRTtZQUNiNTVCLEdBQUcsR0FBRytmLGVBQXNCLENBQUM2WixTQUFTLEVBQUU1NUIsR0FBRyxDQUFDO1VBQzlDO1VBQ0E7VUFDQSxJQUFJODVCLGFBQWEsRUFBRTtZQUNqQjk1QixHQUFHLEdBQUcrZixZQUFtQixDQUFDL2YsR0FBRyxDQUFDO1lBQzlCQSxHQUFHLEdBQUcrZixxQkFBNEIsQ0FBQy9mLEdBQUcsQ0FBQztZQUN2Q0EsR0FBRyxHQUFHK2Ysd0JBQStCLENBQUMvZixHQUFHLENBQUM7WUFDMUNBLEdBQUcsR0FBRytmLHdCQUErQixDQUFDL2YsR0FBRyxDQUFDO1VBQzVDO1VBQ0EsSUFBSTY1QixRQUFRLEVBQUU7WUFDWjc1QixHQUFHLEdBQUdBLEdBQUcsQ0FBQ2c2QixVQUFVLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztZQUNwQ3h3QyxTQUFLLENBQUNzaEIsc0JBQUksRUFBRSwyQkFBMkIsQ0FBQztVQUMxQztVQUNBNFYsa0JBQWtCLENBQUMxZ0IsR0FBRyxHQUFHQSxHQUFHO1VBQzVCLE1BQUksQ0FBQ29iLFVBQVUsQ0FBQ2lILFlBQVksRUFBRTtVQUM5QjcyQixDQUFDLENBQUMzQixPQUFPLENBQUM2MkIsa0JBQWtCLENBQUM7UUFDL0IsQ0FBQyxDQUFDLENBQ0Q5MEIsS0FBSyxDQUFDLFVBQUNpRyxHQUFHLEVBQUs7VUFDZCxNQUFJLENBQUN1cEIsVUFBVSxDQUFDa0gsVUFBVSxDQUFDendCLEdBQUcsQ0FBQztVQUMvQnJHLENBQUMsQ0FBQzFCLE1BQU0sQ0FBQytILEdBQUcsQ0FBQztRQUNmLENBQUMsQ0FBQztNQUNOLENBQUMsQ0FBQyxDQUNEakcsS0FBSyxDQUFDLFVBQUNpRyxHQUFHLEVBQUs7UUFDZHJJLFNBQUssQ0FBQ3NoQixzQkFBSSxFQUFFLHFCQUFxQixDQUFDO1FBQ2xDdGYsQ0FBQyxDQUFDMUIsTUFBTSxDQUFDK0gsR0FBRyxDQUFDO01BQ2YsQ0FBQyxDQUFDO01BQ0osT0FBT3JHLENBQUMsQ0FBQ21FLGNBQWMsQ0FBQyxTQUFTLENBQUMsR0FBR25FLENBQUMsQ0FBQ3pCLE9BQU8sR0FBR3lCLENBQUM7SUFDcEQ7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVZFO0lBQUE7SUFBQTtNQUFBLHFFQVdBO1FBQUE7UUFBQSxJQUFpQ291QyxTQUFTLHVFQUFHLElBQUk7UUFBQSxJQUFFQyxRQUFRLHVFQUFHLEtBQUs7UUFBQSxJQUFFQyxhQUFhLHVFQUFHLEtBQUs7UUFBQTtVQUFBO1VBQUE7WUFBQTtjQUFBO2dCQUN4RnR3QyxTQUFLLENBQUNzaEIsc0JBQUksRUFBRSw0QkFBNEIsQ0FBQztnQkFBQTtnQkFBQTtnQkFBQSxPQUVSLE1BQUksQ0FBQ21VLGVBQWUsQ0FBQ2lXLFdBQVcsRUFBRTtjQUFBO2dCQUE3RHhVLGtCQUFrQjtnQkFDaEIxZ0IsR0FBRyxHQUFLMGdCLGtCQUFrQixDQUExQjFnQixHQUFHO2dCQUNULElBQUk0NUIsU0FBUyxFQUFFO2tCQUNiNTVCLEdBQUcsR0FBRytmLGVBQXNCLENBQUM2WixTQUFTLEVBQUU1NUIsR0FBRyxDQUFDO2dCQUM5QztnQkFDQTtnQkFDQSxJQUFJODVCLGFBQWEsRUFBRTtrQkFDakI5NUIsR0FBRyxHQUFHK2YsWUFBbUIsQ0FBQy9mLEdBQUcsQ0FBQztrQkFDOUJBLEdBQUcsR0FBRytmLHFCQUE0QixDQUFDL2YsR0FBRyxDQUFDO2tCQUN2Q0EsR0FBRyxHQUFHK2Ysd0JBQStCLENBQUMvZixHQUFHLENBQUM7a0JBQzFDQSxHQUFHLEdBQUcrZix3QkFBK0IsQ0FBQy9mLEdBQUcsQ0FBQztnQkFDNUM7Z0JBQ0EsSUFBSTY1QixRQUFRLEVBQUU7a0JBQ1o3NUIsR0FBRyxHQUFHQSxHQUFHLENBQUNnNkIsVUFBVSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7a0JBQ3BDeHdDLFNBQUssQ0FBQ3NoQixzQkFBSSxFQUFFLDJCQUEyQixDQUFDO2dCQUMxQztnQkFDQTRWLGtCQUFrQixDQUFDMWdCLEdBQUcsR0FBR0EsR0FBRztnQkFDNUIsTUFBSSxDQUFDb2IsVUFBVSxDQUFDaUgsWUFBWSxFQUFFO2dCQUFBLGlDQUN2QjNCLGtCQUFrQjtjQUFBO2dCQUFBO2dCQUFBO2dCQUV6QmwzQixTQUFLLENBQUNzaEIsc0JBQUksRUFBRSxxQkFBcUIsQ0FBQztnQkFDbEMsTUFBSSxDQUFDc1EsVUFBVSxDQUFDa0gsVUFBVSxhQUFHO2dCQUFBO2NBQUE7Y0FBQTtnQkFBQTtZQUFBO1VBQUE7UUFBQTtNQUFBLENBR2hDO01BQUE7UUFBQTtNQUFBO01BQUE7SUFBQTtJQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUxFO0lBQUE7SUFBQSxPQU1BLHVCQUFjbkYsVUFBVSxFQUFFO01BQ3hCO01BQ0EsSUFBTThjLFFBQVEsR0FBRyxJQUFJLENBQUN4ZixJQUFJLENBQUM7UUFDekJzUSxTQUFTLEVBQUU1TjtNQUNiLENBQUMsQ0FBQztNQUNGM3pCLFNBQUssQ0FBQ3NoQixzQkFBSSxpREFBMENtdkIsUUFBUSxFQUFHO01BQy9ELE9BQU9BLFFBQVE7SUFDakI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEsb0JBQVdYLEtBQUssRUFBRW5jLFVBQVUsRUFBRTtNQUM1QjN6QixTQUFLLENBQUNzaEIsc0JBQUksZ0NBQWdDO01BQzFDLE9BQU8sSUFBSSxDQUFDMlAsSUFBSSxDQUFDO1FBQ2Y4ZSxVQUFVLEVBQUVELEtBQUs7UUFDakJuYyxVQUFVLEVBQUVBO01BQ2QsQ0FBQyxDQUFDO0lBQ0o7RUFBQztFQUFBO0FBQUEsRUFqUytCNEIsYUFBZ0I7QUFvU25DeWEsMkZBQW1CLEU7O0FDbFR0Qjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVvQztBQUNMO0FBQ007QUFDVDtBQUN1QjtBQUNGO0FBQ3BCO0FBQ0E7QUFDNkM7QUFDcEM7QUFDSjtBQUNJO0FBQ087QUFDYTtBQUNyQjtBQUN5QztBQUNoRDtBQUNBO0FBQ0Y7QUFDVDtBQUUvQixJQUFNVSxhQUFhLEdBQUcsZ0JBQWdCO0FBQ3RDLElBQU1DLFlBQVksR0FBRyxnQkFBZ0I7QUFDckMsSUFBTXJ2QiwwQkFBSSxHQUFHLGNBQWM7QUFDM0IsSUFBTXRoQixpQkFBSyxHQUFHLFNBQVJBLEtBQUssQ0FBSTVCLE9BQU8sRUFBSztFQUN6Qnd5QyxTQUFRLENBQUN0dkIsMEJBQUksRUFBRWxqQixPQUFPLENBQUM7QUFDekIsQ0FBQztBQUNELElBQU02QixnQkFBSSxHQUFHLFNBQVBBLElBQUksQ0FBSTdCLE9BQU8sRUFBSztFQUN4Qnl5QyxRQUFPLENBQUN2dkIsMEJBQUksRUFBRWxqQixPQUFPLENBQUM7QUFDeEIsQ0FBQztBQUNELElBQU04QixpQkFBSyxHQUFHLFNBQVJBLEtBQUssQ0FBSTlCLE9BQU8sRUFBSztFQUN6QjB5QyxTQUFRLENBQUN4dkIsMEJBQUksRUFBRWxqQixPQUFPLENBQUM7QUFDekIsQ0FBQzs7QUFFRDtBQUNBLElBQU13K0IsMEJBQWMsR0FBRztFQUNyQjVDLFFBQVEsRUFBRSxLQUFLO0VBQ2ZQLElBQUksRUFBRSxHQUFHO0VBQ1RZLEdBQUcsRUFBRSxNQUFNO0VBQ1hnVCxVQUFVLEVBQUVVLGdCQUFnQixDQUFDQyxJQUFJO0VBQ2pDK0MsWUFBWSxFQUFFLElBQUk7RUFDbEJqVSxjQUFjLEVBQUUsbUJBQW1CO0VBQ25DQyxnQkFBZ0IsRUFBRTtJQUNoQi9HLFVBQVUsRUFBRSxDQUFDO01BQUVnSCxJQUFJLEVBQUU7SUFBZ0MsQ0FBQyxDQUFDO0lBQ3ZENUcsb0JBQW9CLEVBQUUsQ0FBQztJQUN2QkMsWUFBWSxFQUFFO0VBQ2hCLENBQUM7RUFBRTtFQUNITCxVQUFVLEVBQUUvMkIsU0FBUztFQUFFO0VBQ3ZCZytCLFlBQVksRUFBRVYsaUJBQWlCLENBQUNDLEdBQUc7RUFDbkM0VCxTQUFTLEVBQUU7SUFDVDEzQixLQUFLLEVBQUUsRUFBRTtJQUNUN0UsS0FBSyxFQUFFO0VBQ1QsQ0FBQztFQUNEbTlCLHFCQUFxQixFQUFFLEtBQUs7RUFDNUJ4RCxnQkFBZ0IsRUFBRSxJQUFJaUIsa0JBQWtCLEVBQUU7RUFDMUN3QyxjQUFjLEVBQUVoeUMsU0FBUztFQUN6Qm0rQixtQkFBbUIsRUFBRSxJQUFJO0VBQ3pCdkcsd0JBQXdCLEVBQUU1M0IsU0FBUztFQUNuQ294QyxRQUFRLEVBQUUsS0FBSztFQUNmaFQsaUJBQWlCLEVBQUUsSUFBSTtFQUN2QkMsZUFBZSxFQUFFO0FBQ25CLENBQUM7QUFFRCxJQUFNNFQsNkJBQTZCLEdBQUcsU0FBaENBLDZCQUE2QixDQUFJOXhDLE1BQU0sRUFBSztFQUNoRCxJQUFJcU4sV0FBVyxHQUFHO0lBQUVpTSxLQUFLLEVBQUUsS0FBSztJQUFFN0UsS0FBSyxFQUFFO0VBQU0sQ0FBQztFQUNoRCxJQUFJczBCLFFBQVEsR0FBRztJQUFFenZCLEtBQUssRUFBRSxLQUFLO0lBQUU3RSxLQUFLLEVBQUU7RUFBTSxDQUFDO0VBQzdDelUsTUFBTSxDQUFDK3hDLFNBQVMsRUFBRSxDQUFDbnJDLE9BQU8sQ0FBQyxVQUFDUCxLQUFLLEVBQUs7SUFDcEMsSUFBSUEsS0FBSyxDQUFDMnJDLElBQUksS0FBSyxPQUFPLEVBQUU7TUFDMUJqSixRQUFRLENBQUN0MEIsS0FBSyxHQUFHcE8sS0FBSyxDQUFDNHJDLFdBQVcsRUFBRTtNQUNwQzVrQyxXQUFXLENBQUNvSCxLQUFLLEdBQUdwTyxLQUFLLENBQUM2ckMsY0FBYyxFQUFFO0lBQzVDLENBQUMsTUFBTSxJQUFJN3JDLEtBQUssQ0FBQzJyQyxJQUFJLEtBQUssT0FBTyxFQUFFO01BQ2pDakosUUFBUSxDQUFDenZCLEtBQUssR0FBR2pULEtBQUssQ0FBQzRyQyxXQUFXLEVBQUU7TUFDcEM1a0MsV0FBVyxDQUFDaU0sS0FBSyxHQUFHalQsS0FBSyxDQUFDNnJDLGNBQWMsRUFBRTtJQUM1QztFQUNGLENBQUMsQ0FBQztFQUNGLE9BQU87SUFBRUMsU0FBUyxFQUFFOWtDLFdBQVc7SUFBRStrQyxRQUFRLEVBQUVySjtFQUFTLENBQUM7QUFDdkQsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkEsSUFLTXNKLHdCQUFZO0VBQUE7RUFBQTtFQUNoQix3QkFBYztJQUFBO0lBQUE7SUFDWjtJQUNBLE1BQUsvVCxRQUFRLEdBQUd6K0IsU0FBUztJQUN6QixNQUFLdytCLEtBQUssR0FBR3grQixTQUFTO0lBQ3RCLE1BQUswK0IsV0FBVyxHQUFHMStCLFNBQVM7SUFDNUIsTUFBSzIrQixhQUFhLEdBQUczK0IsU0FBUztJQUM5QixNQUFLNCtCLGlCQUFpQixHQUFHNStCLFNBQVM7SUFDbEMsTUFBSysrQixZQUFZLEdBQUcvK0IsU0FBUztJQUM3QixNQUFLcS9CLHFCQUFxQixHQUFHci9CLFNBQVM7SUFFdEMsTUFBS3l5QyxhQUFhLEdBQUd6eUMsU0FBUztJQUM5QixNQUFLMHlDLGdCQUFnQixHQUFHMXlDLFNBQVM7SUFDakMsTUFBSzJ5QyxXQUFXLEdBQUczeUMsU0FBUztJQUM1QixNQUFLNHlDLFlBQVksR0FBRzV5QyxTQUFTO0lBQzdCLE1BQUs2eUMsZ0JBQWdCLEdBQUc3eUMsU0FBUztJQUNqQyxNQUFLOHlDLGlCQUFpQixHQUFHOXlDLFNBQVM7SUFDbEMsTUFBSyt5QyxjQUFjLEdBQUcveUMsU0FBUztJQUMvQixNQUFLZ3pDLGdCQUFnQixHQUFHaHpDLFNBQVM7SUFFakMsTUFBS2l6QyxvQkFBb0IsR0FBRyxNQUFLQSxvQkFBb0IsQ0FBQzd2QixJQUFJLENBQUMsbURBQUs7SUFDaEUsTUFBSzh2QixvQkFBb0IsR0FBRyxNQUFLQyxlQUFlLENBQUMvdkIsSUFBSSxDQUFDLG1EQUFLO0lBQUE7RUFDN0Q7RUFBQztJQUFBO0lBQUEsT0FFRCwyQkFBa0I7TUFDaEIsSUFBSSxDQUFDcXZCLGFBQWEsR0FBRzV3QyxNQUFNLENBQUNKLGdCQUFnQixDQUFDLElBQUksQ0FBQ2d4QyxhQUFhLENBQUM7TUFDaEUsT0FBTyxJQUFJLENBQUNBLGFBQWEsQ0FBQ254QyxPQUFPO0lBQ25DO0VBQUM7SUFBQTtJQUFBLE9BRUQsMEJBQWlCO01BQ2YsT0FBT08sTUFBTSxDQUFDSixnQkFBZ0IsQ0FBQyxJQUFJLENBQUNxeEMsaUJBQWlCLENBQUM7SUFDeEQ7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLGNBQUtwd0MsT0FBTyxFQUFFO01BQUE7TUFDWjtNQUNBLElBQU0wd0MsZ0NBQWdDLEdBQUcsU0FBbkNBLGdDQUFnQyxDQUFJOW1DLFdBQVcsRUFBSztRQUN4RCxJQUFJLENBQUNBLFdBQVcsRUFBRSxPQUFPLEtBQUs7UUFDOUIsSUFBTSttQyxNQUFNLEdBQUcvbUMsV0FBVyxDQUFDNGxDLFNBQVMsRUFBRTtRQUN0QztRQUNBLElBQUltQixNQUFNLElBQUlBLE1BQU0sQ0FBQy93QyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1VBQy9CLE9BQU8rd0MsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDbEIsSUFBSSxLQUFLLE9BQU87UUFDbkM7UUFDQSxPQUFPLEtBQUs7TUFDZCxDQUFDO01BRUQsSUFBSXp2QyxPQUFPLENBQUNzdkMsY0FBYyxLQUFLaHlDLFNBQVMsRUFBRTtRQUN4Q2UsaUJBQUssQ0FBQyxnRUFBZ0UsQ0FBQztRQUN2RTJCLE9BQU8sQ0FDSnN2QyxjQUFjLEVBQUUsQ0FDaEIvdUMsSUFBSSxDQUFDLFVBQUMrUyxLQUFLLEVBQUs7VUFDZixJQUFJbzlCLGdDQUFnQyxDQUFDcDlCLEtBQUssQ0FBQyxFQUFFO1lBQzNDalYsaUJBQUssQ0FBQywyRUFBMkUsQ0FBQztZQUNsRixNQUFJLENBQUN1eUMsSUFBSSxDQUFDNXdDLE9BQU8sQ0FBQztZQUNsQjtVQUNGO1VBQ0EsTUFBSSxDQUFDdWlCLE9BQU8sQ0FDVixJQUFJbEUsY0FBYyxDQUFDeEUsc0JBQXNCLENBQUNDLG9CQUFvQixFQUFFLE1BQUksRUFBRXkxQiw2QkFBNkIsQ0FBQ2o4QixLQUFLLENBQUMsQ0FBQyxDQUM1RztVQUNELE1BQUksQ0FBQ3k4QixhQUFhLENBQUNyeEMsT0FBTyxDQUFDNFUsS0FBSyxDQUFDO1FBQ25DLENBQUMsQ0FBQyxDQUNEN1MsS0FBSyxDQUFDLFVBQUNpRyxHQUFHLEVBQUs7VUFDZG5JLGlCQUFLLG9FQUE2RG1JLEdBQUcsRUFBRztVQUN4RSxNQUFJLENBQUM2YixPQUFPLENBQ1YsSUFBSWxFLGNBQWMsQ0FBQ3hFLHNCQUFzQixDQUFDRSxvQkFBb0IsRUFBRSxNQUFJLEVBQUU7WUFDcEVqUCxXQUFXLEVBQUU5SyxPQUFPLENBQUM2ckM7VUFDdkIsQ0FBQyxDQUFDLENBQ0g7VUFDRCxNQUFJLENBQUNrRSxhQUFhLENBQUNweEMsTUFBTSxDQUFDK0gsR0FBRyxDQUFDO1FBQ2hDLENBQUMsQ0FBQztNQUNOLENBQUMsTUFBTTtRQUNMckksaUJBQUssa0RBQTJDdUUsSUFBSSxDQUFDNE8sU0FBUyxDQUFDeFIsT0FBTyxDQUFDNnJDLGdCQUFnQixFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRztRQUNwRyxJQUFJLENBQUM3UCxXQUFXLENBQ2JoMEIsWUFBWSxDQUFDaEksT0FBTyxDQUFDNnJDLGdCQUFnQixFQUFFLElBQUksQ0FBQzJFLG9CQUFvQixDQUFDLENBQ2pFandDLElBQUksQ0FBQyxVQUFDa1UsR0FBRyxFQUFLO1VBQ2IsSUFBSWk4QixnQ0FBZ0MsQ0FBQ2o4QixHQUFHLENBQUNuQixLQUFLLENBQUMsRUFBRTtZQUMvQ2pWLGlCQUFLLENBQUMsMkVBQTJFLENBQUM7WUFDbEYsTUFBSSxDQUFDdXlDLElBQUksQ0FBQzV3QyxPQUFPLENBQUM7WUFDbEI7VUFDRjtVQUNBM0IsaUJBQUssb0NBQTZCdUUsSUFBSSxDQUFDNE8sU0FBUyxDQUFDaUQsR0FBRyxDQUFDM0osV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRztVQUM3RSxNQUFJLENBQUN5WCxPQUFPLENBQ1YsSUFBSWxFLGNBQWMsQ0FDaEJ4RSxzQkFBc0IsQ0FBQ0Msb0JBQW9CLEVBQzNDLE1BQUksRUFDSnkxQiw2QkFBNkIsQ0FBQzk2QixHQUFHLENBQUNuQixLQUFLLENBQUMsQ0FDekMsQ0FDRjtVQUNELE1BQUksQ0FBQ2lQLE9BQU8sQ0FBQyxJQUFJbEUsY0FBYyxDQUFDNUYsbUJBQW1CLENBQUNnQixnQkFBZ0IsRUFBRSxNQUFJLEVBQUVoRixHQUFHLENBQUMzSixXQUFXLENBQUMsQ0FBQztVQUM3RixNQUFJLENBQUNpbEMsYUFBYSxDQUFDcnhDLE9BQU8sQ0FBQytWLEdBQUcsQ0FBQ25CLEtBQUssQ0FBQztRQUN2QyxDQUFDLENBQUMsQ0FDRDdTLEtBQUssQ0FBQyxVQUFDb3dDLEdBQUcsRUFBSztVQUNkeHlDLGlCQUFLLDZEQUFzRHVFLElBQUksQ0FBQzRPLFNBQVMsQ0FBQ3EvQixHQUFHLENBQUMvbEMsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRztVQUN0R3ZNLGlCQUFLLGlGQUEwRXN5QyxHQUFHLENBQUN0eUMsS0FBSyxFQUFHO1VBQzNGRixpQkFBSyw4RUFDbUV1RSxJQUFJLENBQUM0TyxTQUFTLENBQ2xGcS9CLEdBQUcsQ0FBQy9sQyxXQUFXLEVBQ2YsSUFBSSxFQUNKLENBQUMsQ0FDRixFQUNGO1VBQ0QsTUFBSSxDQUFDeVgsT0FBTyxDQUNWLElBQUlsRSxjQUFjLENBQUN4RSxzQkFBc0IsQ0FBQ0Usb0JBQW9CLEVBQUUsTUFBSSxFQUFFO1lBQUVqUCxXQUFXLEVBQUUrbEMsR0FBRyxDQUFDL2xDO1VBQVksQ0FBQyxDQUFDLENBQ3hHO1VBQ0Q7VUFDQTlLLE9BQU8sQ0FBQ3N2QyxjQUFjLEdBQUcsWUFBTTtZQUM3QixPQUFPLE1BQUksQ0FBQ3RULFdBQVcsQ0FBQ3JuQixjQUFjLENBQUNrOEIsR0FBRyxDQUFDL2xDLFdBQVcsQ0FBQztVQUN6RCxDQUFDO1VBQ0QsTUFBSSxDQUFDOGxDLElBQUksQ0FBQzV3QyxPQUFPLENBQUM7UUFDcEIsQ0FBQyxDQUFDO01BQ047SUFDRjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEseUJBQWdCOHdDLG1CQUFtQixFQUFFO01BQ25DLElBQUksQ0FBQ3Z1QixPQUFPLENBQ1YsSUFBSWxFLGNBQWMsQ0FBQ3hFLHNCQUFzQixDQUFDRSxvQkFBb0IsRUFBRSxJQUFJLEVBQUU7UUFBRWpQLFdBQVcsRUFBRWdtQztNQUFvQixDQUFDLENBQUMsQ0FDNUc7SUFDSDs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEsOEJBQXFCM3RDLFdBQVcsRUFBRTtNQUNoQyxJQUFJLElBQUksQ0FBQ3k5QixtQkFBbUIsRUFBRSxFQUFFO1FBQzlCLElBQUksQ0FBQ0EsbUJBQW1CLEVBQUUsQ0FBQ3RSLElBQUksQ0FBQztVQUM5QjZDLElBQUksRUFBRTtZQUNKdkMsTUFBTSxFQUFFLFlBQVk7WUFDcEIzdEIsSUFBSSxFQUFFO2NBQ0o4dUMsaUJBQWlCLEVBQUU1dEM7WUFDckI7VUFDRjtRQUNGLENBQUMsQ0FBQztNQUNKO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLGdDQUF1QnlHLFdBQVcsRUFBRTtNQUNsQyxJQUFJLENBQUN5eUIsWUFBWSxHQUFHenlCLFdBQVc7TUFDL0IsSUFBSSxDQUFDMlksT0FBTyxDQUFDLElBQUlsRSxjQUFjLENBQUN4RSxzQkFBc0IsQ0FBQ0csc0JBQXNCLEVBQUUsSUFBSSxFQUFFcFEsV0FBVyxDQUFDLENBQUM7TUFDbEcsSUFBSSxJQUFJLENBQUNreUIsS0FBSyxFQUFFO1FBQ2QsSUFBSSxDQUFDQSxLQUFLLENBQUNrVixPQUFPLENBQUMsSUFBSSxDQUFDM1UsWUFBWSxDQUFDO01BQ3ZDO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEsNEJBQW1CTyxXQUFXLEVBQThCO01BQUEsSUFBNUJ6QixjQUFjLHVFQUFHNzlCLFNBQVM7TUFDeEQsSUFBSSxPQUFPcy9CLFdBQVcsS0FBSyxXQUFXLElBQUl6QixjQUFjLEtBQUs3OUIsU0FBUyxFQUFFO1FBQ3RFLElBQUk4bkIsSUFBSSxHQUFHLElBQUk4bUIsWUFBVyxDQUFDL1EsY0FBYyxDQUFDO1FBQzFDL1YsSUFBSSxDQUFDOG5CLGVBQWUsQ0FBQyxJQUFJLENBQUM7TUFDNUI7SUFDRjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBVkU7SUFBQTtJQUFBLE9BV0EsOEJBQXFCbGIsVUFBVSxFQUFFO01BQy9CM3pCLGlCQUFLLENBQUMsdUJBQXVCLENBQUM7TUFDOUI7TUFDQSxJQUFJLENBQUMyeEMsZ0JBQWdCLEdBQUc3d0MsTUFBTSxDQUFDSixnQkFBZ0IsQ0FBQyxJQUFJLENBQUNpeEMsZ0JBQWdCLENBQUM7TUFDdEUsSUFBSSxJQUFJLENBQUNqVSxRQUFRLENBQUNKLGVBQWUsRUFBRTtRQUNqQyxJQUFJLENBQUNxVSxnQkFBZ0IsQ0FBQ3R4QyxPQUFPLENBQUMsSUFBSSxDQUFDO01BQ3JDLENBQUMsTUFBTTtRQUNMLElBQUksQ0FBQ3U5QixhQUFhLENBQUMzTSxJQUFJLENBQUM7VUFDdEJrRCxXQUFXLEVBQUVSLFVBQVU7VUFDdkJpZixNQUFNLEVBQUU7UUFDVixDQUFDLENBQUM7TUFDSjtNQUNBLE9BQU8sSUFBSSxDQUFDakIsZ0JBQWdCLENBQUNweEMsT0FBTztJQUN0Qzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQWZFO0lBQUE7SUFBQSxPQWdCQSwrQkFBc0JxMkIsYUFBYSxFQUFnRTtNQUFBLElBQTlEQyx3QkFBd0IsdUVBQUc1M0IsU0FBUztNQUFBLElBQUUrMkIsVUFBVSx1RUFBRy8yQixTQUFTO01BQy9GZSxpQkFBSyxDQUFDLGVBQWUsQ0FBQztNQUN0QixJQUFJLENBQUM0eEMsV0FBVyxHQUFHM3lDLFNBQVM7TUFDNUIsSUFBSSxDQUFDMnlDLFdBQVcsR0FBRzl3QyxNQUFNLENBQUNKLGdCQUFnQixDQUFDLElBQUksQ0FBQ2t4QyxXQUFXLENBQUM7TUFFNUQsSUFBSTViLFVBQVUsSUFBSVksYUFBYSxFQUFFO1FBQy9CMzJCLGdCQUFJLENBQ0Ysb09BQW9PLENBQ3JPO1FBQ0QyMkIsYUFBYSxDQUFDWixVQUFVLEdBQUdBLFVBQVU7TUFDdkM7TUFDQSxJQUFJaDBCLENBQUM7TUFDTCxJQUFJNDBCLGFBQWEsS0FBSzMzQixTQUFTLEVBQUU7UUFDL0IrQyxDQUFDLEdBQUcsSUFBSSxDQUFDMjdCLFdBQVcsQ0FBQytCLDBCQUEwQixDQUFDOUksYUFBYSxFQUFFQyx3QkFBd0IsRUFBRSxJQUFJLENBQUMrYSxXQUFXLENBQUM7TUFDNUcsQ0FBQyxNQUFNO1FBQ0w1dkMsQ0FBQyxHQUFHLElBQUksQ0FBQzI3QixXQUFXLENBQUNqSyxLQUFLLENBQUNzQyxVQUFVLEVBQUUsSUFBSSxDQUFDNGIsV0FBVyxFQUFFLElBQUksQ0FBQ2xVLFFBQVEsQ0FBQ3hILGFBQWEsQ0FBQztNQUN2RjtNQUNBLE9BQU9sMEIsQ0FBQztJQUNWOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBVEU7SUFBQTtJQUFBLE9BVUEsd0JBQWlEO01BQUEsSUFBcENvdUMsU0FBUyx1RUFBRyxJQUFJO01BQUEsSUFBRUMsUUFBUSx1RUFBRyxLQUFLO01BQzdDcndDLGlCQUFLLENBQUMsZUFBZSxDQUFDO01BQ3RCLElBQUksQ0FBQzZ4QyxZQUFZLEdBQUc1eUMsU0FBUztNQUM3QixJQUFJLENBQUM0eUMsWUFBWSxHQUFHL3dDLE1BQU0sQ0FBQ0osZ0JBQWdCLENBQUMsSUFBSSxDQUFDbXhDLFlBQVksQ0FBQztNQUM5RCxJQUFJLENBQUNsVSxXQUFXLENBQUMrTixXQUFXLENBQUMwRSxTQUFTLEVBQUVDLFFBQVEsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDd0IsWUFBWSxDQUFDO01BQzNFLE9BQU8sSUFBSSxDQUFDQSxZQUFZLENBQUN0eEMsT0FBTztJQUNsQzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVRFO0lBQUE7SUFBQSxPQVVBLCtCQUFzQmlXLEdBQUcsRUFBRTtNQUN6QnhXLGlCQUFLLENBQUMsd0JBQXdCLENBQUM7TUFDL0IsT0FBTyxJQUFJLENBQUMyOUIsV0FBVyxDQUFDdkcsb0JBQW9CLENBQUM1Z0IsR0FBRyxDQUFDO0lBQ25EOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFiRTtJQUFBO0lBQUEsT0FjQSxvQkFBV0EsR0FBRyxFQUFFbWQsVUFBVSxFQUFFaUwsU0FBUyxFQUFFO01BQ3JDNStCLGlCQUFLLENBQUMsYUFBYSxDQUFDO01BQ3BCLElBQUksQ0FBQzh4QyxnQkFBZ0IsR0FBRzd5QyxTQUFTO01BQ2pDLElBQUksQ0FBQzZ5QyxnQkFBZ0IsR0FBR2h4QyxNQUFNLENBQUNKLGdCQUFnQixDQUFDLElBQUksQ0FBQ215QyxjQUFjLENBQUM7TUFDcEUsSUFBSSxDQUFDalYsYUFBYSxDQUFDM00sSUFBSSxDQUFDO1FBQ3RCNmhCLFdBQVcsRUFBRW5mLFVBQVU7UUFDdkJpTCxTQUFTLEVBQUVBLFNBQVM7UUFDcEJoN0IsSUFBSSxFQUFFO1VBQ0o0UyxHQUFHLEVBQUVBO1FBQ1A7TUFDRixDQUFDLENBQUM7TUFDRixPQUFPLElBQUksQ0FBQ3M3QixnQkFBZ0IsQ0FBQ3Z4QyxPQUFPO0lBQ3RDOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFWRTtJQUFBO0lBQUEsT0FXQSx3QkFBZXN6QixTQUFTLEVBQUVGLFVBQVUsRUFBRTtNQUNwQzN6QixpQkFBSyxDQUFDLGlCQUFpQixDQUFDO01BQ3hCLElBQUksQ0FBQzQ5QixhQUFhLENBQUMzTSxJQUFJLENBQUM7UUFDdEIyQyxlQUFlLEVBQUVELFVBQVU7UUFDM0IvdkIsSUFBSSxFQUFFO1VBQ0ppd0IsU0FBUyxFQUFFQTtRQUNiO01BQ0YsQ0FBQyxDQUFDO0lBQ0o7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQWJFO0lBQUE7SUFBQSxPQWNBLHlCQUFnQkYsVUFBVSxFQUFFMFosVUFBVSxFQUFFMEYsU0FBUyxFQUFFO01BQ2pEL3lDLGlCQUFLLENBQUMsa0JBQWtCLENBQUM7TUFDekIsSUFBSSxDQUFDZ3lDLGNBQWMsR0FBRy95QyxTQUFTO01BQy9CLElBQUksQ0FBQyt5QyxjQUFjLEdBQUdseEMsTUFBTSxDQUFDSixnQkFBZ0IsQ0FBQyxJQUFJLENBQUNzeEMsY0FBYyxDQUFDO01BQ2xFLElBQUksQ0FBQ3BVLGFBQWEsQ0FBQzNNLElBQUksQ0FBQztRQUN0QitoQixPQUFPLEVBQUVyZixVQUFVO1FBQ25CanVCLElBQUksRUFBRTJuQyxVQUFVO1FBQ2hCMEQsWUFBWSxFQUFFZ0M7TUFDaEIsQ0FBQyxDQUFDO01BQ0YsT0FBTyxJQUFJLENBQUNmLGNBQWMsQ0FBQ3p4QyxPQUFPO0lBQ3BDOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBVEU7SUFBQTtJQUFBLE9BVUEsMkJBQWtCb3pCLFVBQVUsRUFBRTtNQUM1QixJQUFJLENBQUNzZSxnQkFBZ0IsR0FBR2h6QyxTQUFTO01BQ2pDLElBQUksQ0FBQ2d6QyxnQkFBZ0IsR0FBR254QyxNQUFNLENBQUNKLGdCQUFnQixDQUFDLElBQUksQ0FBQ3V4QyxnQkFBZ0IsQ0FBQztNQUN0RTtNQUNBO01BQ0E7TUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDMVAsbUJBQW1CLEVBQUUsQ0FBQzBRLGFBQWEsQ0FBQ3RmLFVBQVUsQ0FBQyxFQUFFO1FBQ3pELElBQUksQ0FBQ3NlLGdCQUFnQixDQUFDNXhDLE9BQU8sRUFBRTtNQUNqQztNQUNBLE9BQU8sSUFBSSxDQUFDNHhDLGdCQUFnQixDQUFDMXhDLE9BQU87SUFDdEM7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLGNBQUtvQixPQUFPLEVBQUU7TUFDWixJQUFJLENBQUMrdkMsYUFBYSxHQUFHenlDLFNBQVM7TUFDOUIsSUFBTXVXLFFBQVEsR0FBRyxJQUFJM1UsZUFBZSxFQUFFO01BQ3RDLElBQUksQ0FBQzAxQixrQkFBa0IsRUFBRSxJQUFJLENBQUMvQyxxQkFBcUIsRUFBRSxFQUFFO1FBQ3JEaGUsUUFBUSxDQUFDbFYsTUFBTSxDQUNiLHFHQUFxRyxDQUN0RztNQUNILENBQUMsTUFBTTtRQUNMLElBQUksQ0FBQ285QixRQUFRLEdBQUducUIsTUFBTSxDQUFDbW5CLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRWtDLDBCQUFjLEVBQUVqN0IsT0FBTyxDQUFDO1FBQzFELElBQUksQ0FBQ2c4QixXQUFXLEdBQUcsSUFBSXFTLGlCQUFtQixDQUFDLElBQUksQ0FBQztRQUNoRCxJQUFJLENBQUNwUyxhQUFhLEdBQUcsSUFBSTRSLGlCQUFxQixDQUFDLElBQUksQ0FBQztRQUNwRCxJQUFJLENBQUMzUixpQkFBaUIsR0FBRyxJQUFJLENBQUNBLGlCQUFpQixJQUFJLElBQUksQ0FBQ0QsYUFBYTtRQUNyRSxJQUFJLENBQUNzVixlQUFlLEVBQUUsQ0FDbkJoeEMsSUFBSSxDQUFDLElBQUksQ0FBQ2l4QyxzQkFBc0IsQ0FBQzl3QixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FDNUNqZ0IsS0FBSyxDQUFDLFVBQUNsQyxLQUFLLEVBQUs7VUFDaEJELGdCQUFJLGtCQUFXQyxLQUFLLEVBQUc7UUFDekIsQ0FBQyxDQUFDO1FBQ0osSUFBSSxDQUFDcXlDLElBQUksQ0FBQyxJQUFJLENBQUM3VSxRQUFRLENBQUM7UUFDeEI7UUFDQSxJQUFJLENBQUNrRCxrQkFBa0IsQ0FBQyxJQUFJLENBQUNuRCxLQUFLLEVBQUUsSUFBSSxDQUFDQyxRQUFRLENBQUNaLGNBQWMsQ0FBQztRQUNqRXRuQixRQUFRLENBQUNuVixPQUFPLENBQUMsSUFBSSxDQUFDO01BQ3hCO01BQ0EsT0FBT21WLFFBQVEsQ0FBQ2pWLE9BQU87SUFDekI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBWEU7SUFBQTtJQUFBLE9BWUEsd0JBQWVvQixPQUFPLEVBQUU0SixXQUFXLEVBQUU7TUFDbkN2TCxpQkFBSyxDQUFDLGtCQUFrQixDQUFDO01BQ3pCLElBQUksQ0FBQzB4QyxhQUFhLEdBQUd6eUMsU0FBUztNQUM5QixJQUFNdVcsUUFBUSxHQUFHLElBQUkzVSxlQUFlLEVBQUU7TUFDdEMsSUFBSSxDQUFDMDFCLGtCQUFrQixFQUFFLElBQUksQ0FBQy9DLHFCQUFxQixFQUFFLEVBQUU7UUFDckRoZSxRQUFRLENBQUNsVixNQUFNLENBQ2IscUdBQXFHLENBQ3RHO01BQ0gsQ0FBQyxNQUFNO1FBQ0wsSUFBSSxDQUFDbzlCLFFBQVEsR0FBR25xQixNQUFNLENBQUNtbkIsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFa0MsMEJBQWMsRUFBRWo3QixPQUFPLENBQUM7UUFDMUQsSUFBSSxDQUFDZzhCLFdBQVcsR0FBRyxJQUFJcVMsaUJBQW1CLENBQUMsSUFBSSxDQUFDO1FBQ2hELElBQUksQ0FBQ3BTLGFBQWEsR0FBRyxJQUFJNFIsaUJBQXFCLENBQUMsSUFBSSxDQUFDO1FBQ3BELElBQUksQ0FBQzNSLGlCQUFpQixHQUFHLElBQUksQ0FBQ0EsaUJBQWlCLElBQUksSUFBSSxDQUFDRCxhQUFhO1FBQ3JFO1FBQ0EsSUFBSSxDQUFDZ0Qsa0JBQWtCLENBQUMsSUFBSSxDQUFDbkQsS0FBSyxFQUFFLElBQUksQ0FBQ0MsUUFBUSxDQUFDWixjQUFjLENBQUM7UUFDakUsSUFBSXNXLFlBQVksR0FBRyxJQUFJLENBQUNGLGVBQWUsRUFBRTtRQUN6Q0UsWUFBWSxDQUFDbHhDLElBQUksQ0FBQyxJQUFJLENBQUNpeEMsc0JBQXNCLENBQUM5d0IsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUNqZ0IsS0FBSyxDQUFDLFVBQUNsQyxLQUFLLEVBQUs7VUFDekVELGdCQUFJLGtCQUFXQyxLQUFLLEVBQUc7UUFDekIsQ0FBQyxDQUFDO1FBQ0YsSUFBSSxDQUFDd3hDLGFBQWEsQ0FBQ3J4QyxPQUFPLENBQUNrTCxXQUFXLENBQUM7UUFDdkNpSyxRQUFRLENBQUNuVixPQUFPLENBQUMsSUFBSSxDQUFDO01BQ3hCO01BQ0EsT0FBT21WLFFBQVEsQ0FBQ2pWLE9BQU87SUFDekI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEsaUJBQVF3bUIsSUFBSSxFQUFFO01BQ1osSUFBSSxDQUFDMFcsS0FBSyxHQUFHMVcsSUFBSTtNQUNqQixJQUFJLElBQUksQ0FBQ2lYLFlBQVksSUFBSSxJQUFJLENBQUNQLEtBQUssRUFBRTtRQUNuQyxJQUFJLENBQUNBLEtBQUssQ0FBQ2tWLE9BQU8sQ0FBQyxJQUFJLENBQUMzVSxZQUFZLENBQUM7TUFDdkM7TUFDQSxPQUFPLElBQUk7SUFDYjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQU5FO0lBQUE7SUFBQSxPQU9BLG1CQUFVO01BQUE7TUFDUmgrQixpQkFBSyxDQUFDLFdBQVcsQ0FBQztNQUNsQixJQUFNZ0MsQ0FBQyxHQUFHLElBQUl4QixPQUFPLENBQUMsVUFBQzRWLEdBQUcsRUFBSztRQUM3QkEsR0FBRyxDQUFDLE1BQUksQ0FBQztNQUNYLENBQUMsQ0FBQztNQUNGLElBQUksQ0FBQ3dxQixrQkFBa0IsQ0FBQyxJQUFJLENBQUNuRCxLQUFLLEVBQUUsSUFBSSxDQUFDQyxRQUFRLENBQUNaLGNBQWMsQ0FBQztNQUNqRSxPQUFPOTZCLENBQUM7SUFDVjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFMRTtJQUFBO0lBQUEsT0FNQSxxQkFBWTtNQUNWaEMsaUJBQUssQ0FBQyxhQUFhLENBQUM7TUFDcEIsSUFBSSxJQUFJLENBQUNnK0IsWUFBWSxFQUFFO1FBQ3JCLElBQUksQ0FBQ0EsWUFBWSxDQUFDbVQsU0FBUyxFQUFFLENBQUNuckMsT0FBTyxDQUFDLFVBQUNQLEtBQUssRUFBSztVQUMvQ0EsS0FBSyxDQUFDK21CLElBQUksRUFBRTtRQUNkLENBQUMsQ0FBQztNQUNKO01BQ0EsSUFBSSxJQUFJLENBQUNpUixLQUFLLEVBQUU7UUFDZCxJQUFJLENBQUNBLEtBQUssQ0FBQzRWLFNBQVMsRUFBRTtNQUN4QjtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFWRTtJQUFBO0lBQUEsT0FXQSxtQkFBMkM7TUFBQTtNQUFBLElBQW5DMWYsVUFBVSx1RUFBRyxJQUFJO01BQUEsSUFBRXB6QixPQUFPLHVFQUFHLElBQUk7TUFDdkNQLGlCQUFLLENBQUMsV0FBVyxDQUFDO01BQ2xCLElBQUksQ0FBQzA5QixRQUFRLENBQUMvSixVQUFVLEdBQUdBLFVBQVUsSUFBSSxJQUFJLENBQUMrSixRQUFRLENBQUMvSixVQUFVO01BQ2pFLElBQU0zeEIsQ0FBQyxHQUFHekIsT0FBTyxJQUFJLElBQUlNLGVBQWUsRUFBRTtNQUMxQyxJQUFNcS9CLGFBQWEsR0FBRyxJQUFJci9CLGVBQWUsRUFBRTtNQUMzQyxJQUFNcy9CLFNBQVMsR0FBR0MsNEJBQW1CLENBQUMsSUFBSSxDQUFDMUMsUUFBUSxFQUFFO1FBQ25EenlCLEVBQUUsRUFBRSxJQUFJLENBQUN5eUIsUUFBUSxDQUFDL0o7TUFDcEIsQ0FBQyxDQUFDO01BQ0YsSUFBSSxDQUFDb2UsaUJBQWlCLEdBQUcsSUFBSSxDQUFDdUIsY0FBYyxFQUFFO01BRTlDLElBQUksQ0FBQyxJQUFJLENBQUMzVixXQUFXLEVBQUU7UUFDckIsSUFBSSxDQUFDQSxXQUFXLEdBQUcsSUFBSXFTLGlCQUFtQixDQUFDLElBQUksQ0FBQztNQUNsRDtNQUNBLElBQUksSUFBSSxDQUFDcFMsYUFBYSxFQUFFO1FBQ3RCLElBQUksQ0FBQ0EsYUFBYSxDQUFDL0ssVUFBVSxFQUFFO01BQ2pDLENBQUMsTUFBTTtRQUNMLElBQUksQ0FBQytLLGFBQWEsR0FBRyxJQUFJNFIsaUJBQXFCLENBQUMsSUFBSSxDQUFDO1FBQ3BELElBQUksQ0FBQzNSLGlCQUFpQixHQUFHLElBQUksQ0FBQ0QsYUFBYTtNQUM3QztNQUNBLElBQUksQ0FBQ0EsYUFBYSxDQUFDbEssS0FBSyxDQUFDeU0sU0FBUyxFQUFFRCxhQUFhLENBQUM7TUFFbEQscUJBQTBFLElBQUksQ0FBQ3hDLFFBQVE7UUFBakZYLGdCQUFnQixrQkFBaEJBLGdCQUFnQjtRQUFFSyxtQkFBbUIsa0JBQW5CQSxtQkFBbUI7UUFBRXZHLHdCQUF3QixrQkFBeEJBLHdCQUF3QjtNQUNyRTtNQUNBO01BQ0EsSUFBTXdKLGtCQUFrQixHQUFHakQsbUJBQW1CLElBQUk3RywwQkFBMEIsRUFBRTtNQUM5RSxJQUFJOEosa0JBQWtCLElBQUksQ0FBQ3hKLHdCQUF3QixFQUFFO1FBQ25EQSx3QkFBd0IsR0FBRztVQUN6Qmo1QixJQUFJO1FBQ04sQ0FBQztNQUNIO01BQ0EsSUFBSSxDQUFDOC9CLFFBQVEsQ0FBQ04sbUJBQW1CLEdBQUdpRCxrQkFBa0I7O01BRXREO01BQ0EsSUFBSSxDQUFDMlIsY0FBYyxHQUFHbHhDLE1BQU0sQ0FBQ0osZ0JBQWdCLENBQUMsSUFBSSxDQUFDc3hDLGNBQWMsQ0FBQztNQUNsRSxJQUFJLENBQUNBLGNBQWMsQ0FBQ3p4QyxPQUFPLENBQUM2QixLQUFLLENBQUMsVUFBQ2xDLEtBQUssRUFBSztRQUMzQzBQLE9BQVcsQ0FBQ3ZDLDhCQUE4QixDQUFDLE1BQUksQ0FBQzZrQyxvQkFBb0IsQ0FBQztRQUNyRWx3QyxDQUFDLENBQUMxQixNQUFNLENBQUNKLEtBQUssQ0FBQztRQUNmLE1BQUksQ0FBQ2drQixPQUFPLENBQUMsSUFBSWxFLGNBQWMsQ0FBQzVGLG1CQUFtQixDQUFDRyxlQUFlLEVBQUUsTUFBSSxFQUFFcmEsS0FBSyxDQUFDLENBQUM7TUFDcEYsQ0FBQyxDQUFDOztNQUVGO01BQ0FnZ0MsYUFBYSxDQUFDMy9CO01BQ1o7TUFBQSxDQUNDMkIsSUFBSSxDQUFDLFlBQU07UUFDVixNQUFJLENBQUNnaUIsT0FBTyxDQUFDLElBQUlsRSxjQUFjLENBQUM1RixtQkFBbUIsQ0FBQ0UsZUFBZSxFQUFFLE1BQUksQ0FBQyxDQUFDO1FBQzNFLE9BQU8sTUFBSSxDQUFDNDRCLGVBQWUsRUFBRTtNQUMvQixDQUFDO01BQ0Q7TUFBQSxDQUNDaHhDLElBQUksQ0FBQyxZQUFNO1FBQ1YsT0FBTyxNQUFJLENBQUMyK0Isb0JBQW9CLENBQUMsTUFBSSxDQUFDbkQsUUFBUSxDQUFDL0osVUFBVSxFQUFFLE1BQUksQ0FBQytKLFFBQVEsQ0FBQzZWLFVBQVUsQ0FBQztNQUN0RixDQUFDO01BQ0Q7TUFBQSxDQUNDcnhDLElBQUksQ0FBQyxZQUFNO1FBQ1YsT0FBTyxNQUFJLENBQUNzeEMscUJBQXFCLENBQUN6VyxnQkFBZ0IsRUFBRWxHLHdCQUF3QixFQUFFLE1BQUksQ0FBQzZHLFFBQVEsQ0FBQzFILFVBQVUsQ0FBQztNQUN6RyxDQUFDO01BQ0Q7TUFBQSxDQUNDOXpCLElBQUksQ0FBQyxVQUFDNnpCLFVBQVUsRUFBSztRQUNwQixNQUFJLENBQUM3UixPQUFPLENBQUMsSUFBSWxFLGNBQWMsQ0FBQ3hFLHNCQUFzQixDQUFDSSx5QkFBeUIsRUFBRSxNQUFJLEVBQUVtYSxVQUFVLENBQUMsQ0FBQztRQUNwRyxNQUFJLENBQUNpSSxZQUFZLENBQUNtVCxTQUFTLEVBQUUsQ0FBQ25yQyxPQUFPLENBQUMsVUFBQ1AsS0FBSyxFQUFLO1VBQy9Dc3dCLFVBQVUsQ0FBQzBkLFFBQVEsQ0FBQ2h1QyxLQUFLLEVBQUUsTUFBSSxDQUFDdTRCLFlBQVksQ0FBQztRQUMvQyxDQUFDLENBQUM7UUFDRjtRQUNBO1FBQ0EsT0FBTyxNQUFJLENBQUMwVixZQUFZLENBQUMsTUFBSSxDQUFDaFcsUUFBUSxDQUFDMFMsU0FBUyxFQUFFLE1BQUksQ0FBQzFTLFFBQVEsQ0FBQzJTLFFBQVEsQ0FBQztNQUMzRSxDQUFDO01BQ0Q7TUFBQSxDQUNDbnVDLElBQUksQ0FBQyxVQUFDZzFCLGtCQUFrQixFQUFLO1FBQzVCLE1BQUksQ0FBQ2hULE9BQU8sQ0FBQyxJQUFJbEUsY0FBYyxDQUFDeEUsc0JBQXNCLENBQUNLLFdBQVcsRUFBRSxNQUFJLEVBQUVxYixrQkFBa0IsQ0FBQyxDQUFDO1FBQzlGLE9BQU8sTUFBSSxDQUFDeWMsVUFBVSxDQUFDemMsa0JBQWtCLEVBQUUsTUFBSSxDQUFDd0csUUFBUSxDQUFDL0osVUFBVSxFQUFFLE1BQUksQ0FBQytKLFFBQVEsQ0FBQ1QsWUFBWSxDQUFDO01BQ2xHLENBQUM7TUFDRDtNQUFBLENBQ0MvNkIsSUFBSSxDQUFDLFVBQUNzVSxHQUFHLEVBQUs7UUFDYixPQUFPLE1BQUksQ0FBQ285QixxQkFBcUIsQ0FBQ3A5QixHQUFHLENBQUNBLEdBQUcsQ0FBQztNQUM1QyxDQUFDO01BQ0Q7TUFBQSxDQUNDdFUsSUFBSSxDQUFDLFVBQUNzVSxHQUFHLEVBQUs7UUFDYixNQUFJLENBQUMwTixPQUFPLENBQUMsSUFBSWxFLGNBQWMsQ0FBQ3hFLHNCQUFzQixDQUFDTSxTQUFTLEVBQUUsTUFBSSxFQUFFdEYsR0FBRyxDQUFDLENBQUM7UUFDN0UsT0FBTyxNQUFJLENBQUM4OEIsY0FBYyxFQUFFLENBQUMveUMsT0FBTztNQUN0QyxDQUFDO01BQ0Q7TUFBQSxDQUNDMkIsSUFBSSxDQUFDLFlBQU07UUFDVixNQUFJLENBQUNnaUIsT0FBTyxDQUFDLElBQUlsRSxjQUFjLENBQUN4RSxzQkFBc0IsQ0FBQ1Esb0JBQW9CLEVBQUUsTUFBSSxDQUFDLENBQUM7UUFDbkYsT0FBTyxNQUFJLENBQUM2M0IsZUFBZSxDQUFDLE1BQUksQ0FBQ25XLFFBQVEsQ0FBQy9KLFVBQVUsRUFBRSxNQUFJLENBQUMrSixRQUFRLENBQUMyUCxVQUFVLEVBQUUsTUFBSSxDQUFDM1AsUUFBUSxDQUFDcVQsWUFBWSxDQUFDO01BQzdHLENBQUM7TUFDRDtNQUFBLENBQ0M3dUMsSUFBSSxDQUFDLFlBQU07UUFDVjBOLE9BQVcsQ0FBQzNDLDJCQUEyQixDQUFDLE1BQUksQ0FBQ2lsQyxvQkFBb0IsQ0FBQztRQUNsRWx3QyxDQUFDLENBQUMzQixPQUFPLENBQUMsTUFBSSxDQUFDO1FBQ2YsTUFBSSxDQUFDNmpCLE9BQU8sQ0FBQyxJQUFJbEUsY0FBYyxDQUFDNUYsbUJBQW1CLENBQUNJLGFBQWEsRUFBRSxNQUFJLENBQUMsQ0FBQztNQUMzRSxDQUFDLENBQUMsQ0FDRHBZLEtBQUssQ0FBQyxVQUFDbEMsS0FBSyxFQUFLO1FBQ2hCMFAsT0FBVyxDQUFDdkMsOEJBQThCLENBQUMsTUFBSSxDQUFDNmtDLG9CQUFvQixDQUFDO1FBQ3JFbHdDLENBQUMsQ0FBQzFCLE1BQU0sQ0FBQ0osS0FBSyxDQUFDO1FBQ2YsTUFBSSxDQUFDZ2tCLE9BQU8sQ0FBQyxJQUFJbEUsY0FBYyxDQUFDNUYsbUJBQW1CLENBQUNHLGVBQWUsRUFBRSxNQUFJLEVBQUVyYSxLQUFLLENBQUMsQ0FBQztNQUNwRixDQUFDLENBQUM7TUFDSixPQUFPOEIsQ0FBQyxDQUFDbUUsY0FBYyxDQUFDLFNBQVMsQ0FBQyxHQUFHbkUsQ0FBQyxDQUFDekIsT0FBTyxHQUFHeUIsQ0FBQztJQUNwRDs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBaEJFO0lBQUE7SUFBQSxPQWlCQSwyQkFBa0I0d0IsTUFBTSxFQUFxQztNQUFBO01BQUEsSUFBbkNlLFVBQVUsdUVBQUcsSUFBSTtNQUFBLElBQUVwekIsT0FBTyx1RUFBRyxJQUFJO01BQ3pEUCxpQkFBSyxDQUFDLHFCQUFxQixDQUFDO01BQzVCLElBQUksQ0FBQzA5QixRQUFRLENBQUMvSixVQUFVLEdBQUdBLFVBQVUsSUFBSSxJQUFJLENBQUMrSixRQUFRLENBQUMvSixVQUFVO01BQ2pFLElBQU0zeEIsQ0FBQyxHQUFHekIsT0FBTyxJQUFJLElBQUlNLGVBQWUsRUFBRTtNQUMxQyxJQUFNcS9CLGFBQWEsR0FBRyxJQUFJci9CLGVBQWUsRUFBRTtNQUMzQyxJQUFJLENBQUMrOEIsYUFBYSxHQUFHLElBQUk0UixpQkFBcUIsQ0FBQyxJQUFJLENBQUM7TUFDcEQsSUFBSSxDQUFDNVIsYUFBYSxDQUFDa1csZUFBZSxDQUFDbGhCLE1BQU0sRUFBRXNOLGFBQWEsQ0FBQzs7TUFFekQ7TUFDQUEsYUFBYSxDQUFDMy9CO01BQ1o7TUFBQSxDQUNDMkIsSUFBSSxDQUFDLFlBQU07UUFDVixPQUFPLE1BQUksQ0FBQzJ4QyxlQUFlLENBQUMsTUFBSSxDQUFDblcsUUFBUSxDQUFDL0osVUFBVSxFQUFFLE1BQUksQ0FBQytKLFFBQVEsQ0FBQzJQLFVBQVUsRUFBRSxNQUFJLENBQUMzUCxRQUFRLENBQUNxVCxZQUFZLENBQUM7TUFDN0csQ0FBQztNQUNEO01BQUEsQ0FDQzd1QyxJQUFJLENBQUMsWUFBTTtRQUNWME4sT0FBVyxDQUFDM0MsMkJBQTJCLENBQUMsTUFBSSxDQUFDaWxDLG9CQUFvQixDQUFDO1FBQ2xFbHdDLENBQUMsQ0FBQzNCLE9BQU8sQ0FBQyxNQUFJLENBQUM7UUFDZixNQUFJLENBQUM2akIsT0FBTyxDQUFDLElBQUlsRSxjQUFjLENBQUM1RixtQkFBbUIsQ0FBQ0ksYUFBYSxFQUFFLE1BQUksQ0FBQyxDQUFDO01BQzNFLENBQUMsQ0FBQyxDQUNEcFksS0FBSyxDQUFDLFVBQUNsQyxLQUFLLEVBQUs7UUFDaEIwUCxPQUFXLENBQUN2Qyw4QkFBOEIsQ0FBQyxNQUFJLENBQUM2a0Msb0JBQW9CLENBQUM7UUFDckVsd0MsQ0FBQyxDQUFDMUIsTUFBTSxDQUFDSixLQUFLLENBQUM7UUFDZixNQUFJLENBQUNna0IsT0FBTyxDQUFDLElBQUlsRSxjQUFjLENBQUM1RixtQkFBbUIsQ0FBQ0csZUFBZSxFQUFFLE1BQUksRUFBRXJhLEtBQUssQ0FBQyxDQUFDO01BQ3BGLENBQUMsQ0FBQztNQUNKLE9BQU84QixDQUFDLENBQUNtRSxjQUFjLENBQUMsU0FBUyxDQUFDLEdBQUduRSxDQUFDLENBQUN6QixPQUFPLEdBQUd5QixDQUFDO0lBQ3BEOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVJFO0lBQUE7SUFBQSxPQVNBLHFCQUE2QjtNQUFBO01BQUEsSUFBbkIreEMsU0FBUyx1RUFBRyxLQUFLO01BQ3pCL3pDLGlCQUFLLENBQUMsYUFBYSxDQUFDO01BQ3BCLElBQU1nMEMsWUFBWSxHQUFHLFNBQWZBLFlBQVksR0FBUztRQUN6QixJQUFJLE1BQUksQ0FBQ3BXLGFBQWEsRUFBRTtVQUN0QjU5QixpQkFBSyxDQUFDLHNCQUFzQixDQUFDO1VBQzdCLE1BQUksQ0FBQzQ5QixhQUFhLENBQUNyTCxRQUFRLEVBQUU7UUFDL0I7UUFDQSxJQUFJLE1BQUksQ0FBQ29MLFdBQVcsRUFBRTtVQUNwQixNQUFJLENBQUNBLFdBQVcsQ0FBQ3BMLFFBQVEsRUFBRTtRQUM3QjtRQUNBLE1BQUksQ0FBQ3FMLGFBQWEsR0FBRzMrQixTQUFTO1FBQzlCLE1BQUksQ0FBQzArQixXQUFXLEdBQUcxK0IsU0FBUztRQUM1QixNQUFJLENBQUM0K0IsaUJBQWlCLEdBQUc1K0IsU0FBUztNQUNwQyxDQUFDO01BQ0QsSUFBSSxJQUFJLENBQUN5K0IsUUFBUSxDQUFDc1QscUJBQXFCLElBQUkrQyxTQUFTLEVBQUU7UUFDcEQsSUFBSSxDQUFDVixTQUFTLEVBQUU7TUFDbEI7TUFDQSxJQUFJLENBQUMxQixnQkFBZ0IsR0FBRzF5QyxTQUFTO01BQ2pDLElBQUksQ0FBQzJ5QyxXQUFXLEdBQUczeUMsU0FBUztNQUM1QixJQUFJLENBQUM0eUMsWUFBWSxHQUFHNXlDLFNBQVM7TUFDN0IsSUFBSSxDQUFDNnlDLGdCQUFnQixHQUFHN3lDLFNBQVM7TUFDakMsSUFBSSxDQUFDOHlDLGlCQUFpQixHQUFHOXlDLFNBQVM7TUFDbEMsSUFBSSxDQUFDK3lDLGNBQWMsR0FBRy95QyxTQUFTO01BQy9CLElBQU0yQixDQUFDLEdBQUcsSUFBSSxDQUFDcXpDLGlCQUFpQixDQUFDLElBQUksQ0FBQ3ZXLFFBQVEsQ0FBQy9KLFVBQVUsRUFBRSxJQUFJLENBQUMrSixRQUFRLENBQUN3VyxTQUFTLENBQUM7TUFDbkZ0ekMsQ0FBQyxDQUFDc0IsSUFBSSxDQUFDLFlBQU07UUFDWCxNQUFJLENBQUMrdkMsZ0JBQWdCLEdBQUdoekMsU0FBUztRQUNqQztRQUNBKzBDLFlBQVksRUFBRTtRQUNkLE1BQUksQ0FBQzl2QixPQUFPLENBQUMsSUFBSWxFLGNBQWMsQ0FBQzVGLG1CQUFtQixDQUFDTyxpQkFBaUIsRUFBRSxNQUFJLENBQUMsQ0FBQztNQUMvRSxDQUFDLENBQUM7TUFDRi9LLE9BQVcsQ0FBQ3ZDLDhCQUE4QixDQUFDLElBQUksQ0FBQzZrQyxvQkFBb0IsQ0FBQztNQUNyRSxPQUFPdHhDLENBQUM7SUFDVjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsZ0JBQU87TUFDTDtNQUNBLElBQUksQ0FBQ2lpQyxTQUFTLEVBQUU7SUFDbEI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLGtCQUFTO01BQ1A7TUFDQSxJQUFJLENBQUNzUixXQUFXLEVBQUU7SUFDcEI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7RUFIRTtJQUFBO0lBQUEsT0FJQSxxQkFBWTtNQUNWLElBQUksQ0FBQzVSLG1CQUFtQixFQUFFLENBQUN0UixJQUFJLENBQUM7UUFDOUJuSixJQUFJLEVBQUU7VUFDSithLFNBQVMsRUFBRTtRQUNiO01BQ0YsQ0FBQyxDQUFDO0lBQ0o7O0lBRUE7QUFDRjtBQUNBO0VBRkU7SUFBQTtJQUFBLE9BR0EsdUJBQWM7TUFDWixJQUFJLENBQUNOLG1CQUFtQixFQUFFLENBQUN0UixJQUFJLENBQUM7UUFDOUJuSixJQUFJLEVBQUU7VUFDSithLFNBQVMsRUFBRTtRQUNiO01BQ0YsQ0FBQyxDQUFDO0lBQ0o7O0lBRUE7QUFDRjtBQUNBO0VBRkU7SUFBQTtJQUFBLE9BR0EscUJBQVk7TUFDVixJQUFJLENBQUNOLG1CQUFtQixFQUFFLENBQUN0UixJQUFJLENBQUM7UUFDOUJuSixJQUFJLEVBQUU7VUFDSmdiLFNBQVMsRUFBRTtRQUNiO01BQ0YsQ0FBQyxDQUFDO0lBQ0o7O0lBRUE7QUFDRjtBQUNBO0VBRkU7SUFBQTtJQUFBLE9BR0EsdUJBQWM7TUFDWixJQUFJLENBQUNQLG1CQUFtQixFQUFFLENBQUN0UixJQUFJLENBQUM7UUFDOUJuSixJQUFJLEVBQUU7VUFDSmdiLFNBQVMsRUFBRTtRQUNiO01BQ0YsQ0FBQyxDQUFDO0lBQ0o7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLGNBQUtuMUIsVUFBVSxFQUFFL0osSUFBSSxFQUFFO01BQ3JCLElBQUksQ0FBQzIrQixtQkFBbUIsRUFBRSxDQUFDdFIsSUFBSSxDQUFDO1FBQzlCNkMsSUFBSSxFQUFFO1VBQ0p2QyxNQUFNLEVBQUU1akIsVUFBVTtVQUNsQi9KLElBQUksRUFBRSxPQUFPQSxJQUFJLEtBQUssUUFBUSxHQUFHVyxJQUFJLENBQUNDLEtBQUssQ0FBQ1osSUFBSSxDQUFDLEdBQUdBO1FBQ3REO01BQ0YsQ0FBQyxDQUFDO0lBQ0o7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUkU7SUFBQTtJQUFBLE9BU0Esb0JBQVcrSixVQUFVLEVBQUUrRCxJQUFJLEVBQUU7TUFDM0IsT0FBTyxJQUFJLENBQUM2d0IsbUJBQW1CLEVBQUUsQ0FBQ0MsU0FBUyxDQUFDO1FBQzFDQyxXQUFXLEVBQUU7VUFDWGxSLE1BQU0sRUFBRTVqQixVQUFVO1VBQ2xCa0UsU0FBUyxFQUFFSDtRQUNiO01BQ0YsQ0FBQyxDQUFDO0lBQ0o7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLGlCQUFRNVQsS0FBSyxFQUFFTSxPQUFPLEVBQUU7TUFDdEIsSUFBSTtRQUNGLElBQU1za0MsUUFBUSxHQUFHbnZCLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDalYsTUFBTSxDQUFDLENBQUNrRCxJQUFJLENBQUMsVUFBQytYLENBQUM7VUFBQSxPQUFLQSxDQUFDLENBQUNqUSxXQUFXLEVBQUUsS0FBS3pMLEtBQUssQ0FBQ3lMLFdBQVcsRUFBRTtRQUFBLEVBQUMsR0FBR3pMLEtBQUssR0FBR1MsTUFBTSxDQUFDRyxLQUFLO1FBQ2hILElBQU1pa0MsVUFBVSxHQUFHLE9BQU92a0MsT0FBTyxLQUFLLFFBQVEsR0FBR0EsT0FBTyxHQUFHbUcsSUFBSSxDQUFDNE8sU0FBUyxDQUFDL1UsT0FBTyxDQUFDO1FBQ2xGLElBQUksQ0FBQ21rQyxtQkFBbUIsRUFBRSxDQUFDdFIsSUFBSSxDQUFDO1VBQzlCeHpCLEdBQUcsRUFBRWlsQyxRQUFRLENBQUNFLFdBQVcsRUFBRTtVQUMzQnhrQyxPQUFPLEVBQUV1a0M7UUFDWCxDQUFDLENBQUM7TUFDSixDQUFDLENBQUMsT0FBT2wrQixDQUFDLEVBQUU7UUFDVixJQUFNckcsUUFBTyxHQUFHcUcsQ0FBQyxDQUFDckcsT0FBTyxJQUFJcUcsQ0FBQztRQUM5QnZFLGlCQUFLLENBQUNvaEIsMEJBQUksdUdBQXVHO1FBQ2pIcGhCLGlCQUFLLENBQUNvaEIsMEJBQUksRUFBRWxqQixRQUFPLENBQUM7TUFDdEI7SUFDRjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsMkJBQWtCMmlDLE9BQU8sRUFBRTtNQUN6Qi9nQyxpQkFBSyxDQUFDLHVCQUF1QixHQUFHdUUsSUFBSSxDQUFDNE8sU0FBUyxDQUFDNHRCLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7TUFDakUsSUFBSSxDQUFDNFEsZ0JBQWdCLEdBQUc3d0MsTUFBTSxDQUFDSixnQkFBZ0IsQ0FBQyxJQUFJLENBQUNpeEMsZ0JBQWdCLENBQUM7TUFDdEUsSUFBSSxDQUFDQSxnQkFBZ0IsQ0FBQ3J4QyxNQUFNLDRCQUFxQixJQUFJLENBQUNvOUIsUUFBUSxDQUFDL0osVUFBVSx1Q0FBb0M7TUFDN0csSUFBSSxDQUFDelAsT0FBTyxDQUFDLElBQUlsRSxjQUFjLENBQUM1RixtQkFBbUIsQ0FBQ00sb0JBQW9CLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDbEY7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLDZCQUFvQnFtQixPQUFPLEVBQUU7TUFDM0I7TUFDQS9nQyxpQkFBSyxrQkFBVyxJQUFJLENBQUMwOUIsUUFBUSxDQUFDL0osVUFBVSxzQkFBbUI7TUFDM0QzekIsaUJBQUssQ0FBQyx5QkFBeUIsR0FBR3VFLElBQUksQ0FBQzRPLFNBQVMsQ0FBQzR0QixPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO01BQ25FLElBQUksQ0FBQzRRLGdCQUFnQixHQUFHN3dDLE1BQU0sQ0FBQ0osZ0JBQWdCLENBQUMsSUFBSSxDQUFDaXhDLGdCQUFnQixDQUFDO01BQ3RFLElBQUksQ0FBQ0EsZ0JBQWdCLENBQUN0eEMsT0FBTyxDQUFDLElBQUksQ0FBQztJQUNyQzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EseUJBQWdCdXlCLE1BQU0sRUFBRXgwQixPQUFPLEVBQUU7TUFDL0IsSUFBSSxDQUFDOGxCLE9BQU8sQ0FDVixJQUFJbEUsY0FBYyxDQUFDeEUsc0JBQXNCLENBQUNTLGNBQWMsRUFBRSxJQUFJLEVBQUU7UUFDOUQyVyxNQUFNLEVBQUVBLE1BQU07UUFDZHgwQixPQUFPLEVBQUVBO01BQ1gsQ0FBQyxDQUFDLENBQ0g7SUFDSDs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsOEJBQXFCQSxPQUFPLEVBQWlCO01BQUEsSUFBZmkxQixNQUFNLHVFQUFHLElBQUk7TUFDekNuekIsaUJBQUssb0NBQTZCOUIsT0FBTyxtQ0FBeUJpMUIsTUFBTSxFQUFHO01BQzNFLElBQUksSUFBSSxDQUFDMmUsY0FBYyxFQUFFO1FBQ3ZCLElBQUksQ0FBQzl0QixPQUFPLENBQUMsSUFBSWxFLGNBQWMsQ0FBQzVGLG1CQUFtQixDQUFDSyxZQUFZLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDeEUsSUFBSSxDQUFDdTNCLGNBQWMsQ0FBQzF4QyxNQUFNLENBQUNsQyxPQUFPLENBQUM7UUFDbkMsSUFBSSxDQUFDbWpDLFNBQVMsRUFBRTtNQUNsQjtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSx1QkFBY0YsVUFBVSxFQUFFO01BQ3hCcmhDLGlCQUFLLENBQUMsaUJBQWlCLENBQUM7TUFDeEIsSUFBSSxJQUFJLENBQUMyOUIsV0FBVyxFQUFFO1FBQ3BCLElBQUksQ0FBQ0EsV0FBVyxDQUFDcEwsUUFBUSxFQUFFO01BQzdCO01BQ0EsSUFBSSxDQUFDck8sT0FBTyxDQUFDLElBQUlsRSxjQUFjLENBQUM1RixtQkFBbUIsQ0FBQ2UsaUJBQWlCLEVBQUUsSUFBSSxFQUFFa21CLFVBQVUsQ0FBQyxDQUFDO0lBQzNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxnQ0FBdUI7TUFDckJyaEMsaUJBQUssQ0FBQyx3QkFBd0IsQ0FBQztNQUMvQixJQUFJLENBQUNra0IsT0FBTyxDQUFDLElBQUlsRSxjQUFjLENBQUM1RixtQkFBbUIsQ0FBQ0ssWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFDO01BQ3hFLElBQUksQ0FBQ3UzQixjQUFjLENBQUMxeEMsTUFBTSxDQUFDLHlCQUF5QixDQUFDO0lBQ3ZEOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSwrQkFBc0J5QyxLQUFLLEVBQUU7TUFDM0IvQyxpQkFBSyxDQUFDLHlCQUF5QixDQUFDO01BQ2hDLElBQUksSUFBSSxDQUFDNDlCLGFBQWEsRUFBRTtRQUN0QjU5QixpQkFBSyxDQUFDLGtDQUFrQyxDQUFDO1FBQ3pDLElBQUksQ0FBQzQ5QixhQUFhLENBQUNyTCxRQUFRLEVBQUU7TUFDL0I7TUFDQSxJQUFJLENBQUNZLGFBQWEsQ0FBQ3B3QixLQUFLLENBQUM7SUFDM0I7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLGdDQUF1QjtNQUNyQi9DLGlCQUFLLENBQUMsMEJBQTBCLENBQUM7TUFDakMsSUFBSSxDQUFDa2tCLE9BQU8sQ0FBQyxJQUFJbEUsY0FBYyxDQUFDeEUsc0JBQXNCLENBQUNlLG9CQUFvQixDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQytrQixpQkFBaUIsRUFBRSxDQUFDO0lBQy9HOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxrQ0FBeUI3N0IsS0FBSyxFQUFFO01BQzlCekYsaUJBQUssQ0FBQywyQkFBMkIsQ0FBQztNQUNsQyxJQUFJLENBQUNra0IsT0FBTyxDQUFDLElBQUlsRSxjQUFjLENBQUN4RSxzQkFBc0IsQ0FBQ2dCLFdBQVcsRUFBRSxJQUFJLEVBQUU7UUFBRS9XLEtBQUssRUFBTEE7TUFBTSxDQUFDLENBQUMsQ0FBQztJQUN2Rjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0Esc0JBQWFzN0IsT0FBTyxFQUFFO01BQ3BCLElBQUloaEMsSUFBSSxHQUFHZ2hDLE9BQU8sR0FBRyxJQUFJLEdBQUd4OEIsSUFBSSxDQUFDNE8sU0FBUyxDQUFDNHRCLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRTtNQUNqRS9nQyxpQkFBSyx5QkFBa0JELElBQUksRUFBRztJQUNoQzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0Esb0JBQVdnaEMsT0FBTyxFQUFFO01BQ2xCLElBQUksQ0FBQzdjLE9BQU8sQ0FBQyxJQUFJbEUsY0FBYyxDQUFDNUYsbUJBQW1CLENBQUNLLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQztNQUN4RSxJQUFJMjVCLFFBQVEsR0FBR3JULE9BQU8sR0FBRyxJQUFJLEdBQUd4OEIsSUFBSSxDQUFDNE8sU0FBUyxDQUFDNHRCLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRTtNQUNyRTdnQyxpQkFBSyx1QkFBZ0JrMEMsUUFBUSxFQUFHO0lBQ2xDOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxxQkFBWTU5QixHQUFHLEVBQUU7TUFDZnhXLGlCQUFLLENBQUMsZ0JBQWdCLEdBQUd1RSxJQUFJLENBQUM0TyxTQUFTLENBQUNxRCxHQUFHLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO01BQ3RELElBQUksQ0FBQ3M3QixnQkFBZ0IsR0FBR2h4QyxNQUFNLENBQUNKLGdCQUFnQixDQUFDLElBQUksQ0FBQ294QyxnQkFBZ0IsQ0FBQztNQUN0RSxJQUFJLENBQUNBLGdCQUFnQixDQUFDenhDLE9BQU8sQ0FBQ21XLEdBQUcsQ0FBQztJQUNwQzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsMkJBQWtCcWQsU0FBUyxFQUFFO01BQzNCN3pCLGlCQUFLLENBQUMsbUJBQW1CLENBQUM7TUFDMUIsSUFBSSxDQUFDMjlCLFdBQVcsQ0FDYnRHLGVBQWUsQ0FBQ3hELFNBQVMsQ0FBQyxDQUMxQjN4QixJQUFJLENBQUMsWUFBTTtRQUNWbEMsaUJBQUssQ0FBQywyQkFBMkIsQ0FBQztNQUNwQyxDQUFDLENBQUMsQ0FDRG9DLEtBQUssQ0FBQyxVQUFDaUcsR0FBRyxFQUFLO1FBQ2RwSSxnQkFBSSxxQ0FBOEJvSSxHQUFHLEVBQUc7TUFDMUMsQ0FBQyxDQUFDO0lBQ047O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLHdCQUFld3JCLFNBQVMsRUFBRTtNQUN4Qjd6QixpQkFBSyxDQUFDLHVCQUF1QixDQUFDO01BQzlCLElBQUksQ0FBQ2loQyxjQUFjLENBQUNwTixTQUFTLEVBQUUsSUFBSSxDQUFDNkosUUFBUSxDQUFDL0osVUFBVSxDQUFDO0lBQzFEOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxvQ0FBMkI7TUFDekIzekIsaUJBQUssQ0FBQywyQkFBMkIsQ0FBQztJQUNwQzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsNEJBQW1CO01BQ2pCQSxpQkFBSyxDQUFDLDZCQUE2QixDQUFDO01BQ3BDLElBQUksQ0FBQ2trQixPQUFPLENBQUMsSUFBSWxFLGNBQWMsQ0FBQ3hFLHNCQUFzQixDQUFDTyxrQkFBa0IsQ0FBQyxDQUFDO0lBQzdFOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxtQ0FBMEI7TUFDeEIvYixpQkFBSyxDQUFDLDZCQUE2QixDQUFDO01BQ3BDLElBQUksSUFBSSxDQUFDNDlCLGFBQWEsRUFBRTtRQUN0QixJQUFJLENBQUNBLGFBQWEsQ0FBQ3VELG1CQUFtQixDQUFDLElBQUksQ0FBQ3pELFFBQVEsQ0FBQy9KLFVBQVUsQ0FBQztNQUNsRTtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxtQ0FBMEI7TUFDeEIzekIsaUJBQUssQ0FBQywwQkFBMEIsQ0FBQztNQUNqQyxJQUFJLENBQUNzekMsY0FBYyxFQUFFLENBQUNqekMsT0FBTyxFQUFFO01BQy9CO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLDJCQUFrQjYwQixNQUFNLEVBQUU7TUFDeEJsMUIsaUJBQUssQ0FBQyxzQkFBc0IsR0FBR3VFLElBQUksQ0FBQzRPLFNBQVMsQ0FBQytoQixNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO01BQy9ELElBQU1tZixVQUFVLEdBQUcxRCxZQUFZLENBQUNoc0MsSUFBSSxDQUFDdXdCLE1BQU0sQ0FBQzkyQixPQUFPLENBQUM7TUFDcEQsSUFBTXVqQyxXQUFXLEdBQUcrTyxhQUFhLENBQUMvckMsSUFBSSxDQUFDdXdCLE1BQU0sQ0FBQzkyQixPQUFPLENBQUM7TUFDdEQsSUFBSWkyQyxVQUFVLElBQUlBLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMzVyxRQUFRLENBQUMvSixVQUFVLEVBQUU7UUFDNUQsSUFBSSxDQUFDc2UsZ0JBQWdCLENBQUM1eEMsT0FBTyxFQUFFO01BQ2pDLENBQUMsTUFBTSxJQUFJc2hDLFdBQVcsSUFBSUEsV0FBVyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQ2pFLFFBQVEsQ0FBQy9KLFVBQVUsRUFBRTtRQUNyRSxJQUFJLENBQUNxZSxjQUFjLENBQUMzeEMsT0FBTyxFQUFFO01BQy9CLENBQUMsTUFBTSxJQUFJNjBCLE1BQU0sQ0FBQ3hLLElBQUksSUFBSXdLLE1BQU0sQ0FBQ3hLLElBQUksS0FBSywrQkFBK0IsRUFBRTtRQUN6RSxJQUFJLENBQUN4RyxPQUFPLENBQUMsSUFBSWxFLGNBQWMsQ0FBQzVGLG1CQUFtQixDQUFDVSxpQkFBaUIsRUFBRSxJQUFJLENBQUNvYSxNQUFNLENBQUMsQ0FBQztNQUN0RixDQUFDLE1BQU07UUFDTCxJQUFJLENBQUNoUixPQUFPLENBQUMsSUFBSWxFLGNBQWMsQ0FBQzVGLG1CQUFtQixDQUFDUyxjQUFjLEVBQUUsSUFBSSxFQUFFcWEsTUFBTSxDQUFDLENBQUM7TUFDcEY7SUFDRjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEsaUNBQXdCdHhCLElBQUksRUFBRTtNQUM1QixJQUFJLENBQUNzZ0IsT0FBTyxDQUFDLElBQUlsRSxjQUFjLENBQUM1RixtQkFBbUIsQ0FBQ1csOEJBQThCLEVBQUUsSUFBSSxFQUFFblgsSUFBSSxDQUFDLENBQUM7SUFDbEc7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLCtCQUFzQkEsSUFBSSxFQUFFO01BQzFCLElBQUksQ0FBQ3NnQixPQUFPLENBQUMsSUFBSWxFLGNBQWMsQ0FBQzVGLG1CQUFtQixDQUFDWSw0QkFBNEIsRUFBRSxJQUFJLEVBQUVwWCxJQUFJLENBQUMsQ0FBQztJQUNoRzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEsK0JBQXNCQSxJQUFJLEVBQUU7TUFDMUIsSUFBSSxDQUFDc2dCLE9BQU8sQ0FBQyxJQUFJbEUsY0FBYyxDQUFDNUYsbUJBQW1CLENBQUNhLDRCQUE0QixFQUFFLElBQUksRUFBRXJYLElBQUksQ0FBQyxDQUFDO0lBQ2hHOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSx3QkFBZStKLFVBQVUsRUFBRS9KLElBQUksRUFBRTtNQUMvQixJQUFJK0osVUFBVSxLQUFLLFlBQVksRUFBRTtRQUMvQixJQUFJLENBQUN5bkIsVUFBVSxDQUFDeHhCLElBQUksQ0FBQztNQUN2QixDQUFDLE1BQU07UUFDTDtRQUNBLElBQUksQ0FBQ3NnQixPQUFPLENBQ1YsSUFBSWxFLGNBQWMsQ0FBQzVGLG1CQUFtQixDQUFDYyxtQkFBbUIsRUFBRSxJQUFJLEVBQUU7VUFDaEV2TixVQUFVLEVBQUVBLFVBQVU7VUFDdEIvSixJQUFJLEVBQUVBO1FBQ1IsQ0FBQyxDQUFDLENBQ0g7TUFDSDtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxnQ0FBdUJrK0IsV0FBVyxFQUFFO01BQUE7TUFDbEM5aEMsaUJBQUssQ0FBQyw0QkFBNEIsQ0FBQztNQUNuQyxJQUFJLENBQUNzK0IscUJBQXFCLEdBQUc7UUFDM0J5RCxhQUFhLEVBQUVELFdBQVcsSUFBSTtNQUNoQyxDQUFDO01BQ0QsSUFBSSxJQUFJLENBQUNwRSxRQUFRLENBQUNOLG1CQUFtQixFQUFFO1FBQ3JDLElBQUlqYSxDQUFDLEdBQUd2YSxVQUFVLENBQ2hCLFlBQU07VUFDSnNlLFlBQVksQ0FBQy9ELENBQUMsQ0FBQztVQUNmLElBQUksTUFBSSxDQUFDeWEsYUFBYSxFQUFFO1lBQ3RCLE1BQUksQ0FBQ0EsYUFBYSxDQUFDb0UsS0FBSyxDQUFDLE1BQUksQ0FBQzFELHFCQUFxQixDQUFDO1VBQ3REO1VBQ0EsTUFBSSxDQUFDVCxpQkFBaUIsR0FBRyxNQUFJLENBQUNGLFdBQVc7VUFDekMsTUFBSSxDQUFDelosT0FBTyxDQUNWLElBQUl6RCwwQkFBMEIsQ0FBQ3BCLCtCQUErQixDQUFDRyxNQUFNLEVBQUUsTUFBSSxFQUFFO1lBQzNFeWlCLFVBQVUsRUFBRSxNQUFJO1lBQ2hCckQsU0FBUyxFQUFFLE1BQUksQ0FBQ2Y7VUFDbEIsQ0FBQyxDQUFDLENBQ0g7UUFDSCxDQUFDLEVBQ0QsSUFBSSxDQUFDRCxhQUFhLEdBQUcsSUFBSSxDQUFDRixRQUFRLENBQUNMLGlCQUFpQixHQUFHLEdBQUcsQ0FDM0Q7TUFDSDtNQUNBLElBQUksQ0FBQ25aLE9BQU8sQ0FDVixJQUFJbEUsY0FBYyxDQUFDeEUsc0JBQXNCLENBQUNXLHNCQUFzQixFQUFFLElBQUksRUFBRTtRQUN0RXZlLElBQUksRUFBRWtrQyxXQUFXO1FBQ2pCbk0sV0FBVyxFQUFFLElBQUksQ0FBQ3VNLGNBQWM7TUFDbEMsQ0FBQyxDQUFDLENBQ0g7SUFDSDs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEsNEJBQW1Cdk0sV0FBVyxFQUFFejFCLEtBQUssRUFBRTtNQUNyQyxJQUFJLENBQUNna0IsT0FBTyxDQUNWLElBQUlsRSxjQUFjLENBQUN4RSxzQkFBc0IsQ0FBQ2Msa0JBQWtCLEVBQUUsSUFBSSxFQUFFO1FBQ2xFcVosV0FBVyxFQUFFQSxXQUFXO1FBQ3hCejFCLEtBQUssRUFBRUE7TUFDVCxDQUFDLENBQUMsQ0FDSDtJQUNIOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQRTtJQUFBO0lBQUEsT0FRQSw4QkFBcUJ5MUIsV0FBVyxFQUFFd00sV0FBVyxFQUFFO01BQzdDLElBQUksQ0FBQ2plLE9BQU8sQ0FDVixJQUFJbEUsY0FBYyxDQUFDeEUsc0JBQXNCLENBQUNhLG9CQUFvQixFQUFFLElBQUksRUFBRTtRQUNwRXNaLFdBQVcsRUFBRUEsV0FBVztRQUN4QnYzQixPQUFPLEVBQUUrakM7TUFDWCxDQUFDLENBQUMsQ0FDSDtJQUNIOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSwyQkFBa0J4TSxXQUFXLEVBQUU7TUFDN0IsSUFBSSxDQUFDelIsT0FBTyxDQUNWLElBQUlsRSxjQUFjLENBQUN4RSxzQkFBc0IsQ0FBQ1UsaUJBQWlCLEVBQUUsSUFBSSxFQUFFO1FBQ2pFeVosV0FBVyxFQUFFQTtNQUNmLENBQUMsQ0FBQyxDQUNIO0lBQ0g7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLDRCQUFtQkEsV0FBVyxFQUFFO01BQzlCLElBQUksQ0FBQ3pSLE9BQU8sQ0FDVixJQUFJbEUsY0FBYyxDQUFDeEUsc0JBQXNCLENBQUNZLGtCQUFrQixFQUFFLElBQUksRUFBRTtRQUNsRXVaLFdBQVcsRUFBRUE7TUFDZixDQUFDLENBQUMsQ0FDSDtJQUNIOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxvQkFBVy94QixJQUFJLEVBQUU7TUFDZjtNQUNBLElBQUksQ0FBQ3NnQixPQUFPLENBQUMsSUFBSWxFLGNBQWMsQ0FBQzVGLG1CQUFtQixDQUFDUSxnQkFBZ0IsRUFBRSxJQUFJLEVBQUVoWCxJQUFJLENBQUMsQ0FBQztJQUNwRjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0Esd0JBQWUyckMsVUFBVSxFQUFFO01BQ3pCLElBQUksQ0FBQzdSLFFBQVEsR0FBR25xQixNQUFNLENBQUNtbkIsTUFBTSxDQUFDLElBQUksQ0FBQ2dELFFBQVEsRUFBRTZSLFVBQVUsQ0FBQztJQUMxRDs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEsK0JBQXNCO01BQ3BCLE9BQU8sSUFBSSxDQUFDMVIsaUJBQWlCO0lBQy9COztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQRTtJQUFBO0lBQUEsT0FRQSx5QkFBZ0I7TUFDZCxPQUFPLElBQUksQ0FBQ0QsYUFBYTtJQUMzQjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsNkJBQW9CO01BQ2xCLE9BQU8sSUFBSSxDQUFDRCxXQUFXLEdBQUcsSUFBSSxDQUFDQSxXQUFXLENBQUM1SCxVQUFVLEdBQUc5MkIsU0FBUztJQUNuRTs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsMEJBQWlCO01BQ2YsT0FBTyxJQUFJLENBQUMwK0IsV0FBVyxHQUFHLElBQUksQ0FBQ0EsV0FBVyxDQUFDaEksV0FBVyxHQUFHMTJCLFNBQVM7SUFDcEU7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLDBCQUFpQjtNQUNmLE9BQU8sSUFBSSxDQUFDKytCLFlBQVk7SUFDMUI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLHNCQUFhO01BQ1gsT0FBTyxJQUFJLENBQUNOLFFBQVE7SUFDdEI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLG1CQUFVO01BQ1IsT0FBT29RLFlBQVksQ0FBQ25TLEdBQUcsQ0FBQ2lILFdBQVcsRUFBRTtJQUN2QztFQUFDO0VBQUE7QUFBQSxFQW53Q3dCaGdDLGFBQVk7QUFzd0N4QjZ1QyxrRkFBWSxFOzs7Ozs7MkRDMTFDM0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUQyQztBQUNIO0FBQ3FCO0FBQ1o7QUFDUDtBQUNBO0FBQ0Y7QUFDQTtBQUNpQztBQUN2QjtBQUNBO0FBQ29DO0FBRXRGLElBQU1ud0IsaUJBQUksR0FBRyxZQUFZO0FBQ3pCLElBQU0ycEIsK0JBQWtCLEdBQUcsSUFBSTtBQUUvQixJQUFNanJDLGtCQUFLLEdBQUcsU0FBUkEsS0FBSyxDQUFJNUIsT0FBTyxFQUFLO0VBQ3pCd3lDLFNBQVEsQ0FBQ3R2QixpQkFBSSxFQUFFbGpCLE9BQU8sQ0FBQztBQUN6QixDQUFDO0FBQ0QsSUFBTTZCLGlCQUFJLEdBQUcsU0FBUEEsSUFBSSxDQUFJN0IsT0FBTyxFQUFLO0VBQ3hCeXlDLFFBQU8sQ0FBQ3Z2QixpQkFBSSxFQUFFbGpCLE9BQU8sQ0FBQztBQUN4QixDQUFDO0FBQ0QsSUFBTThCLGtCQUFLLEdBQUcsU0FBUkEsS0FBSyxDQUFJOUIsT0FBTyxFQUFLO0VBQ3pCMHlDLFNBQVEsQ0FBQ3h2QixpQkFBSSxFQUFFbGpCLE9BQU8sQ0FBQztBQUN6QixDQUFDOztBQUVEO0FBQ0EsSUFBTXcrQiwyQkFBYyxHQUFHO0VBQ3JCNUMsUUFBUSxFQUFFLE9BQU87RUFDakJQLElBQUksRUFBRSxHQUFHO0VBQ1RZLEdBQUcsRUFBRSxNQUFNO0VBQ1hnVCxVQUFVLEVBQUVVLGdCQUFnQixDQUFDQyxJQUFJO0VBQ2pDK0MsWUFBWSxFQUFFLElBQUk7RUFDbEJqVSxjQUFjLEVBQUUsbUJBQW1CO0VBQ25DQyxnQkFBZ0IsRUFBRTtJQUNoQi9HLFVBQVUsRUFBRSxDQUFDO01BQUVnSCxJQUFJLEVBQUU7SUFBZ0MsQ0FBQyxDQUFDO0lBQ3ZENUcsb0JBQW9CLEVBQUUsQ0FBQztJQUN2QkMsWUFBWSxFQUFFO0VBQ2hCLENBQUM7RUFBRTtFQUNITCxVQUFVLEVBQUUvMkIsU0FBUztFQUFFO0VBQ3ZCZytCLFlBQVksRUFBRVYsaUJBQWlCLENBQUNDLEdBQUc7RUFDbkM0VCxTQUFTLEVBQUU7SUFDVDEzQixLQUFLLEVBQUUsRUFBRTtJQUNUN0UsS0FBSyxFQUFFO0VBQ1QsQ0FBQztFQUNEbTlCLHFCQUFxQixFQUFFLEtBQUs7RUFDNUJ4RCxnQkFBZ0IsRUFBRSxJQUFJaUIsa0JBQWtCLEVBQUU7RUFDMUN3QyxjQUFjLEVBQUVoeUMsU0FBUztFQUN6QjQzQix3QkFBd0IsRUFBRTUzQixTQUFTO0VBQ25Db3hDLFFBQVEsRUFBRSxLQUFLO0VBQ2YvUyxlQUFlLEVBQUUsS0FBSztFQUN0QkYsbUJBQW1CLEVBQUUsS0FBSztFQUFFO0VBQzVCOE4sVUFBVSxFQUFFLEtBQUssQ0FBRTtBQUNyQixDQUFDO0FBQUEsSUFFS29KLHVCQUFVO0VBQUE7RUFBQTtFQUNkO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0Usb0JBQVlscEMsR0FBRyxFQUFFMEMsT0FBTyxFQUFzQjtJQUFBO0lBQUEsSUFBcEJvOUIsVUFBVSx1RUFBRyxLQUFLO0lBQUE7SUFDMUM7SUFDQSxJQUFNRSxjQUFjLEdBQUdoZ0MsR0FBRyxHQUFHa3dCLHNCQUFzQixDQUFDbHdCLEdBQUcsQ0FBQyxHQUFHd3hCLDJCQUFjO0lBQ3pFd08sY0FBYyxDQUFDdE8sY0FBYyxHQUFHaHZCLE9BQU8sR0FBR0EsT0FBTyxDQUFDN0MsRUFBRSxHQUFHMnhCLDJCQUFjLENBQUNFLGNBQWM7SUFDcEZzTyxjQUFjLENBQUNGLFVBQVUsR0FBR0EsVUFBVTtJQUV0QyxNQUFLRyxXQUFXLEdBQUdwc0MsU0FBUztJQUU1QixJQUFJbU0sR0FBRyxFQUFFO01BQ1AsTUFBS2tnQyxnQkFBZ0IsQ0FBQ0YsY0FBYyxDQUFDO0lBQ3ZDO0lBQUM7RUFDSDs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBO01BQUEsMkdBUUEsaUJBQXVCenBDLE9BQU87UUFBQTtVQUFBO1lBQUE7Y0FBQTtjQUFBLE9BQ3RCLElBQUksQ0FBQzRwQyxJQUFJLENBQUM1cEMsT0FBTyxDQUFDO1lBQUE7Y0FBQTtjQUFBLE9BQ2xCLElBQUksQ0FBQ3F4QyxPQUFPLEVBQUU7WUFBQTtZQUFBO2NBQUE7VUFBQTtRQUFBO01BQUEsQ0FDckI7TUFBQTtRQUFBO01BQUE7TUFBQTtJQUFBO0lBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQTtNQUFBLDBHQVFBLGtCQUFzQmpkLFVBQVU7UUFBQTtVQUFBO1lBQUE7Y0FBQSxrQ0FDdkIsSUFBSXYxQixPQUFPLENBQUMsVUFBQ0gsT0FBTyxFQUFFQyxNQUFNLEVBQUs7Z0JBQ3RDLElBQUl5MUIsVUFBVSxDQUFDMkMsaUJBQWlCLEtBQUssVUFBVSxFQUFFO2tCQUMvQ3I0QixPQUFPLENBQUMwMUIsVUFBVSxDQUFDNlYsZ0JBQWdCLENBQUM7Z0JBQ3RDLENBQUMsTUFBTTtrQkFDTGhqQyxVQUFVLENBQUMsWUFBWTtvQkFDckJ2SSxPQUFPLENBQUMwMUIsVUFBVSxDQUFDNlYsZ0JBQWdCLENBQUM7a0JBQ3RDLENBQUMsRUFBRVgsK0JBQWtCLENBQUM7a0JBQ3RCbFYsVUFBVSxDQUFDMEMseUJBQXlCLEdBQUcsWUFBTTtvQkFDM0MxQyxVQUFVLENBQUMyQyxpQkFBaUIsS0FBSyxVQUFVLElBQUlyNEIsT0FBTyxDQUFDMDFCLFVBQVUsQ0FBQzZWLGdCQUFnQixDQUFDO2tCQUNyRixDQUFDO2dCQUNIO2NBQ0YsQ0FBQyxDQUFDO1lBQUE7WUFBQTtjQUFBO1VBQUE7UUFBQTtNQUFBLENBQ0g7TUFBQTtRQUFBO01BQUE7TUFBQTtJQUFBO0lBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUkU7SUFBQTtJQUFBO01BQUEscUdBU0Esa0JBQWlCMVUsa0JBQWtCO1FBQUE7UUFBQTtVQUFBO1lBQUE7Y0FBQTtjQUV2QjFnQixHQUFHLEdBQUswZ0Isa0JBQWtCLENBQTFCMWdCLEdBQUc7Y0FDTCs5QixPQUFPLEdBQUdoZSxZQUFtQixDQUFDL2YsR0FBRyxDQUFDO2NBQUE7Y0FBQSxPQUMzQixJQUFJLENBQUM2MEIsV0FBVyxDQUFDUSxZQUFZLENBQUMwSSxPQUFPLENBQUM7WUFBQTtjQUFBO1lBQUE7Y0FBQTtjQUFBO2NBRW5EcjBDLGtCQUFLLENBQUMsYUFBRTlCLE9BQU8sZ0JBQUssQ0FBQztjQUNyQjtjQUNBLElBQUksQ0FBQ2cyQixpQkFBaUIsY0FBRztjQUFBO1lBQUE7WUFBQTtjQUFBO1VBQUE7UUFBQTtNQUFBLENBRzVCO01BQUE7UUFBQTtNQUFBO01BQUE7SUFBQTtJQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBO01BQUEsa0hBT0Esa0JBQThCNWQsR0FBRztRQUFBO1FBQUE7UUFBQTtVQUFBO1lBQUE7Y0FDekJzMUIsUUFBUSxHQUFHdlYsd0JBQStCLENBQUMvZixHQUFHLEVBQUUsTUFBTSxDQUFDO2NBQ3ZEdTFCLFNBQVMsR0FBR3hWLHdCQUErQixDQUFDL2YsR0FBRyxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUM7Y0FBQTtjQUFBLE9BQy9ELElBQUksQ0FBQzYwQixXQUFXLENBQUNXLE9BQU8sQ0FBQ0YsUUFBUSxDQUFDO1lBQUE7Y0FBQSxrQ0FDakMsSUFBSXRyQyxPQUFPLENBQUMsVUFBQ0gsT0FBTyxFQUFFQyxNQUFNLEVBQUs7Z0JBQ3RDLElBQU0yckMsU0FBUyxHQUFHLFNBQVpBLFNBQVMsR0FBUztrQkFDdEJyakMsVUFBVSxrR0FBQztvQkFBQTtzQkFBQTt3QkFBQTswQkFBQTswQkFBQSxPQUNILE1BQUksQ0FBQ3lpQyxXQUFXLENBQUNXLE9BQU8sQ0FBQ0QsU0FBUyxDQUFDO3dCQUFBOzBCQUN6QzFyQyxPQUFPLEVBQUU7d0JBQUE7d0JBQUE7MEJBQUE7c0JBQUE7b0JBQUE7a0JBQUEsQ0FDVixJQUFFLEdBQUcsQ0FBQztnQkFDVCxDQUFDO2dCQUNENHJDLFNBQVMsRUFBRTtjQUNiLENBQUMsQ0FBQztZQUFBO1lBQUE7Y0FBQTtVQUFBO1FBQUE7TUFBQSxDQUNIO01BQUE7UUFBQTtNQUFBO01BQUE7SUFBQTtJQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFWRTtJQUFBO0lBQUEsT0FXQSx3QkFBZXBZLFNBQVMsRUFBRUYsVUFBVSxFQUFFO01BQ3BDM3pCLGtCQUFLLENBQUN1RSxJQUFJLENBQUM0TyxTQUFTLENBQUMwZ0IsU0FBUyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztJQUMzQzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBO01BQUEsK0ZBUUEsa0JBQVdseUIsT0FBTztRQUFBO1FBQUE7VUFBQTtZQUFBO2NBQ2hCLElBQUksQ0FBQys3QixRQUFRLEdBQUcsd0RBQUtkLDJCQUFjLEdBQUtqN0IsT0FBTyxDQUFFO2NBQUEsaUJBQ0MsSUFBSSxDQUFDKzdCLFFBQVEsRUFBdkQxRCxRQUFRLGtCQUFSQSxRQUFRLEVBQUVPLElBQUksa0JBQUpBLElBQUksRUFBRWQsSUFBSSxrQkFBSkEsSUFBSSxFQUFFWSxHQUFHLGtCQUFIQSxHQUFHLEVBQUUxRyxVQUFVLGtCQUFWQSxVQUFVO2NBQ3ZDMFksS0FBSyxHQUFHclMsUUFBUSxLQUFLLElBQUksR0FBRyxNQUFNLEdBQUcsT0FBTztjQUNsRCxJQUFJLENBQUNzUyxRQUFRLGFBQU1ELEtBQUssZ0JBQU05UixJQUFJLGNBQUlkLElBQUksY0FBSVksR0FBRyw0QkFBa0IxRyxVQUFVLENBQUU7Y0FDL0UsSUFBSSxDQUFDMFgsV0FBVyxHQUFHLElBQUlsQix5QkFBdUIsQ0FBQyxJQUFJLENBQUNtQyxRQUFRLENBQUM7Y0FDN0QsSUFBSSxDQUFDek8saUJBQWlCLEdBQUcsSUFBSSxDQUFDd04sV0FBVztjQUFBLCtIQUV2QjFwQyxPQUFPO1lBQUE7WUFBQTtjQUFBO1VBQUE7UUFBQTtNQUFBLENBQzFCO01BQUE7UUFBQTtNQUFBO01BQUE7SUFBQTtJQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVhFO0lBQUE7SUFBQTtNQUFBLHlHQVlBLGtCQUFxQkEsT0FBTyxFQUFFNEosV0FBVztRQUFBO1FBQUE7VUFBQTtZQUFBO2NBQUEsa0JBQ1csSUFBSSxDQUFDbXlCLFFBQVEsRUFBdkQxRCxRQUFRLG1CQUFSQSxRQUFRLEVBQUVPLElBQUksbUJBQUpBLElBQUksRUFBRWQsSUFBSSxtQkFBSkEsSUFBSSxFQUFFWSxHQUFHLG1CQUFIQSxHQUFHLEVBQUUxRyxVQUFVLG1CQUFWQSxVQUFVO2NBQzdDLElBQUksQ0FBQzJZLFFBQVEsYUFBTXRTLFFBQVEsZ0JBQU1PLElBQUksY0FBSWQsSUFBSSxjQUFJWSxHQUFHLDRCQUFrQjFHLFVBQVUsQ0FBRTtjQUNsRixJQUFJLENBQUMwWCxXQUFXLEdBQUcsSUFBSWxCLHlCQUF1QixDQUFDLElBQUksQ0FBQ21DLFFBQVEsQ0FBQztjQUM3RCxJQUFJLENBQUN6TyxpQkFBaUIsR0FBRyxJQUFJLENBQUN3TixXQUFXO2NBQUEseUlBRWIxcEMsT0FBTyxFQUFFNEosV0FBVztZQUFBO1lBQUE7Y0FBQTtVQUFBO1FBQUE7TUFBQSxDQUNqRDtNQUFBO1FBQUE7TUFBQTtNQUFBO0lBQUE7SUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBVkU7SUFBQTtJQUFBO01BQUEsNkNBV0E7UUFBQTtRQUFBLElBQWNvb0IsVUFBVSx1RUFBRyxJQUFJO1FBQUEsSUFBRXB6QixPQUFPLHVFQUFHLElBQUk7UUFBQTtVQUFBO1VBQUE7WUFBQTtjQUFBO2dCQUFBLGtCQUUzQyxNQUFJLENBQUNtOUIsUUFBUSxFQURUMFMsU0FBUyxtQkFBVEEsU0FBUyxFQUFFQyxRQUFRLG1CQUFSQSxRQUFRLEVBQUV0VCxnQkFBZ0IsbUJBQWhCQSxnQkFBZ0IsRUFBRUssbUJBQW1CLG1CQUFuQkEsbUJBQW1CLEVBQUV2Ryx3QkFBd0IsbUJBQXhCQSx3QkFBd0IsRUFBRXFVLFVBQVUsbUJBQVZBLFVBQVUsRUFFdEc7Z0JBQ0E7Z0JBQ003SyxrQkFBa0IsR0FBR2pELG1CQUFtQixJQUFJN0csMEJBQTBCLEVBQUU7Z0JBQzlFLElBQUk4SixrQkFBa0IsSUFBSSxDQUFDeEosd0JBQXdCLEVBQUU7a0JBQ25EQSx3QkFBd0IsR0FBRztvQkFDekJqNUIsSUFBSTtrQkFDTixDQUFDO2dCQUNIO2dCQUNBLE1BQUksQ0FBQzgvQixRQUFRLENBQUNOLG1CQUFtQixHQUFHaUQsa0JBQWtCO2dCQUFBO2dCQUdwRCxJQUFJMU0sVUFBVSxFQUFFO2tCQUNkLE1BQUksQ0FBQytKLFFBQVEsQ0FBQy9KLFVBQVUsR0FBR0EsVUFBVTtnQkFDdkM7Z0JBQUM7Z0JBQUEsT0FDdUIsTUFBSSxDQUFDMFgsV0FBVyxDQUFDa0IsVUFBVSxFQUFFO2NBQUE7Z0JBQUE7Z0JBQTdDN0IsS0FBSyx5QkFBTEEsS0FBSztnQkFDYixJQUFJQSxLQUFLLEVBQUU7a0JBQ1QsTUFBSSxDQUFDaE4sUUFBUSxDQUFDMUgsVUFBVSxHQUFHMFUsS0FBSztnQkFDbEM7Z0JBQ0E7Z0JBQ0E7Z0JBQUE7Z0JBQUEsT0FDeUIsTUFBSSxDQUFDOEkscUJBQXFCLENBQ2pEelcsZ0JBQWdCLEVBQ2hCOTlCLFNBQVMsRUFDVHlyQyxLQUFLLElBQUksTUFBSSxDQUFDaE4sUUFBUSxDQUFDMUgsVUFBVSxDQUNsQztjQUFBO2dCQUpLRCxVQUFVO2dCQUtoQixNQUFJLENBQUM3UixPQUFPLENBQUMsSUFBSWxFLGNBQWMsQ0FBQ3hFLHNCQUFzQixDQUFDSSx5QkFBeUIsRUFBRSxNQUFJLEVBQUVtYSxVQUFVLENBQUMsQ0FBQztnQkFBQTtnQkFBQSxPQUMxRSxNQUFJLENBQUNtZCxlQUFlLEVBQUU7Y0FBQTtnQkFBMUMzbkMsV0FBVztnQkFDakI7Z0JBQ0FBLFdBQVcsQ0FBQzRsQyxTQUFTLEVBQUUsQ0FBQ25yQyxPQUFPLENBQUMsVUFBQ1AsS0FBSyxFQUFLO2tCQUN6QyxJQUFNK3VDLFdBQVcsR0FBR3plLFVBQVUsQ0FBQ3lWLGNBQWMsQ0FBQy9sQyxLQUFLLEVBQUU7b0JBQ25EZ21DLFNBQVMsRUFBRTtrQkFDYixDQUFDLENBQUM7Z0JBQ0osQ0FBQyxDQUFDO2dCQUNGO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUFBO2dCQUFBLE9BQ29CLE1BQUksQ0FBQzlOLFdBQVcsQ0FBQzhXLDBCQUEwQixDQUFDckUsU0FBUyxFQUFFQyxRQUFRLENBQUM7Y0FBQTtnQkFBOUVwUixLQUFLO2dCQUFBO2dCQUFBLE9BQ0wsTUFBSSxDQUFDdEIsV0FBVyxDQUFDeEcsbUJBQW1CLENBQUM4SCxLQUFLLENBQUM7Y0FBQTtnQkFBQTtnQkFBQSxPQUNsQixNQUFJLENBQUNpTixlQUFlLENBQUNuVyxVQUFVLENBQUM7Y0FBQTtnQkFBekQ2VixnQkFBZ0I7Z0JBQ3RCLE1BQUksQ0FBQzFuQixPQUFPLENBQUMsSUFBSWxFLGNBQWMsQ0FBQ3hFLHNCQUFzQixDQUFDSyxXQUFXLEVBQUUsTUFBSSxFQUFFK3ZCLGdCQUFnQixDQUFDLENBQUM7Z0JBQUE7Z0JBQUEsT0FDdEUsTUFBSSxDQUFDTyxVQUFVLENBQUNqQixVQUFVLEdBQUdqTSxLQUFLLEdBQUcyTSxnQkFBZ0IsQ0FBQztjQUFBO2dCQUFBO2dCQUFwRXAxQixHQUFHLHlCQUFIQSxHQUFHO2dCQUFBO2dCQUFBLE9BQ0wsTUFBSSxDQUFDbzlCLHFCQUFxQixDQUFDO2tCQUFFdjBDLElBQUksRUFBRSxRQUFRO2tCQUFFbVgsR0FBRyxFQUFFK2YsWUFBbUIsQ0FBQy9mLEdBQUc7Z0JBQUUsQ0FBQyxDQUFDO2NBQUE7Z0JBQ25GLE1BQUksQ0FBQzBOLE9BQU8sQ0FBQyxJQUFJbEUsY0FBYyxDQUFDeEUsc0JBQXNCLENBQUNNLFNBQVMsRUFBRSxNQUFJLEVBQUV0RixHQUFHLENBQUMsQ0FBQztnQkFBQSxLQUN6RTAwQixVQUFVO2tCQUFBO2tCQUFBO2dCQUFBO2dCQUNKMTBCLElBQUcsR0FBS28xQixnQkFBZ0IsQ0FBeEJwMUIsR0FBRztnQkFBQTtnQkFBQSxPQUNMLE1BQUksQ0FBQzQxQix1QkFBdUIsQ0FBQzUxQixJQUFHLENBQUM7Y0FBQTtnQkFFekMsTUFBSSxDQUFDME4sT0FBTyxDQUFDLElBQUlsRSxjQUFjLENBQUN4RSxzQkFBc0IsQ0FBQ1Esb0JBQW9CLEVBQUUsTUFBSSxDQUFDLENBQUM7Z0JBQ25GcE0sT0FBVyxDQUFDM0MsMkJBQTJCLENBQUMsTUFBSSxDQUFDaWxDLG9CQUFvQixDQUFDO2dCQUNsRSxNQUFJLENBQUNodUIsT0FBTyxDQUFDLElBQUlsRSxjQUFjLENBQUM1RixtQkFBbUIsQ0FBQ0ksYUFBYSxFQUFFLE1BQUksQ0FBQyxDQUFDO2dCQUN6RSxJQUFJamEsT0FBTyxFQUFFO2tCQUNYQSxPQUFPLENBQUNGLE9BQU8sQ0FBQyxNQUFJLENBQUM7Z0JBQ3ZCO2dCQUFDLGtDQUNNLE1BQUk7Y0FBQTtnQkFBQTtnQkFBQTtnQkFFWEgsa0JBQUssY0FBRztnQkFDUjBQLE9BQVcsQ0FBQ3ZDLDhCQUE4QixDQUFDLE1BQUksQ0FBQzZrQyxvQkFBb0IsQ0FBQztnQkFDckUsTUFBSSxDQUFDaHVCLE9BQU8sQ0FBQyxJQUFJbEUsY0FBYyxDQUFDNUYsbUJBQW1CLENBQUNHLGVBQWUsRUFBRSxNQUFJLGVBQUksQ0FBQztnQkFDOUUsSUFBSWhhLE9BQU8sRUFBRTtrQkFDWEEsT0FBTyxDQUFDRCxNQUFNLGNBQUc7Z0JBQ25CO2dCQUFDO2NBQUE7Y0FBQTtnQkFBQTtZQUFBO1VBQUE7UUFBQTtNQUFBLENBR0o7TUFBQTtRQUFBO01BQUE7TUFBQTtJQUFBO0lBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUkU7SUFBQTtJQUFBO01BQUEsK0NBU0E7UUFBQTtRQUFBLElBQWdCeXpDLFNBQVMsdUVBQUcsS0FBSztRQUFBO1VBQUE7WUFBQTtjQUFBO2dCQUMvQi96QyxrQkFBSyxDQUFDLHNCQUFzQixDQUFDO2dCQUM3QixJQUFJLE1BQUksQ0FBQ3FyQyxXQUFXLEVBQUU7a0JBQ3BCLE1BQUksQ0FBQ0EsV0FBVyxDQUFDOVksUUFBUSxFQUFFO2dCQUM3QjtnQkFDQSxJQUFJLE1BQUksQ0FBQ29MLFdBQVcsRUFBRTtrQkFDcEIsTUFBSSxDQUFDQSxXQUFXLENBQUNwTCxRQUFRLEVBQUU7Z0JBQzdCO2dCQUNBLE1BQUksQ0FBQzhZLFdBQVcsR0FBR3BzQyxTQUFTO2dCQUM1QixNQUFJLENBQUMwK0IsV0FBVyxHQUFHMStCLFNBQVM7Z0JBQzVCLE1BQUksQ0FBQzQrQixpQkFBaUIsR0FBRzUrQixTQUFTO2dCQUVsQyxJQUFJLE1BQUksQ0FBQ3krQixRQUFRLENBQUNzVCxxQkFBcUIsSUFBSStDLFNBQVMsRUFBRTtrQkFDcEQsTUFBSSxDQUFDVixTQUFTLEVBQUU7Z0JBQ2xCO2dCQUNBLE1BQUksQ0FBQ252QixPQUFPLENBQUMsSUFBSWxFLGNBQWMsQ0FBQzVGLG1CQUFtQixDQUFDTyxpQkFBaUIsRUFBRSxNQUFJLENBQUMsQ0FBQztnQkFDN0UvSyxPQUFXLENBQUN2Qyw4QkFBOEIsQ0FBQyxNQUFJLENBQUM2a0Msb0JBQW9CLENBQUM7Z0JBQUEsa0NBQzlELE1BQUk7Y0FBQTtjQUFBO2dCQUFBO1lBQUE7VUFBQTtRQUFBO01BQUEsQ0FDWjtNQUFBO1FBQUE7TUFBQTtNQUFBO0lBQUE7SUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQU5FO0lBQUE7SUFBQSxPQU9BLHlCQUFnQjtNQUNkLE9BQU9qekMsU0FBUztJQUNsQjtFQUFDO0VBQUE7QUFBQSxFQWxSc0J3eUMscUJBQVk7QUFxUnRCNkMsd0VBQVUsRTs7QUM1VWI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFNkM7QUFDVDtBQUNOO0FBQ0Y7QUFDRDtBQUVVO0FBQ0g7QUFDVjtBQUVwQyxJQUFNaHpCLGNBQUksR0FBRyxrQkFBa0I7QUFDL0IsSUFBTW96QixjQUFjLEdBQUcsSUFBSXJ6QyxrQkFBZ0IsRUFBRTtBQUM3QyxJQUFNc3pDLGFBQWEsR0FBSSxZQUFZO0VBQ2pDLElBQUlwMUMsR0FBRyxHQUFHLElBQUl5cUMsR0FBRyxFQUFFO0VBQ25CenFDLEdBQUcsQ0FBQzRCLEdBQUcsQ0FBQzJzQyxZQUFZLENBQUNuUyxHQUFHLEVBQUU4VixxQkFBWSxDQUFDO0VBQ3ZDbHlDLEdBQUcsQ0FBQzRCLEdBQUcsQ0FBQzJzQyxZQUFZLENBQUNsUyxJQUFJLEVBQUUrUyxzQkFBYSxDQUFDO0VBQ3pDLE9BQU9wdkMsR0FBRztBQUNaLENBQUMsRUFBRzs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkEsSUFLTXExQywwQkFBZ0I7RUFBQTtFQUFBO0VBRXBCLDRCQUFlO0lBQUE7SUFBQTtJQUNiO0lBQ0EsTUFBS2xYLFFBQVEsR0FBR3orQixTQUFTO0lBQ3pCLE1BQUswdEMsTUFBTSxHQUFHLENBQ1ptQixZQUFZLENBQUNuUyxHQUFHLEVBQ2hCbVMsWUFBWSxDQUFDbFMsSUFBSSxDQUNsQjtJQUFBO0VBQ0g7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORTtJQUFBO0lBQUEsT0FPQSxnQ0FBd0J2NUIsS0FBSyxFQUFFVixPQUFPLEVBQUU7TUFDdEMsT0FBTyt5QyxjQUFjLENBQUN2NkIsTUFBTSxDQUFDOVgsS0FBSyxFQUFFc3lDLGFBQWEsRUFBRWh6QyxPQUFPLEVBQUUsTUFBTSxDQUFDO0lBQ3JFOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUxFO0lBQUE7SUFBQSxPQU1BLDJCQUFtQjtNQUNqQixPQUFPLElBQUksQ0FBQ2dyQyxNQUFNO0lBQ3BCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVJFO0lBQUE7SUFBQSxPQVNBLHlCQUFpQnRxQyxLQUFLLEVBQUU7TUFDdEI7TUFDQUEsS0FBSyxHQUFHLE9BQU9BLEtBQUssS0FBSyxRQUFRLEdBQUcsQ0FBQ0EsS0FBSyxDQUFDLEdBQUdBLEtBQUs7O01BRW5EO01BQ0EsSUFBTThnQixDQUFDLEdBQUc5Z0IsS0FBSyxDQUFDNFAsTUFBTSxDQUFDLFVBQUE2RixLQUFLLEVBQUk7UUFDOUIsSUFBSXhWLEdBQUc7UUFDUCxLQUFLQSxHQUFHLElBQUl3ckMsWUFBWSxFQUFFO1VBQ3hCLElBQUlBLFlBQVksQ0FBQ3hyQyxHQUFHLENBQUMsQ0FBQ2lILFdBQVcsRUFBRSxLQUFLdU8sS0FBSyxDQUFDdk8sV0FBVyxFQUFFLEVBQUU7WUFDM0QsT0FBTyxJQUFJO1VBQ2I7UUFDRjtRQUNBLE9BQU8sS0FBSztNQUNkLENBQUMsQ0FBQyxDQUFDaEssR0FBRyxDQUFDLFVBQUF1WSxLQUFLO1FBQUEsT0FBSUEsS0FBSyxDQUFDdk8sV0FBVyxFQUFFO01BQUEsRUFBQzs7TUFFcEM7TUFDQSxJQUFJLENBQUNvakMsTUFBTSxHQUFHLDRCQUFJLElBQUlDLEdBQUcsQ0FBQ3pwQixDQUFDLENBQUMsQ0FBQztNQUM3Qm5qQixTQUFLLENBQUNzaEIsY0FBSSwyQkFBb0IsSUFBSSxDQUFDcXJCLE1BQU0sRUFBRztNQUM1QyxPQUFPLElBQUk7SUFDYjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEsY0FBTWhyQyxPQUFPLEVBQUU7TUFDYixJQUFNNlQsUUFBUSxHQUFHLElBQUkzVSxlQUFlLEVBQUU7TUFDdENiLFNBQUssQ0FBQ3NoQixjQUFJLEVBQUUsV0FBVyxDQUFDO01BQ3hCLElBQUksQ0FBQ29jLFFBQVEsR0FBRy83QixPQUFPO01BQ3ZCLElBQUksQ0FBQ2t6QyxzQkFBc0IsQ0FBQyxJQUFJLENBQUNsSSxNQUFNLEVBQUUsSUFBSSxDQUFDalAsUUFBUSxDQUFDLENBQ3BEeDdCLElBQUksQ0FBQyxVQUFBK2QsU0FBUyxFQUFJO1FBQ2pCekssUUFBUSxDQUFDblYsT0FBTyxDQUFDNGYsU0FBUyxDQUFDO01BQzdCLENBQUMsQ0FBQyxDQUNEN2QsS0FBSyxDQUFDLFVBQUFpRyxHQUFHLEVBQUk7UUFDWnBJLFFBQUksQ0FBQ3FoQixjQUFJLDZEQUFzRGpaLEdBQUcsRUFBRztRQUNyRW1OLFFBQVEsQ0FBQ2xWLE1BQU0sQ0FBQytILEdBQUcsQ0FBQztNQUN0QixDQUFDLENBQUM7TUFDSixPQUFPbU4sUUFBUSxDQUFDalYsT0FBTztJQUN6Qjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUhFO0lBQUE7SUFBQSxLQUlBLGVBQW9CO01BQ2xCLE9BQU91dEMsWUFBWTtJQUNyQjtFQUFDO0VBQUE7QUFBQSxFQTNGNEJsckMsYUFBWTs7Ozs7Ozs7Ozs7Ozs7OztBQzFCSztBQUNSO0FBS2pCO0FBQ21CO0FBQ0Y7QUFDRTtBQUUxQyxJQUFNMGUsaUJBQUksR0FBRyxxQkFBcUI7QUFDbEMsSUFBTXd6QixtQkFBbUIsR0FBRyxDQUFDO0FBQzdCLElBQU1DLGlCQUFpQixHQUFHLENBQUM7QUFDM0IsSUFBTUMsaUJBQWlCLEdBQUcsQ0FBQztBQUUzQixJQUFNaDFDLGtCQUFLLEdBQUcsU0FBUkEsS0FBSyxDQUFJaTFDLE1BQU0sRUFBRTcyQyxPQUFPLEVBQUs7RUFDakN3eUMsU0FBUSxDQUFDLENBQUN0dkIsaUJBQUksRUFBRTJ6QixNQUFNLENBQUMsQ0FBQy8vQixJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU5VyxPQUFPLENBQUM7QUFDN0MsQ0FBQztBQUNELElBQU02QixpQkFBSSxHQUFHLFNBQVBBLElBQUksQ0FBSWcxQyxNQUFNLEVBQUU3MkMsT0FBTyxFQUFLO0VBQ2hDeXlDLFFBQU8sQ0FBQyxDQUFDdnZCLGlCQUFJLEVBQUUyekIsTUFBTSxDQUFDLENBQUMvL0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFOVcsT0FBTyxDQUFDO0FBQzVDLENBQUM7QUFDRCxJQUFNOEIsa0JBQUssR0FBRyxTQUFSQSxLQUFLLENBQUkrMEMsTUFBTSxFQUFFNzJDLE9BQU8sRUFBSztFQUNqQzB5QyxTQUFRLENBQUMsQ0FBQ3h2QixpQkFBSSxFQUFFMnpCLE1BQU0sQ0FBQyxDQUFDLy9CLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTlXLE9BQU8sQ0FBQztBQUM3QyxDQUFDO0FBRUQsSUFBTTgyQyx5QkFBeUIsR0FBRyxTQUE1QkEseUJBQXlCLENBQUk5MkMsT0FBTyxFQUFLO0VBQzdDLE9BQU8sT0FBT0EsT0FBTyxLQUFLLFFBQVEsR0FBR21HLElBQUksQ0FBQ0MsS0FBSyxDQUFDcEcsT0FBTyxDQUFDLEdBQUdBLE9BQU87QUFDcEUsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkEsSUFLTSsyQyxZQUFZO0VBRWhCLHNCQUFhN3lDLEdBQUcsRUFBRUUsS0FBSyxFQUFFO0lBQUE7SUFDdkIsSUFBSSxDQUFDRixHQUFHLEdBQUdBLEdBQUc7SUFDZCxJQUFJLENBQUNFLEtBQUssR0FBR0EsS0FBSztFQUNwQjtFQUFDO0lBQUE7SUFBQSxPQUVELG9CQUFZO01BQ1YsSUFBSXlRLEdBQUcsR0FBSSxDQUFDLENBQUM7TUFDYkEsR0FBRyxDQUFDLElBQUksQ0FBQzNRLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQ0UsS0FBSztNQUMxQixPQUFPeVEsR0FBRztJQUNaO0VBQUM7RUFBQTtBQUFBO0FBSUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBLElBS01taUMsVUFBVTtFQUVkLG9CQUFhem5DLFVBQVUsRUFBRXZQLE9BQU8sRUFBRTtJQUFBO0lBQ2hDLElBQUksQ0FBQ3VQLFVBQVUsR0FBR0EsVUFBVTtJQUM1QixJQUFJMG5DLFdBQVc7SUFDZixJQUFJOWhDLE1BQU0sQ0FBQzNCLFNBQVMsQ0FBQy9DLFFBQVEsQ0FBQ2pCLElBQUksQ0FBQ3hQLE9BQU8sQ0FBQyxLQUFLLGdCQUFnQixFQUFFO01BQ2hFLElBQUk0RSxDQUFDO01BQ0wsSUFBSWpGLEdBQUc7TUFDUCxJQUFJd0QsTUFBTSxHQUFHbkQsT0FBTyxDQUFDbUQsTUFBTTtNQUMzQjh6QyxXQUFXLEdBQUcsRUFBRTtNQUNoQixLQUFLcnlDLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR3pCLE1BQU0sRUFBRXlCLENBQUMsRUFBRSxFQUFFO1FBQzNCakYsR0FBRyxHQUFHbTNDLHlCQUF5QixDQUFDOTJDLE9BQU8sQ0FBQzRFLENBQUMsQ0FBQyxDQUFDO1FBQzNDLElBQUl1USxNQUFNLENBQUMzQixTQUFTLENBQUMvQyxRQUFRLENBQUNqQixJQUFJLENBQUN4UCxPQUFPLENBQUMsS0FBSyxnQkFBZ0IsRUFBRTtVQUNoRWkzQyxXQUFXLEdBQUdBLFdBQVcsQ0FBQzUxQyxNQUFNLENBQUMxQixHQUFHLENBQUM7UUFDdkMsQ0FBQyxNQUNJO1VBQ0hzM0MsV0FBVyxDQUFDbDJDLElBQUksQ0FBQ3BCLEdBQUcsQ0FBQztRQUN2QjtNQUNGO0lBQ0YsQ0FBQyxNQUNJO01BQ0hzM0MsV0FBVyxHQUFHLENBQUNILHlCQUF5QixDQUFDOTJDLE9BQU8sQ0FBQyxDQUFDO0lBQ3BEO0lBQ0EsSUFBSSxDQUFDQSxPQUFPLEdBQUdpM0MsV0FBVyxDQUFDOXpDLE1BQU0sS0FBSyxDQUFDLEdBQUc4ekMsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHQSxXQUFXO0VBQ3hFO0VBQUM7SUFBQTtJQUFBLE9BRUQsb0JBQVk7TUFDVixPQUFPO1FBQ0wxbkMsVUFBVSxFQUFFLElBQUksQ0FBQ0EsVUFBVTtRQUMzQnZQLE9BQU8sRUFBRSxJQUFJLENBQUNBO01BQ2hCLENBQUM7SUFDSDtFQUFDO0VBQUE7QUFBQTtBQUlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQSxJQUtNazNDLGdDQUFtQjtFQUFBO0VBQUE7RUFFdkI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFLDZCQUFhMTNDLElBQUksRUFBRW00QixVQUFVLEVBQUU7SUFBQTtJQUFBO0lBQzdCO0lBQ0EsTUFBS3ZWLEtBQUssR0FBRzVpQixJQUFJO0lBQ2pCLE1BQUsyM0MsVUFBVSxHQUFHdDJDLFNBQVM7SUFDM0IsTUFBS3UyQyxvQkFBb0IsR0FBR3YyQyxTQUFTO0lBQ3JDLE1BQUtxekIsUUFBUSxHQUFHLE1BQUt0YyxLQUFLLENBQUNxTSxJQUFJLENBQUMsMENBQUs7SUFDckMsTUFBS296QiwyQkFBMkIsR0FBRyxNQUFLQSwyQkFBMkIsQ0FBQ3B6QixJQUFJLENBQUMsMENBQUs7SUFDOUUsTUFBS3F6Qiw2QkFBNkIsR0FBRyxNQUFLQSw2QkFBNkIsQ0FBQ3J6QixJQUFJLENBQUMsMENBQUs7SUFDbEYsTUFBS3N6Qiw2QkFBNkIsQ0FBQzVmLFVBQVUsQ0FBQztJQUFBO0VBQ2hEOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQRTtJQUFBO0lBQUEsT0FRQSw2QkFBcUI2SSxTQUFTLEVBQUU7TUFDOUJBLFNBQVMsQ0FBQ2dYLDhCQUE4QixDQUFDLElBQUksQ0FBQztNQUM5QyxJQUFJO1FBQ0Y1MUMsa0JBQUssQ0FBQyxJQUFJLENBQUN3Z0IsS0FBSyxFQUFFLGdDQUFnQyxDQUFDO1FBQ25EO1FBQ0E7UUFDQW9lLFNBQVMsQ0FBQzVXLEVBQUUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDNnRCLHdCQUF3QixDQUFDO1FBQ2hEalgsU0FBUyxDQUFDc0cscUJBQXFCLENBQUMsSUFBSSxDQUFDMWtCLEtBQUssQ0FBQztRQUMzQzVRLE9BQVcsQ0FBQ3JDLGVBQWUsQ0FBQyxJQUFJLENBQUMra0IsUUFBUSxFQUFFLENBQUMsQ0FBQztNQUMvQyxDQUFDLENBQ0QsT0FBTzd0QixDQUFDLEVBQUU7UUFDUnZFLGtCQUFLLENBQUMsSUFBSSxDQUFDc2dCLEtBQUssRUFBRSxnQ0FBZ0MsR0FBRy9iLENBQUMsQ0FBQ3JHLE9BQU8sQ0FBQztRQUMvRCxJQUFJLENBQUNtM0MsVUFBVSxHQUFHdDJDLFNBQVM7UUFDM0IsSUFBSSxDQUFDdTJDLG9CQUFvQixHQUFHdjJDLFNBQVM7TUFDdkM7SUFDRjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsdUNBQStCOEQsS0FBSyxFQUFFO01BQUE7TUFDcEMsSUFBUWsvQixVQUFVLEdBQUtsL0IsS0FBSyxDQUFDYSxJQUFJLENBQXpCcStCLFVBQVU7TUFDbEIsSUFBSTllLENBQUMsR0FBR3ZhLFVBQVUsQ0FBQyxZQUFNO1FBQ3ZCc2UsWUFBWSxDQUFDL0QsQ0FBQyxDQUFDO1FBQ2YsTUFBSSxDQUFDd3lCLDZCQUE2QixDQUFDMVQsVUFBVSxDQUFDO01BQ2hELENBQUMsRUFBRSxJQUFJLENBQUM7SUFDVjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EscUNBQTZCbC9CLEtBQUssRUFBRTtNQUNsQy9DLGtCQUFLLENBQUMsSUFBSSxDQUFDd2dCLEtBQUssWUFBS3pkLEtBQUssQ0FBQ25GLElBQUksZUFBS21GLEtBQUssQ0FBQzFELElBQUksRUFBRztNQUNqRCxJQUFJMEQsS0FBSyxDQUFDMUQsSUFBSSxLQUFLZ2dCLCtCQUErQixDQUFDRSxLQUFLLEVBQUU7UUFDeEQsSUFBSSxDQUFDMkUsT0FBTyxDQUFDLElBQUk1RCxpQkFBaUIsQ0FBQ3JCLHNCQUFzQixDQUFDOUQsaUJBQWlCLEVBQUUsSUFBSSxDQUFDcUYsS0FBSyxDQUFDLENBQUM7UUFDekYsSUFBSSxDQUFDeEssS0FBSyxFQUFFO01BQ2Q7SUFDRjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEsbUNBQTJCNVgsT0FBTyxFQUFFO01BQ2xDLElBQUk7UUFDRixPQUFPLE9BQU9BLE9BQU8sQ0FBQ3dGLElBQUksS0FBSyxRQUFRLEdBQUdXLElBQUksQ0FBQ0MsS0FBSyxDQUFDcEcsT0FBTyxDQUFDd0YsSUFBSSxDQUFDLEdBQUd4RixPQUFPLENBQUN3RixJQUFJO01BQ25GLENBQUMsQ0FDRCxPQUFPYSxDQUFDLEVBQUU7UUFDUnhFLGlCQUFJLENBQUMsSUFBSSxDQUFDdWdCLEtBQUssRUFBRSw0Q0FBNEMsR0FBR3BpQixPQUFPLENBQUN3RixJQUFJLEdBQUcsV0FBVyxHQUFHYSxDQUFDLENBQUNyRyxPQUFPLENBQUM7TUFDekc7TUFDQSxPQUFPLElBQUk7SUFDYjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEsaUNBQXlCdTdCLFdBQVcsRUFBRTtNQUNwQyxJQUFJcG1CLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDbW1CLFdBQVcsQ0FBQyxDQUFDcDRCLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDdkMsSUFBSSxDQUFDMmlCLE9BQU8sQ0FBQyxJQUFJNUQsaUJBQWlCLENBQUNyQixzQkFBc0IsQ0FBQ0MsZUFBZSxFQUFFLElBQUksQ0FBQ3NCLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO01BQy9GLENBQUMsTUFDSTtRQUNILElBQUlsZSxHQUFHO1FBQ1AsS0FBS0EsR0FBRyxJQUFJcTNCLFdBQVcsRUFBRTtVQUN2QixJQUFJLENBQUN6VixPQUFPLENBQUMsSUFBSTVELGlCQUFpQixDQUFDckIsc0JBQXNCLENBQUNDLGVBQWUsRUFBRSxJQUFJLENBQUNzQixLQUFLLEVBQUUsSUFBSTIwQixZQUFZLENBQUM3eUMsR0FBRyxFQUFFcTNCLFdBQVcsQ0FBQ3IzQixHQUFHLENBQUMsQ0FBQyxDQUFDd3pDLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDN0k7TUFDRjtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQRTtJQUFBO0lBQUEsT0FRQSx5QkFBaUJDLE1BQU0sRUFBRTtNQUN2QixJQUFJL3lDLENBQUMsRUFBRUQsS0FBSztNQUNaLElBQUlneEIsT0FBTyxHQUFHLEtBQUs7TUFDbkIsSUFBTXh5QixNQUFNLEdBQUd3MEMsTUFBTSxDQUFDeDBDLE1BQU07TUFDNUIsS0FBS3lCLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR3pCLE1BQU0sRUFBRXlCLENBQUMsRUFBRSxFQUFFO1FBQzNCRCxLQUFLLEdBQUdnekMsTUFBTSxDQUFDL3lDLENBQUMsQ0FBQztRQUNqQixRQUFRRCxLQUFLLENBQUNpekMsT0FBTztVQUNuQixLQUFLaEIsaUJBQWlCO1lBQ3BCLElBQUksQ0FBQzl3QixPQUFPLENBQUMsSUFBSTVELGlCQUFpQixDQUFDckIsc0JBQXNCLENBQUNFLGVBQWUsRUFBRSxJQUFJLENBQUNxQixLQUFLLEVBQUU7Y0FBRXBTLFNBQVMsRUFBRXJMLEtBQUssQ0FBQ3FMO1lBQVUsQ0FBQyxDQUFDLENBQUM7WUFDdkgybEIsT0FBTyxHQUFHLElBQUk7WUFDZDtVQUNGLEtBQUsrZ0IsbUJBQW1CO1lBQ3RCLElBQUkveEMsS0FBSyxDQUFDK2dDLFVBQVUsRUFBRTtjQUNwQjtjQUNBLElBQUksQ0FBQ21TLHVCQUF1QixDQUFDbHpDLEtBQUssQ0FBQytnQyxVQUFVLENBQUM7WUFDaEQsQ0FBQyxNQUFNO2NBQ0wsSUFBSSxDQUFDNWYsT0FBTyxDQUFDLElBQUk1RCxpQkFBaUIsQ0FBQ3JCLHNCQUFzQixDQUFDQyxlQUFlLEVBQUUsSUFBSSxDQUFDc0IsS0FBSyxFQUFFLElBQUkyMEIsWUFBWSxDQUFDcHlDLEtBQUssQ0FBQ3FMLFNBQVMsRUFBRXJMLEtBQUssQ0FBQ1AsS0FBSyxDQUFDLENBQUNzekMsUUFBUSxFQUFFLENBQUMsQ0FBQztZQUNwSjtZQUNBL2hCLE9BQU8sR0FBRyxJQUFJO1lBQ2Q7VUFDRixLQUFLZ2hCLGlCQUFpQjtZQUNwQixJQUFJLENBQUM3d0IsT0FBTyxDQUFDLElBQUk1RCxpQkFBaUIsQ0FBQ3JCLHNCQUFzQixDQUFDRyxhQUFhLEVBQUUsSUFBSSxDQUFDb0IsS0FBSyxFQUFFLElBQUk0MEIsVUFBVSxDQUFDcnlDLEtBQUssQ0FBQ3d1QixNQUFNLEVBQUV4dUIsS0FBSyxDQUFDUCxLQUFLLENBQUMsQ0FBQ3N6QyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1lBQzNJL2hCLE9BQU8sR0FBRyxJQUFJO1lBQ2Q7UUFBSztNQUVYO01BQ0EsT0FBT0EsT0FBTztJQUNoQjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsaUJBQVMzMUIsT0FBTyxFQUFFO01BQ2hCLElBQUlBLE9BQU8sQ0FBQ3dGLElBQUksRUFBRTtRQUNoQixJQUFJcXdCLElBQUksR0FBRyxJQUFJLENBQUNpaUIseUJBQXlCLENBQUM5M0MsT0FBTyxDQUFDO1FBQ2xELElBQUk2MUIsSUFBSSxLQUFLLElBQUksRUFBRTtVQUNqQmgwQixpQkFBSSxDQUFDLElBQUksQ0FBQ3VnQixLQUFLLEVBQUUsNkVBQTZFLENBQUM7VUFDL0YsT0FBTyxJQUFJO1FBQ2I7UUFDQSxJQUFJeVQsSUFBSSxDQUFDcndCLElBQUksS0FBSzNFLFNBQVMsRUFBRTtVQUMzQixJQUFJZzFCLElBQUksQ0FBQ3J3QixJQUFJLENBQUNoRyxJQUFJLEtBQUssSUFBSSxDQUFDNGlCLEtBQUssRUFBRTtZQUNqQ3hnQixrQkFBSyxDQUFDLElBQUksQ0FBQ3dnQixLQUFLLEVBQUUsMkJBQTJCLEdBQUdqYyxJQUFJLENBQUM0TyxTQUFTLENBQUM4Z0IsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztZQUM5RSxJQUFJQSxJQUFJLENBQUNyd0IsSUFBSSxDQUFDc3hCLE1BQU0sS0FBSywrQkFBK0IsSUFDcERqQixJQUFJLENBQUNyd0IsSUFBSSxDQUFDeEYsT0FBTyxLQUFLLFNBQVMsRUFBRTtjQUNuQyxJQUFJLENBQUNtM0MsVUFBVSxDQUFDcFEscUJBQXFCLENBQUMsSUFBSSxDQUFDM2tCLEtBQUssQ0FBQztjQUNqRCxPQUFPLElBQUk7WUFDYixDQUFDLE1BQU0sSUFBSXlULElBQUksQ0FBQ3J3QixJQUFJLENBQUNzeEIsTUFBTSxLQUFLLCtCQUErQixJQUMzRGpCLElBQUksQ0FBQ3J3QixJQUFJLENBQUN4RixPQUFPLEtBQUssTUFBTSxFQUFFO2NBQ2hDLElBQUksQ0FBQzhsQixPQUFPLENBQUMsSUFBSTVELGlCQUFpQixDQUFDckIsc0JBQXNCLENBQUMxRSxlQUFlLEVBQUUsSUFBSSxDQUFDaUcsS0FBSyxDQUFDLENBQUM7Y0FDdkYsT0FBTyxJQUFJO1lBQ2IsQ0FBQyxNQUFNLElBQUl5VCxJQUFJLENBQUNyd0IsSUFBSSxDQUFDc3hCLE1BQU0sS0FBSyw2QkFBNkIsSUFDekRqQixJQUFJLENBQUNyd0IsSUFBSSxDQUFDeEYsT0FBTyxLQUFLLFNBQVMsRUFBRTtjQUNuQyxJQUFJLENBQUM4bEIsT0FBTyxDQUFDLElBQUk1RCxpQkFBaUIsQ0FBQ3JCLHNCQUFzQixDQUFDM0UsZUFBZSxFQUFFLElBQUksQ0FBQ2tHLEtBQUssQ0FBQyxDQUFDO2NBQ3ZGLE9BQU8sSUFBSTtZQUNiLENBQUMsTUFBTSxJQUFJeVQsSUFBSSxDQUFDcndCLElBQUksQ0FBQ3N4QixNQUFNLEtBQUssNkJBQTZCLElBQ3pEakIsSUFBSSxDQUFDcndCLElBQUksQ0FBQ3hGLE9BQU8sS0FBSyxNQUFNLEVBQUU7Y0FDaEMsSUFBSSxDQUFDOGxCLE9BQU8sQ0FBQyxJQUFJNUQsaUJBQWlCLENBQUNyQixzQkFBc0IsQ0FBQzFFLGVBQWUsRUFBRSxJQUFJLENBQUNpRyxLQUFLLENBQUMsQ0FBQztjQUN2RixPQUFPLElBQUk7WUFDYixDQUFDLE1BQU0sSUFBSXlULElBQUksQ0FBQ3J3QixJQUFJLENBQUNzeEIsTUFBTSxLQUFLLGdDQUFnQyxFQUFFO2NBQ2hFLElBQUksQ0FBQ2hSLE9BQU8sQ0FBQyxJQUFJNUQsaUJBQWlCLENBQUNyQixzQkFBc0IsQ0FBQzlELGlCQUFpQixFQUFFLElBQUksQ0FBQ3FGLEtBQUssQ0FBQyxDQUFDO2NBQ3pGLE9BQU8sSUFBSTtZQUNiLENBQUMsTUFBTSxJQUFJeVQsSUFBSSxDQUFDcndCLElBQUksQ0FBQ3ZFLElBQUksS0FBSyxjQUFjLEVBQUU7Y0FDNUMsSUFBSTQwQixJQUFJLENBQUNyd0IsSUFBSSxDQUFDdUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxFQUFFO2dCQUN0QyxPQUFPLElBQUksQ0FBQ2d3QyxlQUFlLENBQUNsaUIsSUFBSSxDQUFDcndCLElBQUksQ0FBQ215QyxNQUFNLENBQUM7Y0FDL0MsQ0FBQyxNQUFNLElBQUk5aEIsSUFBSSxDQUFDcndCLElBQUksQ0FBQ3VDLGNBQWMsQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDNUMsT0FBTyxJQUFJLENBQUM4dkMsdUJBQXVCLENBQUNoaUIsSUFBSSxDQUFDcndCLElBQUksQ0FBQ3BCLEtBQUssQ0FBQztjQUN0RDtZQUNGO1VBQ0YsQ0FBQyxNQUFNO1lBQ0x4QyxrQkFBSyxDQUFDLElBQUksQ0FBQ3dnQixLQUFLLEVBQUUsOEJBQThCLEdBQUdqYyxJQUFJLENBQUM0TyxTQUFTLENBQUM4Z0IsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztVQUNuRjtRQUNGO01BQ0Y7TUFDQSxPQUFPLEtBQUs7SUFDZDs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEsY0FBTXRtQixVQUFVLEVBQUUvSixJQUFJLEVBQUU7TUFDdEIsSUFBTWc3QixTQUFTLEdBQUcsSUFBSSxDQUFDMlcsVUFBVTtNQUNqQyxJQUFJM1csU0FBUyxFQUFFO1FBQ2JBLFNBQVMsQ0FBQ2dJLGtCQUFrQixDQUFDLElBQUksQ0FBQ3BtQixLQUFLLEVBQUU3UyxVQUFVLEVBQUUvSixJQUFJLENBQUM7TUFDNUQsQ0FBQyxNQUFNO1FBQ0wzRCxpQkFBSSxDQUFDLElBQUksQ0FBQ3VnQixLQUFLLEVBQUUsb0NBQW9DLENBQUM7TUFDeEQ7SUFDRjs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEU7SUFBQTtJQUFBLE9BUUEscUJBQWFsZSxHQUFHLEVBQUVFLEtBQUssRUFBRTtNQUN2QixJQUFJLENBQUMreUMsVUFBVSxDQUFDMU8sMEJBQTBCLENBQUMsSUFBSSxDQUFDcm1CLEtBQUssRUFBRWxlLEdBQUcsRUFBRUUsS0FBSyxDQUFDO0lBQ3BFOztJQUVBO0FBQ0Y7QUFDQTtFQUZFO0lBQUE7SUFBQSxPQUdBLGlCQUFTO01BQ1AsSUFBTW84QixTQUFTLEdBQUcsSUFBSSxDQUFDMlcsVUFBVTtNQUNqQyxJQUFJM1csU0FBUyxFQUFFO1FBQ2IsSUFBSTtVQUNGQSxTQUFTLENBQUNrSSxpQkFBaUIsQ0FBQyxJQUFJLENBQUN0bUIsS0FBSyxDQUFDO1FBQ3pDLENBQUMsQ0FBQyxPQUFPL2IsQ0FBQyxFQUFFO1VBQ1Y7UUFBQTtRQUVGbTZCLFNBQVMsQ0FBQ3dYLGlDQUFpQyxDQUFDLElBQUksQ0FBQztRQUNqRHhYLFNBQVMsQ0FBQ3lYLEdBQUcsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDWiwyQkFBMkIsQ0FBQztNQUN0RDtNQUNBLElBQUksQ0FBQ0YsVUFBVSxHQUFHdDJDLFNBQVM7TUFDM0IsSUFBSSxDQUFDdTJDLG9CQUFvQixHQUFHdjJDLFNBQVM7TUFDckMyUSxPQUFXLENBQUNuQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUM2a0IsUUFBUSxDQUFDO0lBQy9DOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSx5Q0FBaUM7TUFDL0IsT0FBTyxJQUFJLENBQUNrakIsb0JBQW9CO0lBQ2xDOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0EsdUNBQStCdlQsVUFBVSxFQUFFO01BQ3pDLElBQUksSUFBSSxDQUFDc1QsVUFBVSxFQUFFO1FBQ25CLElBQUksQ0FBQ0EsVUFBVSxDQUFDYSxpQ0FBaUMsQ0FBQyxJQUFJLENBQUM7UUFDdkQsSUFBSSxDQUFDYixVQUFVLENBQUNjLEdBQUcsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDWiwyQkFBMkIsQ0FBQztRQUMxRDdsQyxPQUFXLENBQUNuQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUM2a0IsUUFBUSxDQUFDO1FBQzdDLElBQUksQ0FBQ2lqQixVQUFVLEdBQUd0MkMsU0FBUztRQUMzQixJQUFJLENBQUN1MkMsb0JBQW9CLEdBQUd2MkMsU0FBUztNQUN2QztNQUVBLElBQUksQ0FBQ3UyQyxvQkFBb0IsR0FBR3ZULFVBQVU7TUFDdEMsSUFBSSxDQUFDc1QsVUFBVSxHQUFHLElBQUksQ0FBQ0Msb0JBQW9CLENBQUNqVCxtQkFBbUIsRUFBRTtNQUNqRSxJQUFJLElBQUksQ0FBQ2lULG9CQUFvQixJQUFJLElBQUksQ0FBQ0QsVUFBVSxFQUFFO1FBQ2hELElBQUksQ0FBQ0Msb0JBQW9CLENBQUN4dEIsRUFBRSxDQUFDM0ksK0JBQStCLENBQUNHLE1BQU0sRUFBRSxJQUFJLENBQUNrMkIsNkJBQTZCLENBQUM7UUFDeEcsSUFBSSxDQUFDWSxtQkFBbUIsQ0FBQyxJQUFJLENBQUNmLFVBQVUsQ0FBQztNQUMzQztJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSxtQkFBVztNQUNULE9BQU8sSUFBSSxDQUFDLzBCLEtBQUs7SUFDbkI7RUFBQztFQUFBO0FBQUEsRUEvUitCNWQsYUFBWTtBQW1TL0IweUMsaUZBQW1CLEU7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbFlnQjtBQUNEO0FBQ3lDO0FBQzFGOztBQUVBO0FBQ0E7QUFDQTtBQUZBLElBR01pQixnQ0FBeUI7RUFBQTtFQUFBO0VBRTdCLHFDQUFvQztJQUFBO0lBQUEsSUFBdkI1a0IsU0FBUyx1RUFBRzF5QixTQUFTO0lBQUE7SUFDaEMsSUFBTXUzQyxJQUFJLEdBQUdwa0MsSUFBSSxDQUFDc1csS0FBSyxDQUFDdFcsSUFBSSxDQUFDMmUsTUFBTSxFQUFFLEdBQUcsT0FBTyxDQUFDLENBQUNsaUIsUUFBUSxDQUFDLEVBQUUsQ0FBQztJQUM3RCxJQUFNalIsSUFBSSwwQkFBbUI0NEMsSUFBSSxDQUFFO0lBQ25DLDBCQUFNN2tCLFNBQVMsRUFBRS96QixJQUFJO0lBQ3JCLE1BQUtxTixFQUFFLEdBQUdyTixJQUFJO0lBQ2QsTUFBSzY0QyxpQkFBaUIsR0FBR3gzQyxTQUFTO0lBQUE7RUFDcEM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLCtCQUF1QnJCLElBQUksRUFBRTtNQUMzQixpSEFBNEJBLElBQUk7TUFDaEMsSUFBSSxDQUFDNjRDLGlCQUFpQixHQUFHNzRDLElBQUk7SUFDL0I7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVZFO0lBQUE7SUFBQSxPQVdBLGNBQU1nNUIsYUFBYSxFQUFrQztNQUFBLElBQWhDM3JCLEVBQUUsdUVBQUdoTSxTQUFTO01BQUEsSUFBRXkzQyxVQUFVLHVFQUFHLENBQUM7TUFDakQsSUFBTXhXLGFBQWEsR0FBRyxJQUFJci9CLGVBQWUsRUFBRTtNQUMzQyxJQUFJLENBQUNvSyxFQUFFLEdBQUdBLEVBQUUsSUFBSSxJQUFJLENBQUNBLEVBQUU7TUFDdkIsSUFBSSxDQUFDdVYsS0FBSyxHQUFHLElBQUksQ0FBQ3ZWLEVBQUU7TUFDcEI7TUFDQSxJQUFNRyxHQUFHLEdBQUdnMUIsNEJBQW1CLENBQUN4SixhQUFhLEVBQUU7UUFBQzNyQixFQUFFLEVBQUUsSUFBSSxDQUFDQSxFQUFFO1FBQUUwckMsWUFBWSxFQUFFRDtNQUFVLENBQUMsQ0FBQztNQUN2RixJQUFJLENBQUNoakIsS0FBSyxDQUFDdG9CLEdBQUcsRUFBRTgwQixhQUFhLENBQUM7TUFDOUIsT0FBT0EsYUFBYSxDQUFDMy9CLE9BQU87SUFDOUI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORTtJQUFBO0lBQUEsT0FPQSxpQkFBU25DLE9BQU8sRUFBRTtNQUFFO01BQ2xCLElBQUksQ0FBQyxtR0FBY0EsT0FBTyxDQUFDLEVBQUU7UUFDM0IsSUFBSUEsT0FBTyxDQUFDd0YsSUFBSSxFQUFFO1VBQ2hCLElBQUlxd0IsSUFBSSxHQUFHLElBQUksQ0FBQ0Msd0JBQXdCLENBQUM5MUIsT0FBTyxDQUFDO1VBQ2pELElBQUk2MUIsSUFBSSxJQUFJQSxJQUFJLENBQUNyd0IsSUFBSSxFQUFFO1lBQ3JCLElBQVFBLElBQUksR0FBS3F3QixJQUFJLENBQWJyd0IsSUFBSTtZQUNaLElBQUlBLElBQUksQ0FBQ3ZFLElBQUksS0FBSyxRQUFRLEVBQUU7Y0FDMUIsSUFBSXVFLElBQUksQ0FBQzhtQixJQUFJLEtBQUssOEJBQThCLEVBQUU7Z0JBQ2hEO2dCQUNBLElBQUksQ0FBQ3lHLE9BQU8sQ0FBQztrQkFDWHZ0QixJQUFJLEVBQUU7b0JBQ0pBLElBQUksRUFBRTtzQkFDSnN4QixNQUFNLEVBQUUsZ0NBQWdDO3NCQUN4QzkyQixPQUFPLEVBQUV3RixJQUFJLENBQUM4bUIsSUFBSTtzQkFDbEI5c0IsSUFBSSxFQUFFLElBQUksQ0FBQzY0QztvQkFDYjtrQkFDRjtnQkFDRixDQUFDLENBQUM7Z0JBQ0YsSUFBSSxDQUFDQSxpQkFBaUIsR0FBR3gzQyxTQUFTO2NBQ3BDLENBQUMsTUFBTSxJQUFJMkUsSUFBSSxDQUFDOG1CLElBQUksS0FBSyxvQ0FBb0MsSUFBSSxJQUFJLENBQUNrSCxVQUFVLEVBQUU7Z0JBQ2hGLElBQUksQ0FBQ0EsVUFBVSxDQUFDZ2xCLG9CQUFvQixFQUFFO2NBQ3hDLENBQUMsTUFBTSxJQUFJaHpDLElBQUksQ0FBQzhtQixJQUFJLEtBQUsscUNBQXFDLElBQUksSUFBSSxDQUFDa0gsVUFBVSxFQUFFO2dCQUNqRixJQUFJLENBQUNBLFVBQVUsQ0FBQzZDLHNCQUFzQixDQUFDN3dCLElBQUksQ0FBQ3dFLFdBQVcsQ0FBQztjQUMxRCxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUN3cEIsVUFBVSxFQUFFO2dCQUMxQixJQUFJLENBQUNBLFVBQVUsQ0FBQ2lsQixjQUFjLENBQUNqekMsSUFBSSxDQUFDO2NBQ3RDO1lBQ0YsQ0FBQyxNQUFNLElBQUlBLElBQUksQ0FBQzRTLEdBQUcsRUFBRTtjQUNuQixJQUFRQSxHQUFHLEdBQUs1UyxJQUFJLENBQVo0UyxHQUFHO2NBQ1gsSUFBSUEsR0FBRyxDQUFDblgsSUFBSSxLQUFLLFFBQVEsSUFBSSxJQUFJLENBQUN1eUIsVUFBVSxFQUFFO2dCQUM1QyxJQUFJLENBQUNBLFVBQVUsQ0FBQzZkLFdBQVcsQ0FBQ2o1QixHQUFHLENBQUM7Y0FDbEM7WUFDRixDQUFDLE1BQU0sSUFBSTVTLElBQUksQ0FBQ2l3QixTQUFTLElBQUksSUFBSSxDQUFDakMsVUFBVSxFQUFFO2NBQzVDLElBQVFpQyxTQUFTLEdBQUtqd0IsSUFBSSxDQUFsQml3QixTQUFTO2NBQ2pCLElBQUksQ0FBQ2pDLFVBQVUsQ0FBQ2lELGlCQUFpQixDQUFDaEIsU0FBUyxDQUFDO1lBQzlDO1VBQ0Y7UUFDRjtNQUNGO0lBQ0Y7O0lBRUE7QUFDRjtBQUNBO0VBRkU7SUFBQTtJQUFBLE9BR0EsaUJBQVM7TUFDUCxJQUFJLENBQUM0aUIsaUJBQWlCLEdBQUd4M0MsU0FBUztNQUNsQyxJQUFJLENBQUNzekIsUUFBUSxFQUFFO0lBQ2pCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSwrQkFBdUI7TUFDckIsT0FBTyxJQUFJO0lBQ2I7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLHlCQUFpQjtNQUNmLE9BQU8sSUFBSTtJQUNiO0VBQUM7RUFBQTtBQUFBLEVBaEhxQ2IsYUFBWTtBQW9IckM2a0Isd0ZBQXlCLEU7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUhHO0FBQ1c7QUFDZDtBQUNRO0FBQ0Y7QUFJN0I7QUFDZ0M7QUFDYjtBQUVwQyxJQUFNTyxZQUFZLEdBQUcsZ0JBQWdCOztBQUVyQztBQUNBO0FBQ0E7QUFGQSxJQUdNQyxzQ0FBaUM7RUFBQTtFQUFBO0VBRXJDLDZDQUFvQztJQUFBO0lBQUEsSUFBdkJwbEIsU0FBUyx1RUFBRzF5QixTQUFTO0lBQUE7SUFDaEMsSUFBTXUzQyxJQUFJLEdBQUdwa0MsSUFBSSxDQUFDc1csS0FBSyxDQUFDdFcsSUFBSSxDQUFDMmUsTUFBTSxFQUFFLEdBQUcsT0FBTyxDQUFDLENBQUNsaUIsUUFBUSxDQUFDLEVBQUUsQ0FBQztJQUM3RCxJQUFNalIsSUFBSSwwQkFBbUI0NEMsSUFBSSxDQUFFO0lBQ25DLDBCQUFNN2tCLFNBQVMsRUFBRS96QixJQUFJO0lBQ3JCLE1BQUtxTixFQUFFLEdBQUdyTixJQUFJO0lBQ2QsTUFBSzgvQixRQUFRLEdBQUd6K0IsU0FBUztJQUN6QixNQUFLKzNDLE9BQU8sR0FBRy8zQyxTQUFTO0lBQ3hCLE1BQUt3M0MsaUJBQWlCLEdBQUd4M0MsU0FBUztJQUNsQyxNQUFLOHlCLGtCQUFrQixHQUFHOXlCLFNBQVM7SUFBQTtFQUNyQzs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ0U7RUFBQTtJQUFBO0lBQUEsT0FDQSxtQ0FBMkI4MkIsVUFBVSxFQUFFO01BQ3JDQSxVQUFVLENBQUN5Qix1QkFBdUIsR0FBR3Y0QixTQUFTO01BQzlDODJCLFVBQVUsQ0FBQzBCLDBCQUEwQixHQUFHeDRCLFNBQVM7TUFDakQ4MkIsVUFBVSxDQUFDMkIsY0FBYyxHQUFHejRCLFNBQVM7TUFDckM4MkIsVUFBVSxDQUFDNEIsT0FBTyxHQUFHMTRCLFNBQVM7TUFDOUI4MkIsVUFBVSxDQUFDNkIsYUFBYSxHQUFHMzRCLFNBQVM7SUFDdEM7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7SUFDRTtFQUFBO0lBQUE7SUFBQSxPQUNBLGdDQUF3QjgyQixVQUFVLEVBQUV4MUIsT0FBTyxFQUFFO01BQUE7TUFDM0MsSUFBSXMzQixnQkFBZ0I7TUFDcEIsSUFBTUMsWUFBWSxHQUFHLElBQUk7TUFFekJ2M0IsT0FBTyxHQUFHQSxPQUFPLElBQUksSUFBSSxDQUFDd3hCLGtCQUFrQjtNQUM1Q2dFLFVBQVUsQ0FBQ3lCLHVCQUF1QixHQUFHLFlBQU07UUFDekN4M0IsU0FBSyxDQUFDLE1BQUksQ0FBQ3dnQixLQUFLLG9EQUE2Q3VWLFVBQVUsQ0FBQ2dDLGVBQWUsRUFBRztRQUMxRixJQUFJaEMsVUFBVSxDQUFDZ0MsZUFBZSxLQUFLLFdBQVcsRUFBRTtVQUM5Qy8zQixTQUFLLENBQUMsTUFBSSxDQUFDd2dCLEtBQUssRUFBRSx1QkFBdUIsQ0FBQztVQUMxQztVQUNBLE1BQUksQ0FBQzBELE9BQU8sQ0FBQyxJQUFJekQsMEJBQTBCLENBQUNwQiwrQkFBK0IsQ0FBQ0MsSUFBSSxFQUFFLE1BQUksQ0FBQ2tCLEtBQUssRUFBRTtZQUFDeTJCLGNBQWMsRUFBRTtVQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ3hILENBQUMsTUFBTSxJQUFJbGhCLFVBQVUsQ0FBQ2dDLGVBQWUsS0FBSyxRQUFRLElBQ2hEaEMsVUFBVSxDQUFDZ0MsZUFBZSxLQUFLLGNBQWMsRUFBRTtVQUMvQzkzQixRQUFJLENBQUMsTUFBSSxDQUFDdWdCLEtBQUssRUFBRSx3QkFBd0IsQ0FBQztVQUMxQyxJQUFJdVYsVUFBVSxDQUFDZ0MsZUFBZSxLQUFLLFFBQVEsRUFBRTtZQUMzQyxNQUFJLENBQUM3VCxPQUFPLENBQUMsSUFBSXpELDBCQUEwQixDQUFDcEIsK0JBQStCLENBQUN6Z0IsS0FBSyxFQUFFLE1BQUksQ0FBQzRoQixLQUFLLEVBQUU7Y0FBQ3kyQixjQUFjLEVBQUUsTUFBSTtjQUFFLzJDLEtBQUssRUFBRTtZQUFvQixDQUFDLENBQUMsQ0FBQztVQUN0SjtVQUNBLElBQUlLLE9BQU8sRUFBRTtZQUNYQSxPQUFPLENBQUNELE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQztVQUN0QztRQUNGO01BQ0YsQ0FBQztNQUVEeTFCLFVBQVUsQ0FBQzJCLGNBQWMsR0FBRyxVQUFDMzBCLEtBQUssRUFBSztRQUNyQy9DLFNBQUssQ0FBQyxNQUFJLENBQUN3Z0IsS0FBSyxvREFBNkN6ZCxLQUFLLENBQUM4d0IsU0FBUyxFQUFHO1FBQy9FLElBQUk5d0IsS0FBSyxDQUFDOHdCLFNBQVMsRUFBRTtVQUNuQixNQUFJLENBQUNtakIsT0FBTyxDQUFDL2xCLElBQUksQ0FBQztZQUNoQjJDLGVBQWUsRUFBRSxNQUFJLENBQUNwVCxLQUFLO1lBQzNCNWMsSUFBSSxFQUFFO2NBQ0ppd0IsU0FBUyxFQUFFOXdCLEtBQUssQ0FBQzh3QjtZQUNuQjtVQUNGLENBQUMsQ0FBQztRQUNKLENBQUMsTUFBTSxJQUFJOXdCLEtBQUssQ0FBQzh3QixTQUFTLEtBQUssSUFBSSxFQUFFO1VBQ25DN3pCLFNBQUssQ0FBQyxNQUFJLENBQUN3Z0IsS0FBSyxFQUFFLDJCQUEyQixDQUFDO1VBQzlDLElBQUlqZ0IsT0FBTyxFQUFFO1lBQ1g7VUFBQTtRQUVKO01BQ0YsQ0FBQztNQUVEdzFCLFVBQVUsQ0FBQzBCLDBCQUEwQixHQUFHLFVBQUMxMEIsS0FBSyxFQUFLO1FBQ2pELElBQU13aUIsS0FBSyxHQUFHd1EsVUFBVSxDQUFDc0Msa0JBQWtCO1FBQzNDcjRCLFNBQUssQ0FBQyxNQUFJLENBQUN3Z0IsS0FBSyx1REFBZ0QrRSxLQUFLLEVBQUc7UUFDeEUsSUFBSUEsS0FBSyxLQUFLLFdBQVcsSUFBSTNWLE9BQVcsQ0FBQzVGLFNBQVMsRUFBRSxFQUFFO1VBQ3BEO1VBQ0E7VUFDQTtVQUNBaEssU0FBSyxDQUFDLE1BQUksQ0FBQ3dnQixLQUFLLEVBQUUsNkJBQTZCLENBQUM7VUFDaER4Z0IsU0FBSyxDQUFDLE1BQUksQ0FBQ3dnQixLQUFLLEVBQUUsNkJBQTZCLENBQUM7VUFDaEQsTUFBSSxDQUFDdzJCLE9BQU8sQ0FBQzdWLG1CQUFtQixDQUFDLE1BQUksQ0FBQzNnQixLQUFLLENBQUM7UUFDOUMsQ0FBQyxNQUNJLElBQUkrRSxLQUFLLEtBQUssUUFBUSxFQUFFO1VBQzNCLElBQUlzUyxnQkFBZ0IsRUFBRTtZQUNwQjNRLFlBQVksQ0FBQzJRLGdCQUFnQixDQUFDO1VBQ2hDO1VBQ0EsTUFBSSxDQUFDM1QsT0FBTyxDQUFDLElBQUl6RCwwQkFBMEIsQ0FBQ3BCLCtCQUErQixDQUFDemdCLEtBQUssRUFBRSxNQUFJLENBQUM0aEIsS0FBSyxFQUFFO1lBQUN5MkIsY0FBYyxFQUFFLE1BQUk7WUFBRS8yQyxLQUFLLEVBQUU7VUFBb0IsQ0FBQyxDQUFDLENBQUM7VUFDcEosTUFBSSxDQUFDZ2tCLE9BQU8sQ0FBQyxJQUFJekQsMEJBQTBCLENBQUNwQiwrQkFBK0IsQ0FBQ0UsS0FBSyxFQUFFLE1BQUksQ0FBQ2lCLEtBQUssRUFBRTtZQUFDeTJCLGNBQWMsRUFBRSxNQUFJO1lBQUVsMEMsS0FBSyxFQUFFQTtVQUFLLENBQUMsQ0FBQyxDQUFDO1VBQ3JJLElBQUl4QyxPQUFPLEVBQUU7WUFDWEEsT0FBTyxDQUFDRCxNQUFNLENBQUMsb0JBQW9CLENBQUM7VUFDdEM7UUFDRixDQUFDLE1BQ0ksSUFBSWlsQixLQUFLLEtBQUssY0FBYyxFQUFFO1VBQ2pDO1VBQ0FzUyxnQkFBZ0IsR0FBR2p2QixVQUFVLENBQUUsWUFBTTtZQUNuQzVJLFNBQUssQ0FBQyxNQUFJLENBQUN3Z0IsS0FBSywyRkFBMkY7WUFDM0cwRyxZQUFZLENBQUMyUSxnQkFBZ0IsQ0FBQztZQUM5QixNQUFJLENBQUMzVCxPQUFPLENBQUMsSUFBSXpELDBCQUEwQixDQUFDcEIsK0JBQStCLENBQUNFLEtBQUssRUFBRSxNQUFJLENBQUNpQixLQUFLLEVBQUU7Y0FBQ3kyQixjQUFjLEVBQUUsTUFBSTtjQUFFbDBDLEtBQUssRUFBRUE7WUFBSyxDQUFDLENBQUMsQ0FBQztVQUN2SSxDQUFDLEVBQUUrMEIsWUFBWSxDQUFDO1FBQ2xCLENBQUMsTUFDSTtVQUNILElBQUlELGdCQUFnQixFQUFFO1lBQ3BCNzNCLFNBQUssQ0FBQyxNQUFJLENBQUN3Z0IsS0FBSyx3RUFBd0U7WUFDeEYwRyxZQUFZLENBQUMyUSxnQkFBZ0IsQ0FBQztVQUNoQztRQUNGO01BQ0YsQ0FBQztNQUVEOUIsVUFBVSxDQUFDMEMseUJBQXlCLEdBQUcsWUFBTTtRQUMzQyxJQUFNbFQsS0FBSyxHQUFHd1EsVUFBVSxDQUFDMkMsaUJBQWlCO1FBQzFDMTRCLFNBQUssQ0FBQyxNQUFJLENBQUN3Z0IsS0FBSyxzREFBK0MrRSxLQUFLLEVBQUc7UUFDdkUsSUFBSUEsS0FBSyxLQUFLLFVBQVUsRUFBRTtVQUN4QnZsQixTQUFLLENBQUMsTUFBSSxDQUFDd2dCLEtBQUssRUFBRSw2QkFBNkIsQ0FBQztVQUNoRCxNQUFJLENBQUN3MkIsT0FBTyxDQUFDN1YsbUJBQW1CLENBQUMsTUFBSSxDQUFDM2dCLEtBQUssQ0FBQztRQUM5QztNQUNGLENBQUM7SUFDSDtFQUFDO0lBQUE7SUFBQSxPQUVELHdCQUFtQztNQUFBO01BQUEsSUFBckJqZ0IsT0FBTyx1RUFBR3RCLFNBQVM7TUFDL0JlLFNBQUssQ0FBQyxJQUFJLENBQUN3Z0IsS0FBSyx1QkFBdUI7TUFDdkMsSUFBSSxDQUFDaVYsZUFBZSxDQUFDaVcsV0FBVyxFQUFFLENBQy9CeHBDLElBQUksQ0FBQyxVQUFBc1UsR0FBRyxFQUFJO1FBQ1h4VyxTQUFLLENBQUMsTUFBSSxDQUFDd2dCLEtBQUsseUJBQWtCaEssR0FBRyxDQUFDQSxHQUFHLEVBQUc7UUFDNUMsTUFBSSxDQUFDaWYsZUFBZSxDQUFDMEIsbUJBQW1CLENBQUMzZ0IsR0FBRyxDQUFDLENBQzFDdFUsSUFBSSxDQUFDLFlBQU07VUFDVixNQUFJLENBQUM4MEMsT0FBTyxDQUFDL2xCLElBQUksQ0FBQztZQUNoQjZoQixXQUFXLEVBQUUsTUFBSSxDQUFDdHlCLEtBQUs7WUFDdkJvZSxTQUFTLEVBQUUsS0FBSztZQUNoQmg3QixJQUFJLEVBQUU7Y0FDSjRTLEdBQUcsRUFBRUE7WUFDUDtVQUNGLENBQUMsQ0FBQztRQUNKLENBQUMsQ0FBQyxDQUNEcFUsS0FBSyxDQUFDLFVBQUFsQyxLQUFLLEVBQUk7VUFDZCxJQUFJSyxPQUFPLEVBQUU7WUFDWEEsT0FBTyxDQUFDRCxNQUFNLENBQUNKLEtBQUssQ0FBQztVQUN2QjtRQUNGLENBQUMsQ0FBQztNQUNOLENBQUMsQ0FBQztJQUNOOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSwrQkFBdUJ0QyxJQUFJLEVBQUU7TUFDM0IscUhBQTRCQSxJQUFJO01BQ2hDLElBQUksQ0FBQzY0QyxpQkFBaUIsR0FBRzc0QyxJQUFJO0lBQy9COztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVJFO0lBQUE7SUFBQSxPQVNBLGNBQU1nNUIsYUFBYSxFQUFrQjtNQUFBO01BQUEsSUFBaEIzckIsRUFBRSx1RUFBR2hNLFNBQVM7TUFDakMsSUFBTWk0QyxXQUFXLEdBQUcsSUFBSXIyQyxlQUFlLEVBQUU7TUFDekMsSUFBSSxDQUFDb0ssRUFBRSxHQUFHQSxFQUFFLElBQUksSUFBSSxDQUFDQSxFQUFFO01BQ3ZCLElBQUksQ0FBQ3VWLEtBQUssR0FBRyxJQUFJLENBQUN2VixFQUFFO01BQ3BCLElBQUksQ0FBQ3l5QixRQUFRLEdBQUc5RyxhQUFhO01BQzdCLElBQUksQ0FBQ29nQixPQUFPLEdBQUcsSUFBSVQsbUJBQXlCLENBQUMsSUFBSSxDQUFDO01BQ2xELElBQUksQ0FBQ1MsT0FBTyxDQUFDaHZCLEVBQUUsQ0FBQyx1QkFBdUIsRUFBRSxVQUFDamxCLEtBQUssRUFBSztRQUNsRC9DLFNBQUssQ0FBQyxNQUFJLENBQUN3Z0IsS0FBSyw2QkFBc0J6ZCxLQUFLLENBQUMxRCxJQUFJLEVBQUc7UUFDbkQsTUFBSSxDQUFDMHlCLGtCQUFrQixHQUFHbWxCLFdBQVc7UUFDckMsTUFBSSxDQUFDeFgsMEJBQTBCLENBQUM5SSxhQUFhLENBQUNtRyxnQkFBZ0IsRUFBRSxNQUFJLENBQUNvYSwyQkFBMkIsQ0FBQ3ZnQixhQUFhLENBQUMsQ0FBQyxDQUMzRzEwQixJQUFJLENBQUMsWUFBTTtVQUNWLE1BQUksQ0FBQ3d4QyxZQUFZLENBQUN3RCxXQUFXLENBQUM7UUFDaEMsQ0FBQyxDQUFDLENBQ0Q5MEMsS0FBSyxDQUFDLFVBQUFsQyxLQUFLLEVBQUk7VUFDZCxNQUFJLENBQUNna0IsT0FBTyxDQUFDLElBQUl6RCwwQkFBMEIsQ0FBQ3BCLCtCQUErQixDQUFDemdCLEtBQUssRUFBRSxNQUFJLENBQUM0aEIsS0FBSyxFQUFFO1lBQUN5MkIsY0FBYyxFQUFFLE1BQUk7WUFBRS8yQyxLQUFLLEVBQUVBO1VBQUssQ0FBQyxDQUFDLENBQUM7VUFDcklnM0MsV0FBVyxDQUFDNTJDLE1BQU0sQ0FBQ0osS0FBSyxDQUFDO1FBQzNCLENBQUMsQ0FBQztNQUNSLENBQUMsQ0FBQztNQUNGO01BQ0EsSUFBSSxDQUFDODJDLE9BQU8sQ0FBQ3pMLElBQUksQ0FBQzNVLGFBQWEsRUFBRSxJQUFJLENBQUMzckIsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUN6QzdJLEtBQUssQ0FBQyxVQUFBbEMsS0FBSyxFQUFJO1FBQ2QsTUFBSSxDQUFDZ2tCLE9BQU8sQ0FBQyxJQUFJekQsMEJBQTBCLENBQUNwQiwrQkFBK0IsQ0FBQ3pnQixLQUFLLEVBQUUsTUFBSSxDQUFDNGhCLEtBQUssRUFBRTtVQUFDeTJCLGNBQWMsRUFBRSxNQUFJO1VBQUUvMkMsS0FBSyxFQUFFQTtRQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ3JJZzNDLFdBQVcsQ0FBQzUyQyxNQUFNLENBQUNKLEtBQUssQ0FBQztNQUMzQixDQUFDLENBQUM7TUFDSixPQUFPZzNDLFdBQVcsQ0FBQzMyQyxPQUFPO0lBQzVCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFKRTtJQUFBO0lBQUEsT0FLQSwrQkFBdUI7TUFDckIsT0FBTyxJQUFJLENBQUN5MkMsT0FBTyxJQUFJLElBQUk7SUFDN0I7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLHFDQUE2QnBnQixhQUFhLEVBQUU7TUFDMUMsT0FBT0EsYUFBYSxDQUFDQyx3QkFBd0IsSUFBSTtRQUFDajVCLElBQUksRUFBRTtNQUFTLENBQUM7SUFDcEU7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUE7SUFBQSxPQVFBLDRCQUFvQmc1QixhQUFhLEVBQUU7TUFDakMsSUFDRUMsd0JBQXdCLEdBQ3RCRCxhQUFhLENBRGZDLHdCQUF3QjtNQUUxQixJQUFJQSx3QkFBd0IsSUFBSUEsd0JBQXdCLENBQUNqNUIsSUFBSSxFQUFFO1FBQzdELE9BQU9pNUIsd0JBQXdCLENBQUNqNUIsSUFBSTtNQUN0QztNQUNBLE9BQU8sU0FBUztJQUNsQjs7SUFFQTtFQUFBO0lBQUE7SUFBQSxPQUNBLGdDQUF3QjtNQUN0Qm9DLFNBQUssQ0FBQyxJQUFJLENBQUN3Z0IsS0FBSyw4QkFBOEI7TUFDOUMsSUFBSSxDQUFDdzJCLE9BQU8sQ0FBQy9sQixJQUFJLENBQUM7UUFDaEJtbUIsWUFBWSxFQUFFLElBQUksQ0FBQ0Msa0JBQWtCLENBQUMsSUFBSSxDQUFDM1osUUFBUTtNQUNyRCxDQUFDLENBQUM7SUFDSjtFQUFDO0lBQUE7SUFBQSxPQUVELDJCQUFtQjdKLFNBQVMsRUFBRTtNQUM1Qjd6QixTQUFLLENBQUMsSUFBSSxDQUFDd2dCLEtBQUssMkJBQTJCO01BQzNDLElBQUksQ0FBQ2xOLGFBQWEsQ0FBQ3VnQixTQUFTLENBQUNBLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZDLElBQUksQ0FBQzRCLGVBQWUsQ0FBQzRCLGVBQWUsQ0FBQ3hELFNBQVMsQ0FBQztNQUNqRCxDQUFDLE1BQU07UUFDTDd6QixTQUFLLENBQUMsSUFBSSxDQUFDd2dCLEtBQUssNEJBQTRCO01BQzlDO0lBQ0Y7RUFBQztJQUFBO0lBQUEsT0FFRCxxQkFBYWhLLEdBQUcsRUFBRTtNQUFBO01BQ2hCeFcsU0FBSyxDQUFDLElBQUksQ0FBQ3dnQixLQUFLLHdCQUF3QjtNQUN4QyxJQUFJLENBQUNpVixlQUFlLENBQUMyQixvQkFBb0IsQ0FBQyxJQUFJYixxQkFBNEIsQ0FBQy9mLEdBQUcsQ0FBQyxDQUFDLENBQzdFdFUsSUFBSSxDQUFDLFlBQU07UUFDVjtNQUFBLENBQ0QsQ0FBQyxDQUNERSxLQUFLLENBQUMsVUFBQWxDLEtBQUssRUFBSTtRQUNkLE1BQUksQ0FBQ2drQixPQUFPLENBQUMsSUFBSXpELDBCQUEwQixDQUFDcEIsK0JBQStCLENBQUN6Z0IsS0FBSyxFQUFFLE1BQUksQ0FBQzRoQixLQUFLLEVBQUU7VUFBQ3kyQixjQUFjLEVBQUUsTUFBSTtVQUFFLzJDLEtBQUssRUFBRUE7UUFBSyxDQUFDLENBQUMsQ0FBQztRQUNySSxNQUFJLENBQUM2eEIsa0JBQWtCLENBQUN6eEIsTUFBTSxDQUFDSixLQUFLLENBQUM7TUFDdkMsQ0FBQyxDQUFDO0lBQ047RUFBQztJQUFBO0lBQUEsT0FFRCxnQ0FBd0I0aEMsV0FBVyxFQUFFO01BQ25DLElBQUksQ0FBQ2tWLE9BQU8sQ0FBQ2hWLEtBQUssQ0FBQztRQUFDRCxhQUFhLEVBQUVELFdBQVcsSUFBSTtNQUFTLENBQUMsQ0FBQztNQUM3RCxJQUFJLENBQUNrVixPQUFPLEdBQUcvM0MsU0FBUztNQUN4QixJQUFJLENBQUM4eUIsa0JBQWtCLENBQUMxeEIsT0FBTyxDQUFDLElBQUksQ0FBQztJQUN2QztFQUFDO0lBQUE7SUFBQSxPQUVELHdCQUFnQmkzQyxVQUFVLEVBQUU7TUFDMUIsSUFBSUEsVUFBVSxDQUFDbDVDLE9BQU8sRUFBRTtRQUN0QixJQUFNdWpDLFdBQVcsR0FBR21WLFlBQVksQ0FBQ255QyxJQUFJLENBQUMyeUMsVUFBVSxDQUFDbDVDLE9BQU8sQ0FBQztRQUN6RDRCLFNBQUssQ0FBQyxJQUFJLENBQUN3Z0IsS0FBSywwQkFBbUI4MkIsVUFBVSxDQUFDbDVDLE9BQU8sRUFBRztRQUN4RCxJQUFJdWpDLFdBQVcsSUFBSUEsV0FBVyxDQUFDcGdDLE1BQU0sR0FBRyxDQUFDLEVBQUU7VUFDekM7VUFDQTtVQUNBO1VBQ0E7UUFBQTtNQUVKO0lBQ0Y7SUFDQTtFQUFBO0VBQUE7QUFBQSxFQXJSOENnMEIsYUFBZ0I7QUF5UmpEd2hCLDRGQUFpQyxFOztBQzFTQTtBQUNBO0FBQ007Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBSXJDO0FBQ3VCO0FBQ0o7QUFFcEMsSUFBTXJHLHlCQUFhLEdBQUcsaUNBQWlDO0FBQ3ZEO0FBQ0EsSUFBTUMsd0JBQVksR0FBRyxxQkFBcUI7QUFDMUMsSUFBTXJ2QixnQkFBSSxHQUFHLDBCQUEwQjtBQUN2QyxJQUFNaTJCLGtCQUFrQixHQUFHLFNBQVM7QUFDcEMsSUFBTUMsaUJBQWlCLEdBQUcsQ0FBQzs7QUFFM0I7QUFDQSxJQUFNQyxvQkFBb0IsR0FBRztFQUMzQnZELFNBQVMsRUFBRXFELGtCQUFrQjtFQUM3QkcsdUJBQXVCLEVBQUUsSUFBSTtFQUM3QkMsWUFBWSxFQUFFO0FBQ2hCLENBQUM7QUFBQSxJQUVLQyxvQ0FBd0I7RUFBQTtFQUFBO0VBRTVCLG9DQUFlO0lBQUE7SUFBQTtJQUNiO0lBQ0EsTUFBS3AzQixLQUFLLEdBQUdjLGdCQUFJO0lBQ2pCLE1BQUt1MkIsWUFBWSxHQUFHLEVBQUU7SUFDdEIsTUFBS0MsWUFBWSxHQUFHLEVBQUU7SUFDdEIsTUFBS0MsaUJBQWlCLEdBQUc5NEMsU0FBUztJQUNsQztJQUNBO0lBQUE7RUFDRjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBSkU7SUFBQTtJQUFBLE9BS0EsK0JBQXVCO01BQ3JCLElBQUkrNEMsWUFBWSxHQUFHOXVDLFFBQVEsQ0FBQ21CLGFBQWEsQ0FBQyxPQUFPLENBQUM7TUFDbEQ7TUFDQTJ0QyxZQUFZLENBQUMvc0MsRUFBRSxHQUFHLGVBQWU7TUFDakMrc0MsWUFBWSxDQUFDMXRCLFFBQVEsR0FBRyxVQUFVO01BQ2xDMHRCLFlBQVksQ0FBQ3hzQyxRQUFRLEdBQUcsVUFBVTtNQUNsQ3dzQyxZQUFZLENBQUN6cUIsV0FBVyxHQUFHLGFBQWE7TUFDeEMsT0FBT3lxQixZQUFZO0lBQ3JCOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQRTtJQUFBO0lBQUEsT0FRQSw4QkFBc0I1NEMsTUFBTSxFQUFFNjRDLE1BQU0sRUFBRTtNQUNwQyxJQUFNQyxDQUFDLEdBQUc5NEMsTUFBTSxDQUFDKzRDLGNBQWMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDNXVCLEtBQUssRUFBRTtNQUM1Q25xQixNQUFNLENBQUNxMEMsUUFBUSxDQUFDeUUsQ0FBQyxDQUFDO01BQ2xCLE9BQU0sRUFBRUQsTUFBTSxHQUFHLENBQUMsQ0FBQyxFQUFFO1FBQ25CLElBQUk3ZCxPQUFPLEdBQUcsSUFBSWdlLFlBQVksRUFBRTtRQUNoQyxJQUFJQyxJQUFJLEdBQUdqZSxPQUFPLENBQUNrZSw0QkFBNEIsRUFBRTtRQUNqRGxlLE9BQU8sQ0FBQ21lLHVCQUF1QixDQUFDbjVDLE1BQU0sQ0FBQyxDQUFDcW5DLE9BQU8sQ0FBQzRSLElBQUksQ0FBQztRQUNyRGo1QyxNQUFNLENBQUNxMEMsUUFBUSxDQUFDNEUsSUFBSSxDQUFDajVDLE1BQU0sQ0FBQ281QyxjQUFjLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztNQUNsRDtJQUNGOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFWRTtJQUFBO0lBQUEsT0FXQSx3QkFBa0Q7TUFBQSxJQUFwQ3BJLFNBQVMsdUVBQUcsSUFBSTtNQUFBLElBQUVDLFFBQVEsdUVBQUcsS0FBSztNQUM5Q3J3QyxTQUFLLENBQUMsZUFBZSxDQUFDO01BQ3RCLElBQUksQ0FBQzZ4QyxZQUFZLEdBQUc1eUMsU0FBUztNQUM3QixJQUFJLENBQUM0eUMsWUFBWSxHQUFHL3dDLE1BQU0sQ0FBQ0osZ0JBQWdCLENBQUMsSUFBSSxDQUFDbXhDLFlBQVksQ0FBQztNQUM5RCxJQUFJLENBQUNsVSxXQUFXLENBQUMrTixXQUFXLENBQUMwRSxTQUFTLEVBQUVDLFFBQVEsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDd0IsWUFBWSxDQUFDO01BQzFFLE9BQU8sSUFBSSxDQUFDQSxZQUFZLENBQUN0eEMsT0FBTztJQUNsQzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFkRTtJQUFBO0lBQUEsT0FlQSxvQkFBWWlXLEdBQUcsRUFBRW1kLFVBQVUsRUFBRWlMLFNBQVMsRUFBRTtNQUN0QyxJQUNFc1YsU0FBUyxHQUNQLElBQUksQ0FBQ3hXLFFBQVEsQ0FEZndXLFNBQVM7TUFFWCxJQUFJLENBQUNwQyxnQkFBZ0IsR0FBRzd5QyxTQUFTO01BQ2pDLElBQUksQ0FBQzZ5QyxnQkFBZ0IsR0FBR2h4QyxNQUFNLENBQUNKLGdCQUFnQixDQUFDLElBQUksQ0FBQ215QyxjQUFjLENBQUM7TUFDcEUsSUFBSSxDQUFDalYsYUFBYSxDQUFDM00sSUFBSSxDQUFDO1FBQ3RCd25CLFNBQVMsRUFBRXZFLFNBQVM7UUFDcEJ2Z0IsVUFBVSxFQUFFQSxVQUFVO1FBQ3RCaUwsU0FBUyxFQUFFQSxTQUFTO1FBQ3BCaDdCLElBQUksRUFBRTtVQUNKNFMsR0FBRyxFQUFFQTtRQUNQO01BQ0YsQ0FBQyxDQUFDO01BQ0YsT0FBTyxJQUFJLENBQUNzN0IsZ0JBQWdCLENBQUN2eEMsT0FBTztJQUN0Qzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7SUFDRTtFQUFBO0lBQUE7SUFBQSxPQUNBLHlCQUFpQm96QixVQUFVLEVBQUUwWixVQUFVLEVBQUUwRCxZQUFZLEVBQUU7TUFDckQsSUFBUTJHLHVCQUF1QixHQUFLLElBQUksQ0FBQ2hhLFFBQVEsQ0FBekNnYSx1QkFBdUI7TUFDL0I7TUFDQSxJQUFJLENBQUMxRixjQUFjLEdBQUcveUMsU0FBUztNQUMvQixJQUFJLENBQUMreUMsY0FBYyxHQUFHbHhDLE1BQU0sQ0FBQ0osZ0JBQWdCLENBQUMsSUFBSSxDQUFDc3hDLGNBQWMsQ0FBQztNQUNsRSxJQUFJLENBQUNBLGNBQWMsQ0FBQzN4QyxPQUFPLEVBQUU7TUFDN0IsSUFBSXEzQyx1QkFBdUIsRUFBRTtRQUMzQixJQUFJLENBQUNLLGlCQUFpQixHQUFHLElBQUksQ0FBQ1csZUFBZSxFQUFFO1FBQy9DLElBQUksQ0FBQ3gwQixPQUFPLENBQUMsSUFBSXhELDZCQUE2QixDQUFDakIsa0NBQWtDLENBQUNHLFlBQVksRUFBRSxJQUFJLEVBQUU7VUFDcEd4Z0IsTUFBTSxFQUFFLElBQUksQ0FBQzI0QztRQUNmLENBQUMsQ0FBQyxDQUFDO01BQ0w7TUFDQSxPQUFPLElBQUksQ0FBQy9GLGNBQWMsQ0FBQ3p4QyxPQUFPO0lBQ3BDOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTkU7SUFBQTtJQUFBLE9BT0EscUJBQWE7TUFDWCxJQUFJLElBQUksQ0FBQ3czQyxpQkFBaUIsRUFBRTtRQUMxQixJQUFJLENBQUNBLGlCQUFpQixDQUFDNUcsU0FBUyxFQUFFLENBQUNuckMsT0FBTyxDQUFDLFVBQUFtZCxDQUFDO1VBQUEsT0FBSUEsQ0FBQyxDQUFDcUosSUFBSSxFQUFFO1FBQUEsRUFBQztNQUMzRDtNQUNBLE9BQU87SUFDVDs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0lBQ0U7RUFBQTtJQUFBO0lBQUEsT0FDQSwyQkFBbUJtSCxVQUFVLEVBQUU7TUFDN0IsSUFDRXVnQixTQUFTLEdBQ1AsSUFBSSxDQUFDeFcsUUFBUSxDQURmd1csU0FBUztNQUVYLElBQUksQ0FBQ2pDLGdCQUFnQixHQUFHaHpDLFNBQVM7TUFDakMsSUFBSSxDQUFDZ3pDLGdCQUFnQixHQUFHbnhDLE1BQU0sQ0FBQ0osZ0JBQWdCLENBQUMsSUFBSSxDQUFDdXhDLGdCQUFnQixDQUFDO01BQ3RFO01BQ0E7TUFDQTtNQUNBLElBQUksQ0FBQyxJQUFJLENBQUMxUCxtQkFBbUIsRUFBRSxDQUFDb1csVUFBVSxDQUFDekUsU0FBUyxFQUFFdmdCLFVBQVUsQ0FBQyxFQUFFO1FBQ2pFLElBQUksQ0FBQ3NlLGdCQUFnQixDQUFDNXhDLE9BQU8sRUFBRTtNQUNqQztNQUNBLE9BQU8sSUFBSSxDQUFDNHhDLGdCQUFnQixDQUFDMXhDLE9BQU87SUFDdEM7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEsMkJBQW1CO01BQ2pCLElBQU1xNEMsY0FBYyxHQUFHLElBQUksQ0FBQ3RYLGlCQUFpQixFQUFFLENBQUN1WCxlQUFlLEVBQUUsQ0FBQ3Q1QyxHQUFHLENBQUMsVUFBQTRqQixDQUFDLEVBQUk7UUFDekUsSUFBSUEsQ0FBQyxDQUFDMjFCLGdCQUFnQixLQUFLLFVBQVUsRUFBRTtVQUNyQyxPQUFPMzFCLENBQUMsQ0FBQzQxQixRQUFRLENBQUN0ekMsS0FBSztRQUN6QjtRQUNBLE9BQU94RyxTQUFTO01BQ2xCLENBQUMsQ0FBQyxDQUFDZ1QsTUFBTSxDQUFDLFVBQUFrUixDQUFDO1FBQUEsT0FBSUEsQ0FBQztNQUFBLEVBQUM7TUFDakIsSUFBUXcwQixZQUFZLEdBQUssSUFBSSxDQUFDamEsUUFBUSxDQUE5QmlhLFlBQVk7TUFDcEIsSUFBSXY0QyxNQUFNO01BQ1YsSUFBSW1NLFdBQVcsR0FBRyxJQUFJLENBQUN3c0MsaUJBQWlCLElBQUksSUFBSWlCLFdBQVcsRUFBRTtNQUU3RCxJQUFJLENBQUNyQixZQUFZLEVBQUU7UUFFakI7UUFDQWlCLGNBQWMsQ0FBQzV5QyxPQUFPLENBQUMsVUFBQW1kLENBQUM7VUFBQSxPQUFJNVgsV0FBVyxDQUFDa29DLFFBQVEsQ0FBQ3R3QixDQUFDLENBQUM7UUFBQSxFQUFDO01BQ3RELENBQUMsTUFBTTtRQUVMO1FBQ0EsSUFBTTgxQixFQUFFLEdBQUcsSUFBSWIsWUFBWSxFQUFFO1FBQzdCO1FBQ0EsSUFBTWMsT0FBTyxHQUFHTixjQUFjLENBQUNyNUMsR0FBRyxDQUFDLFVBQUE0akIsQ0FBQyxFQUFJO1VBQ3RDLElBQUlBLENBQUMsQ0FBQ2l1QixJQUFJLEtBQUssT0FBTyxFQUFFO1lBQ3RCLE9BQU82SCxFQUFFLENBQUNWLHVCQUF1QixDQUFDLElBQUlTLFdBQVcsQ0FBQyxDQUFDNzFCLENBQUMsQ0FBQyxDQUFDLENBQUM7VUFDekQ7VUFDQSxPQUFPbGtCLFNBQVM7UUFDbEIsQ0FBQyxDQUFDLENBQUNnVCxNQUFNLENBQUMsVUFBQWtSLENBQUM7VUFBQSxPQUFJQSxDQUFDO1FBQUEsRUFBQztRQUNqQjtRQUNBLElBQU1rMUIsSUFBSSxHQUFHWSxFQUFFLENBQUNYLDRCQUE0QixFQUFFO1FBQzlDO1FBQ0FZLE9BQU8sQ0FBQ2x6QyxPQUFPLENBQUMsVUFBQTBRLENBQUM7VUFBQSxPQUFJQSxDQUFDLENBQUMrdkIsT0FBTyxDQUFDNFIsSUFBSSxDQUFDO1FBQUEsRUFBQztRQUNyQ2o1QyxNQUFNLEdBQUdpNUMsSUFBSSxDQUFDajVDLE1BQU07UUFDcEJBLE1BQU0sQ0FBQyt4QyxTQUFTLEVBQUUsQ0FBQ25yQyxPQUFPLENBQUMsVUFBQW1kLENBQUM7VUFBQSxPQUFJNVgsV0FBVyxDQUFDa29DLFFBQVEsQ0FBQ3R3QixDQUFDLENBQUM7UUFBQSxFQUFDO01BQzFEO01BQ0F5MUIsY0FBYyxDQUFDNXlDLE9BQU8sQ0FBQyxVQUFBbWQsQ0FBQyxFQUFJO1FBQzFCLElBQUlBLENBQUMsQ0FBQ2l1QixJQUFJLEtBQUssT0FBTyxFQUFFO1VBQ3RCN2xDLFdBQVcsQ0FBQ2tvQyxRQUFRLENBQUN0d0IsQ0FBQyxDQUFDO1FBQ3pCO01BQ0YsQ0FBQyxDQUFDO01BQ0YsT0FBTzVYLFdBQVc7SUFDcEI7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUkU7SUFBQTtJQUFBLE9BU0EsY0FBTTVKLE9BQU8sRUFBRTtNQUNiLE9BQU8seUdBQVc0UixNQUFNLENBQUNtbkIsTUFBTSxDQUFDK2Msb0JBQW9CLEVBQUU5MUMsT0FBTyxDQUFDO0lBQ2hFOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFWRTtJQUFBO0lBQUEsT0FXQSx3QkFBZ0JBLE9BQU8sRUFBRXZDLE1BQU0sRUFBRTtNQUMvQixPQUFPLG1IQUFxQm1VLE1BQU0sQ0FBQ21uQixNQUFNLENBQUMrYyxvQkFBb0IsRUFBRTkxQyxPQUFPLENBQUMsRUFBRXZDLE1BQU07SUFDbEY7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUE7SUFBQSxPQUtBLGtDQUEwQnFHLEtBQUssRUFBRTtNQUMvQixJQUFRaXlDLHVCQUF1QixHQUFLLElBQUksQ0FBQ2hhLFFBQVEsQ0FBekNnYSx1QkFBdUI7TUFDL0IsSUFBSUEsdUJBQXVCLElBQUlqeUMsS0FBSyxDQUFDMnJDLElBQUksS0FBSyxPQUFPLEVBQUU7UUFDckQsSUFBSSxDQUFDeUcsWUFBWSxDQUFDMTRDLElBQUksQ0FBQ3NHLEtBQUssQ0FBQztNQUMvQixDQUFDLE1BQU0sSUFBSWl5Qyx1QkFBdUIsSUFBSWp5QyxLQUFLLENBQUMyckMsSUFBSSxLQUFLLE9BQU8sRUFBRTtRQUM1RCxJQUFJLENBQUMwRyxZQUFZLENBQUMzNEMsSUFBSSxDQUFDc0csS0FBSyxDQUFDO01BQy9CO01BQ0EsNkhBQStCQSxLQUFLO0lBQ3RDOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUxFO0lBQUE7SUFBQSxPQU1BLGdDQUF3QjhGLFdBQVcsRUFBRTtNQUNuQyxJQUFJLENBQUM0dEMsb0JBQW9CLENBQUM1dEMsV0FBVyxFQUFFaXNDLGlCQUFpQixDQUFDO01BQ3pELDJIQUE2QmpzQyxXQUFXO0lBQzFDOztJQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUxFO0lBQUE7SUFBQSxPQU1BLHFCQUFhaUwsR0FBRyxFQUFFO01BQ2hCLElBQ0VtZCxVQUFVLEdBQ1IsSUFBSSxDQUFDK0osUUFBUSxDQURmL0osVUFBVTtNQUVaO01BQ0EsSUFBSSxDQUFDeWxCLGNBQWMsQ0FBQztRQUNsQnpsQixVQUFVLEVBQUVuZCxHQUFHLENBQUM2aUMsYUFBYTtRQUM3QkEsYUFBYSxFQUFFN2lDLEdBQUcsQ0FBQzZpQyxhQUFhO1FBQ2hDQyxhQUFhLEVBQUUzbEI7TUFDakIsQ0FBQyxDQUFDO01BQ0YsSUFBSSxDQUFDbWUsZ0JBQWdCLEdBQUdoeEMsTUFBTSxDQUFDSixnQkFBZ0IsQ0FBQyxJQUFJLENBQUNveEMsZ0JBQWdCLENBQUM7TUFDdEUsSUFBSSxDQUFDQSxnQkFBZ0IsQ0FBQ3p4QyxPQUFPLENBQUNtVyxHQUFHLENBQUM7SUFDcEM7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBTEU7SUFBQTtJQUFBLE9BTUEsMkJBQW1CMGUsTUFBTSxFQUFFO01BQ3pCbDFCLFNBQUssQ0FBQyxJQUFJLENBQUN3Z0IsS0FBSyxFQUFFLHNCQUFzQixHQUFHamMsSUFBSSxDQUFDNE8sU0FBUyxDQUFDK2hCLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7TUFDM0UsSUFBTW1mLFVBQVUsR0FBRzFELHdCQUFZLENBQUNoc0MsSUFBSSxDQUFDdXdCLE1BQU0sQ0FBQzkyQixPQUFPLENBQUM7TUFDcEQsSUFBTXVqQyxXQUFXLEdBQUcrTyx5QkFBYSxDQUFDL3JDLElBQUksQ0FBQ3V3QixNQUFNLENBQUM5MkIsT0FBTyxDQUFDO01BQ3RELElBQUlpMkMsVUFBVSxJQUFJQSxVQUFVLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDM1csUUFBUSxDQUFDd1csU0FBUyxFQUFFO1FBQzNELElBQUksQ0FBQ2pDLGdCQUFnQixDQUFDNXhDLE9BQU8sRUFBRTtNQUNqQyxDQUFDLE1BQU0sSUFBSXNoQyxXQUFXLElBQUlBLFdBQVcsQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUNqRSxRQUFRLENBQUMvSixVQUFVLEVBQUU7UUFDckUsSUFBSSxDQUFDcWUsY0FBYyxDQUFDM3hDLE9BQU8sRUFBRTtNQUMvQixDQUFDLE1BQU07UUFDTEosUUFBSSxDQUFDLElBQUksQ0FBQ3VnQixLQUFLLEVBQUUsa0RBQWtELENBQUM7TUFDdEU7SUFDRjtFQUFDO0VBQUE7QUFBQSxFQW5Ub0NpeEIscUJBQVk7QUF1VHBDbUcsb0ZBQXdCLEU7O0FDN1V2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBS2M7QUFDaUM7QUFDSTtBQUNGO0FBQ007QUFDUjtBQUNKO0FBQ2M7QUFDRTtBQUNJO0FBQ2M7QUFDWDtBQUN4QjtBQUNBO0FBQ3FCOztBQUUvRDtBQUNBO0FBQ0E7QUFDaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU1sTCxvQkFBaUIsR0FBRzZNLDRCQUErQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFNL2IsZ0JBQWEsR0FBRytiLFdBQTJCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTXBPLGFBQVUsR0FBR29PLFlBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU03UixpQkFBYyxHQUFHNlIsWUFBNEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTXBRLGdCQUFhLEdBQUdvUSxXQUEyQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTTNFLG1CQUFnQixHQUFHNEUsMEJBQTZCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTS9ILGVBQVksR0FBRytILHFCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU1sRixhQUFVLEdBQUdrRixZQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFNN0ssZ0JBQWEsR0FBRzZLLHNCQUEwQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNzQjs7QUFFdEI7QUFDa0Y7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFNbEUsc0JBQW1CLEdBQUdtRSxZQUFtQzs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFNbEQsNEJBQXlCLEdBQUdrRCxtQkFBeUM7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTTFDLG9DQUFpQyxHQUFHMEMsaUJBQWlEOztBQUVsRztBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU1yL0Isc0JBQW1CLEdBQUdzL0IsbUJBQWtDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNPLElBQU1sK0IseUJBQXNCLEdBQUdrK0Isc0JBQXFDO0FBQzNFO0FBQ0E7QUFDQTtBQUNPLElBQU1yK0IsOEJBQTJCLEdBQUdxK0IsMkJBQTBDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNPLElBQU05OEIsdUJBQW9CLEdBQUcrOEIsb0JBQW9DO0FBQ3hFO0FBQ0E7QUFDQTtBQUNPLElBQU12N0IsMEJBQXVCLEdBQUd1N0IsdUJBQXVDO0FBQzlFO0FBQ0E7QUFDQTtBQUNPLElBQU01NkIsMkJBQXdCLEdBQUc0NkIsd0JBQXdDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNPLElBQU0xN0IsK0JBQTRCLEdBQUcwN0IsNEJBQTRDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNPLElBQU0xNkIseUJBQXNCLEdBQUcyNkIsc0JBQXdDO0FBQzlFO0FBQ0E7QUFDQTtBQUNPLElBQU12NkIsa0NBQStCLEdBQUd3NkIsK0JBQTBEO0FBQ3pHO0FBQ0E7QUFDQTtBQUNPLElBQU1DLGlDQUFpQyxHQUFHQyxrQ0FBd0Q7O0FBRXpHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU1qZSx1QkFBb0IsR0FBR2tlLG9CQUFpQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFNNWQsdUJBQW9CLEdBQUc0ZCxvQkFBaUM7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFNemQsb0JBQWlCLEdBQUcwZCxpQkFBNEI7QUFFN0RuN0MsbUJBQWUsQ0FBQyxVQUFHbzdDLE9BQVMsS0FBTTM3QyxLQUFZLENBQUMsRUFBQzs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU00N0MsY0FBVyxHQUFHLFNBQWRBLFdBQVcsQ0FBSXI4QyxLQUFLLEVBQW1CO0VBQUEsSUFBakJpQixNQUFNLHVFQUFDLEtBQUs7RUFDN0MsSUFBSVIsTUFBTSxDQUFDNEgsY0FBYyxDQUFDckksS0FBSyxDQUFDOGtDLFdBQVcsRUFBRSxDQUFDLEVBQUU7SUFDOUM5akMsbUJBQWUsQ0FBQ2hCLEtBQUssRUFBRWlCLE1BQU0sQ0FBQztJQUM5QixJQUFJdkIsT0FBTyxFQUFFO01BQ1hBLE9BQU8sQ0FBQ0MsR0FBRyxnQ0FBeUIyOEMsU0FBVyxFQUFHLEVBQUM7SUFDckQ7RUFDRjtBQUNGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3dCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFNQyxVQUFVLEdBQUc5N0MsTUFBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFNcUIsWUFBUyxHQUFHMDZDLFNBQVUsQyIsImZpbGUiOiJyZWQ1cHJvLXNkay5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInJlZDVwcm9zZGtcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wicmVkNXByb3Nka1wiXSA9IGZhY3RvcnkoKTtcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEpO1xuIiwiLyoqXG4gKiAhVGhpcyBpcyBhIHN0cmlwcGVkIGRvd24gdmVyc2lvbiBvZiBCdW55YW4gdGFyZ2V0ZWQgc3BlY2lmaWNhbGx5IGZvciB0aGUgYnJvd3NlclxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgVHJlbnQgTWljay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIENvcHlyaWdodCAoYykgMjAxNCBKb3llbnQgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoZSBidW55YW4gbG9nZ2luZyBsaWJyYXJ5IGZvciBub2RlLmpzLlxuICpcbiAqIC0qLSBtb2RlOiBqcyAtKi1cbiAqIHZpbTogZXhwYW5kdGFiOnRzPTQ6c3c9NFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFZFUlNJT04gPSAnMC4yLjMnO1xuXG4vLyBCdW55YW4gbG9nIGZvcm1hdCB2ZXJzaW9uLiBUaGlzIGJlY29tZXMgdGhlICd2JyBmaWVsZCBvbiBhbGwgbG9nIHJlY29yZHMuXG4vLyBgMGAgaXMgdW50aWwgSSByZWxlYXNlIGEgdmVyc2lvbiAnMS4wLjAnIG9mIG5vZGUtYnVueWFuLiBUaGVyZWFmdGVyLFxuLy8gc3RhcnRpbmcgd2l0aCBgMWAsIHRoaXMgd2lsbCBiZSBpbmNyZW1lbnRlZCBpZiB0aGVyZSBpcyBhbnkgYmFja3dhcmRcbi8vIGluY29tcGF0aWJsZSBjaGFuZ2UgdG8gdGhlIGxvZyByZWNvcmQgZm9ybWF0LiBEZXRhaWxzIHdpbGwgYmUgaW5cbi8vICdDSEFOR0VTLm1kJyAodGhlIGNoYW5nZSBsb2cpLlxudmFyIExPR19WRVJTSU9OID0gMDtcblxuLy8tLS0tIEludGVybmFsIHN1cHBvcnQgc3R1ZmZcblxuLyoqXG4gKiBBIHNoYWxsb3cgY29weSBvZiBhbiBvYmplY3QuIEJ1bnlhbiBsb2dnaW5nIGF0dGVtcHRzIHRvIG5ldmVyIGNhdXNlXG4gKiBleGNlcHRpb25zLCBzbyB0aGlzIGZ1bmN0aW9uIGF0dGVtcHRzIHRvIGhhbmRsZSBub24tb2JqZWN0cyBncmFjZWZ1bGx5LlxuICovXG5mdW5jdGlvbiBvYmpDb3B5KG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyB8fCBvYmogPT09IG51bGwpIHsgIC8vIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIChvYmopID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgY29weSA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGNvcHlba10gPSBvYmpba107XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbn1cblxudmFyIGZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcblxuICAgIGlmKGYgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG5cbiAgICBpZih0eXBlb2YgZiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGYudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgdmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5cbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICAgIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHggPT09ICclJScpIHtcbiAgICAgICAgICAgIHJldHVybiAnJSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICAgICAgICBjYXNlICclaic6XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogR2F0aGVyIHNvbWUgY2FsbGVyIGluZm8gMyBzdGFjayBsZXZlbHMgdXAuXG4gKiBTZWUgPGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC93aWtpL0phdmFTY3JpcHRTdGFja1RyYWNlQXBpPi5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FsbGVyM0luZm8oKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIHZhciBzYXZlTGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gICAgdmFyIHNhdmVQcmVwYXJlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMztcbiAgICAvL0Vycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGdldENhbGxlcjNJbmZvKTtcblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnVuY3Rpb24gKF8sIHN0YWNrKSB7XG4gICAgICAgIHZhciBjYWxsZXIgPSBzdGFja1syXTtcbiAgICAgICAgb2JqLmZpbGUgPSBjYWxsZXIuZ2V0RmlsZU5hbWUoKTtcbiAgICAgICAgb2JqLmxpbmUgPSBjYWxsZXIuZ2V0TGluZU51bWJlcigpO1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxlci5nZXRGdW5jdGlvbk5hbWUoKTtcbiAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICAgIG9iai5mdW5jID0gZnVuYztcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gc2F2ZUxpbWl0O1xuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gc2F2ZVByZXBhcmU7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuXG5mdW5jdGlvbiBfaW5kZW50KHMsIGluZGVudCkge1xuICAgIGlmICghaW5kZW50KSB7XG4gICAgICAgIGluZGVudCA9ICcgICAgJztcbiAgICB9XG4gICAgdmFyIGxpbmVzID0gcy5zcGxpdCgvXFxyP1xcbi9nKTtcbiAgICByZXR1cm4gaW5kZW50ICsgbGluZXMuam9pbignXFxuJyArIGluZGVudCk7XG59XG5cblxuLyoqXG4gKiBXYXJuIGFib3V0IGFuIGJ1bnlhbiBwcm9jZXNzaW5nIGVycm9yLlxuICpcbiAqIEBwYXJhbSBtc2cge1N0cmluZ30gTWVzc2FnZSB3aXRoIHdoaWNoIHRvIHdhcm4uXG4gKiBAcGFyYW0gZGVkdXBLZXkge1N0cmluZ30gT3B0aW9uYWwuIEEgc2hvcnQgc3RyaW5nIGtleSBmb3IgdGhpcyB3YXJuaW5nIHRvXG4gKiAgICAgIGhhdmUgaXRzIHdhcm5pbmcgb25seSBwcmludGVkIG9uY2UuXG4gKi9cbmZ1bmN0aW9uIF93YXJuKG1zZywgZGVkdXBLZXkpIHtcbiAgICBpZiAoZGVkdXBLZXkpIHtcbiAgICAgICAgaWYgKF93YXJuZWRbZGVkdXBLZXldKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX3dhcm5lZFtkZWR1cEtleV0gPSB0cnVlO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKG1zZyArICdcXG4nKTtcbn1cbmZ1bmN0aW9uIF9oYXZlV2FybmVkKGRlZHVwS2V5KSB7XG4gICAgcmV0dXJuIF93YXJuZWRbZGVkdXBLZXldO1xufVxudmFyIF93YXJuZWQgPSB7fTtcblxuXG5mdW5jdGlvbiBDb25zb2xlUmF3U3RyZWFtKCkge1xufVxuQ29uc29sZVJhd1N0cmVhbS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocmVjKSB7XG4gICAgaWYgKHJlYy5sZXZlbCA8IElORk8pIHtcbiAgICAgICAgY29uc29sZS5sb2cocmVjKTtcbiAgICB9IGVsc2UgaWYgKHJlYy5sZXZlbCA8IFdBUk4pIHtcbiAgICAgICAgY29uc29sZS5pbmZvKHJlYyk7XG4gICAgfSBlbHNlIGlmIChyZWMubGV2ZWwgPCBFUlJPUikge1xuICAgICAgICBjb25zb2xlLndhcm4ocmVjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKHJlYyk7XG4gICAgfVxuXG4gICAgaWYocmVjLmVyciAmJiByZWMuZXJyLnN0YWNrKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IocmVjLmVyci5zdGFjayk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gQ29uc29sZUZvcm1hdHRlZFN0cmVhbSgpIHt9XG5Db25zb2xlRm9ybWF0dGVkU3RyZWFtLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChyZWMpIHtcblxuICAgIHZhciBsZXZlbENzcywgZGVmYXVsdENzcyA9ICdjb2xvcjogRGltR3JheScsIG1zZ0NzcyA9ICdjb2xvcjogU3RlZWxCbHVlJztcblxuICAgIGlmIChyZWMubGV2ZWwgPCBERUJVRykge1xuICAgICAgICBsZXZlbENzcyA9ICdjb2xvcjogRGVlcFBpbmsnO1xuICAgIH0gZWxzZSBpZiAocmVjLmxldmVsIDwgSU5GTykge1xuICAgICAgICBsZXZlbENzcyA9ICdjb2xvcjogR29sZGVuUm9kJztcbiAgICB9IGVsc2UgaWYgKHJlYy5sZXZlbCA8IFdBUk4pIHtcbiAgICAgICAgbGV2ZWxDc3MgPSAnY29sb3I6IERhcmtUdXJxdW9pc2UnO1xuICAgIH0gZWxzZSBpZiAocmVjLmxldmVsIDwgRVJST1IpIHtcbiAgICAgICAgbGV2ZWxDc3MgPSAnY29sb3I6IFB1cnBsZSc7XG4gICAgfSBlbHNlIGlmIChyZWMubGV2ZWwgPCBGQVRBTCkge1xuICAgICAgICBsZXZlbENzcyA9ICdjb2xvcjogQ3JpbXNvbic7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxDc3MgPSAnY29sb3I6IEJsYWNrJztcbiAgICB9XG5cbiAgICB2YXIgbG9nZ2VyTmFtZSA9IHJlYy5jaGlsZE5hbWUgPyByZWMubmFtZSArICcvJyArIHJlYy5jaGlsZE5hbWUgOiByZWMubmFtZTtcblxuICAgIC8vZ2V0IGxldmVsIG5hbWUgYW5kIHBhZCBzdGFydCB3aXRoIHNwYWNzXG4gICAgdmFyIGxldmVsTmFtZSA9IG5hbWVGcm9tTGV2ZWxbcmVjLmxldmVsXS50b1VwcGVyQ2FzZSgpO1xuICAgIGxldmVsTmFtZSA9IEFycmF5KDYgLSBsZXZlbE5hbWUubGVuZ3RoKS5qb2luKCcgJykgKyBsZXZlbE5hbWU7XG5cbiAgICBmdW5jdGlvbiBwYWRaZXJvcyhudW1iZXIsIGxlbikge1xuICAgICAgICByZXR1cm4gQXJyYXkoKGxlbiArIDEpIC0gKG51bWJlciArICcnKS5sZW5ndGgpLmpvaW4oJzAnKSArIG51bWJlcjtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnWyVzOiVzOiVzOiVzXSAlYyVzJWM6ICVzOiAlYyVzJyxcbiAgICAgICAgcGFkWmVyb3MocmVjLnRpbWUuZ2V0SG91cnMoKSwgMiksIHBhZFplcm9zKHJlYy50aW1lLmdldE1pbnV0ZXMoKSwgMiksXG4gICAgICAgIHBhZFplcm9zKHJlYy50aW1lLmdldFNlY29uZHMoKSwgMiksIHBhZFplcm9zKHJlYy50aW1lLmdldE1pbGxpc2Vjb25kcygpLCA0KSxcbiAgICAgICAgbGV2ZWxDc3MsIGxldmVsTmFtZSxcbiAgICAgICAgZGVmYXVsdENzcywgbG9nZ2VyTmFtZSxcbiAgICAgICAgbXNnQ3NzLCByZWMubXNnKTtcbiAgICBpZihyZWMuZXJyICYmIHJlYy5lcnIuc3RhY2spIHtcbiAgICAgICAgY29uc29sZS5sb2coJyVjJXMsJywgbGV2ZWxDc3MsIHJlYy5lcnIuc3RhY2spO1xuICAgIH1cbn07XG5cbi8vLS0tLSBMZXZlbHNcblxudmFyIFRSQUNFID0gMTA7XG52YXIgREVCVUcgPSAyMDtcbnZhciBJTkZPID0gMzA7XG52YXIgV0FSTiA9IDQwO1xudmFyIEVSUk9SID0gNTA7XG52YXIgRkFUQUwgPSA2MDtcblxudmFyIGxldmVsRnJvbU5hbWUgPSB7XG4gICAgJ3RyYWNlJzogVFJBQ0UsXG4gICAgJ2RlYnVnJzogREVCVUcsXG4gICAgJ2luZm8nOiBJTkZPLFxuICAgICd3YXJuJzogV0FSTixcbiAgICAnZXJyb3InOiBFUlJPUixcbiAgICAnZmF0YWwnOiBGQVRBTFxufTtcbnZhciBuYW1lRnJvbUxldmVsID0ge307XG5PYmplY3Qua2V5cyhsZXZlbEZyb21OYW1lKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgbmFtZUZyb21MZXZlbFtsZXZlbEZyb21OYW1lW25hbWVdXSA9IG5hbWU7XG59KTtcblxuXG4vKipcbiAqIFJlc29sdmUgYSBsZXZlbCBudW1iZXIsIG5hbWUgKHVwcGVyIG9yIGxvd2VyY2FzZSkgdG8gYSBsZXZlbCBudW1iZXIgdmFsdWUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUxldmVsKG5hbWVPck51bSkge1xuICAgIHZhciBsZXZlbCA9ICh0eXBlb2YgKG5hbWVPck51bSkgPT09ICdzdHJpbmcnID8gbGV2ZWxGcm9tTmFtZVtuYW1lT3JOdW0udG9Mb3dlckNhc2UoKV0gOiBuYW1lT3JOdW0pO1xuICAgIHJldHVybiBsZXZlbDtcbn1cblxuXG4vLy0tLS0gTG9nZ2VyIGNsYXNzXG5cbi8qKlxuICogQ3JlYXRlIGEgTG9nZ2VyIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IFNlZSBkb2N1bWVudGF0aW9uIGZvciBmdWxsIGRldGFpbHMuIEF0IG1pbmltdW1cbiAqICAgIHRoaXMgbXVzdCBpbmNsdWRlIGEgJ25hbWUnIHN0cmluZyBrZXkuIENvbmZpZ3VyYXRpb24ga2V5czpcbiAqICAgICAgLSBgc3RyZWFtc2A6IHNwZWNpZnkgdGhlIGxvZ2dlciBvdXRwdXQgc3RyZWFtcy4gVGhpcyBpcyBhbiBhcnJheSBvZlxuICogICAgICAgIG9iamVjdHMgd2l0aCB0aGVzZSBmaWVsZHM6XG4gKiAgICAgICAgICAtIGB0eXBlYDogVGhlIHN0cmVhbSB0eXBlLiBTZWUgUkVBRE1FLm1kIGZvciBmdWxsIGRldGFpbHMuXG4gKiAgICAgICAgICAgIE9mdGVuIHRoaXMgaXMgaW1wbGllZCBieSB0aGUgb3RoZXIgZmllbGRzLiBFeGFtcGxlcyBhcmVcbiAqICAgICAgICAgICAgJ2ZpbGUnLCAnc3RyZWFtJyBhbmQgXCJyYXdcIi5cbiAqICAgICAgICAgIC0gYGxldmVsYDogRGVmYXVsdHMgdG8gJ2luZm8nLlxuICogICAgICAgICAgLSBgcGF0aGAgb3IgYHN0cmVhbWA6IFRoZSBzcGVjaWZ5IHRoZSBmaWxlIHBhdGggb3Igd3JpdGVhYmxlXG4gKiAgICAgICAgICAgIHN0cmVhbSB0byB3aGljaCBsb2cgcmVjb3JkcyBhcmUgd3JpdHRlbi4gRS5nLlxuICogICAgICAgICAgICBgc3RyZWFtOiBwcm9jZXNzLnN0ZG91dGAuXG4gKiAgICAgICAgICAtIGBjbG9zZU9uRXhpdGAgKGJvb2xlYW4pOiBPcHRpb25hbC4gRGVmYXVsdCBpcyB0cnVlIGZvciBhXG4gKiAgICAgICAgICAgICdmaWxlJyBzdHJlYW0gd2hlbiBgcGF0aGAgaXMgZ2l2ZW4sIGZhbHNlIG90aGVyd2lzZS5cbiAqICAgICAgICBTZWUgUkVBRE1FLm1kIGZvciBmdWxsIGRldGFpbHMuXG4gKiAgICAgIC0gYGxldmVsYDogc2V0IHRoZSBsZXZlbCBmb3IgYSBzaW5nbGUgb3V0cHV0IHN0cmVhbSAoY2Fubm90IGJlIHVzZWRcbiAqICAgICAgICB3aXRoIGBzdHJlYW1zYClcbiAqICAgICAgLSBgc3RyZWFtYDogdGhlIG91dHB1dCBzdHJlYW0gZm9yIGEgbG9nZ2VyIHdpdGgganVzdCBvbmUsIGUuZy5cbiAqICAgICAgICBgcHJvY2Vzcy5zdGRvdXRgIChjYW5ub3QgYmUgdXNlZCB3aXRoIGBzdHJlYW1zYClcbiAqICAgICAgLSBgc2VyaWFsaXplcnNgOiBvYmplY3QgbWFwcGluZyBsb2cgcmVjb3JkIGZpZWxkIG5hbWVzIHRvXG4gKiAgICAgICAgc2VyaWFsaXppbmcgZnVuY3Rpb25zLiBTZWUgUkVBRE1FLm1kIGZvciBkZXRhaWxzLlxuICogICAgICAtIGBzcmNgOiBCb29sZWFuIChkZWZhdWx0IGZhbHNlKS4gU2V0IHRydWUgdG8gZW5hYmxlICdzcmMnIGF1dG9tYXRpY1xuICogICAgICAgIGZpZWxkIHdpdGggbG9nIGNhbGwgc291cmNlIGluZm8uXG4gKiAgICBBbGwgb3RoZXIga2V5cyBhcmUgbG9nIHJlY29yZCBmaWVsZHMuXG4gKlxuICogQW4gYWx0ZXJuYXRpdmUgKmludGVybmFsKiBjYWxsIHNpZ25hdHVyZSBpcyB1c2VkIGZvciBjcmVhdGluZyBhIGNoaWxkOlxuICogICAgbmV3IExvZ2dlcig8cGFyZW50IGxvZ2dlcj4sIDxjaGlsZCBvcHRpb25zPlssIDxjaGlsZCBvcHRzIGFyZSBzaW1wbGU+XSk7XG4gKlxuICogQHBhcmFtIF9jaGlsZFNpbXBsZSAoQm9vbGVhbikgQW4gYXNzZXJ0aW9uIHRoYXQgdGhlIGdpdmVuIGBfY2hpbGRPcHRpb25zYFxuICogICAgKGEpIG9ubHkgYWRkIGZpZWxkcyAobm8gY29uZmlnKSBhbmQgKGIpIG5vIHNlcmlhbGl6YXRpb24gaGFuZGxpbmcgaXNcbiAqICAgIHJlcXVpcmVkIGZvciB0aGVtLiBJT1csIHRoaXMgaXMgYSBmYXN0IHBhdGggZm9yIGZyZXF1ZW50IGNoaWxkXG4gKiAgICBjcmVhdGlvbi5cbiAqL1xuZnVuY3Rpb24gTG9nZ2VyKG9wdGlvbnMsIF9jaGlsZE9wdGlvbnMsIF9jaGlsZFNpbXBsZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMb2dnZXIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9nZ2VyKG9wdGlvbnMsIF9jaGlsZE9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIElucHV0IGFyZyB2YWxpZGF0aW9uLlxuICAgIHZhciBwYXJlbnQ7XG4gICAgaWYgKF9jaGlsZE9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJlbnQgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gX2NoaWxkT3B0aW9ucztcbiAgICAgICAgaWYgKCEocGFyZW50IGluc3RhbmNlb2YgTG9nZ2VyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAnaW52YWxpZCBMb2dnZXIgY3JlYXRpb246IGRvIG5vdCBwYXNzIGEgc2Vjb25kIGFyZycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIChvYmplY3QpIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLm5hbWUgKHN0cmluZykgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgb3B0aW9ucy5uYW1lOiBjaGlsZCBjYW5ub3Qgc2V0IGxvZ2dlciBuYW1lJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3RyZWFtICYmIG9wdGlvbnMuc3RyZWFtcykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3QgbWl4IFwic3RyZWFtc1wiIGFuZCBcInN0cmVhbVwiIG9wdGlvbnMnKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3RyZWFtcyAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zLnN0cmVhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgb3B0aW9ucy5zdHJlYW1zOiBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNlcmlhbGl6ZXJzICYmICh0eXBlb2YgKG9wdGlvbnMuc2VyaWFsaXplcnMpICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMuc2VyaWFsaXplcnMpKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIG9wdGlvbnMuc2VyaWFsaXplcnM6IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgdmFyIGZpZWxkcywgbmFtZSwgaTtcblxuICAgIC8vIEZhc3QgcGF0aCBmb3Igc2ltcGxlIGNoaWxkIGNyZWF0aW9uLlxuICAgIGlmIChwYXJlbnQgJiYgX2NoaWxkU2ltcGxlKSB7XG4gICAgICAgIC8vIGBfaXNTaW1wbGVDaGlsZGAgaXMgYSBzaWduYWwgdG8gc3RyZWFtIGNsb3NlIGhhbmRsaW5nIHRoYXQgdGhpcyBjaGlsZFxuICAgICAgICAvLyBvd25zIG5vbmUgb2YgaXRzIHN0cmVhbXMuXG4gICAgICAgIHRoaXMuX2lzU2ltcGxlQ2hpbGQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX2xldmVsID0gcGFyZW50Ll9sZXZlbDtcbiAgICAgICAgdGhpcy5zdHJlYW1zID0gcGFyZW50LnN0cmVhbXM7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplcnMgPSBwYXJlbnQuc2VyaWFsaXplcnM7XG4gICAgICAgIHRoaXMuc3JjID0gcGFyZW50LnNyYztcbiAgICAgICAgZmllbGRzID0gdGhpcy5maWVsZHMgPSB7fTtcbiAgICAgICAgdmFyIHBhcmVudEZpZWxkTmFtZXMgPSBPYmplY3Qua2V5cyhwYXJlbnQuZmllbGRzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcmVudEZpZWxkTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5hbWUgPSBwYXJlbnRGaWVsZE5hbWVzW2ldO1xuICAgICAgICAgICAgZmllbGRzW25hbWVdID0gcGFyZW50LmZpZWxkc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBmaWVsZHNbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOdWxsIHZhbHVlcy5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICB0aGlzLl9sZXZlbCA9IHBhcmVudC5fbGV2ZWw7XG4gICAgICAgIHRoaXMuc3RyZWFtcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyZW50LnN0cmVhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzID0gb2JqQ29weShwYXJlbnQuc3RyZWFtc1tpXSk7XG4gICAgICAgICAgICBzLmNsb3NlT25FeGl0ID0gZmFsc2U7IC8vIERvbid0IG93biBwYXJlbnQgc3RyZWFtLlxuICAgICAgICAgICAgdGhpcy5zdHJlYW1zLnB1c2gocyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJpYWxpemVycyA9IG9iakNvcHkocGFyZW50LnNlcmlhbGl6ZXJzKTtcbiAgICAgICAgdGhpcy5zcmMgPSBwYXJlbnQuc3JjO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IG9iakNvcHkocGFyZW50LmZpZWxkcyk7XG4gICAgICAgIGlmIChvcHRpb25zLmxldmVsKSB7XG4gICAgICAgICAgICB0aGlzLmxldmVsKG9wdGlvbnMubGV2ZWwpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbGV2ZWwgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIHRoaXMuc3RyZWFtcyA9IFtdO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zcmMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5maWVsZHMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgKmNvbmZpZyogb3B0aW9ucyAoaS5lLiBvcHRpb25zIHRoYXQgYXJlIG5vdCBqdXN0IHBsYWluIGRhdGFcbiAgICAvLyBmb3IgbG9nIHJlY29yZHMpLlxuICAgIGlmIChvcHRpb25zLnN0cmVhbSkge1xuICAgICAgICBzZWxmLmFkZFN0cmVhbSh7XG4gICAgICAgICAgICB0eXBlOiAnc3RyZWFtJyxcbiAgICAgICAgICAgIHN0cmVhbTogb3B0aW9ucy5zdHJlYW0sXG4gICAgICAgICAgICBjbG9zZU9uRXhpdDogZmFsc2UsXG4gICAgICAgICAgICBsZXZlbDogb3B0aW9ucy5sZXZlbFxuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc3RyZWFtcykge1xuICAgICAgICBvcHRpb25zLnN0cmVhbXMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgc2VsZi5hZGRTdHJlYW0ocywgb3B0aW9ucy5sZXZlbCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocGFyZW50ICYmIG9wdGlvbnMubGV2ZWwpIHtcbiAgICAgICAgdGhpcy5sZXZlbChvcHRpb25zLmxldmVsKTtcbiAgICB9IGVsc2UgaWYgKCFwYXJlbnQpIHtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBJbiB0aGUgYnJvd3NlciB3ZSdsbCBiZSBlbWl0dGluZyB0byBjb25zb2xlLmxvZyBieSBkZWZhdWx0LlxuICAgICAgICAgKiBBbnkgY29uc29sZS5sb2cgd29ydGggaXRzIHNhbHQgdGhlc2UgZGF5cyBjYW4gbmljZWx5IHJlbmRlclxuICAgICAgICAgKiBhbmQgaW50cm9zcGVjdCBvYmplY3RzIChlLmcuIHRoZSBGaXJlZm94IGFuZCBDaHJvbWUgY29uc29sZSlcbiAgICAgICAgICogc28gbGV0J3MgZW1pdCB0aGUgcmF3IGxvZyByZWNvcmQuIEFyZSB0aGVyZSBicm93c2VycyBmb3Igd2hpY2hcbiAgICAgICAgICogdGhhdCBicmVha3MgdGhpbmdzP1xuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5hZGRTdHJlYW0oe1xuICAgICAgICAgICAgdHlwZTogJ3JhdycsXG4gICAgICAgICAgICBzdHJlYW06IG5ldyBDb25zb2xlUmF3U3RyZWFtKCksXG4gICAgICAgICAgICBjbG9zZU9uRXhpdDogZmFsc2UsXG4gICAgICAgICAgICBsZXZlbDogb3B0aW9ucy5sZXZlbFxuICAgICAgICB9KTtcblxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zZXJpYWxpemVycykge1xuICAgICAgICBzZWxmLmFkZFNlcmlhbGl6ZXJzKG9wdGlvbnMuc2VyaWFsaXplcnMpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zcmMpIHtcbiAgICAgICAgdGhpcy5zcmMgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZpZWxkcy5cbiAgICAvLyBUaGVzZSBhcmUgdGhlIGRlZmF1bHQgZmllbGRzIGZvciBsb2cgcmVjb3JkcyAobWludXMgdGhlIGF0dHJpYnV0ZXNcbiAgICAvLyByZW1vdmVkIGluIHRoaXMgY29uc3RydWN0b3IpLiBUbyBhbGxvdyBzdG9yaW5nIHJhdyBsb2cgcmVjb3Jkc1xuICAgIC8vICh1bnJlbmRlcmVkKSwgYHRoaXMuZmllbGRzYCBtdXN0IG5ldmVyIGJlIG11dGF0ZWQuIENyZWF0ZSBhIGNvcHkgZm9yXG4gICAgLy8gYW55IGNoYW5nZXMuXG4gICAgZmllbGRzID0gb2JqQ29weShvcHRpb25zKTtcbiAgICBkZWxldGUgZmllbGRzLnN0cmVhbTtcbiAgICBkZWxldGUgZmllbGRzLmxldmVsO1xuICAgIGRlbGV0ZSBmaWVsZHMuc3RyZWFtcztcbiAgICBkZWxldGUgZmllbGRzLnNlcmlhbGl6ZXJzO1xuICAgIGRlbGV0ZSBmaWVsZHMuc3JjO1xuICAgIGlmICh0aGlzLnNlcmlhbGl6ZXJzKSB7XG4gICAgICAgIHRoaXMuX2FwcGx5U2VyaWFsaXplcnMoZmllbGRzKTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoZmllbGRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHNlbGYuZmllbGRzW2tdID0gZmllbGRzW2tdO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEFkZCBhIHN0cmVhbVxuICpcbiAqIEBwYXJhbSBzdHJlYW0ge09iamVjdH0uIE9iamVjdCB3aXRoIHRoZXNlIGZpZWxkczpcbiAqICAgIC0gYHR5cGVgOiBUaGUgc3RyZWFtIHR5cGUuIFNlZSBSRUFETUUubWQgZm9yIGZ1bGwgZGV0YWlscy5cbiAqICAgICAgT2Z0ZW4gdGhpcyBpcyBpbXBsaWVkIGJ5IHRoZSBvdGhlciBmaWVsZHMuIEV4YW1wbGVzIGFyZVxuICogICAgICAnZmlsZScsICdzdHJlYW0nIGFuZCBcInJhd1wiLlxuICogICAgLSBgcGF0aGAgb3IgYHN0cmVhbWA6IFRoZSBzcGVjaWZ5IHRoZSBmaWxlIHBhdGggb3Igd3JpdGVhYmxlXG4gKiAgICAgIHN0cmVhbSB0byB3aGljaCBsb2cgcmVjb3JkcyBhcmUgd3JpdHRlbi4gRS5nLlxuICogICAgICBgc3RyZWFtOiBwcm9jZXNzLnN0ZG91dGAuXG4gKiAgICAtIGBsZXZlbGA6IE9wdGlvbmFsLiBGYWxscyBiYWNrIHRvIGBkZWZhdWx0TGV2ZWxgLlxuICogICAgLSBgY2xvc2VPbkV4aXRgIChib29sZWFuKTogT3B0aW9uYWwuIERlZmF1bHQgaXMgdHJ1ZSBmb3IgYVxuICogICAgICAnZmlsZScgc3RyZWFtIHdoZW4gYHBhdGhgIGlzIGdpdmVuLCBmYWxzZSBvdGhlcndpc2UuXG4gKiAgICBTZWUgUkVBRE1FLm1kIGZvciBmdWxsIGRldGFpbHMuXG4gKiBAcGFyYW0gZGVmYXVsdExldmVsIHtOdW1iZXJ8U3RyaW5nfSBPcHRpb25hbC4gQSBsZXZlbCB0byB1c2UgaWZcbiAqICAgICAgYHN0cmVhbS5sZXZlbGAgaXMgbm90IHNldC4gSWYgbmVpdGhlciBpcyBnaXZlbiwgdGhpcyBkZWZhdWx0cyB0byBJTkZPLlxuICovXG5Mb2dnZXIucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzLCBkZWZhdWx0TGV2ZWwpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKGRlZmF1bHRMZXZlbCA9PT0gbnVsbCB8fCBkZWZhdWx0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZhdWx0TGV2ZWwgPSBJTkZPO1xuICAgIH1cblxuICAgIHMgPSBvYmpDb3B5KHMpO1xuXG4gICAgLy8gSW1wbGljaXQgJ3R5cGUnIGZyb20gb3RoZXIgYXJncy5cbiAgICBpZiAoIXMudHlwZSAmJiBzLnN0cmVhbSkge1xuICAgICAgICBzLnR5cGUgPSAncmF3JztcbiAgICB9XG4gICAgcy5yYXcgPSAocy50eXBlID09PSAncmF3Jyk7ICAvLyBQRVJGOiBBbGxvdyBmb3IgZmFzdGVyIGNoZWNrIGluIGBfZW1pdGAuXG5cbiAgICBpZiAocy5sZXZlbCkge1xuICAgICAgICBzLmxldmVsID0gcmVzb2x2ZUxldmVsKHMubGV2ZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHMubGV2ZWwgPSByZXNvbHZlTGV2ZWwoZGVmYXVsdExldmVsKTtcbiAgICB9XG4gICAgaWYgKHMubGV2ZWwgPCBzZWxmLl9sZXZlbCkge1xuICAgICAgICBzZWxmLl9sZXZlbCA9IHMubGV2ZWw7XG4gICAgfVxuXG4gICAgc3dpdGNoIChzLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnc3RyZWFtJzpcbiAgICAgICAgICAgIGlmICghcy5jbG9zZU9uRXhpdCkge1xuICAgICAgICAgICAgICAgIHMuY2xvc2VPbkV4aXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyYXcnOlxuICAgICAgICAgICAgaWYgKCFzLmNsb3NlT25FeGl0KSB7XG4gICAgICAgICAgICAgICAgcy5jbG9zZU9uRXhpdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmtub3duIHN0cmVhbSB0eXBlIFwiJyArIHMudHlwZSArICdcIicpO1xuICAgIH1cblxuICAgIHNlbGYuc3RyZWFtcy5wdXNoKHMpO1xuICAgIGRlbGV0ZSBzZWxmLmhhdmVOb25SYXdTdHJlYW1zOyAgLy8gcmVzZXRcbn07XG5cblxuLyoqXG4gKiBBZGQgc2VyaWFsaXplcnNcbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplcnMge09iamVjdH0gT3B0aW9uYWwuIE9iamVjdCBtYXBwaW5nIGxvZyByZWNvcmQgZmllbGQgbmFtZXNcbiAqICAgIHRvIHNlcmlhbGl6aW5nIGZ1bmN0aW9ucy4gU2VlIFJFQURNRS5tZCBmb3IgZGV0YWlscy5cbiAqL1xuTG9nZ2VyLnByb3RvdHlwZS5hZGRTZXJpYWxpemVycyA9IGZ1bmN0aW9uIGFkZFNlcmlhbGl6ZXJzKHNlcmlhbGl6ZXJzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKCFzZWxmLnNlcmlhbGl6ZXJzKSB7XG4gICAgICAgIHNlbGYuc2VyaWFsaXplcnMgPSB7fTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoc2VyaWFsaXplcnMpLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVyID0gc2VyaWFsaXplcnNbZmllbGRdO1xuICAgICAgICBpZiAodHlwZW9mIChzZXJpYWxpemVyKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmb3JtYXQoXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgc2VyaWFsaXplciBmb3IgXCIlc1wiIGZpZWxkOiBtdXN0IGJlIGEgZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgIGZpZWxkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnNlcmlhbGl6ZXJzW2ZpZWxkXSA9IHNlcmlhbGl6ZXI7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBjaGlsZCBsb2dnZXIsIHR5cGljYWxseSB0byBhZGQgYSBmZXcgbG9nIHJlY29yZCBmaWVsZHMuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gcGFzc2luZyBhIGxvZ2dlciB0byBhIHN1Yi1jb21wb25lbnQsIGUuZy4gYVxuICogJ3d1enpsZScgY29tcG9uZW50IG9mIHlvdXIgc2VydmljZTpcbiAqXG4gKiAgICB2YXIgd3V6emxlTG9nID0gbG9nLmNoaWxkKHtjb21wb25lbnQ6ICd3dXp6bGUnfSlcbiAqICAgIHZhciB3dXp6bGUgPSBuZXcgV3V6emxlKHsuLi4sIGxvZzogd3V6emxlTG9nfSlcbiAqXG4gKiBUaGVuIGxvZyByZWNvcmRzIGZyb20gdGhlIHd1enpsZSBjb2RlIHdpbGwgaGF2ZSB0aGUgc2FtZSBzdHJ1Y3R1cmUgYXNcbiAqIHRoZSBhcHAgbG9nLCAqcGx1cyB0aGUgY29tcG9uZW50PSd3dXp6bGUnIGZpZWxkKi5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSBPcHRpb25hbC4gU2V0IG9mIG9wdGlvbnMgdG8gYXBwbHkgdG8gdGhlIGNoaWxkLlxuICogICAgQWxsIG9mIHRoZSBzYW1lIG9wdGlvbnMgZm9yIGEgbmV3IExvZ2dlciBhcHBseSBoZXJlLiBOb3RlczpcbiAqICAgICAgLSBUaGUgcGFyZW50J3Mgc3RyZWFtcyBhcmUgaW5oZXJpdGVkIGFuZCBjYW5ub3QgYmUgcmVtb3ZlZCBpbiB0aGlzXG4gKiAgICAgICAgY2FsbC4gQW55IGdpdmVuIGBzdHJlYW1zYCBhcmUgKmFkZGVkKiB0byB0aGUgc2V0IGluaGVyaXRlZCBmcm9tXG4gKiAgICAgICAgdGhlIHBhcmVudC5cbiAqICAgICAgLSBUaGUgcGFyZW50J3Mgc2VyaWFsaXplcnMgYXJlIGluaGVyaXRlZCwgdGhvdWdoIGNhbiBlZmZlY3RpdmVseSBiZVxuICogICAgICAgIG92ZXJ3cml0dGVuIGJ5IHVzaW5nIGR1cGxpY2F0ZSBrZXlzLlxuICogICAgICAtIENhbiB1c2UgYGxldmVsYCB0byBzZXQgdGhlIGxldmVsIG9mIHRoZSBzdHJlYW1zIGluaGVyaXRlZCBmcm9tXG4gKiAgICAgICAgdGhlIHBhcmVudC4gVGhlIGxldmVsIGZvciB0aGUgcGFyZW50IGlzIE5PVCBhZmZlY3RlZC5cbiAqIEBwYXJhbSBzaW1wbGUge0Jvb2xlYW59IE9wdGlvbmFsLiBTZXQgdG8gdHJ1ZSB0byBhc3NlcnQgdGhhdCBgb3B0aW9uc2BcbiAqICAgIChhKSBvbmx5IGFkZCBmaWVsZHMgKG5vIGNvbmZpZykgYW5kIChiKSBubyBzZXJpYWxpemF0aW9uIGhhbmRsaW5nIGlzXG4gKiAgICByZXF1aXJlZCBmb3IgdGhlbS4gSU9XLCB0aGlzIGlzIGEgZmFzdCBwYXRoIGZvciBmcmVxdWVudCBjaGlsZFxuICogICAgY3JlYXRpb24uIFNlZSAndG9vbHMvdGltZWNoaWxkLmpzJyBmb3IgbnVtYmVycy5cbiAqL1xuTG9nZ2VyLnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzaW1wbGUpIHtcbiAgICByZXR1cm4gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKSh0aGlzLCBvcHRpb25zIHx8IHt9LCBzaW1wbGUpO1xufTtcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBsZXZlbCBvZiBhbGwgc3RyZWFtcyBvbiB0aGlzIGxvZ2dlci5cbiAqXG4gKiBHZXQgVXNhZ2U6XG4gKiAgICAvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGxvZyBsZXZlbCAobG93ZXN0IGxldmVsIG9mIGFsbCBpdHMgc3RyZWFtcykuXG4gKiAgICBsb2cubGV2ZWwoKSAtPiBJTkZPXG4gKlxuICogU2V0IFVzYWdlOlxuICogICAgbG9nLmxldmVsKElORk8pICAgICAgIC8vIHNldCBhbGwgc3RyZWFtcyB0byBsZXZlbCBJTkZPXG4gKiAgICBsb2cubGV2ZWwoJ2luZm8nKSAgICAgLy8gY2FuIHVzZSAnaW5mbycgZXQgYWwgYWxpYXNlc1xuICovXG5Mb2dnZXIucHJvdG90eXBlLmxldmVsID0gZnVuY3Rpb24gbGV2ZWwodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGV2ZWw7XG4gICAgfVxuICAgIHZhciBuZXdMZXZlbCA9IHJlc29sdmVMZXZlbCh2YWx1ZSk7XG4gICAgdmFyIGxlbiA9IHRoaXMuc3RyZWFtcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLnN0cmVhbXNbaV0ubGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG4gICAgdGhpcy5fbGV2ZWwgPSBuZXdMZXZlbDtcbn07XG5cblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBsZXZlbCBvZiBhIHBhcnRpY3VsYXIgc3RyZWFtIG9uIHRoaXMgbG9nZ2VyLlxuICpcbiAqIEdldCBVc2FnZTpcbiAqICAgIC8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGxldmVscyBvZiBlYWNoIHN0cmVhbS5cbiAqICAgIGxvZy5sZXZlbHMoKSAtPiBbVFJBQ0UsIElORk9dXG4gKlxuICogICAgLy8gUmV0dXJucyBhIGxldmVsIG9mIHRoZSBpZGVudGlmaWVkIHN0cmVhbS5cbiAqICAgIGxvZy5sZXZlbHMoMCkgLT4gVFJBQ0UgICAgICAvLyBsZXZlbCBvZiBzdHJlYW0gYXQgaW5kZXggMFxuICogICAgbG9nLmxldmVscygnZm9vJykgICAgICAgICAgIC8vIGxldmVsIG9mIHN0cmVhbSB3aXRoIG5hbWUgJ2ZvbydcbiAqXG4gKiBTZXQgVXNhZ2U6XG4gKiAgICBsb2cubGV2ZWxzKDAsIElORk8pICAgICAgICAgLy8gc2V0IGxldmVsIG9mIHN0cmVhbSAwIHRvIElORk9cbiAqICAgIGxvZy5sZXZlbHMoMCwgJ2luZm8nKSAgICAgICAvLyBjYW4gdXNlICdpbmZvJyBldCBhbCBhbGlhc2VzXG4gKiAgICBsb2cubGV2ZWxzKCdmb28nLCBXQVJOKSAgICAgLy8gc2V0IHN0cmVhbSBuYW1lZCAnZm9vJyB0byBXQVJOXG4gKlxuICogU3RyZWFtIG5hbWVzOiBXaGVuIHN0cmVhbXMgYXJlIGRlZmluZWQsIHRoZXkgY2FuIG9wdGlvbmFsbHkgYmUgZ2l2ZW5cbiAqIGEgbmFtZS4gRm9yIGV4YW1wbGUsXG4gKiAgICAgICBsb2cgPSBuZXcgTG9nZ2VyKHtcbiAqICAgICAgICAgc3RyZWFtczogW1xuICogICAgICAgICAgIHtcbiAqICAgICAgICAgICAgIG5hbWU6ICdmb28nLFxuICogICAgICAgICAgICAgcGF0aDogJy92YXIvbG9nL215LXNlcnZpY2UvZm9vLmxvZydcbiAqICAgICAgICAgICAgIGxldmVsOiAndHJhY2UnXG4gKiAgICAgICAgICAgfSxcbiAqICAgICAgICAgLi4uXG4gKlxuICogQHBhcmFtIG5hbWUge1N0cmluZ3xOdW1iZXJ9IFRoZSBzdHJlYW0gaW5kZXggb3IgbmFtZS5cbiAqIEBwYXJhbSB2YWx1ZSB7TnVtYmVyfFN0cmluZ30gVGhlIGxldmVsIHZhbHVlIChJTkZPKSBvciBhbGlhcyAoJ2luZm8nKS5cbiAqICAgIElmIG5vdCBnaXZlbiwgdGhpcyBpcyBhICdnZXQnIG9wZXJhdGlvbi5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBubyBzdHJlYW0gd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAqL1xuTG9nZ2VyLnByb3RvdHlwZS5sZXZlbHMgPSBmdW5jdGlvbiBsZXZlbHMobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbXMubWFwKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcy5sZXZlbDtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgc3RyZWFtO1xuICAgIGlmICh0eXBlb2YgKG5hbWUpID09PSAnbnVtYmVyJykge1xuICAgICAgICBzdHJlYW0gPSB0aGlzLnN0cmVhbXNbbmFtZV07XG4gICAgICAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0cmVhbSBpbmRleDogJyArIG5hbWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuc3RyZWFtcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5zdHJlYW1zW2ldO1xuICAgICAgICAgICAgaWYgKHMubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbSA9IHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ25vIHN0cmVhbSB3aXRoIG5hbWUgXCIlc1wiJywgbmFtZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0ubGV2ZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5ld0xldmVsID0gcmVzb2x2ZUxldmVsKHZhbHVlKTtcbiAgICAgICAgc3RyZWFtLmxldmVsID0gbmV3TGV2ZWw7XG4gICAgICAgIGlmIChuZXdMZXZlbCA8IHRoaXMuX2xldmVsKSB7XG4gICAgICAgICAgICB0aGlzLl9sZXZlbCA9IG5ld0xldmVsO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4vKipcbiAqIEFwcGx5IHJlZ2lzdGVyZWQgc2VyaWFsaXplcnMgdG8gdGhlIGFwcHJvcHJpYXRlIGtleXMgaW4gdGhlIGdpdmVuIGZpZWxkcy5cbiAqXG4gKiBQcmUtY29uZGl0aW9uOiBUaGlzIGlzIG9ubHkgY2FsbGVkIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBzZXJpYWxpemVyLlxuICpcbiAqIEBwYXJhbSBmaWVsZHMgKE9iamVjdCkgVGhlIGxvZyByZWNvcmQgZmllbGRzLlxuICogQHBhcmFtIGV4Y2x1ZGVGaWVsZHMgKE9iamVjdCkgT3B0aW9uYWwgbWFwcGluZyBvZiBrZXlzIHRvIGB0cnVlYCBmb3JcbiAqICAgIGtleXMgdG8gTk9UIGFwcGx5IGEgc2VyaWFsaXplci5cbiAqL1xuTG9nZ2VyLnByb3RvdHlwZS5fYXBwbHlTZXJpYWxpemVycyA9IGZ1bmN0aW9uIChmaWVsZHMsIGV4Y2x1ZGVGaWVsZHMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBDaGVjayBlYWNoIHNlcmlhbGl6ZXIgYWdhaW5zdCB0aGVzZSAocHJlc3VtaW5nIG51bWJlciBvZiBzZXJpYWxpemVyc1xuICAgIC8vIGlzIHR5cGljYWxseSBsZXNzIHRoYW4gbnVtYmVyIG9mIGZpZWxkcykuXG4gICAgT2JqZWN0LmtleXModGhpcy5zZXJpYWxpemVycykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAoZmllbGRzW25hbWVdID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIChleGNsdWRlRmllbGRzICYmIGV4Y2x1ZGVGaWVsZHNbbmFtZV0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpZWxkc1tuYW1lXSA9IHNlbGYuc2VyaWFsaXplcnNbbmFtZV0oZmllbGRzW25hbWVdKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfd2Fybihmb3JtYXQoJ2J1bnlhbjogRVJST1I6IEV4Y2VwdGlvbiB0aHJvd24gZnJvbSB0aGUgXCIlc1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAnQnVueWFuIHNlcmlhbGl6ZXIuIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi4gVGhpcyBpcyBhIGJ1ZycgK1xuICAgICAgICAgICAgICAgICAgICAnaW4gdGhhdCBzZXJpYWxpemVyIGZ1bmN0aW9uLlxcbiVzJyxcbiAgICAgICAgICAgICAgICBuYW1lLCBlcnIuc3RhY2sgfHwgZXJyKSk7XG4gICAgICAgICAgICBmaWVsZHNbbmFtZV0gPSBmb3JtYXQoJyhFcnJvciBpbiBCdW55YW4gbG9nIFwiJXNcIiBzZXJpYWxpemVyIGJyb2tlIGZpZWxkLiBTZWUgc3RkZXJyIGZvciBkZXRhaWxzLiknLCBuYW1lKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIEVtaXQgYSBsb2cgcmVjb3JkLlxuICpcbiAqIEBwYXJhbSByZWMge2xvZyByZWNvcmR9XG4gKiBAcGFyYW0gbm9lbWl0IHtCb29sZWFufSBPcHRpb25hbC4gU2V0IHRvIHRydWUgdG8gc2tpcCBlbWlzc2lvblxuICogICAgICBhbmQganVzdCByZXR1cm4gdGhlIEpTT04gc3RyaW5nLlxuICovXG5Mb2dnZXIucHJvdG90eXBlLl9lbWl0ID0gZnVuY3Rpb24gKHJlYywgbm9lbWl0KSB7XG4gICAgdmFyIGk7XG5cbiAgICAvLyBMYXppbHkgZGV0ZXJtaW5lIGlmIHRoaXMgTG9nZ2VyIGhhcyBub24tJ3Jhdycgc3RyZWFtcy4gSWYgdGhlcmUgYXJlXG4gICAgLy8gYW55LCB0aGVuIHdlIG5lZWQgdG8gc3RyaW5naWZ5IHRoZSBsb2cgcmVjb3JkLlxuICAgIGlmICh0aGlzLmhhdmVOb25SYXdTdHJlYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5oYXZlTm9uUmF3U3RyZWFtcyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zdHJlYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RyZWFtc1tpXS5yYXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhdmVOb25SYXdTdHJlYW1zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0cmluZ2lmeSB0aGUgb2JqZWN0LiBBdHRlbXB0IHRvIHdhcm4vcmVjb3ZlciBvbiBlcnJvci5cbiAgICB2YXIgc3RyO1xuICAgIGlmIChub2VtaXQgfHwgdGhpcy5oYXZlTm9uUmF3U3RyZWFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RyID0gSlNPTi5zdHJpbmdpZnkocmVjLCBzYWZlQ3ljbGVzKCkpICsgJ1xcbic7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHZhciBkZWR1cEtleSA9IGUuc3RhY2suc3BsaXQoL1xcbi9nLCAyKS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIF93YXJuKCdidW55YW46IEVSUk9SOiBFeGNlcHRpb24gaW4gJyArXG4gICAgICAgICAgICAgICAgICAgICdgSlNPTi5zdHJpbmdpZnkocmVjKWAuIFlvdSBjYW4gaW5zdGFsbCB0aGUgJyArXG4gICAgICAgICAgICAgICAgICAgICdcInNhZmUtanNvbi1zdHJpbmdpZnlcIiBtb2R1bGUgdG8gaGF2ZSBCdW55YW4gZmFsbGJhY2sgJyArXG4gICAgICAgICAgICAgICAgICAgICd0byBzYWZlciBzdHJpbmdpZmljYXRpb24uIFJlY29yZDpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgX2luZGVudChmb3JtYXQoJyVzXFxuJXMnLCByZWMsIGUuc3RhY2spKSxcbiAgICAgICAgICAgICAgICBkZWR1cEtleSk7XG4gICAgICAgICAgICBzdHIgPSBmb3JtYXQoJyhFeGNlcHRpb24gaW4gSlNPTi5zdHJpbmdpZnkocmVjKTogJWouIFNlZSBzdGRlcnIgZm9yIGRldGFpbHMuKVxcbicsIGUubWVzc2FnZSk7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2VtaXQpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cblxuICAgIHZhciBsZXZlbCA9IHJlYy5sZXZlbDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zdHJlYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5zdHJlYW1zW2ldO1xuICAgICAgICBpZiAocy5sZXZlbCA8PSBsZXZlbCkge1xuICAgICAgICAgICAgcy5zdHJlYW0ud3JpdGUocy5yYXcgPyByZWMgOiBzdHIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbn07XG5cblxuLyoqXG4gKiBCdWlsZCBhIGxvZyBlbWl0dGVyIGZ1bmN0aW9uIGZvciBsZXZlbCBtaW5MZXZlbC4gSS5lLiB0aGlzIGlzIHRoZVxuICogY3JlYXRvciBvZiBgbG9nLmluZm9gLCBgbG9nLmVycm9yYCwgZXRjLlxuICovXG5mdW5jdGlvbiBta0xvZ0VtaXR0ZXIobWluTGV2ZWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9nID0gdGhpcztcblxuICAgICAgICBmdW5jdGlvbiBta1JlY29yZChhcmdzKSB7XG4gICAgICAgICAgICB2YXIgZXhjbHVkZUZpZWxkcztcbiAgICAgICAgICAgIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBgbG9nLjxsZXZlbD4oZXJyLCAuLi4pYFxuICAgICAgICAgICAgICAgIGZpZWxkcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoaXMgTG9nZ2VyJ3MgZXJyIHNlcmlhbGl6ZXIsIGlmIGRlZmluZWQuXG4gICAgICAgICAgICAgICAgICAgIGVycjogKGxvZy5zZXJpYWxpemVycyAmJiBsb2cuc2VyaWFsaXplcnMuZXJyID8gbG9nLnNlcmlhbGl6ZXJzLmVycihhcmdzWzBdKSA6IExvZ2dlci5zdGRTZXJpYWxpemVycy5lcnIoYXJnc1swXSkpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBleGNsdWRlRmllbGRzID0ge2VycjogdHJ1ZX07XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZ0FyZ3MgPSBbZmllbGRzLmVyci5tZXNzYWdlXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtc2dBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKGFyZ3NbMF0pICE9PSAnb2JqZWN0JyAmJiBhcmdzWzBdICE9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgICAgICAgICAgIC8vIGBsb2cuPGxldmVsPihtc2csIC4uLilgXG4gICAgICAgICAgICAgICAgZmllbGRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBtc2dBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG4gICAgICAgICAgICB9IGVsc2UgeyAgLy8gYGxvZy48bGV2ZWw+KGZpZWxkcywgbXNnLCAuLi4pYFxuICAgICAgICAgICAgICAgIGZpZWxkcyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgbXNnQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCdWlsZCB1cCB0aGUgcmVjb3JkIG9iamVjdC5cbiAgICAgICAgICAgIHZhciByZWMgPSBvYmpDb3B5KGxvZy5maWVsZHMpO1xuICAgICAgICAgICAgcmVjLmxldmVsID0gbWluTGV2ZWw7XG4gICAgICAgICAgICB2YXIgcmVjRmllbGRzID0gKGZpZWxkcyA/IG9iakNvcHkoZmllbGRzKSA6IG51bGwpO1xuICAgICAgICAgICAgaWYgKHJlY0ZpZWxkcykge1xuICAgICAgICAgICAgICAgIGlmIChsb2cuc2VyaWFsaXplcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLl9hcHBseVNlcmlhbGl6ZXJzKHJlY0ZpZWxkcywgZXhjbHVkZUZpZWxkcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlY0ZpZWxkcykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgICAgICByZWNba10gPSByZWNGaWVsZHNba107XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWMubGV2ZWxOYW1lID0gbmFtZUZyb21MZXZlbFttaW5MZXZlbF07XG4gICAgICAgICAgICByZWMubXNnID0gZm9ybWF0LmFwcGx5KGxvZywgbXNnQXJncyk7XG4gICAgICAgICAgICBpZiAoIXJlYy50aW1lKSB7XG4gICAgICAgICAgICAgICAgcmVjLnRpbWUgPSAobmV3IERhdGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgY2FsbCBzb3VyY2UgaW5mb1xuICAgICAgICAgICAgaWYgKGxvZy5zcmMgJiYgIXJlYy5zcmMpIHtcbiAgICAgICAgICAgICAgICByZWMuc3JjID0gZ2V0Q2FsbGVyM0luZm8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYy52ID0gTE9HX1ZFUlNJT047XG5cbiAgICAgICAgICAgIHJldHVybiByZWM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmllbGRzID0gbnVsbDtcbiAgICAgICAgdmFyIG1zZ0FyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHZhciByZWMgPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMuX2VtaXQpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBTaG93IHRoaXMgaW52YWxpZCBCdW55YW4gdXNhZ2Ugd2FybmluZyAqb25jZSouXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogU2VlIDxodHRwczovL2dpdGh1Yi5jb20vdHJlbnRtL25vZGUtYnVueWFuL2lzc3Vlcy8xMDA+IGZvclxuICAgICAgICAgICAgICogYW4gZXhhbXBsZSBvZiBob3cgdGhpcyBjYW4gaGFwcGVuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgZGVkdXBLZXkgPSAndW5ib3VuZCc7XG4gICAgICAgICAgICBpZiAoIV9oYXZlV2FybmVkW2RlZHVwS2V5XSkge1xuICAgICAgICAgICAgICAgIHZhciBjYWxsZXIgPSBnZXRDYWxsZXIzSW5mbygpO1xuICAgICAgICAgICAgICAgIF93YXJuKGZvcm1hdCgnYnVueWFuIHVzYWdlIGVycm9yOiAlczolczogYXR0ZW1wdCB0byBsb2cgd2l0aCBhbiB1bmJvdW5kIGxvZyBtZXRob2Q6IGB0aGlzYCBpczogJXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVyLmZpbGUsIGNhbGxlci5saW5lLCB0aGlzLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgICAgICAgICBkZWR1cEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgeyAgIC8vIGBsb2cuPGxldmVsPigpYFxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9sZXZlbCA8PSBtaW5MZXZlbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbGV2ZWwgPiBtaW5MZXZlbCkge1xuICAgICAgICAgICAgLyogcGFzcyB0aHJvdWdoICovXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWMgPSBta1JlY29yZChtc2dBcmdzKTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQocmVjKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuLyoqXG4gKiBUaGUgZnVuY3Rpb25zIGJlbG93IGxvZyBhIHJlY29yZCBhdCBhIHNwZWNpZmljIGxldmVsLlxuICpcbiAqIFVzYWdlczpcbiAqICAgIGxvZy48bGV2ZWw+KCkgIC0+IGJvb2xlYW4gaXMtdHJhY2UtZW5hYmxlZFxuICogICAgbG9nLjxsZXZlbD4oPEVycm9yPiBlcnIsIFs8c3RyaW5nPiBtc2csIC4uLl0pXG4gKiAgICBsb2cuPGxldmVsPig8c3RyaW5nPiBtc2csIC4uLilcbiAqICAgIGxvZy48bGV2ZWw+KDxvYmplY3Q+IGZpZWxkcywgPHN0cmluZz4gbXNnLCAuLi4pXG4gKlxuICogd2hlcmUgPGxldmVsPiBpcyB0aGUgbG93ZXJjYXNlIHZlcnNpb24gb2YgdGhlIGxvZyBsZXZlbC4gRS5nLjpcbiAqXG4gKiAgICBsb2cuaW5mbygpXG4gKlxuICogQHBhcmFtcyBmaWVsZHMge09iamVjdH0gT3B0aW9uYWwgc2V0IG9mIGFkZGl0aW9uYWwgZmllbGRzIHRvIGxvZy5cbiAqIEBwYXJhbXMgbXNnIHtTdHJpbmd9IExvZyBtZXNzYWdlLiBUaGlzIGNhbiBiZSBmb2xsb3dlZCBieSBhZGRpdGlvbmFsXG4gKiAgICBhcmd1bWVudHMgdGhhdCBhcmUgaGFuZGxlZCBsaWtlXG4gKiAgICBbdXRpbC5mb3JtYXRdKGh0dHA6Ly9ub2RlanMub3JnL2RvY3MvbGF0ZXN0L2FwaS9hbGwuaHRtbCN1dGlsLmZvcm1hdCkuXG4gKi9cbkxvZ2dlci5wcm90b3R5cGUudHJhY2UgPSBta0xvZ0VtaXR0ZXIoVFJBQ0UpO1xuTG9nZ2VyLnByb3RvdHlwZS5kZWJ1ZyA9IG1rTG9nRW1pdHRlcihERUJVRyk7XG5Mb2dnZXIucHJvdG90eXBlLmluZm8gPSBta0xvZ0VtaXR0ZXIoSU5GTyk7XG5Mb2dnZXIucHJvdG90eXBlLndhcm4gPSBta0xvZ0VtaXR0ZXIoV0FSTik7XG5Mb2dnZXIucHJvdG90eXBlLmVycm9yID0gbWtMb2dFbWl0dGVyKEVSUk9SKTtcbkxvZ2dlci5wcm90b3R5cGUuZmF0YWwgPSBta0xvZ0VtaXR0ZXIoRkFUQUwpO1xuXG5cbi8vLS0tLSBTdGFuZGFyZCBzZXJpYWxpemVyc1xuLy8gQSBzZXJpYWxpemVyIGlzIGEgZnVuY3Rpb24gdGhhdCBzZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBvYmplY3QgdG8gYVxuLy8gSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgbG9nZ2luZy4gVGhlcmUgaXMgYSBzdGFuZGFyZCBzZXQgb2YgcHJlc3VtZWRcbi8vIGludGVyZXN0aW5nIG9iamVjdHMgaW4gbm9kZS5qcy1sYW5kLlxuXG5Mb2dnZXIuc3RkU2VyaWFsaXplcnMgPSB7fTtcblxuLypcbiAqIFRoaXMgZnVuY3Rpb24gZHVtcHMgbG9uZyBzdGFjayB0cmFjZXMgZm9yIGV4Y2VwdGlvbnMgaGF2aW5nIGEgY2F1c2UoKVxuICogbWV0aG9kLiBUaGUgZXJyb3IgY2xhc3NlcyBmcm9tXG4gKiBbdmVycm9yXShodHRwczovL2dpdGh1Yi5jb20vZGF2ZXBhY2hlY28vbm9kZS12ZXJyb3IpIGFuZFxuICogW3Jlc3RpZnkgdjIuMF0oaHR0cHM6Ly9naXRodWIuY29tL21jYXZhZ2Uvbm9kZS1yZXN0aWZ5KSBhcmUgZXhhbXBsZXMuXG4gKlxuICogQmFzZWQgb24gYGR1bXBFeGNlcHRpb25gIGluXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGF2ZXBhY2hlY28vbm9kZS1leHRzcHJpbnRmL2Jsb2IvbWFzdGVyL2xpYi9leHRzcHJpbnRmLmpzXG4gKi9cbmZ1bmN0aW9uIGdldEZ1bGxFcnJvclN0YWNrKGV4KSB7XG4gICAgdmFyIHJldCA9IGV4LnN0YWNrIHx8IGV4LnRvU3RyaW5nKCk7XG4gICAgaWYgKGV4LmNhdXNlICYmIHR5cGVvZiAoZXguY2F1c2UpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBjZXggPSBleC5jYXVzZSgpO1xuICAgICAgICBpZiAoY2V4KSB7XG4gICAgICAgICAgICByZXQgKz0gJ1xcbkNhdXNlZCBieTogJyArIGdldEZ1bGxFcnJvclN0YWNrKGNleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChyZXQpO1xufVxuXG4vLyBTZXJpYWxpemUgYW4gRXJyb3Igb2JqZWN0XG4vLyAoQ29yZSBlcnJvciBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhYmxlIGluIG5vZGUgMC40LCBub3QgaW4gMC42KS5cbkxvZ2dlci5zdGRTZXJpYWxpemVycy5lcnIgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBpZiAoIWVyciB8fCAhZXJyLnN0YWNrKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgdmFyIG9iaiA9IHtcbiAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgICAgIG5hbWU6IGVyci5uYW1lLFxuICAgICAgICBzdGFjazogZ2V0RnVsbEVycm9yU3RhY2soZXJyKSxcbiAgICAgICAgY29kZTogZXJyLmNvZGUsXG4gICAgICAgIHNpZ25hbDogZXJyLnNpZ25hbFxuICAgIH07XG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuLy8gQSBKU09OIHN0cmluZ2lmaWVyIHRoYXQgaGFuZGxlcyBjeWNsZXMgc2FmZWx5LlxuLy8gVXNhZ2U6IEpTT04uc3RyaW5naWZ5KG9iaiwgc2FmZUN5Y2xlcygpKVxuZnVuY3Rpb24gc2FmZUN5Y2xlcygpIHtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKCF2YWwgfHwgdHlwZW9mICh2YWwpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKHZhbCkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4ucHVzaCh2YWwpO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH07XG59XG5cbi8vLS0tLSBFeHBvcnRzXG5cbm1vZHVsZS5leHBvcnRzID0gTG9nZ2VyO1xuXG5tb2R1bGUuZXhwb3J0cy5UUkFDRSA9IFRSQUNFO1xubW9kdWxlLmV4cG9ydHMuREVCVUcgPSBERUJVRztcbm1vZHVsZS5leHBvcnRzLklORk8gPSBJTkZPO1xubW9kdWxlLmV4cG9ydHMuV0FSTiA9IFdBUk47XG5tb2R1bGUuZXhwb3J0cy5FUlJPUiA9IEVSUk9SO1xubW9kdWxlLmV4cG9ydHMuRkFUQUwgPSBGQVRBTDtcbm1vZHVsZS5leHBvcnRzLnJlc29sdmVMZXZlbCA9IHJlc29sdmVMZXZlbDtcbm1vZHVsZS5leHBvcnRzLmxldmVsRnJvbU5hbWUgPSBsZXZlbEZyb21OYW1lO1xubW9kdWxlLmV4cG9ydHMubmFtZUZyb21MZXZlbCA9IG5hbWVGcm9tTGV2ZWw7XG5cbm1vZHVsZS5leHBvcnRzLlZFUlNJT04gPSBWRVJTSU9OO1xubW9kdWxlLmV4cG9ydHMuTE9HX1ZFUlNJT04gPSBMT0dfVkVSU0lPTjtcblxubW9kdWxlLmV4cG9ydHMuY3JlYXRlTG9nZ2VyID0gZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IExvZ2dlcihvcHRpb25zKTtcbn07XG5cbi8vIFVzZWZ1bCBmb3IgY3VzdG9tIGB0eXBlID09ICdyYXcnYCBzdHJlYW1zIHRoYXQgbWF5IGRvIEpTT04gc3RyaW5naWZpY2F0aW9uXG4vLyBvZiBsb2cgcmVjb3JkcyB0aGVtc2VsdmVzLiBVc2FnZTpcbi8vICAgIHZhciBzdHIgPSBKU09OLnN0cmluZ2lmeShyZWMsIGJ1bnlhbi5zYWZlQ3ljbGVzKCkpO1xubW9kdWxlLmV4cG9ydHMuc2FmZUN5Y2xlcyA9IHNhZmVDeWNsZXM7XG5cbi8vc3RyZWFtc1xubW9kdWxlLmV4cG9ydHMuQ29uc29sZUZvcm1hdHRlZFN0cmVhbSA9IENvbnNvbGVGb3JtYXR0ZWRTdHJlYW07XG5tb2R1bGUuZXhwb3J0cy5Db25zb2xlUmF3U3RyZWFtID0gQ29uc29sZVJhd1N0cmVhbTsiLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgbmFtZUZyb21MZXZlbCB9IGZyb20gJ2Jyb3dzZXItYnVueWFuJ1xuXG4vKipcbiAqIEN1c3RvbSBsb2dnZXIgZm9yIGJ1bnlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgUmF3U3RyZWFtIHtcbiAgd3JpdGUgKHJlYykge1xuICAgIGNvbnNvbGUubG9nKCclcyAtIFslc10gJXM6ICVzJywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICByZWMudGltZS50b0lTT1N0cmluZygpLFxuICAgICAgcmVjLm5hbWUsXG4gICAgICBuYW1lRnJvbUxldmVsW3JlYy5sZXZlbF0sXG4gICAgICByZWMubXNnXG4gICAgKVxuICB9XG59XG5cbiIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBjcmVhdGVMb2dnZXIsIG5hbWVGcm9tTGV2ZWwgfSBmcm9tICdicm93c2VyLWJ1bnlhbidcbmltcG9ydCB7IFJhd1N0cmVhbSB9IGZyb20gJy4vYnVueWFuLXdyaXRlcidcblxubGV0IGxvZ2dlclxubGV0IHN0b3JlXG5cbmNvbnN0IGZvcm1hdE1lc3NhZ2UgPSAoZGlzcGF0Y2hlcikgPT4ge1xuICByZXR1cm4gbWVzc2FnZSA9PiB7XG4gICAgcmV0dXJuIGAoJHtkaXNwYXRjaGVyfSkgJHttZXNzYWdlfWBcbiAgfVxufVxuXG5jb25zdCBkZWNvcmF0ZSA9IChsZXZlbCkgPT4ge1xuICByZXR1cm4gKHNvdXJjZSwgbWVzc2FnZSkgPT4ge1xuICAgIGxvZ2dlcltsZXZlbF0oZm9ybWF0TWVzc2FnZShzb3VyY2UpKG1lc3NhZ2UpKVxuICB9XG59XG5cbi8qXG4gKiBUaGUgbG9nIGxldmVscyBzdXBwb3J0ZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBMRVZFTFMgPSB7XG4gIFRSQUNFOiAndHJhY2UnLFxuICBJTkZPOiAnaW5mbycsXG4gIERFQlVHOiAnZGVidWcnLFxuICBXQVJOOiAnd2FybicsXG4gIEVSUk9SOiAnZXJyb3InLFxuICBGQVRBTDogJ2ZhdGFsJ1xufVxuXG4vKipcbiAqIEVzdGFibGlzaCBsb2dnZXIgdG8gdXNlIGF0IGxldmVsLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBsZXZlbFxuICogICAgICAgIFRoZSBsZXZlbCB0eXBlIGZyb20gYExFVkVMU2AuXG4gKiBAcGFyYW0ge0FycmF5fSBzdHJlYW1MaXN0XG4gKiAgICAgICAgVGhlIHN0cmVhbUxpc3QgdG8gdXNlIGluIGNyZWF0aW5nIGJ1bnlvbi1iYXNlZCBsb2dnZXIuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGVzdGFibGlzaExvZ2dlciA9IChsZXZlbCwgcmVjb3JkID0gZmFsc2UsIHN0cmVhbUxpc3QgPSB1bmRlZmluZWQpID0+IHtcbiAgbGV0IHN0cmVhbXMgPSBbXVxuICBzdHJlYW1zLnB1c2goe1xuICAgIGxldmVsOiBsZXZlbCxcbiAgICBzdHJlYW06IG5ldyBSYXdTdHJlYW0oKSxcbiAgICB0eXBlOiAncmF3J1xuICB9KVxuICBpZiAoc3RyZWFtTGlzdCkge1xuICAgIGNvbnN0IGxpc3QgPSBzdHJlYW1MaXN0Lm1hcChpdGVtID0+IHtcbiAgICAgIGl0ZW0ubGV2ZWwgPSBsZXZlbFxuICAgIH0pXG4gICAgc3RyZWFtcyA9IHN0cmVhbXMuY29uY2F0KGxpc3QpXG4gIH1cbiAgaWYgKHJlY29yZCkge1xuICAgIHN0b3JlID0gW11cbiAgICBzdHJlYW1zLnB1c2goe1xuICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgc3RyZWFtOiB7XG4gICAgICAgIHdyaXRlOiByZWMgPT4ge1xuICAgICAgICAgIGNvbnN0IGxvZyA9IGBbJHtyZWMudGltZS50b0lTT1N0cmluZygpfV0gJHtuYW1lRnJvbUxldmVsW3JlYy5sZXZlbF19OiAke3JlYy5tc2d9YFxuICAgICAgICAgIHN0b3JlLnB1c2gobG9nKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuICBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoe1xuICAgIGxldmVsOiBsZXZlbCxcbiAgICBuYW1lOiAncmVkNXByby1zZGsnLFxuICAgIHN0cmVhbXM6IHN0cmVhbXNcbiAgfSlcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGRldGVybWluZWQgbG9nZ2VyIGluc3RhbmNlLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgZ2V0TG9nZ2VyID0gKCkgPT4ge1xuICByZXR1cm4gbG9nZ2VyXG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3RvcmVkIGxvZ3MgaWYgcmVxdWVzdGVkIHRvIGByZWNvcmRgIG9uIGVzdGFibGlzaG1lbnQgb2YgbG9nZ2VyLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5leHBvcnQgY29uc3QgZ2V0UmVjb3JkZWRMb2dzID0gKCkgPT4ge1xuICByZXR1cm4gc3RvcmVcbn1cblxuLyogUXVpY2sgYWNjZXNzIHRvIGxvZ2dlciBsZXZlbCB0eXBlcy4gKi9cbmV4cG9ydCBjb25zdCB0cmFjZSA9IGRlY29yYXRlKExFVkVMUy5UUkFDRSlcbmV4cG9ydCBjb25zdCBpbmZvID0gZGVjb3JhdGUoTEVWRUxTLklORk8pXG5leHBvcnQgY29uc3QgZGVidWcgPSBkZWNvcmF0ZShMRVZFTFMuREVCVUcpXG5leHBvcnQgY29uc3Qgd2FybiA9IGRlY29yYXRlKExFVkVMUy5XQVJOKVxuZXhwb3J0IGNvbnN0IGVycm9yID0gZGVjb3JhdGUoTEVWRUxTLkVSUk9SKVxuZXhwb3J0IGNvbnN0IGZhdGFsID0gZGVjb3JhdGUoTEVWRUxTLkZBVEFMKVxuXG4iLCIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBBIERlZmVycmVkUHJvbWlzZSBhbGxvd3MgZm9yIGNvbnN0cnVjdGlvbiBhbmQgYXNzaWdubWVudCBvZiBhIGZ1dHVyZSBmdWxsZmlsbWVudCBvZiBhIGBQcm9taXNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBfRGVmZXJyZWRQcm9taXNlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMucmVzb2x2ZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMucmVqZWN0ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZVxuICAgICAgdGhpcy5yZWplY3QgPSByZWplY3RcbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogQSBGdXR1cmUgZGV0ZXJtaW5lcyBpZiBleGlzdGFudCBEZWZlcnJlZFByb21pc2UgaXMgYXZhaWxhYmxlIG9yIGNyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgb25lLlxuICpcbiAqIEBwYXJhbSB7RGVmZXJyZWRQcm9taXNlfSBkZWZlcnJlZElmRXhpc3RcbiAqICAgICAgICBBbiBvYmplY3QgdGVzdGVkIGZvciB0cnV0aHktbmVzcy5cbiAqIEByZXR1cm4ge0RlZmVycmVkUHJvbWlzZX1cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBfRnV0dXJlID0ge1xuICBjcmVhdGVJZk5vdEV4aXN0OiAoZGVmZXJyZWRJZkV4aXN0KSA9PiB7XG4gICAgbGV0IGYgPSBkZWZlcnJlZElmRXhpc3RcbiAgICBpZiAoIWYpIHtcbiAgICAgIGYgPSBuZXcgX0RlZmVycmVkUHJvbWlzZSgpXG4gICAgfVxuICAgIHJldHVybiBmXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IERlZmVycmVkUHJvbWlzZSA9IF9EZWZlcnJlZFByb21pc2VcbmV4cG9ydCBjb25zdCBGdXR1cmUgPSBfRnV0dXJlXG5cbiIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuL3Byb21pc2UnXG5cbmNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwKClcblxuY29uc3QgcHZ0ID0gKGN0eCkgPT4ge1xuICBpZiAoIW1hcC5oYXMoY3R4KSkge1xuICAgIG1hcC5zZXQoY3R4LCB7fSlcbiAgfVxuXG4gIHJldHVybiBtYXAuZ2V0KGN0eClcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBGYWN0b3J5LlxuICpcbiAqIFRoaXMgaXMgdXNlZCBieSB0aGUgZmFpbC1vdmVyIGZvciBQdWJsaXNoZXIgYW5kIFN1YnNjcmliZXIgdG8gZGV0ZXJtaW5lIGJyb3dzZXIgc3VwcG9ydCBvZiBvcmRlciBsaXN0IG9mIGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW1wbEZhY3RvcnlPcmRlciB7XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMubGlzdG9yZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAqIGxpc3RvcmRlciAobGlzdCkge1xuICAgICAgICB3aGlsZSAobGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgeWllbGQgbGlzdC5zaGlmdCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KCkpXG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IHRvIGNoZWNrIHN1cHBvcnQgYW5kIGluaXRpYWxpemUgQ2xhc3MgaW5zdGFuY2Ugd2l0aGluIHRoZSBvcmRlci4gT3B0aW9uYWxseSwgY2FuIGludm9rZSBhbiBpbml0aWFsaXphdGlvbiB3aXRoIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZXJhdG9yXG4gICAgICogICAgICAgIEl0ZXJhdG9yIHVzZWQgaW4gYWNjZXNzaW5nIHBvc3NpYmxlIENsYXNzIGluc3RhbmNlIG5leHQgaW4gbGlua2VkIGxpc3Qgb2Ygb3JkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcFxuICAgICAqICAgICAgICBNYXAgb2Ygb3JkZXIgdHlwZSB0byBDbGFzcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqICAgICAgICBNYXAgb2YgaW5pdGlhbGl6YXRpb24gY29uZmlndXJhdGlvbnMgdG8gdHlwZXMuXG4gICAgICogQHBhcmFtIHtQcm9taXNlfSBwcm9taXNlXG4gICAgICogICAgICAgIFRoZSBgUHJvbWlzZWAgaW5zdGFuY2UgdG8gdXNlIGluIHJlc29sdmUgb3IgcmVqZWN0IG9uY2UgZWl0aGVyIGEgdmFsaWQgaW5zdGFuY2UgaXMgY3JlYXRlZCBvciBvcmRlciBoYXMgYmVlbiBleGhhdXN0ZWQsIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbml0Rm5cbiAgICAgKiAgICAgICAgT3B0aW9uYWwgZnVuY3Rpb24gdG8gaW52b2tlIHVwb24gaW5zdGFudGlhdGlvbiBhdHRlbXB0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsYXN0RXJyb3JcbiAgICAgKiAgICAgICAgT3B0aW9uYWwgLSBhbmQgY29tcG91bmRlZCAtIGxhc3Qgc3RyaW5nIGVycm9yIHRoYXQgY2F1c2VkIGEgZmFpbHVyZSBpbiBlc3RhYmxpc2hpbmcgYSBzdXBwb3J0ZWQgaW5zdGFuY2UuIFRoaXMgZXJyb3IgaXMgZGVsaXZlcmVkIG9uIHRoZSByZWplY3Rpb24gb2YgdGhlIGBQcm9taXNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHZ0KHRoaXMpLmZpbmQgPSAoaXRlcmF0b3IsIG1hcCwgb3B0aW9ucywgcHJvbWlzZSwgaW5pdEZuID0gbnVsbCwgbGFzdEVycm9yID0gbnVsbCkgPT4ge1xuICAgICAgY29uc3QgW3R5cGUsIEltcGxdID0gcHZ0KHRoaXMpLm5leHQoaXRlcmF0b3IsIG1hcClcbiAgICAgIGlmICghSW1wbCkge1xuICAgICAgICBwcm9taXNlLnJlamVjdChsYXN0RXJyb3IpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcFxuICAgICAgICBsZXQgc3JjID0gb3B0aW9uc1t0eXBlXVxuICAgICAgICBzcmMgPSBzcmMgfHwgb3B0aW9uc1xuICAgICAgICBpZiAoaW5pdEZuKSB7XG4gICAgICAgICAgcCA9IG5ldyBJbXBsKClbaW5pdEZuXShzcmMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcCA9IG5ldyBJbXBsKHNyYylcbiAgICAgICAgfVxuICAgICAgICBwLnRoZW4oKGNvbmNyZXRlKSA9PiB7XG4gICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKGNvbmNyZXRlKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgbGFzdEVycm9yID0gZXJyb3JcbiAgICAgICAgICBwdnQodGhpcykuZmluZChpdGVyYXRvciwgbWFwLCBvcHRpb25zLCBwcm9taXNlLCBpbml0Rm4sIGxhc3RFcnJvcilcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlIG5leHQgaW4gb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB2dCh0aGlzKS5uZXh0ID0gKG9yZGVyLCBtYXApID0+IHtcbiAgICAgIGxldCBJbXBsXG4gICAgICBsZXQga2V5XG4gICAgICBjb25zdCBuZXh0ID0gb3JkZXIubmV4dCgpXG4gICAgICBpZiAoIW5leHQuZG9uZSkge1xuICAgICAgICBrZXkgPSBuZXh0LnZhbHVlXG4gICAgICAgIEltcGwgPSBtYXAuZ2V0KGtleSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBba2V5LCBJbXBsXVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGxvY2F0ZSBzdXBwb3J0ZWQgaW1wbGVtZW50YXRpb24gYW5kIGluaXRpYWxpemUgaXQsIHJlc29sdmluZyB0aGUgYFByb21pc2VgIHdpdGggdGhlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBvcmRlclxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwXG4gICAqICAgICAgICBNYXAgb2YgQ2xhc3MgdG8gb3JkZXIgdHlwZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIEluaXRpYWxpemF0aW9uIG9iamVjdCB0byBwYXNzIHRvIGNvbnN0cnVjdG9yIG9mIENsYXNzIGluIGJyb3dzZXIgdGVzdCBvZiBzdXBwb3J0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbml0Rm5cbiAgICogICAgICAgIE9wdGlvbmFsIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uIHRvIGludm9rZSB3aXRoIHRoZSBgb3B0aW9uc2AgY29uZmlnLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlIChvcmRlciwgbWFwLCBvcHRpb25zLCBpbml0Rm4gPSBudWxsKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHB2dCh0aGlzKS5maW5kKHRoaXMubGlzdG9yZGVyKG9yZGVyLnNsaWNlKCkpLCBtYXAsIG9wdGlvbnMsIHByb21pc2UsIGluaXRGbilcbiAgICByZXR1cm4gcHJvbWlzZS5wcm9taXNlXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBJbXBsRmFjdG9yeU9yZGVyXG5cbiIsImNvbnN0IFdJTERDQVJEID0gJyonXG5jb25zdCBXSUxEQ0FSRF9LRVkgPSAnUkVENVBSTydcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbiBFdmVudCBFbWl0dGVyLlxuICovXG5jbGFzcyBFdmVudEVtaXR0ZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fVxuICAgIHRoaXMuX2NhbGxiYWNrc1tXSUxEQ0FSRF9LRVldID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGV2ZW50IGhhbmRsZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjYWxsYmFja3NcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9ub3RpZnkgKGNhbGxiYWNrcywgZXZlbnQpIHtcbiAgICAgIGxldCBpLCBsZW5ndGggPSBjYWxsYmFja3MubGVuZ3RoXG4gICAgICBmb3IoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsYmFja3NbaV0oZXZlbnQpXG4gICAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXNzaWduIGEgY2FsbGJhY2sgaGFuZGxlciB0byBhbiBldmVudCB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKi9cbiAgb24gKHR5cGUsIGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IFdJTERDQVJEKSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3NbV0lMRENBUkRfS0VZXS5wdXNoKGZuKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NhbGxiYWNrc1t0eXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3NbdHlwZV0gPSBbXVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9jYWxsYmFja3NbdHlwZV0uaW5kZXhPZihmbikgPT09IC0xKSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3NbdHlwZV0ucHVzaChmbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgY2FsbGJhY2sgaGFuZGxlciBmb3IgYW4gZXZlbnQgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICovXG4gIG9mZiAodHlwZSwgZm4pIHtcbiAgICBsZXQgbWFwID0gdGhpcy5fY2FsbGJhY2tzW3R5cGVdXG4gICAgaWYgKHR5cGUgPT09IFdJTERDQVJEKSB7XG4gICAgICBtYXAgPSB0aGlzLl9jYWxsYmFja3NbV0lMRENBUkRfS0VZXVxuICAgIH1cbiAgICBpZiAobWFwKSB7XG4gICAgICBjb25zdCBpbmRleCA9IG1hcC5pbmRleE9mKGZuKVxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBtYXAuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBhbiBldmVudCB0byBiZSBoYW5kbGVkIGJ5IGFueSBhc3NpZ25lZCBjYWxsYmFja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqL1xuICB0cmlnZ2VyIChldmVudCkge1xuICAgIGNvbnN0IHR5cGUgPSBldmVudC50eXBlXG4gICAgaWYgKHRoaXMuX2NhbGxiYWNrc1t0eXBlXSkge1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2NhbGxiYWNrc1t0eXBlXSwgZXZlbnQpXG4gICAgfVxuICAgIHRoaXMuX25vdGlmeSh0aGlzLl9jYWxsYmFja3NbV0lMRENBUkRfS0VZXSwgZXZlbnQpXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBFdmVudEVtaXR0ZXJcblxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogRXhjZXB0aW9uIGZvciBtaXNzaW5nIGVsZW1lbnQgd2hlbiBhc3NpZ25pbmcgUHJlc2VudGF0aW9uIENvbnRyb2xsZXJzIGZvciBQdWJsaXNoZXJzIGFuZCBTdWJzY3JpYmVycy5cbiAqL1xuZXhwb3J0IGNsYXNzIE5vRWxlbWVudEZvdW5kRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHRoaXMubmFtZSA9ICdOb0VsZW1lbnRGb3VuZCdcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlXG4gIH1cbn1cblxuLyoqXG4gKiBFeGNlcHRpb24gd2hlbiByZXF1ZXN0aW5nIG1lZGlhIHdpdGggYSBgTWVkaWFDb25zdHJhaW50YCB0aGF0IHRoZSBicm93c2VyIGNhbm5vdCBzdXBwb3J0LlxuICogV2ViUlRDIE9ubHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBOb1N1cHBvcnRlZENhbWVyYVJlc29sdXRpb25zRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHRoaXMubmFtZSA9ICdOb1N1cHBvcnRlZENhbWVyYVJlc29sdXRpb25zRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QganNvbkF0dHIgPSAvWydcIl0oLio/KVsnXCJdOi9naVxuY29uc3QganNvblZhbCA9IC86WydcIl0oLio/KVsnXCJdL2dpXG5cbmNvbnN0IG1ldGFkYXRhTWFwID0gbmV3IFdlYWtNYXAoKSAvLyB7PHBsYXllcj46IHs8cHJvcGVydHk+OiBmbltdfSB9XG5cbi8qKlxuICogUmVhZHMgdGhlIFVURiBzdHJpbmcgb2YgdGhlIGRhdGEgcGFzc2VkIGluLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiAgICAgICAgIFRoZSBQYXJzZWQgaW5mb3JtYXRpb24uXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVhZFVURiAoZGF0YSxzdGFydCxsZW4pIHtcbiAgbGV0IHJlc3VsdCA9ICcnLCBvZmZzZXQgPSBzdGFydCwgZW5kID0gc3RhcnQgKyBsZW5cbiAgZG8ge1xuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbb2Zmc2V0KytdKVxuICB9XG4gIHdoaWxlKG9mZnNldCA8IGVuZClcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIFBhcnNlcyBpbmNvbWluZyBtZXRhZGF0YSBKU09OIGRhdGEgYW5kIHJldHVybnMgcHJvcGVydHkgaWYgYXZhaWxhYmxlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXN0XG4gKiAgICAgICAgVGhlIEpTT04gc3RyaW5nIHRvIHBhcnNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICogICAgICAgIFRoZSBwcm9wZXJ0eSBuYW1lIHRvIGFjY2VzcyBmcm9tIHRoZSBwYXJzZWQgSlNPTi5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZUpTT05Gb3JQcm9wZXJ0eSAodGV4dCwgcHJvcGVydHkpIHtcbiAgdHJ5IHtcbiAgICBsZXQgdmFsdWUgPSBKU09OLnBhcnNlKHRleHQpXG4gICAgcmV0dXJuIHZhbHVlW3Byb3BlcnR5XVxuICB9XG4gIGNhdGNoIChlKSB7XG4gICAgbGV0IG1hdGNoID0ganNvbkF0dHIuZXhlYyh0ZXh0KVxuICAgIGxldCBtYXRjaDJcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgbWF0Y2gyID0ganNvblZhbC5leGVjKHRleHQpXG4gICAgICBpZiAobWF0Y2hbMV0gPT09IHByb3BlcnR5ICYmIG1hdGNoMiAmJiBtYXRjaDIubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm4gbWF0Y2gyWzFdXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlcyBhbmQgaW50ZXJwcmV0cyB0aGUgb3JpZW50YXRpb24gZGF0YSBmcm9tIHBhc3NlZCBpbiBKU09OIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgIFRoZSBwYXJzZWQgb2JqZWN0IHdpdGggYW4gYG9yaWVudGF0aW9uYCBwcm9wZXJ0eSBpZiBwYXJzZWQgcHJvcGVybHkuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VKU09ORm9yT3JpZW50YXRpb24gKHRleHQpIHtcbiAgY29uc3Qgb3JpZW50YXRpb24gPSBwYXJzZUpTT05Gb3JQcm9wZXJ0eSh0ZXh0LCAnb3JpZW50YXRpb24nKVxuICBpZiAob3JpZW50YXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3JpZW50YXRpb246IHBhcnNlSW50KG9yaWVudGF0aW9uKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIHBhcnNlSlNPTkZvclN0cmVhbWluZ01vZGUgKHRleHQpIHtcbiAgY29uc3Qgc3RyZWFtaW5nTW9kZSA9IHBhcnNlSlNPTkZvclByb3BlcnR5KHRleHQsICdzdHJlYW1pbmdNb2RlJylcbiAgaWYgKHN0cmVhbWluZ01vZGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RyZWFtaW5nTW9kZTogc3RyZWFtaW5nTW9kZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbmNvbnN0IGdldE1ldGFkYXRhTWFwRm9yUGxheWVyID0gKHBsYXllcikgPT4ge1xuICByZXR1cm4gbWV0YWRhdGFNYXAuZ2V0KHBsYXllcilcbn1cblxuY29uc3QgZW5hYmxlTWV0YWRhdGFNb25pdG9yID0gKHBsYXllcikgPT4ge1xuXG4gIGNvbnN0IHRleHRUcmFja3MgPSB0eXBlb2YgcGxheWVyLnRleHRUcmFja3MgPT09ICdmdW5jdGlvbicgPyBwbGF5ZXIudGV4dFRyYWNrcygpIDogcGxheWVyLnRleHRUcmFja3NcblxuICBpZiAodGV4dFRyYWNrcykge1xuXG4gICAgcGxheWVyLmFkZFRleHRUcmFjaygnbWV0YWRhdGEnKVxuXG4gICAgdGV4dFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIGFkZFRyYWNrRXZlbnQgPT4ge1xuXG4gICAgICBsZXQgdHJhY2sgPSBhZGRUcmFja0V2ZW50LnRyYWNrXG4gICAgICB0cmFjay5tb2RlID0gJ2hpZGRlbidcbiAgICAgIHRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2N1ZWNoYW5nZScsIGN1ZUNoYW5nZUV2ZW50ID0+IHtcbiAgICAgICAgbGV0IGN1ZXNcbiAgICAgICAgbGV0IGlcbiAgICAgICAgLy8gTW9zdGx5IENocm9tZS5cbiAgICAgICAgaWYgKGN1ZUNoYW5nZUV2ZW50ICYmIGN1ZUNoYW5nZUV2ZW50LmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICBjdWVzID0gY3VlQ2hhbmdlRXZlbnQuY3VycmVudFRhcmdldC5jdWVzXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodW5kZWZpbmVkID09PSB0aGlzKSB7XG4gICAgICAgICAgY3VlcyA9IHRyYWNrLmN1ZXNcbiAgICAgICAgICBjdWVzID0gY3VlcyAmJiBjdWVzLmxlbmd0aCA+IDAgPyBjdWVzIDogdHJhY2suYWN0aXZlQ3Vlc1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuZGVmaW5lZCAhPT0gdGhpcykge1xuICAgICAgICAgIC8vIE1vc3RseSBGaXJlZm94ICYgU2FmYXJpLlxuICAgICAgICAgIGN1ZXMgPSBjdWVzICYmIGN1ZXMubGVuZ3RoID4gMCA/IGN1ZXMgOiB0aGlzLmFjdGl2ZUN1ZXNcbiAgICAgICAgfVxuICAgICAgICAvLyBNb3N0bHkgZmFpbHVyZS5cbiAgICAgICAgY3VlcyA9IGN1ZXMgfHwgW11cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGN1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgZGF0YSA9IGN1ZXNbaV1cbiAgICAgICAgICBpZiAoZGF0YS52YWx1ZSkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSB0eXBlb2YgZGF0YS52YWx1ZS5kYXRhID09PSAnc3RyaW5nJyA/IGRhdGEudmFsdWUuZGF0YSA6IHJlYWRVVEYoIGRhdGEudmFsdWUuZGF0YSAsIDAgLCBkYXRhLnNpemUpXG4gICAgICAgICAgICBsZXQgb3JpZW50YXRpb24gPSBwYXJzZUpTT05Gb3JPcmllbnRhdGlvbih0ZXh0KVxuICAgICAgICAgICAgbGV0IHN0cmVhbWluZ01vZGUgPSBwYXJzZUpTT05Gb3JTdHJlYW1pbmdNb2RlKHRleHQpXG4gICAgICAgICAgICBjb25zdCBtYXAgPSBnZXRNZXRhZGF0YU1hcEZvclBsYXllcihwbGF5ZXIpXG4gICAgICAgICAgICBpZiAob3JpZW50YXRpb24gJiYgKG1hcCAmJiBtYXAub3JpZW50YXRpb24pKSB7XG4gICAgICAgICAgICAgIG1hcC5vcmllbnRhdGlvbi5mb3JFYWNoKGZuID0+IHtcbiAgICAgICAgICAgICAgICBmbihvcmllbnRhdGlvbilcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJlYW1pbmdNb2RlICYmIChtYXAgJiYgbWFwLnN0cmVhbWluZ01vZGUpKSB7XG4gICAgICAgICAgICAgIG1hcC5zdHJlYW1pbmdNb2RlLmZvckVhY2goZm4gPT4ge1xuICAgICAgICAgICAgICAgIGZuKHN0cmVhbWluZ01vZGUpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgfSlcbiAgfVxuXG59XG5cbi8qKlxuICogRXZlbnQgaGFuZGxlciBmb3IgbWV0YWRhdGEgcmVsYXRlZCB0byBvcmllbnRhdGlvbiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBsYXllclxuICogICAgICAgIFRoZSBtZWRpYSBlbGVtZW50IHJlbGF0ZWQgdG8gdGhlIG1ldGFkYXRhLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqICAgICAgICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggdGhlIHBhcnNlZCBvcmllbnRhdGlvbiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3Qgb25PcmllbnRhdGlvbk1ldGFkYXRhID0gKHBsYXllciwgY2FsbGJhY2spID0+IHtcblxuICBjb25zdCBtYXAgPSBtZXRhZGF0YU1hcC5nZXQocGxheWVyKVxuICBpZiAoIW1ldGFkYXRhTWFwLmhhcyhwbGF5ZXIpKSB7XG4gICAgZW5hYmxlTWV0YWRhdGFNb25pdG9yKHBsYXllcilcbiAgICBtZXRhZGF0YU1hcC5zZXQocGxheWVyLCB7XG4gICAgICBvcmllbnRhdGlvbjogW11cbiAgICB9KVxuICB9IGVsc2UgaWYgKCFtYXAuaGFzT3duUHJvcGVydHkoJ29yaWVudGF0aW9uJykpIHtcbiAgICBtZXRhZGF0YU1hcC5nZXQocGxheWVyKS5vcmllbnRhdGlvbiA9IFtdXG4gIH1cbiAgbWV0YWRhdGFNYXAuZ2V0KHBsYXllcikub3JpZW50YXRpb24ucHVzaChjYWxsYmFjaylcblxufVxuXG4vKipcbiAqIEV2ZW50IGhhbmRsZXIgZm9yIG1ldGFkYXRhIHJlbGF0ZWQgdG8gc3RyZWFtaW5nTW9kZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBsYXllclxuICogICAgICAgIFRoZSBtZWRpYSBlbGVtZW50IHJlbGF0ZWQgdG8gdGhlIG1ldGFkYXRhLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqICAgICAgICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggdGhlIHBhcnNlZCBzdHJlYW1pbmdNb2RlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBvblN0cmVhbWluZ01vZGVNZXRhZGF0YSA9IChwbGF5ZXIsIGNhbGxiYWNrKSA9PiB7XG5cbiAgY29uc3QgbWFwID0gbWV0YWRhdGFNYXAuZ2V0KHBsYXllcilcbiAgaWYgKCFtZXRhZGF0YU1hcC5oYXMocGxheWVyKSkge1xuICAgIGVuYWJsZU1ldGFkYXRhTW9uaXRvcihwbGF5ZXIpXG4gICAgbWV0YWRhdGFNYXAuc2V0KHBsYXllciwge1xuICAgICAgc3RyZWFtaW5nTW9kZTogW11cbiAgICB9KVxuICB9IGVsc2UgaWYgKCFtYXAuaGFzT3duUHJvcGVydHkoJ3N0cmVhbWluZ01vZGUnKSkge1xuICAgIG1ldGFkYXRhTWFwLmdldChwbGF5ZXIpLnN0cmVhbWluZ01vZGUgPSBbXVxuICB9XG4gIG1ldGFkYXRhTWFwLmdldChwbGF5ZXIpLnN0cmVhbWluZ01vZGUucHVzaChjYWxsYmFjaylcblxufVxuXG4vKipcbiAqIFJlcXVlc3QgdG8gcmVtb3ZlIHJlZmVyZW5jZSB0byBwbGF5ZXIgZm9ybSBtZXRhZGF0YSBkZWxlZ2F0ZSBtYXBwaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVQbGF5ZXJEZWxlZ2F0ZXMgPSBwbGF5ZXIgPT4ge1xuICBpZiAobWV0YWRhdGFNYXAuaGFzKHBsYXllcikpIHtcbiAgICBtZXRhZGF0YU1hcC5kZWxldGUocGxheWVyKVxuICB9XG59XG5cbiIsImltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IE5vRWxlbWVudEZvdW5kRXJyb3IgfSBmcm9tICcuLi9leGNlcHRpb24vZXJyb3JzJ1xuaW1wb3J0IHsgXG4gIG9uT3JpZW50YXRpb25NZXRhZGF0YSxcbiAgb25TdHJlYW1pbmdNb2RlTWV0YWRhdGFcbn0gZnJvbSAnLi9tZXRhZGF0YS11dGlsJ1xuaW1wb3J0IHsgZGVidWcsIHdhcm4gfSBmcm9tICcuLi9sb2cnXG5cbmxldCBydG1wU3Vic2NyaWJlckFzc2lnbm1lbnRzID0gW11cblxuLyogUHJvcGVydGllcyBhbmQgbWV0aG9kcyByZWxhdGVkIHRvIGludGVyYWN0aW9uIHdpdGggdGhlIHNjcmVlbmZ1bGwuanMgbGlicmFyeS4gKi9cbmxldCBmdWxsc2NyZWVuSGFuZGxlcnMgPSBbXVxubGV0IHNjcmVlbmZ1bGxIYW5kbGVyQXNzaWduZWQgPSBmYWxzZVxuZnVuY3Rpb24gZW5hYmxlU2NyZWVuZnVsbEhhbmRsZXIgKCkge1xuICBpZiAoIXNjcmVlbmZ1bGxIYW5kbGVyQXNzaWduZWQgJiYgd2luZG93LnNjcmVlbmZ1bGwgJiYgd2luZG93LnNjcmVlbmZ1bGwuZW5hYmxlZCkge1xuICAgICAgc2NyZWVuZnVsbEhhbmRsZXJBc3NpZ25lZCA9IHRydWVcbiAgICAgIHdpbmRvdy5zY3JlZW5mdWxsLm9uY2hhbmdlKCgpID0+IHtcbiAgICAgICAgbGV0IGksIGxlbmd0aCA9IGZ1bGxzY3JlZW5IYW5kbGVycy5sZW5ndGhcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZnVsbHNjcmVlbkhhbmRsZXJzW2ldKHdpbmRvdy5zY3JlZW5mdWxsLmlzRnVsbHNjcmVlbilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxufVxuXG4vKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHJlbGF0ZWQgdG8gZGV2aWNlIGJyb3dzZXIgb3JpZW50YXRpb24gY2hhbmdlLiAqL1xubGV0IG9yaWVudGF0aW9uSGFuZGxlcnMgPSBbXVxuZnVuY3Rpb24gb25vcmllbnRhdGlvbmNoYW5nZSAoZXZlbnQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICBjb25zdCBzY3JlZW5PcmllbnRhdGlvbiA9IHNjcmVlbi5vcmllbnRhdGlvbiA/IHNjcmVlbi5vcmllbnRhdGlvbi5hbmdsZSA6IHVuZGVmaW5lZDtcbiAgY29uc3Qgb3JpZW50YXRpb25WYWx1ZSA9ICh0eXBlb2Ygc2NyZWVuT3JpZW50YXRpb24gPT09ICd1bmRlZmluZWQnKSBcbiAgICA/ICh3aW5kb3cubWF0Y2hNZWRpYShcIihvcmllbnRhdGlvbjogcG9ydHJhaXQpXCIpLm1hdGNoZXMgPyAwIDogOTApIFxuICAgIDogc2NyZWVuT3JpZW50YXRpb247XG4gIGxldCBpLCBsZW5ndGggPSBvcmllbnRhdGlvbkhhbmRsZXJzLmxlbmd0aFxuICBkZWJ1ZyhgW3dpbmRvdzpvbm9yaWVudGF0aW9uY2hhbmdlXWAsICBgb3JpZW50YXRpb24oJHtvcmllbnRhdGlvblZhbHVlfSkuYClcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgb3JpZW50YXRpb25IYW5kbGVyc1tpXSgob3JpZW50YXRpb25WYWx1ZSArIDkwKSAlIDM2MClcbiAgfVxufVxuXG4vKiBQcm9wZXJpZXMgYW5kIG1ldGhvZHMgcmVsYXRlZCB0byB3aW5kb3cgY2xvc2Ugb3BlcmF0aW9uLiAqL1xubGV0IGNsb3NlSGFuZGxlcnMgPSBbXVxubGV0IGhhc09uV2luZG93Q2xvc2UgPSBmYWxzZVxuZnVuY3Rpb24gb253aW5kb3djbG9zZSAoZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIC8vICBjbG9zZUhhbmRsZXJzLmZvckVhY2goaCA9PiBoKCkpXG4gIGxldCBpLCBsZW5ndGggPSBjbG9zZUhhbmRsZXJzLmxlbmd0aFxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjbG9zZUhhbmRsZXJzW2ldKClcbiAgfVxuICBoYXNPbldpbmRvd0Nsb3NlID0gdHJ1ZVxuICAvLyBSZXR1cm5pbmcgYSBzdHJpbmcgdmFsdWUgZm9yY2VzIGEgbGVhdmluZyBjb25maXJtYXRpb24gcG9wdXAgb24gdGhlIGJyb3dzZXIuXG4gIC8vICBlLnJldHVyblZhbHVlID0gJ2dvb2RieWUnXG4gIC8vICByZXR1cm4gJ2dvb2RieWUnXG59XG5cbi8qIENoZWNrIHRvIHNlZSB3aGF0IHRoZSBjdXJyZW50IGZsYXNoIHZlcnNpb24gaXMsIGlmIHBsdWdpbiBpcyBlbmFibGVkLiAqL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvdmlkZW8uanMvYmxvYi9tYXN0ZXIvc3JjL2pzL3RlY2gvZmxhc2guanMjTDQ3NlxuY29uc3QgZmxhc2hWZXJzaW9uID0gZnVuY3Rpb24gKCkge1xuICBsZXQgdmVyc2lvbiA9ICcwLDAsMCdcbiAgLy8gSUVcbiAgdHJ5IHtcbiAgICB2ZXJzaW9uID0gbmV3IHdpbmRvdy5BY3RpdmVYT2JqZWN0KCdTaG9ja3dhdmVGbGFzaC5TaG9ja3dhdmVGbGFzaCcpLkdldFZhcmlhYmxlKCckdmVyc2lvbicpLnJlcGxhY2UoL1xcRCsvZywgJywnKS5tYXRjaCgvXiw/KC4rKSw/JC8pWzFdXG5cbiAgLy8gb3RoZXIgYnJvd3NlcnNcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAobmF2aWdhdG9yLm1pbWVUeXBlc1snYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2gnXS5lbmFibGVkUGx1Z2luKSB7XG4gICAgICAgIHZlcnNpb24gPSAobmF2aWdhdG9yLnBsdWdpbnNbJ1Nob2Nrd2F2ZSBGbGFzaCAyLjAnXSB8fCBuYXZpZ2F0b3IucGx1Z2luc1snU2hvY2t3YXZlIEZsYXNoJ10pLmRlc2NyaXB0aW9uLnJlcGxhY2UoL1xcRCsvZywgJywnKS5tYXRjaCgvXiw/KC4rKSw/JC8pWzFdXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBuYWRhXG4gICAgfVxuICB9XG4gIHJldHVybiB2ZXJzaW9uLnNwbGl0KCcsJylcbn1cblxuLyogU2hpbSBmb3IgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgb2YgYnJvd3Nlci4gKi9cbmNvbnN0IHJlcXVlc3RGcmFtZSA9ICgodGltZSkgPT4ge1xuICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCB0aW1lKVxuICAgICAgICAgfVxufSkoMTAwMCk7XG5cbmNvbnN0IGhhc0FkYXB0ZXJTaGltID0gd2luZG93LmFkYXB0ZXJcblxuLyogQnJvd3NlciB0ZXN0IHRvIHNlZSBpZiBNb3ppbGxhLWJhc2VkLiAqL1xuY29uc3QgaXNNb3ogPSAhIW5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWFcblxuLyogQnJvd3NlciB0ZXN0IHRvIHNlZSBpZiBFZGdlLWJhc2VkLiAqL1xuY29uc3QgaXNJRSA9IGZhbHNlIHx8ICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlXG5jb25zdCBpc0VkZ2UgPSBoYXNBZGFwdGVyU2hpbSA/IHdpbmRvdy5hZGFwdGVyLmJyb3dzZXJEZXRhaWxzLmJyb3dzZXIudG9Mb3dlckNhc2UoKSA9PT0gJ2VkZ2UnIDogIWlzSUUgJiYgISF3aW5kb3cuU3R5bGVNZWRpYVxuXG4vKiBEZXRlcm1pbmUgaWYgY3VycmVudCBicm93c2VyIGhhcyB0b3VjaCBjYXBhYmlsaXRpZXMuICovXG5jb25zdCBpc1RvdWNoRW5hYmxlZCA9ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fFxuICB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJlxuICB3aW5kb3cuZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaFxuXG4vLyBJZiBkZXZlbG9wZXIgaGFzIG5vdCB1c2VkIGFkYXB0ZXIuanMuXG5pZiAoIWhhc0FkYXB0ZXJTaGltKSB7XG4gIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSkgfHwgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLm1zR2V0VXNlck1lZGlhXG59XG5cbi8qIFByb3h5IHRvIGJyb3dzZXItYmFzZWQsIHNwZWNpZmljIGZ1bmN0aW9ucy4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcblxuICByZXF1ZXN0RnJhbWU6IHJlcXVlc3RGcmFtZSxcblxuICBnZXRJc01vejogKCkgPT4ge1xuICAgIHJldHVybiBpc01velxuICB9LFxuXG4gIGdldElzRWRnZTogKCkgPT4ge1xuICAgIHJldHVybiBpc0VkZ2VcbiAgfSxcblxuICBpc1RvdWNoRW5hYmxlZDogKCkgPT4ge1xuICAgIHJldHVybiBpc1RvdWNoRW5hYmxlZFxuICB9LFxuXG4gIHN1cHBvcnRzV2ViU29ja2V0OiAoKSA9PiB7XG4gICAgcmV0dXJuICEhd2luZG93LldlYlNvY2tldFxuICB9LFxuXG4gIHN1cHBvcnRzSExTOiAoKSA9PiB7XG4gICAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKVxuICAgIHJldHVybiBlbC5jYW5QbGF5VHlwZSgnYXBwbGljYXRpb24vdm5kLmFwcGxlLm1wZWdVUkwnKS5sZW5ndGggPiAwIHx8XG4gICAgICBlbC5jYW5QbGF5VHlwZSgnYXBwbGljYXRpb24veC1tcGVnVVJMJykubGVuZ3RoID4gMCB8fFxuICAgICAgZWwuY2FuUGxheVR5cGUoJ2F1ZGlvL21wZWd1cmwnKS5sZW5ndGggPiAwIHx8XG4gICAgICBlbC5jYW5QbGF5VHlwZSgnYXVkaW8veC1tcGVndXJsJykubGVuZ3RoID4gMFxuICB9LFxuXG4gIHN1cHBvcnRzTm9uTmF0aXZlSExTOiAoKSA9PiB7XG4gICAgLy8gaGxzLmpzXG4gICAgcmV0dXJuICEhd2luZG93LkhscyAmJiB3aW5kb3cuSGxzLmlzU3VwcG9ydGVkKClcbiAgfSxcblxuICBjcmVhdGVITFNDbGllbnQ6IChvcHQgPSB7fSkgPT4ge1xuICAgIHJldHVybiBuZXcgd2luZG93LkhscyhvcHQpXG4gIH0sXG5cbiAgZ2V0SExTQ2xpZW50RXZlbnRFbnVtOiAoKSA9PiB7XG4gICAgcmV0dXJuIHdpbmRvdy5IbHMuRXZlbnRzXG4gIH0sXG5cbiAgc3VwcG9ydHNGbGFzaFZlcnNpb246ICh2ZXJzaW9uLCBkZWxpbWl0ZXIgPSAnLicpID0+IHtcbiAgICByZXR1cm4gZmxhc2hWZXJzaW9uKClbMF0gPj0gdmVyc2lvbi5zcGxpdChkZWxpbWl0ZXIpWzBdXG4gIH0sXG5cbiAgcmVzb2x2ZUVsZW1lbnQ6IChpZCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKVxuICAgICAgaWYgKCFlbCkge1xuICAgICAgICB0aHJvdyBuZXcgTm9FbGVtZW50Rm91bmRFcnJvcihgRWxlbWVudCB3aXRoIGlkKCR7aWR9KSBjb3VsZCBub3QgYmUgZm91bmQuYClcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbFxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBOb0VsZW1lbnRGb3VuZEVycm9yKGBFcnJvciBpbiBhY2Nlc3NpbmcgZWxlbWVudCB3aXRoIGlkKCR7aWR9KS4gJHtlLm1lc3NhZ2V9YClcbiAgICB9XG4gIH0sXG5cbiAgY3JlYXRlV2ViU29ja2V0OiAodXJsKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBXZWJTb2NrZXQodXJsKVxuICB9LFxuXG4gIHNldFZpZGVvU291cmNlOiAodmlkZW9FbGVtZW50LCBtZWRpYVN0cmVhbSwgYXV0b3BsYXkgPSBmYWxzZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gbWVkaWFTdHJlYW07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybignW3NldFZpZGVvU291cmNlOm9ial0nLCBgQ291bGQgbm90IHNldCBzcmNPYmplY3Q6ICR7ZS5tZXNzYWdlfWApXG4gICAgICBpZiAoaXNNb3opIHtcbiAgICAgICAgdmlkZW9FbGVtZW50Wydtb3pTcmNPYmplY3QnXSA9IG1lZGlhU3RyZWFtXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2aWRlb0VsZW1lbnQuc3JjID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobWVkaWFTdHJlYW0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGF1dG9wbGF5KSB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgbWF5YmVQcm9taXNlID0gdmlkZW9FbGVtZW50LnBsYXkoKVxuICAgICAgICBpZiAobWF5YmVQcm9taXNlKSB7XG4gICAgICAgICAgbWF5YmVQcm9taXNlLnRoZW4oKCkgPT4gZGVidWcoJ1tzZXRWaWRlb1NvdXJjZTphY3Rpb25dJywgJ3BsYXkgKFNUQVJUKScpKVxuICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHdhcm4oJ1tzZXRWaWRlb1NvdXJjZTphY3Rpb25dJywgJ3BsYXkgKEZBVUxUKSAnICsgKGVyci5tZXNzYWdlID8gZXJyLm1lc3NhZ2UgOiBlcnIpKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gTW9iaWxlIEJyb3dzZXJzOiBVbmNhdWdodCAoaW4gcHJvbWlzZSkgRE9NRXhjZXB0aW9uOiBwbGF5KCkgY2FuIG9ubHkgYmUgaW5pdGlhdGVkIGJ5IGEgdXNlciBnZXN0dXJlLlxuICAgICAgICB3YXJuKCdbc2V0VmlkZW9Tb3VyY2U6YWN0aW9uXScsICdwbGF5IChDQVRDSDo6RkFVTFQpICcgKyBlLm1lc3NhZ2UpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZSgnYXV0b3BsYXknLCBmYWxzZSlcbiAgICAgICAgICB2aWRlb0VsZW1lbnQucGF1c2UoKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB3YXJuKCdbc2V0VmlkZW9Tb3VyY2U6YWN0aW9uXScsICdwYXVzZSAoQ0FUQ0g6OkZBVUxUKSAnICsgZXJyLm1lc3NhZ2UpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKCdhdXRvcGxheScsIGZhbHNlKVxuICAgICAgICB2aWRlb0VsZW1lbnQucGF1c2UoKVxuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gbmFkYS5cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaW5qZWN0U2NyaXB0OiAodXJsKSA9PiB7XG4gICAgbGV0IGRmZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGxldCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICBzY3JpcHQub25sb2FkID0gKCkgPT4ge1xuICAgICAgZGZkLnJlc29sdmUoKVxuICAgIH1cbiAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNjcmlwdC5yZWFkeVN0YXRlID09PSAnbG9hZGVkJyB8fCBzY3JpcHQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbFxuICAgICAgICBkZmQucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgfVxuICAgIHNjcmlwdC5zcmMgPSB1cmxcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHNjcmlwdClcbiAgICByZXR1cm4gZGZkLnByb21pc2VcbiAgfSxcblxuICBnVU06IChjb25zdHJhaW50cykgPT4ge1xuICAgIHJldHVybiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyB8fCBuYXZpZ2F0b3IpLmdldFVzZXJNZWRpYShjb25zdHJhaW50cylcbiAgfSxcblxuICBzZXRHbG9iYWw6IChwcm9wLCB2YWx1ZSkgPT4ge1xuICAgIHdpbmRvd1twcm9wXSA9IHZhbHVlXG4gIH0sXG5cbiAgZ2V0U3dmT2JqZWN0OiAoKSA9PiB7XG4gICAgcmV0dXJuIHdpbmRvdy5zd2ZvYmplY3RcbiAgfSxcblxuICBnZXRFbWJlZE9iamVjdDogKGlkKSA9PiB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKVxuICB9LFxuXG4gIGdldEVsZW1lbnRJZDogKGVsKSA9PiB7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgfSxcblxuICBhZGRPcmllbnRhdGlvbkNoYW5nZUhhbmRsZXI6IChoYW5kbGVyLCBhbmRDYWxsID0gdHJ1ZSkgPT4ge1xuICAgIGNvbnN0IHN1cHBvcnRzT3JpZW50YXRpb25DaGFuZ2UgPSAnb25vcmllbnRhdGlvbmNoYW5nZScgaW4gd2luZG93XG4gICAgaWYgKHN1cHBvcnRzT3JpZW50YXRpb25DaGFuZ2UpIHtcbiAgICAgIGRlYnVnKCdbd2luZG93Om9yaWVudGF0aW9uXScsICdbYWRkT3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyXScsICdhZGRpbmcgcmVzcG9uZGVyLicpXG4gICAgICBvcmllbnRhdGlvbkhhbmRsZXJzLnB1c2goaGFuZGxlcilcbiAgICAgIGlmIChhbmRDYWxsKSB7XG4gICAgICAgIG9ub3JpZW50YXRpb25jaGFuZ2UoKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3JpZW50YXRpb25IYW5kbGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGRlYnVnKCdbd2luZG93Om9yaWVudGF0aW9uXScsICdbYWRkT3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyXScsICdvbm9yaWVudGF0aW9uY2hhbmdlIGFkZGVkLicpXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCBvbm9yaWVudGF0aW9uY2hhbmdlKVxuICAgIH1cbiAgfSxcblxuICByZW1vdmVPcmllbnRhdGlvbkNoYW5nZUhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgbGV0IGkgPSBvcmllbnRhdGlvbkhhbmRsZXJzLmxlbmd0aFxuICAgIHdoaWxlKCAtLWkgPiAtMSkge1xuICAgICAgaWYgKG9yaWVudGF0aW9uSGFuZGxlcnNbaV0gPT09IGhhbmRsZXIpIHtcbiAgICAgICAgb3JpZW50YXRpb25IYW5kbGVycy5zbGljZShpLCAxKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH0gXG4gICAgaWYgKG9yaWVudGF0aW9uSGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWJ1ZygnW3dpbmRvdzpvcmllbnRhdGlvbl0nLCAnW3JlbW92ZU9yaWVudGF0aW9uQ2hhbmdlSGFuZGxlcl06OiBvbm9yaWVudGF0aW9uY2hhbmdlIHJlbW92ZWQuJylcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvbm9yaWVudGF0aW9uY2hhbmdlJywgb25vcmllbnRhdGlvbmNoYW5nZSlcbiAgICB9XG4gIH0sXG5cbiAgYWRkQ2xvc2VIYW5kbGVyOiAoaGFuZGxlciwgaW5zZXJ0VmFsdWUgPSAtMSkgPT4ge1xuICAgIGNsb3NlSGFuZGxlcnMuc3BsaWNlKGluc2VydFZhbHVlID09PSAtMSA/IGNsb3NlSGFuZGxlcnMubGVuZ3RoIDogaW5zZXJ0VmFsdWUsIDAsIGhhbmRsZXIpXG4gICAgLy8gTk9URTogUmVtb3ZlZCBvbmJlZm9yZXVubG9hZCBpbiBmYXZvciBvZiBkZXZlbG9wZXJzIHByb3Blcmx5IGhhbmRsaW5nIHNodXRkb3duLlxuICAgIC8vICAgIGlmICh3aW5kb3cub25iZWZvcmV1bmxvYWQgIT09IG9ud2luZG93Y2xvc2UpIHtcbiAgICAvLyB3aW5kb3cub25iZWZvcmV1bmxvYWQgPSBvbndpbmRvd2Nsb3NlXG4gICAgaWYgKCFoYXNPbldpbmRvd0Nsb3NlKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5sb2FkJywgb253aW5kb3djbG9zZSlcbiAgICB9XG4gICAgLy8gfVxuICB9LFxuXG4gIHJlbW92ZUNsb3NlSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICBsZXQgaSA9IGNsb3NlSGFuZGxlcnMubGVuZ3RoXG4gICAgd2hpbGUoIC0taSA+IC0xKSB7XG4gICAgICBpZiAoY2xvc2VIYW5kbGVyc1tpXSA9PT0gaGFuZGxlcikge1xuICAgICAgICBjbG9zZUhhbmRsZXJzLnNsaWNlKGksIDEpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGludm9rZTogKG1ldGhvZE5hbWUsIGRhdGEpID0+IHtcbiAgICBpZiAod2luZG93Lmhhc093blByb3BlcnR5KG1ldGhvZE5hbWUpKSB7XG4gICAgICB3aW5kb3dbbWV0aG9kTmFtZV0uY2FsbCh3aW5kb3csIGRhdGEpXG4gICAgfVxuICB9LFxuXG4gIC8vIHJlcXVpcmVzIDxzY3JpcHQgc3JjPVwibGliL3NjcmVlbmZ1bGwvc2NyZWVuZnVsbC5taW4uanNcIj48L3NjcmlwdD5cbiAgdG9nZ2xlRnVsbFNjcmVlbjogKGVsZW1lbnQpID0+IHtcbiAgICBpZiAod2luZG93LnNjcmVlbmZ1bGwgJiYgd2luZG93LnNjcmVlbmZ1bGwuZW5hYmxlZCkge1xuICAgICAgd2luZG93LnNjcmVlbmZ1bGwudG9nZ2xlKGVsZW1lbnQpXG4gICAgfVxuICB9LFxuXG4gIG9uRnVsbFNjcmVlblN0YXRlQ2hhbmdlOiAoY2IpID0+IHtcbiAgICBmdWxsc2NyZWVuSGFuZGxlcnMucHVzaChjYilcbiAgICBlbmFibGVTY3JlZW5mdWxsSGFuZGxlcih3aW5kb3cuc2NyZWVuZnVsbClcbiAgfSxcblxuICBvbk9yaWVudGF0aW9uTWV0YWRhdGE6IG9uT3JpZW50YXRpb25NZXRhZGF0YSxcbiAgb25TdHJlYW1pbmdNb2RlTWV0YWRhdGE6IG9uU3RyZWFtaW5nTW9kZU1ldGFkYXRhLFxuXG4gIGhhc0F0dHJpYnV0ZURlZmluZWQ6IChlbGVtLCBhdHRyaWJ1dGUpID0+IHtcbiAgICBjb25zdCBhdHQgPSBlbGVtLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpXG4gICAgcmV0dXJuIChhdHQgIT09IG51bGwgJiYgdHlwZW9mIGF0dCAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICh0eXBlb2YgYXR0ID09PSAnc3RyaW5nJyAmJiAoYXR0ID09PSAnJyB8fCBhdHQgPT09ICd0cnVlJyB8fCBhdHQgPT09IGF0dHJpYnV0ZSkpXG4gIH0sXG5cbiAgaGFzQ2xhc3NEZWZpbmVkOiAoZWxlbSwgY2xhc3NOYW1lKSA9PiB7XG4gICAgcmV0dXJuIGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgfSxcblxuICBjcmVhdGVFbGVtZW50OiAodGFnTmFtZSwgb3B0cykgPT4ge1xuICAgIGlmICh0YWdOYW1lID09PSAndGV4dCcpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShvcHRzLnRvU3RyaW5nKCkpXG4gICAgfVxuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUsIG9wdHMpXG4gIH0sXG5cbiAgYWRkU3Vic2NyaXB0aW9uQXNzaWdubWVudEhhbmRsZXI6IChmbikgPT4ge1xuICAgIHJ0bXBTdWJzY3JpYmVyQXNzaWdubWVudHMucHVzaChmbilcbiAgICBpZiAod2luZG93LnNldFN1YnNjcmliZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB3aW5kb3cuc2V0U3Vic2NyaWJlcklkID0gKGlkKSA9PiB7XG4gICAgICAgIHJ0bXBTdWJzY3JpYmVyQXNzaWdubWVudHMuc2hpZnQoKShpZClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZ2V0TW91c2VYRnJvbUV2ZW50OiAoZXZlbnQpID0+IHtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICBldmVudCA9IHdpbmRvdy5ldmVudFxuICAgIH1cblxuICAgIGlmIChldmVudC5wYWdlWCkge1xuICAgICAgcmV0dXJuIGV2ZW50LnBhZ2VYXG4gICAgfVxuICAgIGVsc2UgaWYgKGV2ZW50LmNsaWVudFgpIHtcbiAgICAgIHJldHVybiBldmVudC5jbGllbnRYICsgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0ICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnRcbiAgICB9XG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIGdldFNjcm9sbFg6ICgpID0+IHtcbiAgICByZXR1cm4gKHdpbmRvdy5wYWdlWE9mZnNldCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgPyB3aW5kb3cucGFnZVhPZmZzZXRcbiAgICAgICAgICAgIDogKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUgfHwgZG9jdW1lbnQuYm9keSkuc2Nyb2xsTGVmdFxuICB9LFxuXG4gIGNyZWF0ZUV2ZW50OiAoRXZlbnRUeXBlKSA9PiB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUV2ZW50KEV2ZW50VHlwZSlcbiAgfSxcblxuICBnZXRHbG9iYWw6ICgpID0+IHdpbmRvd1xuXG59XG5cbiIsImltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuL2Jyb3dzZXInXG5jb25zdCB7IHJlcXVlc3RGcmFtZSB9ID0gZW52aXJvbm1lbnRcblxuLyogfHwgVHJhbnNsYXRpb24gU3R5bGVzIHVzZWQgb24gT3JpZW50YXRpb24tY2hhbmdlIG1ldGFkYXRhIGZyb20gTW9iaWxlIGJyb2FkY2FzdGVycy4gfHwgKi9cbmNvbnN0IG9yaWdpbiA9IFtcbiAgJ3dlYmtpdFRyYW5zZm9ybU9yaWdpbicsXG4gICdtb3pUcmFuc2Zvcm1PcmlnaW4nLFxuICAnbXNUcmFuc2Zvcm1PcmlnaW4nLFxuICAnb1RyYW5zZm9ybU9yaWdpbicsXG4gICd0cmFuc2Zvcm1PcmlnaW4nXG5dXG5jb25zdCBzdHlsZXMgPSBbXG4gICd3ZWJraXRUcmFuc2Zvcm0nLFxuICAnbW96VHJhbnNmb3JtJyxcbiAgJ21zVHJhbnNmb3JtJyxcbiAgJ29UcmFuc2Zvcm0nLFxuICAndHJhbnNmb3JtJ1xuXVxuY29uc3QgdHJhbnNpdGlvbiA9IFtcbiAgJ3dlYmtpdFRyYW5zaXRpb24nLFxuICAnbW96VHJhbnNpdGlvbicsXG4gICdtc1RyYW5zaXRpb24nLFxuICAnb1RyYW5zaXRpb24nLFxuICAndHJhbnNpdGlvbidcbl1cbmNvbnN0IHJvdGF0aW9uVHJhbnNsYXRpb25zID0ge1xuICAnMCc6IHtcbiAgICBvcmlnaW46ICdjZW50ZXIgY2VudGVyJyxcbiAgICB0cmFuc2Zvcm06ICdyb3RhdGUoMGRlZyknXG4gIH0sXG4gICc5MCc6IHtcbiAgICBvcmlnaW46ICdsZWZ0IHRvcCcsXG4gICAgdHJhbnNmb3JtOiAncm90YXRlKDkwZGVnKSB0cmFuc2xhdGVZKC0xMDAlKSdcbiAgfSxcbiAgJzE4MCc6IHtcbiAgICBvcmlnaW46ICdjZW50ZXIgY2VudGVyJyxcbiAgICB0cmFuc2Zvcm06ICdyb3RhdGUoMTgwZGVnKSdcbiAgfSxcbiAgJzI3MCc6IHtcbiAgICBvcmlnaW46ICd0b3AgbGVmdCcsXG4gICAgdHJhbnNmb3JtOiAncm90YXRlKDI3MGRlZykgdHJhbnNsYXRlWCgtMTAwJSkgdHJhbnNsYXRlWSgwJSknXG4gIH0sXG4gICctOTAnOiB7XG4gICAgb3JpZ2luOiAnbGVmdCB0b3AnLFxuICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSgtOTBkZWcpIHRyYW5zbGF0ZVgoLTEwMCUpJ1xuICB9LFxuICAnLTE4MCc6IHtcbiAgICBvcmlnaW46ICdjZW50ZXIgY2VudGVyJyxcbiAgICB0cmFuc2Zvcm06ICdyb3RhdGUoLTE4MGRlZyknXG4gIH0sXG4gICctMjcwJzoge1xuICAgIG9yaWdpbjogJ3RvcCBsZWZ0JyxcbiAgICB0cmFuc2Zvcm06ICdyb3RhdGUoLTI3MGRlZykgdHJhbnNsYXRlWSgtMTAwJSknXG4gIH1cbn1cblxuLyogVXRpbGl0eSBtZXRob2QgdG8gdHJhY2sgYW5kIHJlc2l6ZSBhbiBlbGVtZW50IG9uIGVudGVyIGZyYW1lLiAqL1xuY29uc3QgdHJhY2tSZXNpemUgPSAoZWxlbWVudCwgcmFmLCBpc1JvdGF0ZWQgPSBmYWxzZSkgPT4ge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZVxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGNvbnN0IHB3aWR0aCA9IHBhcmVudC5jbGllbnRXaWR0aFxuICAgICAgY29uc3QgcGhlaWdodCA9IHBhcmVudC5jbGllbnRIZWlnaHRcbiAgICAgIGlmIChpc1JvdGF0ZWQpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCA9IHBoZWlnaHQgKyAncHgnXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCA9IHB3aWR0aCArICdweCdcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV3aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGhcbiAgICAgIGNvbnN0IGVoZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodFxuICAgICAgY29uc3QgbWFyZ2luID0gKGlzUm90YXRlZCA/IChwd2lkdGggLSBlaGVpZ2h0KSA6IChwd2lkdGggLSBld2lkdGgpKSAqIDAuNVxuICAgICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSdcbiAgICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IG1hcmdpbiArICdweCdcbiAgICB9XG4gICAgaWYgKHJhZikge1xuICAgICAgcmFmKHRyYWNrUmVzaXplKGVsZW1lbnQsIHJhZiwgaXNSb3RhdGVkKSlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGFwcGx5T3JpZW50YXRpb24gPSAoZWxlbWVudCwgdmFsdWUsIHJlc29sdXRpb24pID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICBsZXQgaSwgbGVuZ3RoID0gc3R5bGVzLmxlbmd0aFxuICB2YWx1ZSA9IHZhbHVlICUgMzYwXG4gIGNvbnN0IGlzUm90YXRlZCA9IHZhbHVlICUgMTgwICE9PSAwXG4gIGNvbnN0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZVxuICBjb25zdCBwd2lkdGggPSBlbGVtZW50LndpZHRoID8gZWxlbWVudC53aWR0aCA6IHBhcmVudC5jbGllbnRXaWR0aFxuICBjb25zdCBwaGVpZ2h0ID0gZWxlbWVudC5oZWlnaHQgPyBlbGVtZW50LmhlaWdodCA6IHBhcmVudC5jbGllbnRIZWlnaHRcbiAgY29uc3QgdHJhbnNsYXRpb25zID0gcm90YXRpb25UcmFuc2xhdGlvbnNbdmFsdWUudG9TdHJpbmcoKV1cbiAgZm9yKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBlbGVtZW50LnN0eWxlW29yaWdpbltpXV0gPSB0cmFuc2xhdGlvbnMub3JpZ2luXG4gICAgZWxlbWVudC5zdHlsZVtzdHlsZXNbaV1dID0gdHJhbnNsYXRpb25zLnRyYW5zZm9ybVxuICAgIGVsZW1lbnQuc3R5bGVbdHJhbnNpdGlvbltpXV0gPSAndHJhbnNmb3JtIDAuMHMgbGluZWFyJ1xuICB9XG4gIGlmIChpc1JvdGF0ZWQpIHtcbiAgICAvLyBjb25zdCBzY2FsZSA9IHB3aWR0aCA+IHBoZWlnaHQgPyBwaGVpZ2h0IC8gcHdpZHRoIDogcHdpZHRoIC8gcGhlaWdodFxuICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBwaGVpZ2h0ICsgJ3B4J1xuICAgIHBhcmVudC5zdHlsZS5oZWlnaHQgPSBwaGVpZ2h0ICsgJ3B4J1xuICAgIC8vIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKHB3aWR0aCAqIHNjYWxlKSArICdweCdcbiAgfVxuICBlbHNlIHtcbiAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gcHdpZHRoICsgJ3B4J1xuICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gcGhlaWdodCArICdweCdcbiAgICBwYXJlbnQuc3R5bGUuaGVpZ2h0ID0gJ3Vuc2V0J1xuICB9XG5cbiAgaWYgKGRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgcGFyZW50LmF0dGFjaEV2ZW50KCdyZXNpemUnLCB0cmFja1Jlc2l6ZShlbGVtZW50LCByZXF1ZXN0RnJhbWUsIGlzUm90YXRlZCkpXG4gIH1cbiAgZWxzZSB7XG4gICAgdHJhY2tSZXNpemUoZWxlbWVudCwgcmVxdWVzdEZyYW1lLCBpc1JvdGF0ZWQpKClcbiAgfVxufVxuXG4iLCIndXNlIHN0cmljdCdcblxuLy8gaHR0cDovL2Jsb2cuY2FyYm9uZml2ZS5jb20vMjAxNS8wMS8xNC9nZXR0aW4tZnJlYWt5LWZ1bmN0aW9uYWwtd2N1cnJpZWQtamF2YXNjcmlwdC9cbi8qKlxuICogQmFzaWMgY3VycnkgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGN1cnJ5ID0gKGZ4KSA9PiB7XG4gIGxldCBhcml0eSA9IGZ4Lmxlbmd0aDtcbiAgcmV0dXJuIGZ1bmN0aW9uIGYxKCkge1xuICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+PSBhcml0eSkge1xuICAgICAgcmV0dXJuIGZ4LmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBmMigpIHtcbiAgICAgICAgY29uc3QgYXJnczIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICByZXR1cm4gZjEuYXBwbHkobnVsbCwgYXJncy5jb25jYXQoYXJnczIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQmFzaWMgZmlsdGVyIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBmaWx0ZXIgPSBjdXJyeSgoZm4sIGxpc3QpID0+IHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBpZiAoZm4obGlzdFtpZHhdKSkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gbGlzdFtpZHhdO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSlcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHZhbHVlIHRvIGludGVnZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCB0b0ludCA9ICh2YWx1ZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApXG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpXG4gIH1cbn1cblxuLyoqXG4gKiBDaGVja3MgdHJ1dGh5LW5lc3Mgb2YgYHZhbHVlYCBhbmQgcmV0dXJucyBkZWZhdWx0IGlmIGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRWYWx1ZVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRPckVsc2UgPSAodmFsdWUsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICByZXR1cm4gdmFsdWUgfHwgZGVmYXVsdFZhbHVlXG59XG5cbi8qKlxuICogQ2hlY2tzIHRydXRoeS1uZXNzIG9mIGB2YWx1ZWAgYXMgYSBOdW1iZXIgYW5kIHJldHVybnMgZGVmYXVsdCBpZiBmYWxzZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0VmFsdWVcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgZ2V0SW50T3JFbHNlID0gKHZhbHVlLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgcmV0dXJuICFpc05hTih0b0ludCh2YWx1ZSkpID8gdG9JbnQodmFsdWUpIDogZGVmYXVsdFZhbHVlXG59XG5cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIERlZXAtZGVmaW5lcyBhbiBgT2JqZWN0YCBpbiBwbGFjZSB3aXRoIG5hbWVzcGFjZWQgYXR0cmlidXRlIHZhbHVlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBkZWVwRGVmaW5lID0gKG9iamVjdCwgcGF0aHMsIHZhbHVlKSA9PiB7XG4gIGxldCBpID0gMFxuICBsZXQgdGFpbCA9IG9iamVjdFxuICBjb25zdCBwcm9wID0gcGF0aHMucG9wKClcbiAgY29uc3QgbGVuZ3RoID0gcGF0aHMubGVuZ3RoXG4gIGZvciAoaTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHBhdGggPSBwYXRoc1tpXVxuICAgIHRhaWxbcGF0aF0gPSB0YWlsW3BhdGhdIHx8IHt9XG4gICAgdGFpbCA9IHRhaWxbcGF0aF1cbiAgfVxuICB0YWlsW3Byb3BdID0gdmFsdWVcbn1cblxuLyoqXG4gKiBEZWVwLWNvcHkgdXRpbGl6aW5nIEpTT04gQVBJLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBkZWVwQ29weSA9IChvYmopID0+IHtcbiAgY29uc3Qgc3RyID0gSlNPTi5zdHJpbmdpZnkob2JqKVxuICByZXR1cm4gSlNPTi5wYXJzZShzdHIpXG59XG5cbi8qKlxuICogU2ltcGxlIHV0aWwgdG8gcGFyc2UgcmVzb2x1dGlvbiBmcm9tIG1ldGFkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogICAgICAgIFRoZSByZXNvbHV0aW9uIHZhbHVlIGZyb20gbWV0YWRhdGE6IGUuZywgYDY0MCw0ODBgLlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgIFRoZSBzdHJ1Y3R1cmVkIGRpbWVuc2lvbnMgT2JqZWN0IHdpdGggYHdpZHRoYCBhbmQgYGhlaWdodGAgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgbWV0YWRhdGFSZXNvbHV0aW9uVG9PYmplY3QgPSAodmFsdWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBsZXQgZGltcyA9IHZhbHVlLnNwbGl0KCcsJylcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHBhcnNlSW50KGRpbXNbMF0pLFxuICAgICAgaGVpZ2h0OiBwYXJzZUludChkaW1zWzFdKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBVdGlsaXR5IGNoZWNrIGlmIHByb3ZpZGluZyBPYmplY3QgaXMgZW1wdHkgKHdpdGhvdXQgYW55IHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGlzT2JqZWN0RW1wdHkgPSAob2JqKSA9PiB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMCAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IGN1cnJ5LCBmaWx0ZXIgfSBmcm9tICcuLi91dGlsJ1xuaW1wb3J0IHsgZGVlcENvcHkgfSBmcm9tICcuLi91dGlsL29iamVjdCdcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vbG9nJ1xuLy8gaW1wb3J0IHsgTm9TdXBwb3J0ZWRDYW1lcmFSZXNvbHV0aW9uc0Vycm9yIH0gZnJvbSAnLi4vZXhjZXB0aW9uL2Vycm9ycydcblxuLy8gUmVzb2x1dGlvbnMgYm9ycm93ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vd2VicnRjSGFja3MvV2ViUlRDLUNhbWVyYS1SZXNvbHV0aW9uL2Jsb2IvbWFzdGVyL2pzL3Jlc29sdXRpb25TY2FuLmpzXG5jb25zdCBmb3JtYXRzID0gW1xuICB7XG4gICAgbGFiZWw6ICc0SyhVSEQpJyxcbiAgICB3aWR0aDogMzg0MCxcbiAgICBoZWlnaHQ6IDIxNjAsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJzEwODBwKEZIRCknLFxuICAgIHdpZHRoOiAxOTIwLFxuICAgIGhlaWdodDogMTA4MCxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnVVhHQScsXG4gICAgd2lkdGg6IDE2MDAsXG4gICAgaGVpZ2h0OiAxMjAwLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICc3MjBwKEhEKScsXG4gICAgd2lkdGg6IDEyODAsXG4gICAgaGVpZ2h0OiA3MjAsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ1NWR0EnLFxuICAgIHdpZHRoOiA4MDAsXG4gICAgaGVpZ2h0OiA2MDAsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ1ZHQScsXG4gICAgd2lkdGg6IDY0MCxcbiAgICBoZWlnaHQ6IDQ4MCxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnMzYwcChuSEQpJyxcbiAgICB3aWR0aDogNjQwLFxuICAgIGhlaWdodDogMzYwLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdDSUYnLFxuICAgIHdpZHRoOiAzNTIsXG4gICAgaGVpZ2h0OiAyODgsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ1FWR0EnLFxuICAgIHdpZHRoOiAzMjAsXG4gICAgaGVpZ2h0OiAyNDAsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ1FDSUYnLFxuICAgIHdpZHRoOiAxNzYsXG4gICAgaGVpZ2h0OiAxNDQsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ1FRVkdBJyxcbiAgICB3aWR0aDogMTYwLFxuICAgIGhlaWdodDogMTIwLFxuICB9LFxuXVxuXG4vKipcbiAqIERldGVjdHMgaWYgcmVzb2x1dGlvbnMgYXJlIGRlZmluZWQgb24gdGhlIHByb3ZpZWQgY29uc3RyYWludHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnN0cmFpbnRzXG4gKiAgICAgICAgVGhlIE1lZGlhIENvbnN0cmFpbnRzIHRvIHRlc3QgYWdhaW5zdC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgaGFzUmVzb2x1dGlvbnNEZWZpbmVkID0gKGNvbnN0cmFpbnRzKSA9PiB7XG4gIHJldHVybiAoXG4gICAgY29uc3RyYWludHMuaGFzT3duUHJvcGVydHkoJ3ZpZGVvJykgJiZcbiAgICAoY29uc3RyYWludHMudmlkZW8uaGFzT3duUHJvcGVydHkoJ3dpZHRoJykgfHwgY29uc3RyYWludHMudmlkZW8uaGFzT3duUHJvcGVydHkoJ2hlaWdodCcpKVxuICApXG59XG5cbi8qKlxuICogUmV0dXJuIHZhbHVlIG9uIGF0dHJpYnV0ZSBiYXNlZCBvbiBmYWlsb3ZlciB0ZXN0IG9mIGF0dHJpYnV0ZSBhdmFpbGFiaWxpdHkgb24gcHJvdmlkZWQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBnZXRWYWx1ZUZyb21Db25zdHJhaW50QXR0cmlidXRlID0gKGF0dHJpYnV0ZSkgPT4ge1xuICByZXR1cm4gYXR0cmlidXRlLmV4YWN0IHx8IGF0dHJpYnV0ZS5pZGVhbCB8fCBhdHRyaWJ1dGUubWF4IHx8IGF0dHJpYnV0ZS5taW4gfHwgYXR0cmlidXRlXG59XG5cbi8qKlxuICogVGVzdCBpZiB2aWRlbyBvbiBNZWRpYSBDb25zdHJhaW50IGlzIGVpdGhlciBzZXQgdG8gYHRydWVgIG9yIGlmIHRoZSBjb25zdHJhaW50cyBhbmQgZm9ybWF0IG9iamVjdHMgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb24gdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25zdHJhaW50c1xuICogQHBhcmFtIHtPYmplY3R9IGZvcm1hdFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBpc0V4YWN0ID0gY3VycnkoKGNvbnN0cmFpbnRzLCBmb3JtYXQpID0+IHtcbiAgaWYgKHR5cGVvZiBjb25zdHJhaW50cy52aWRlbyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBjb25zdCB3ID0gY29uc3RyYWludHMudmlkZW8uaGFzT3duUHJvcGVydHkoJ3dpZHRoJykgPyBnZXRWYWx1ZUZyb21Db25zdHJhaW50QXR0cmlidXRlKGNvbnN0cmFpbnRzLnZpZGVvLndpZHRoKSA6IDBcbiAgY29uc3QgaCA9IGNvbnN0cmFpbnRzLnZpZGVvLmhhc093blByb3BlcnR5KCdoZWlnaHQnKSA/IGdldFZhbHVlRnJvbUNvbnN0cmFpbnRBdHRyaWJ1dGUoY29uc3RyYWludHMudmlkZW8uaGVpZ2h0KSA6IDBcbiAgY29uc3QgY29uZmlybWVkID0gdyA9PT0gZm9ybWF0LndpZHRoICYmIGggPT09IGZvcm1hdC5oZWlnaHRcbiAgaWYgKGNvbmZpcm1lZCkge1xuICAgIGRlYnVnKCdbZ3VtOmlzRXhhY3RdJywgYEZvdW5kIG1hdGNoaW5nIHJlc29sdXRpb24gZm9yICR7Zm9ybWF0LndpZHRofSwgJHtmb3JtYXQuaGVpZ2h0fS5gKVxuICB9XG4gIHJldHVybiBjb25maXJtZWRcbn0pXG5cbi8qKlxuICogVGVzdCBpZiB0aGUgYXJlYSBvbiB0aGUgcHJvdmlkZSBmb3JtYXQgaXMgbG93ZXIgdGhhbiB0aGUgYXJlYSBvbiB0aGUgTWVkaWEgQ29uc3RyYWludHMuXG4gKiBUaGlzIGlzIHVzZWQgaW4gdHJ5aW5nIHRvIGZpbmQgdGhlIG5leHQgbmVhcmVzdCBuZWlnaGJvciBvZiBkaW1lbnNpb25zIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnN0cmFpbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gZm9ybWF0XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGlzTG93ZXIgPSBjdXJyeSgoY29uc3RyYWludHMsIGZvcm1hdCkgPT4ge1xuICBjb25zdCB3ID0gY29uc3RyYWludHMudmlkZW8uaGFzT3duUHJvcGVydHkoJ3dpZHRoJykgPyBnZXRWYWx1ZUZyb21Db25zdHJhaW50QXR0cmlidXRlKGNvbnN0cmFpbnRzLnZpZGVvLndpZHRoKSA6IDBcbiAgY29uc3QgaCA9IGNvbnN0cmFpbnRzLnZpZGVvLmhhc093blByb3BlcnR5KCdoZWlnaHQnKSA/IGdldFZhbHVlRnJvbUNvbnN0cmFpbnRBdHRyaWJ1dGUoY29uc3RyYWludHMudmlkZW8uaGVpZ2h0KSA6IDBcbiAgY29uc3QgZGVzaXJlZCA9IHcgKiBoXG4gIGNvbnN0IGRpbWVuc2lvbnMgPSBmb3JtYXQud2lkdGggKiBmb3JtYXQuaGVpZ2h0XG4gIHJldHVybiBkaW1lbnNpb25zIDwgZGVzaXJlZFxufSlcblxuLyoqXG4gKiBSZXR1cm5zIGZpbHRlcmVkIG9mIE1lZGlhIENvbnN0cmFpbnQgZm9ybWF0IGlmIG1hdGNoaW5nIHRoZSBjYW5uZWQgbGlzdCBvZiBzdXBwb3J0IGZvcm0gYGZvcm1hdHNgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGZvcm1hdExpc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25zdHJhaW50c1xuICogQHJldHVybiB7QXJyYXl9XG4gKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgaGFzTWF0Y2hpbmdGb3JtYXQgPSBjdXJyeSgoZm9ybWF0c0xpc3QsIGNvbnN0cmFpbnRzKSA9PiB7XG4gIGNvbnN0IGZpbHRlcmVkID0gZmlsdGVyKGlzRXhhY3QoY29uc3RyYWludHMpKShmb3JtYXRzTGlzdClcbiAgZGVidWcoJ1tndW06aGFzTWF0Y2hpbmdGb3JtYXRdJywgJ0ZpbHRlcmVkIGxpc3Q6ICcgKyBKU09OLnN0cmluZ2lmeShmaWx0ZXJlZCwgbnVsbCwgMikpXG4gIHJldHVybiBmaWx0ZXJlZC5sZW5ndGggPiAwXG59KVxuXG4vKipcbiAqIFJldHVybnMgbGlzdCBvZiBmaWx0ZXIgbG93ZXIgcmVzb2x1dGlvbiBjb25zdHJhaW50cyBmcm9tIHRoZSBwcm92aWRlZCBNZWRpYSBjb25zdHJhaW50cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBmb3JtYXlMaXN0XG4gKiBAcGFyYW0ge09iamVjdH0gY29uc3RyYWludHNcbiAqIEByZXR1cm4ge0FycmF5fVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGZpbmRMb3dlclJlc29sdXRpb25zID0gY3VycnkoKGZvcm1hdHNMaXN0LCBjb25zdHJhaW50cykgPT4ge1xuICBsZXQgcmVzSXNMb3dlciA9IGlzTG93ZXIoY29uc3RyYWludHMpXG4gIHJldHVybiBmaWx0ZXIocmVzSXNMb3dlcikoZm9ybWF0c0xpc3QpXG59KVxuXG4vKipcbiAqIEFsbG93cyB0aGUgYnJvd3NlciB0byB0cnkgYW5kIGRldGVybWluZSB0aGUgcmVzb2x1dGlvbiB0byB1c2UgYmFzZWQgb24gYHZpZGVvOiB0cnVlYCBhdHRyaWJ1dGUgaW4gYGdldFVzZXJNZWRpYWAgY2FsbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogICAgICAgIFRoZSBNZWRpYSBDb25zdGFpbnRzIG9iamVjdC5cbiAqIEBwYXJhbSB7UHJvbWlzZX0gcFxuICogICAgICAgIFRoZSBgUHJvbWlzZWAgdG8gcmVzb2x2ZSBvciByZWplY3Qgb24gZGV0ZW1pbmF0aW9uIG9mIGFsbG93ZWQgTWVkaWEgQ29uc3RyYWludHMgb24gdGhlIGJyb3dzZXIuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgYWxsb3dCcm93c2VyVG9EZWZpbmVSZXNvbHV0aW9uID0gKGRhdGEsIHApID0+IHtcbiAgLy8gZGVmYXVsdCB0byBgdmlkZW86IHRydWVgIGluIGhvcGVzIHRoZSBicm93c2VyIGNhbiBkZWNpZGUgb24gaXRzIG93bi5cbiAgZGF0YS52aWRlbyA9IHRydWVcbiAgZW52aXJvbm1lbnRcbiAgICAuZ1VNKGRhdGEpXG4gICAgLnRoZW4oKG1lZGlhKSA9PiB7XG4gICAgICBwLnJlc29sdmUoe1xuICAgICAgICBtZWRpYTogbWVkaWEsXG4gICAgICAgIGNvbnN0cmFpbnRzOiBkYXRhLFxuICAgICAgfSlcbiAgICB9KVxuICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBjb25zdCBtc2cgPSB0eXBlb2YgZXJyID09PSAnc3RyaW5nJyA/IGVyciA6IFtlcnIubmFtZSwgZXJyLm1lc3NhZ2VdLmpvaW4oJzogJylcbiAgICAgIGRlYnVnKCdbZ3VtOmdldFVzZXJNZWRpYV0nLCBgRmFpbHVyZSBpbiBnZXRVc2VyTWVkaWE6ICR7bXNnfS4gQXR0ZW1wdGluZyBvdGhlciByZXNvbHV0aW9uIHRlc3RzLi4uYClcbiAgICAgIGRlYnVnKCdbZ1VNOmZpbmRmb3JtYXRdJywgYENvbnN0cmFpbnRzIGRlY2xpbmVkIGJ5IGJyb3dzZXI6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMil9YClcbiAgICAgIHAucmVqZWN0KCdDb3VsZCBub3QgZmluZCBwcm9wZXIgY2FtZXJhIGZvciBwcm92aWRlZCBjb25zdHJhaW50cy4nKVxuICAgIH0pXG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gc2VsZWN0IHRoZSBiZXN0IHJlc29sdXRpb24gYmFzZWQgb24gd2hldGhlciB0aGUgYnJvd3NlciB0aHJvd3MgYW4gZXhjZXB0aW9uIHdoZW4gcmVxdWVzdGluZyBgTWVkaWFTdHJlYW1gIG9uIGBnZXRVc2VyTWVkaWFgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiAgICAgICAgVGhlIE1lZGlhIENvbnN0YWludHMgb2JqZWN0LlxuICogQHBhcmFtIHtBcnJheX0gc2VsZWN0aW9uc1xuICogICAgICAgIFRoZSBsaXN0aW5nIG9mIGZvcm1hdHMgdG8gdGVzdCBvbi5cbiAqIEBwYXJhbSB7UHJvbWlzZX0gcFxuICogICAgICAgIFRoZSBgUHJvbWlzZWAgdG8gcmVzb2x2ZSBvciByZWplY3Qgb24gZGV0ZW1pbmF0aW9uIG9mIGFsbG93ZWQgTWVkaWEgQ29uc3RyYWludHMgb24gdGhlIGJyb3dzZXIuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgZmluZE5leHRTZWxlY3Rpb24gPSAoZGF0YSwgc2VsZWN0aW9ucywgcCkgPT4ge1xuICBpZiAoc2VsZWN0aW9ucy5sZW5ndGggPT0gMCkge1xuICAgIC8vIGlmIHdlIGdvdCBoZXJlLCB0aGVyZSBpcyBubyBzdXBwb3J0LlxuICAgIGFsbG93QnJvd3NlclRvRGVmaW5lUmVzb2x1dGlvbihkYXRhLCBwKVxuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHNlbGVjdGlvbiA9IHNlbGVjdGlvbnMuc2hpZnQoKVxuICBkYXRhLnZpZGVvLndpZHRoID0geyBleGFjdDogc2VsZWN0aW9uLndpZHRoIH1cbiAgZGF0YS52aWRlby5oZWlnaHQgPSB7IGV4YWN0OiBzZWxlY3Rpb24uaGVpZ2h0IH1cbiAgZW52aXJvbm1lbnRcbiAgICAuZ1VNKGRhdGEpXG4gICAgLnRoZW4oKG1lZGlhKSA9PiB7XG4gICAgICBwLnJlc29sdmUoe1xuICAgICAgICBtZWRpYTogbWVkaWEsXG4gICAgICAgIGNvbnN0cmFpbnRzOiBkYXRhLFxuICAgICAgfSlcbiAgICB9KVxuICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBjb25zdCBtc2cgPSB0eXBlb2YgZXJyID09PSAnc3RyaW5nJyA/IGVyciA6IFtlcnIubmFtZSwgZXJyLm1lc3NhZ2VdLmpvaW4oJzogJylcbiAgICAgIGRlYnVnKCdbZ3VtOmdldFVzZXJNZWRpYV0nLCBgRmFpbHVyZSBpbiBnZXRVc2VyTWVkaWE6ICR7bXNnfS4gQXR0ZW1wdGluZyBvdGhlciByZXNvbHV0aW9uIHRlc3RzLi4uYClcbiAgICAgIGRlYnVnKCdbZ1VNOmZpbmRmb3JtYXRdJywgYENvbnN0cmFpbnRzIGRlY2xpbmVkIGJ5IGJyb3dzZXI6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMil9YClcbiAgICAgIGZpbmROZXh0U2VsZWN0aW9uKGRhdGEsIHNlbGVjdGlvbnMsIHApXG4gICAgfSlcbn1cblxuLyoqXG4gKiBRdWljayB0ZXN0IGlmIHJlc29sdXRpb24gaXMgc3VwcG9ydGVkIG9uIHRoZSBicm93c2VyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25zdHJhaW50c1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBxdWlja1Jlc29sdXRpb25TdXBwb3J0ID0gKGNvbnN0cmFpbnRzKSA9PiB7XG4gIGxldCBkYXRhID0gZGVlcENvcHkoY29uc3RyYWludHMpXG4gIC8vIGlmIHZpZGVvOiBgdHJ1ZWAsIHJldHVybmVkIHVuc2NhdGhlZC5cbiAgaWYgKHR5cGVvZiBjb25zdHJhaW50cy52aWRlbyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuICAvLyBlbHNlLCBkZWZpbmUgZXhhY3QuXG4gIGlmIChjb25zdHJhaW50cy52aWRlby53aWR0aCkge1xuICAgIGRhdGEudmlkZW8ud2lkdGggPSB7IGV4YWN0OiBnZXRWYWx1ZUZyb21Db25zdHJhaW50QXR0cmlidXRlKGNvbnN0cmFpbnRzLnZpZGVvLndpZHRoKSB9XG4gIH1cbiAgaWYgKGNvbnN0cmFpbnRzLnZpZGVvLmhlaWdodCkge1xuICAgIGRhdGEudmlkZW8uaGVpZ2h0ID0geyBleGFjdDogZ2V0VmFsdWVGcm9tQ29uc3RyYWludEF0dHJpYnV0ZShjb25zdHJhaW50cy52aWRlby5oZWlnaHQpIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKipcbiAqIERldGVtaW5lIHRoZSBzdXBwb3J0ZWQgcmVzb2x1dGlvbiBvbiB0aGUgYnJvd3NlciBiYXNlZCBvbiB0aGUgTWVkaWEgQ29uc3RyYWludHMgcmVxdWVzdGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25zdHJhaW50c1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBkZXRlcm1pbmVTdXBwb3J0ZWRSZXNvbHV0aW9uID0gKGNvbnN0cmFpbnRzKSA9PiB7XG4gIGRlYnVnKFxuICAgICdbZ3VtOmRldGVybWluZVN1cHBvcnRlZFJlc29sdXRpb25dJyxcbiAgICAnRGV0ZXJtaW5lIG5leHQgbmVpZ2hib3IgYmFzZWQgb24gY29uc3RyYWludHM6ICcgKyBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cywgbnVsbCwgMilcbiAgKVxuICBsZXQgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgbGV0IHNlbGVjdGlvbnMgPSBmaW5kTG93ZXJSZXNvbHV0aW9ucyhmb3JtYXRzKShjb25zdHJhaW50cylcbiAgbGV0IGRhdGEgPSBkZWVwQ29weShjb25zdHJhaW50cylcbiAgZmluZE5leHRTZWxlY3Rpb24oZGF0YSwgc2VsZWN0aW9ucywgZGVmZXJyZWQpXG4gIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG59XG5cbi8qKlxuICogUXVpY2sgdGVzdCB0byBzZWUgaWYgV2ViUlRDIGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBpc1N1cHBvcnRlZCA9ICgpID0+IHtcbiAgcmV0dXJuIF9SVENQZWVyQ29ubmVjdGlvbiAmJiBfUlRDSWNlQ2FuZGlkYXRlICYmIF9SVENTZXNzaW9uRGVzY3JpcHRpb25cbn1cblxuLyoqXG4gKiBEZXRlY3RzIGlmIGVzc2VudGlhbCBSVENEYXRhQ2hhbm5lbCBBUEkgaXMgYXZhaWxhYmxlIGluIGJyb3dzZXIuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IHN1cHBvcnRzRGF0YUNoYW5uZWwgPSAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGMgPSBuZXcgX1JUQ1BlZXJDb25uZWN0aW9uKG51bGwpXG4gICAgY29uc3QgZGMgPSBwYy5jcmVhdGVEYXRhQ2hhbm5lbCh7IG5hbWU6ICd0ZXN0JyB9KVxuICAgIGRjLmNsb3NlKClcbiAgICBwYy5jbG9zZSgpXG4gICAgcmV0dXJuICEhaXNTdXBwb3J0ZWQoKVxuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoYENvdWxkIG5vdCBkZXRlY3QgUlRDRGF0YUNoYW5uZWwgc3VwcG9ydDogJHtlLm1lc3NhZ2V9YClcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIFByb3h5IG9uIGBnZXRVc2VyTWVkaWFgIHRvIHRyeSBhbmQgcmVzb2x2ZSB0byB0aGUgYmVzdCBwb3NzaWJsZSByZXNvbHV0aW9uIGZvciBicm9hZGNhc3QgYmFzZWQgb24gTWVkaWEgQ29uc3RyYWludHMgb2JqZWN0IHByb3ZpZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25zdHJhaW50c1xuICogICAgICAgIFRoZSBNZWRpYSBDb25zdHJhaW50cyB0byByZXF1ZXN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3Rpb25DQlxuICogICAgICAgIFRoZSBjYWxsYmFjayBmb3IgcmVqZWN0aW9uIG9uIGBnZXRVc2VyTWVkaWFgIHJlcXVlc3QuXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICAgICAgIFRoZSBgUHJvbWlzZWAgd2lsbCByZXNvbHZlIG9yIHJlamVjdCBvbiBwcm9wZXJseSBhY2Nlc3NpbmcgYSBgTWVkaWFTdHJlYW1gIGZyb20gYGdldFVzZXJNZWRpYWAgb24gdGhlIGJyb3dzZXIuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFVzZXJNZWRpYSA9IChjb25zdHJhaW50cywgcmVqZWN0aW9uQ0IpID0+IHtcbiAgLy8gV3JhcHBpbmcgYGdldFVzZXJNZWRpYWAgcmVxdWVzdHMgaW4gYW5vdGhlciBkZWZlcnJlZCBwcm9taXNlIHNvIHdlIGNhbiByZXR1cm4gdGhlIHNlbGVjdGVkIHJlc29sdXRpb25zIGlmIHN1Y2Nlc3NmdWwuXG4gIGxldCBkZmQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgbGV0IGlzQXZhaWxhYmxlSW5Gb3JtYXRzID0gaGFzTWF0Y2hpbmdGb3JtYXQoZm9ybWF0cylcbiAgZGVidWcoJ1tndW06Z2V0VXNlck1lZGlhXScsICdJcyBBdmFpbGFibGUgaW4gZm9ybWF0IGxpc3Rpbmc6ICcgKyBpc0F2YWlsYWJsZUluRm9ybWF0cyhjb25zdHJhaW50cykpXG4gIGNvbnN0IGZhaWxvdmVyID0gKGVycikgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNvbnN0IG1zZyA9IHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnID8gZXJyIDogW2Vyci5uYW1lLCBlcnIubWVzc2FnZV0uam9pbignOiAnKVxuICAgICAgZGVidWcoJ1tndW06Z2V0VXNlck1lZGlhXScsIGBGYWlsdXJlIGluIGdldFVzZXJNZWRpYTogJHttc2d9LiBBdHRlbXB0aW5nIG90aGVyIHJlc29sdXRpb24gdGVzdHMuLi5gKVxuICAgIH1cbiAgICBkZXRlcm1pbmVTdXBwb3J0ZWRSZXNvbHV0aW9uKGNvbnN0cmFpbnRzKVxuICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICBkZmQucmVzb2x2ZSh7XG4gICAgICAgICAgbWVkaWE6IHJlcy5tZWRpYSxcbiAgICAgICAgICBjb25zdHJhaW50czogcmVzLmNvbnN0cmFpbnRzLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgaWYgKHJlamVjdGlvbkNCKSB7XG4gICAgICAgICAgcmVqZWN0aW9uQ0IoY29uc3RyYWludHMpXG4gICAgICAgIH1cbiAgICAgICAgZGZkLnJlamVjdCh7XG4gICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgIGNvbnN0cmFpbnRzOiBjb25zdHJhaW50cyxcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gIH1cbiAgaWYgKCFoYXNSZXNvbHV0aW9uc0RlZmluZWQoY29uc3RyYWludHMpKSB7XG4gICAgZGVidWcoJ1tndW06Z2V0VXNlck1lZGlhXScsICdDb25zdHJhaW50cyB3ZXJlIG5vdCBkZWZpbmVkIHByb3Blcmx5LiBBdHRlbXB0aW5nIGZhaWxvdmVyLi4uJylcbiAgICBlbnZpcm9ubWVudFxuICAgICAgLmdVTShjb25zdHJhaW50cylcbiAgICAgIC50aGVuKChtZWRpYSkgPT4ge1xuICAgICAgICBkZmQucmVzb2x2ZSh7XG4gICAgICAgICAgbWVkaWE6IG1lZGlhLFxuICAgICAgICAgIGNvbnN0cmFpbnRzOiBjb25zdHJhaW50cyxcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZmFpbG92ZXIpXG4gIH0gZWxzZSBpZiAoaXNBdmFpbGFibGVJbkZvcm1hdHMoY29uc3RyYWludHMpKSB7XG4gICAgZGVidWcoXG4gICAgICAnW2d1bTpnZXRVc2VyTWVkaWFdJyxcbiAgICAgICdGb3VuZCBjb25zdHJhaW50cyBpbiBsaXN0LiBDaGVja2luZyBxdWljayBzdXBwb3J0IGZvciBmYXN0ZXIgc2V0dXAgd2l0aDogJyArIEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzLCBudWxsLCAyKVxuICAgIClcbiAgICAvLyBUcnkgcXVpY2sgc2V0dGluZyBvZiBgZXhhY3RgIHJlc29sdXRpb24uLi5cbiAgICBsZXQgYXZhaWxhYmxlID0gcXVpY2tSZXNvbHV0aW9uU3VwcG9ydChjb25zdHJhaW50cylcbiAgICBlbnZpcm9ubWVudFxuICAgICAgLmdVTShhdmFpbGFibGUpXG4gICAgICAudGhlbigobWVkaWEpID0+IHtcbiAgICAgICAgZGZkLnJlc29sdmUoe1xuICAgICAgICAgIG1lZGlhOiBtZWRpYSxcbiAgICAgICAgICBjb25zdHJhaW50czogYXZhaWxhYmxlLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChmYWlsb3ZlcilcbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygnW2d1bTpnZXRVc2VyTWVkaWFdJywgJ0NvdWxkIG5vdCBmaW5kIGNvbnRyYWludHMgaW4gbGlzdC4gQXR0ZW1wdGluZyBmYWlsb3Zlci4uLicpXG4gICAgaWYgKHJlamVjdGlvbkNCKSB7XG4gICAgICByZWplY3Rpb25DQihjb25zdHJhaW50cylcbiAgICB9XG4gICAgZmFpbG92ZXIoKVxuICB9XG4gIHJldHVybiBkZmQucHJvbWlzZVxufVxuXG4vKipcbiAqIEZvcmNlIHRvIGNhbGwgYGdldFVzZXJNZWRpYWAgZGlyZWN0bHkgb24gdGhlIGJyb3dzZXIgYW5kIGJ5cGFzcyB0aGUgcmVzb2x1dGlvbiBkZXRlY3Rpb24gbWVjaGFuaXNtIHByb3ZpZGVkIGJ5IG90aGVyIG1ldGhvZHMgb24gdGhpcyBtb2R1bGUuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGZvcmNlVXNlck1lZGlhID0gKGNvbnN0cmFpbnRzKSA9PiB7XG4gIHJldHVybiBlbnZpcm9ubWVudC5nVU0oY29uc3RyYWludHMpXG59XG5cbmV4cG9ydCBjb25zdCBjbGVhbldoaXBTRFAgPSAoc2RwKSA9PiB7XG4gIGNvbnN0IG9mZmVuc2l2ZSA9IFsnYT1zZW5kcmVjdicsICdhPWVuZC1vZi1jYW5kaWRhdGVzJ11cbiAgbGV0IHMgPSBzZHAuc3BsaXQoJ1xcclxcbicpXG4gIGxldCBpID0gcy5sZW5ndGhcbiAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgaWYgKG9mZmVuc2l2ZS5pbmRleE9mKHNbaV0pID4gLTEpIHtcbiAgICAgIHMuc3BsaWNlKGksIDEpXG4gICAgfVxuICB9XG4gIHJldHVybiBzLmpvaW4oJ1xcclxcbicpXG59XG5cbmV4cG9ydCBjb25zdCBzdHJpcEV4dE1hcHMgPSAoc2RwKSA9PiB7XG4gIGNvbnN0IGV4dFJlZyA9IC9eYT1leHRtYXAvXG4gIGxldCBzID0gc2RwLnNwbGl0KCdcXHJcXG4nKVxuICBsZXQgaSA9IHMubGVuZ3RoXG4gIHdoaWxlICgtLWkgPiAtMSkge1xuICAgIGlmIChleHRSZWcuZXhlYyhzW2ldKSkge1xuICAgICAgcy5zcGxpY2UoaSwgMSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHMuam9pbignXFxyXFxuJylcbn1cblxubGV0IHJ0cG1hcHMgPSAoKGxpc3QpID0+IHtcbiAgbGV0IHJlZ3ggPSBbXVxuICBsaXN0LmZvckVhY2goKGxpbmUpID0+IHJlZ3gucHVzaChuZXcgUmVnRXhwKGBhPSgke2xpbmV9KWAsICdnJykpKVxuICByZXR1cm4gcmVneFxufSkoW1xuICAncnRwbWFwOihcXFxcZHsxLH0pIElTQUMnLFxuICAncnRwbWFwOihcXFxcZHsxLH0pIEc3MjInLFxuICAncnRwbWFwOihcXFxcZHsxLH0pIENOJyxcbiAgJ3J0cG1hcDooXFxcXGR7MSx9KSBQQ01VJyxcbiAgJ3J0cG1hcDooXFxcXGR7MSx9KSBQQ01BJyxcbiAgJ3J0cG1hcDooXFxcXGR7MSx9KSB0ZWxlcGhvbmUtZXZlbnQnLFxuXSlcblxuZXhwb3J0IGNvbnN0IHN0cmlwUlRQTWFwcyA9IChzZHApID0+IHtcbiAgY29uc3QgZm9ybWF0ID0gKGlkKSA9PiB7XG4gICAgcmV0dXJuIGBeYT0ocnRjcC1mYnxmbXRwKToke2lkfSAuKmBcbiAgfVxuICBsZXQgcyA9IHNkcC5zcGxpdCgnXFxyXFxuJylcbiAgbGV0IGkgPSBzLmxlbmd0aFxuICBsZXQgaiwgcnhcbiAgbGV0IG1hdGNoXG4gIGxldCBmb3JtYXRzID0gW11cbiAgbGV0IGZvcm1hdFN0clxuICAvLyBGaW5kIG9mZmVuZGluZyBtYXBzXG4gIHdoaWxlICgtLWkgPiAtMSkge1xuICAgIGZvciAoaiA9IDA7IGogPCBydHBtYXBzLmxlbmd0aDsgaisrKSB7XG4gICAgICByeCA9IHJ0cG1hcHNbal1cbiAgICAgIHJ4Lmxhc3RJbmRleCA9IDBcbiAgICAgIG1hdGNoID0gcnguZXhlYyhzW2ldKVxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIC8vICAgICAgICBjb25zb2xlLmxvZyhgW1NEUF0gcmVtb3ZpbmcgJHtzW2ldfWApXG4gICAgICAgIGZvcm1hdFN0ciA9IGZvcm1hdChtYXRjaFttYXRjaC5sZW5ndGggLSAxXSlcbiAgICAgICAgaWYgKGZvcm1hdHMuaW5kZXhPZihmb3JtYXRTdHIpID09PSAtMSkge1xuICAgICAgICAgIGZvcm1hdHMucHVzaChmb3JtYXRTdHIpXG4gICAgICAgIH1cbiAgICAgICAgcy5zcGxpY2UoaSwgMSlcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gRmluZCBvZmZlbmRpbmcgYXNzb2NpYXRlZCBmb3JtYXRzIG9mIHJlbW92ZWQgbWVkaWEgbWFwcGluZ3MuXG4gIGlmIChyeCkgcngubGFzdEluZGV4ID0gMFxuICBpID0gcy5sZW5ndGhcbiAgLy8gIGNvbnNvbGUubG9nKCdmb3JtYXRzJywgZm9ybWF0cylcbiAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgZm9yIChqID0gMDsgaiA8IGZvcm1hdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHJ4ID0gbmV3IFJlZ0V4cChmb3JtYXRzW2pdLCAnZycpXG4gICAgICByeC5sYXN0SW5kZXggPSAwXG4gICAgICBpZiAocnguZXhlYyhzW2ldKSkge1xuICAgICAgICAvLyAgICAgICAgY29uc29sZS5sb2coYFtTRFBdIHJlbW92aW5nICR7c1tpXX1gKVxuICAgICAgICBzLnNwbGljZShpLCAxKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcy5qb2luKCdcXHJcXG4nKVxufVxuXG5leHBvcnQgY29uc3Qgc3RyaXBOb25IMjY0ID0gKHNkcCkgPT4ge1xuICBsZXQgbWFwcyA9IC9eYT0oKHJ0cG1hcHxydGNwLWZifGZtdHApOihcXGR7MSx9KS4qKS9naVxuICBsZXQgaDI2NCA9IC9eYT1mbXRwOihcXGR7MSx9KS4qcHJvZmlsZS1sZXZlbC1pZD1cXGI0Mi9naVxuICBsZXQgdHlwZXMgPSBbXVxuICBsZXQgcyA9IHNkcC5zcGxpdCgnXFxyXFxuJylcbiAgbGV0IGkgPSBzLmxlbmd0aFxuICBsZXQgaiA9IDBcbiAgbGV0IG1hdGNoLCByeFxuXG4gIHdoaWxlICgtLWkgPiAtMSkge1xuICAgIGgyNjQubGFzdEluZGV4ID0gMFxuICAgIG1hdGNoID0gaDI2NC5leGVjKHNbaV0pXG4gICAgaWYgKG1hdGNoICYmIHR5cGVzLmluZGV4T2YobWF0Y2hbbWF0Y2gubGVuZ3RoIC0gMV0pID09PSAtMSkge1xuICAgICAgdHlwZXMucHVzaChtYXRjaFttYXRjaC5sZW5ndGggLSAxXSlcbiAgICB9XG4gIH1cbiAgaSA9IHMubGVuZ3RoXG4gIC8vICBjb25zb2xlLmxvZygndHlwZXMnLCB0eXBlcylcbiAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgZm9yIChqID0gMDsgaiA8IHR5cGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICBtYXBzLmxhc3RJbmRleCA9IDBcbiAgICAgIG1hdGNoID0gbWFwcy5leGVjKHNbaV0pXG4gICAgICBpZiAobWF0Y2ggJiYgdHlwZXMuaW5kZXhPZihtYXRjaFttYXRjaC5sZW5ndGggLSAxXSkgPT09IC0xKSB7XG4gICAgICAgIC8vICAgICAgICBjb25zb2xlLmxvZyhgW1NEUF0gcmVtb3ZpbmcgJHtzW2ldfWApXG4gICAgICAgIHMuc3BsaWNlKGksIDEpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzLmpvaW4oJ1xcclxcbicpXG59XG5cbmV4cG9ydCBjb25zdCBzdHJpcE5vbkgyNjRGcm9tVmlkZW8gPSAoc2RwKSA9PiB7XG4gIGNvbnN0IHIgPSAvXnZpZGVvL2dcbiAgY29uc3QgdmlkZW9zID0gc2RwLnNwbGl0KCdtPScpXG4gIGxldCBvdXQgPSB2aWRlb3MubWFwKChlbnRyeSkgPT4ge1xuICAgIGlmIChlbnRyeS5tYXRjaChyKSkge1xuICAgICAgaWYgKGVudHJ5LmluZGV4T2YoJ2E9c2VuZHJlY3YnKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHN0cmlwTm9uSDI2NChlbnRyeSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5XG4gIH0pXG4gIHJldHVybiBvdXQuam9pbignbT0nKVxufVxuXG5sZXQgc3NyYyA9IC9hPXNzcmMvZ2lcbmNvbnN0IGZsaXBSZWN2T25seSA9IChzZHAsIG1saW5lLCBtYXRjaCkgPT4ge1xuICBjb25zdCBtZWRpYSA9IHNkcC5zcGxpdChtbGluZSlcbiAgbGV0IGluZGV4ID0gMFxuICAvLyBhPXNlbmRyZWN2IC0+IGE9cmVjdm9ubHlcbiAgbGV0IG91dCA9IG1lZGlhLm1hcCgoZW50cnkpID0+IHtcbiAgICBpZiAoZW50cnkubWF0Y2gobWF0Y2gpKSB7XG4gICAgICBpZiAoKytpbmRleCA+IDEpIHtcbiAgICAgICAgbGV0IHN0ciA9IGVudHJ5LnJlcGxhY2UoJ2E9c2VuZHJlY3YnLCAnYT1yZWN2b25seScpXG4gICAgICAgIGxldCBvdXQgPSBzdHIuc3BsaXQoJ1xcclxcbicpXG4gICAgICAgIGxldCBpID0gb3V0Lmxlbmd0aFxuICAgICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgICBzc3JjLmxhc3RJbmRleCA9IDBcbiAgICAgICAgICBpZiAoc3NyYy5leGVjKG91dFtpXSkpIHtcbiAgICAgICAgICAgIG91dC5zcGxpY2UoaSwgMSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dC5qb2luKCdcXHJcXG4nKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW50cnlcbiAgfSlcbiAgcmV0dXJuIG91dC5qb2luKG1saW5lKVxufVxuXG5leHBvcnQgY29uc3QgZmxpcFJlY3ZPbmx5T25FeHRyYUF1ZGlvID0gKHNkcCkgPT4ge1xuICByZXR1cm4gZmxpcFJlY3ZPbmx5KHNkcCwgJ209JywgL15hdWRpby9nKVxufVxuXG5leHBvcnQgY29uc3QgZmxpcFJlY3ZPbmx5T25FeHRyYVZpZGVvID0gKHNkcCkgPT4ge1xuICByZXR1cm4gZmxpcFJlY3ZPbmx5KHNkcCwgJ209JywgL152aWRlby9nKVxufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbXVhei1raGFuL1dlYlJUQy1FeHBlcmltZW50L2Jsb2IvbWFzdGVyL1JUQ1BlZXJDb25uZWN0aW9uL1JUQ1BlZXJDb25uZWN0aW9uLXYxLjYuanMjTDE1OFxuLy8gTXVheiBLaGFuICAgICAtIGdpdGh1Yi5jb20vbXVhei1raGFuXG4vLyBNSVQgTGljZW5zZSAgIC0gd3d3LldlYlJUQy1FeHBlcmltZW50LmNvbS9saWNlbmNlXG4vLyBEb2N1bWVudGF0aW9uIC0gZ2l0aHViLmNvbS9tdWF6LWtoYW4vV2ViUlRDLUV4cGVyaW1lbnQvdHJlZS9tYXN0ZXIvUlRDUGVlckNvbm5lY3Rpb25cbmV4cG9ydCBjb25zdCB1cGRhdGVCYW5kd2lkdGggPSAob3B0aW9ucywgc2RwKSA9PiB7XG4gIGxldCBhX2luZGV4ID0gc2RwLmluZGV4T2YoJ209YXVkaW8nKVxuICBsZXQgdl9pbmRleCA9IHNkcC5pbmRleE9mKCdtPXZpZGVvJylcbiAgbGV0IGxfaW5kZXgsIGZyb250LCBiYWNrXG4gIGlmIChhX2luZGV4ID4gLTEpIHtcbiAgICBpZiAob3B0aW9ucy5hdWRpbykge1xuICAgICAgbF9pbmRleCA9IHNkcC5pbmRleE9mKCdcXHJcXG4nLCBhX2luZGV4KVxuICAgICAgZnJvbnQgPSBzZHAuc2xpY2UoMCwgbF9pbmRleClcbiAgICAgIGJhY2sgPSBzZHAuc2xpY2UobF9pbmRleCArICdcXHJcXG4nLmxlbmd0aCwgc2RwLmxlbmd0aClcbiAgICAgIHNkcCA9IFtmcm9udCwgJ2I9QVM6JyArIG9wdGlvbnMuYXVkaW8sIGJhY2tdLmpvaW4oJ1xcclxcbicpXG4gICAgfVxuICAgIHZfaW5kZXggPSBzZHAuaW5kZXhPZignbT12aWRlbycpXG4gIH1cbiAgaWYgKHZfaW5kZXggPiAtMSkge1xuICAgIGlmIChvcHRpb25zLnZpZGVvKSB7XG4gICAgICBsX2luZGV4ID0gc2RwLmluZGV4T2YoJ1xcclxcbicsIHZfaW5kZXgpXG4gICAgICBmcm9udCA9IHNkcC5zbGljZSgwLCBsX2luZGV4KVxuICAgICAgYmFjayA9IHNkcC5zbGljZShsX2luZGV4ICsgJ1xcclxcbicubGVuZ3RoLCBzZHAubGVuZ3RoKVxuICAgICAgc2RwID0gW2Zyb250LCAnYj1BUzonICsgb3B0aW9ucy52aWRlbywgYmFja10uam9pbignXFxyXFxuJylcbiAgICB9XG4gIH1cbiAgLy8gTGVnYWN5IENocm9tZS5cbiAgaWYgKGFfaW5kZXggPT09IC0xICYmIHZfaW5kZXggPT09IC0xKSB7XG4gICAgc2RwID0gc2RwLnJlcGxhY2UoL2I9QVMoW15cXHJcXG5dK1xcclxcbikvZywgJycpXG4gICAgaWYgKG9wdGlvbnMuYXVkaW8pIHtcbiAgICAgIHNkcCA9IHNkcC5yZXBsYWNlKC9hPW1pZDphdWRpb1xcclxcbi9nLCAnYT1taWQ6YXVkaW9cXHJcXG5iPUFTOicgKyBvcHRpb25zLmF1ZGlvICsgJ1xcclxcbicpXG4gICAgfVxuICAgIGlmIChvcHRpb25zLnZpZGVvKSB7XG4gICAgICBzZHAgPSBzZHAucmVwbGFjZSgvYT1taWQ6dmlkZW9cXHJcXG4vZywgJ2E9bWlkOnZpZGVvXFxyXFxuYj1BUzonICsgb3B0aW9ucy52aWRlbyArICdcXHJcXG4nKVxuICAgIH1cbiAgfVxuICByZXR1cm4gc2RwXG59XG5cbmV4cG9ydCBjb25zdCBmb3JjZVN0ZXJlb09uTG9jYWxBbnN3ZXIgPSAoc2RwKSA9PiB7XG4gIHJldHVybiBzZHAuaW5jbHVkZXMoJ3N0ZXJlbz0xJykgPyBzZHAgOiBzZHAucmVwbGFjZSgndXNlaW5iYW5kZmVjPTEnLCAndXNlaW5iYW5kZmVjPTE7c3RlcmVvPTE7c3Byb3Atc3RlcmVvPTEnKVxufVxuXG4vKipcbiAqIEZvciBXSElQL1dIRVAgdHJpY2tsZSBpY2UgY2FuZGlkYXRlcywgdGhpcyB3aWxsIGdlbmVyYXRlIHRoZSBmcmFnbWVudCByZXF1aXJlZCB0byBzZW5kIGluIGEgUEFUQ0guXG4gKiBAcGFyYW0ge3N0cmluZ30gc2RwIFRoZSBmdWxsIFNEUCB3aXRoIGNhbmRpZGF0ZSBsaXN0aW5ncyB0byBwYXJzZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIGRlc2lyZWQgY2FuZGlkYXRlIHR5cGUgKGlmIGFueSkuIEVpdGhlciBgaG9zdGAgb3IgYHNyZmx4YC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn19IGlzRW5kIEZsYWcgdG8gYXBwZW5kIGVuZCBvZiBjYW5kaWRhdGVzIGluIHRoZSBmcmFnbWVudC5cbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVNEUENhbmRpZGF0ZUZyYWcgPSAoc2RwLCB0eXBlID0gdW5kZWZpbmVkLCBpc0VuZCA9IGZhbHNlKSA9PiB7XG4gIGNvbnN0IGVuZCA9ICdhPWVuZC1vZi1jYW5kaWRhdGVzJ1xuICBjb25zdCBjYW5kaWRhdGVSZWcgPSAvXmE9Y2FuZGlkYXRlOi9cbiAgY29uc3QgZnJhZ1JlZyA9IC9eYT1pY2UtdWZyYWc6L1xuICBjb25zdCBwd2RSZWcgPSAvXmE9aWNlLXB3ZDovXG4gIGNvbnN0IG1SZWcgPSAvXm09KGF1ZGlvfHZpZGVvfGFwcGxpY2F0aW9uKVxcIC9cbiAgbGV0IGxpbmVzID0gc2RwLnNwbGl0KCdcXHJcXG4nKVxuICBsZXQgaWNlRnJhZyA9ICcnXG4gIGxldCBpY2VQd2QgPSAnJ1xuICBsZXQgbUxpbmVcbiAgbGV0IGlkID0gJ2E9bWlkOjAnXG4gIGxldCBjYW5kaWRhdGVzID0gW11cbiAgbGluZXMuZm9yRWFjaCgobCkgPT4ge1xuICAgIGlmICghbUxpbmUgJiYgbVJlZy5leGVjKGwpKSB7XG4gICAgICBtTGluZSA9IGxcbiAgICB9IGVsc2UgaWYgKGZyYWdSZWcuZXhlYyhsKSkge1xuICAgICAgaWNlRnJhZyA9IGxcbiAgICB9IGVsc2UgaWYgKHB3ZFJlZy5leGVjKGwpKSB7XG4gICAgICBpY2VQd2QgPSBsXG4gICAgfSBlbHNlIGlmIChjYW5kaWRhdGVSZWcuZXhlYyhsKSkge1xuICAgICAgaWYgKHR5cGUgJiYgbC5pbmRleE9mKHR5cGUpICE9IC0xKSB7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaChsKVxuICAgICAgfSBlbHNlIGlmICghdHlwZSkge1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2gobClcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIGlmIChpc0VuZCAmJiBjYW5kaWRhdGVzW2NhbmRpZGF0ZXMubGVuZ3RoIC0gMV0gIT09IGVuZCkge1xuICAgIGNhbmRpZGF0ZXMucHVzaChlbmQpXG4gIH1cbiAgY29uc3QgZnJhZ0xpc3QgPSBbaWNlRnJhZywgaWNlUHdkLCBtTGluZSwgaWRdLmNvbmNhdChjYW5kaWRhdGVzKVxuICByZXR1cm4gZnJhZ0xpc3Quam9pbignXFxyXFxuJylcbn1cblxuLyogLS0gaGFuZGxlZCBieSBhZGFwdGVyLmpzIC0tICovXG5jb25zdCBfUlRDUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHwgd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uIHx8IHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvblxuY29uc3QgX1JUQ0ljZUNhbmRpZGF0ZSA9IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgfHwgd2luZG93Lm1velJUQ0ljZUNhbmRpZGF0ZSB8fCB3aW5kb3cud2Via2l0UlRDSWNlQ2FuZGlkYXRlXG5jb25zdCBfUlRDU2Vzc2lvbkRlc2NyaXB0aW9uID1cbiAgd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiB8fCB3aW5kb3cubW96UlRDU2Vzc2lvbkRlc2NyaXB0aW9uIHx8IHdpbmRvdy53ZWJraXRSVENTZXNzaW9uRGVzY3JpcHRpb25cblxuZXhwb3J0IGNvbnN0IFJUQ1BlZXJDb25uZWN0aW9uID0gX1JUQ1BlZXJDb25uZWN0aW9uXG5leHBvcnQgY29uc3QgUlRDSWNlQ2FuZGlkYXRlID0gX1JUQ0ljZUNhbmRpZGF0ZVxuZXhwb3J0IGNvbnN0IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiA9IF9SVENTZXNzaW9uRGVzY3JpcHRpb25cbiIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5cbi8qKlxuICogVGVzdCBmb3IgV2ViU29ja2V0IHN1cHBvcnQgaW4gZW52aXJvbm1lbnQuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBlbnZpcm9ubWVudC5zdXBwb3J0c1dlYlNvY2tldCgpXG59XG5cbi8qKlxuICogQXR0ZW1wdCBhdCBjcmVhdGluZyBuZXcgaW5zdGFuY2Ugb2YgYSBgV2ViU29ja2V0YCBhdCBlbmRwb2ludCBVUkwuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHJldHVybiB7V2ViU29ja2V0fVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSBmdW5jdGlvbiAodXJsKSB7XG4gIHJldHVybiBlbnZpcm9ubWVudC5jcmVhdGVXZWJTb2NrZXQodXJsKVxufVxuIiwiLyoqXG4gKiBDb21tb24gUHVibGlzaGVyLWJhc2VkIGV2ZW50IHR5cGVzLlxuICovXG5leHBvcnQgY29uc3QgUHVibGlzaGVyRXZlbnRUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuICBDT05ORUNUX1NVQ0NFU1M6ICdDb25uZWN0LlN1Y2Nlc3MnLFxuICBDT05ORUNUX0ZBSUxVUkU6ICdDb25uZWN0LkZhaWx1cmUnLFxuICBQVUJMSVNIX1NUQVJUOiAnUHVibGlzaC5TdGFydCcsXG4gIFBVQkxJU0hfRkFJTDogJ1B1Ymxpc2guRmFpbCcsXG4gIFBVQkxJU0hfSU5WQUxJRF9OQU1FOiAnUHVibGlzaC5JbnZhbGlkTmFtZScsXG4gIFVOUFVCTElTSF9TVUNDRVNTOiAnVW5wdWJsaXNoLlN1Y2Nlc3MnLFxuICBQVUJMSVNIX01FVEFEQVRBOiAnUHVibGlzaC5NZXRhZGF0YScsXG4gIFBVQkxJU0hfU1RBVFVTOiAnUHVibGlzaC5TdGF0dXMnLFxuICBQVUJMSVNIX0FWQUlMQUJMRTogJ1B1Ymxpc2guQXZhaWxhYmxlJyxcbiAgUFVCTElTSF9JTlNVRkZJQ0lFTlRfQkFORFdJRFRIOiAnUHVibGlzaC5JbnN1ZmZpY2llbnRCVycsXG4gIFBVQkxJU0hfU1VGRklDSUVOVF9CQU5EV0lEVEg6ICdQdWJsaXNoLlN1ZmZpY2llbnRCVycsXG4gIFBVQkxJU0hfUkVDT1ZFUklOR19CQU5EV0lEVEg6ICdQdWJsaXNoLlJlY292ZXJpbmdCVycsXG4gIFBVQkxJU0hfU0VORF9JTlZPS0U6ICdQdWJsaXNoLlNlbmQuSW52b2tlJyxcbiAgQ09OTkVDVElPTl9DTE9TRUQ6ICdQdWJsaXNoZXIuQ29ubmVjdGlvbi5DbG9zZWQnLFxuICBESU1FTlNJT05fQ0hBTkdFOiAnUHVibGlzaGVyLlZpZGVvLkRpbWVuc2lvbkNoYW5nZSdcbn0pXG5cbi8qKlxuICogRXZlbnQgdHlwZXMgZGlzcGFjdGhlZCBmcm9tIGFuZCBzcGVjaWZpYyB0byBgUmVkNVByb1B1Ymxpc2hlcmAuXG4gKlxuICogQHNlZSB7UmVkNVByb1B1Ymxpc2hlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEZhaWxvdmVyUHVibGlzaGVyRXZlbnRUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuICBQVUJMSVNIRVJfUkVKRUNUOiAnUHVibGlzaGVyLlJlamVjdCcsXG4gIFBVQkxJU0hFUl9BQ0NFUFQ6ICdQdWJsaXNoZXIuQWNjZXB0J1xufSlcblxuLyoqXG4gKiBFdmVudCB0eXBlcyBkaXNwYXRjaGVkIGZyb20gYW5kIHNwZWNpZmljIHRvIGBSVENQdWJsaXNoZXJgLlxuICpcbiAqIEBzZWUge1JUQ1B1Ymxpc2hlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgQ09OU1RSQUlOVFNfQUNDRVBURUQ6ICdXZWJSVEMuTWVkaWFDb25zdHJhaW50cy5BY2NlcHRlZCcsXG4gIENPTlNUUkFJTlRTX1JFSkVDVEVEOiAnV2ViUlRDLk1lZGlhQ29uc3RyYWludHMuUmVqZWN0ZWQnLFxuICBNRURJQV9TVFJFQU1fQVZBSUxBQkxFOiAnV2ViUlRDLk1lZGlhU3RyZWFtLkF2YWlsYWJsZScsXG4gIFBFRVJfQ09OTkVDVElPTl9BVkFJTEFCTEU6ICdXZWJSVEMuUGVlckNvbm5lY3Rpb24uQXZhaWxhYmxlJyxcbiAgT0ZGRVJfU1RBUlQ6ICdXZWJSVEMuT2ZmZXIuU3RhcnQnLFxuICBPRkZFUl9FTkQ6ICdXZWJSVEMuT2ZmZXIuRW5kJyxcbiAgUEVFUl9DQU5ESURBVEVfRU5EOiAnV2ViUlRDLlBlZXJDb25uZWN0aW9uLkNhbmRpZGF0ZUVuZCcsXG4gIElDRV9UUklDS0xFX0NPTVBMRVRFOiAnV2ViUlRDLkljZVRyaWNrbGUuQ29tcGxldGUnLFxuICBTT0NLRVRfTUVTU0FHRTogJ1dlYlJUQy5Tb2NrZXQuTWVzc2FnZScsXG4gIERBVEFfQ0hBTk5FTF9PUEVOOiAnV2ViUlRDLkRhdGFDaGFubmVsLk9wZW4nLFxuICBEQVRBX0NIQU5ORUxfQVZBSUxBQkxFOiAnV2ViUlRDLkRhdGFDaGFubmVsLkF2YWlsYWJsZScsXG4gIERBVEFfQ0hBTk5FTF9DTE9TRTogJ1dlYlJUQy5EYXRhQ2hhbm5lbC5DbG9zZScsXG4gIERBVEFfQ0hBTk5FTF9NRVNTQUdFOiAnV2ViUlRDLkRhdGFDaGFubmVsLk1lc3NhZ2UnLFxuICBEQVRBX0NIQU5ORUxfRVJST1I6ICdXZWJSVEMuRGF0YUNoYW5uZWwuRXJyb3InLFxuICBQRUVSX0NPTk5FQ1RJT05fT1BFTjogJ1dlYlJUQy5QZWVyQ29ubmVjdGlvbi5PcGVuJyxcbiAgVFJBQ0tfQURERUQ6ICdXZWJSVEMuUGVlckNvbm5lY3Rpb24uT25UcmFjaydcbn0pXG5cbi8qKlxuICogRXZlbnQgdHlwZXMgZGlzcGF0Y2hlZCBmcm9tIGFuZCBzcGVjaWZpYyB0byBgUlRNUFB1Ymxpc2hlcmAuXG4gKlxuICogQHNlZSB7UlRNUFB1Ymxpc2hlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IFJUTVBQdWJsaXNoZXJFdmVudFR5cGVzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEVNQkVEX1NVQ0NFU1M6ICdGbGFzaFBsYXllci5FbWJlZC5TdWNjZXNzJyxcbiAgRU1CRURfRkFJTFVSRTogJ0ZsYXNoUGxheWVyLkVtYmVkLkZhaWx1cmUnXG59KVxuXG4iLCIvKipcbiAqIENvbW1vbiBldmVudCB0eXBlcyBvbiBhbGwgU3Vic2NyaWJlcnMuXG4gKi9cbmV4cG9ydCBjb25zdCBTdWJzY3JpYmVyRXZlbnRUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuICBDT05ORUNUX1NVQ0NFU1M6ICdDb25uZWN0LlN1Y2Nlc3MnLFxuICBDT05ORUNUX0ZBSUxVUkU6ICdDb25uZWN0LkZhaWx1cmUnLFxuICBTVUJTQ1JJQkVfU1RBUlQ6ICdTdWJzY3JpYmUuU3RhcnQnLFxuICBTVUJTQ1JJQkVfU1RPUDogJ1N1YnNjcmliZS5TdG9wJyxcbiAgU1VCU0NSSUJFX0ZBSUw6ICdTdWJzY3JpYmUuRmFpbCcsXG4gIFNVQlNDUklCRV9JTlZBTElEX05BTUU6ICdTdWJzY3JpYmUuSW52YWxpZE5hbWUnLFxuICBTVUJTQ1JJQkVfTUVUQURBVEE6ICdTdWJzY3JpYmUuTWV0YWRhdGEnLFxuICBTVUJTQ1JJQkVfU1RBVFVTOiAnU3Vic2NyaWJlLlN0YXR1cycsXG4gIFNVQlNDUklCRV9TRU5EX0lOVk9LRTogJ1N1YnNjcmliZS5TZW5kLkludm9rZScsXG4gIFNVQlNDUklCRV9QVUJMSVNIRVJfQ09OR0VTVElPTjogJ1N1YnNjcmliZS5QdWJsaXNoZXIuTmV0d29ya0Nvbmdlc3Rpb24nLFxuICBTVUJTQ1JJQkVfUFVCTElTSEVSX1JFQ09WRVJZOiAnU3Vic2NyaWJlLlB1Ymxpc2hlci5OZXR3b3JrUmVjb3ZlcnknLFxuICBQTEFZX1VOUFVCTElTSDogJ1N1YnNjcmliZS5QbGF5LlVucHVibGlzaCcsXG4gIENPTk5FQ1RJT05fQ0xPU0VEOiAnU3Vic2NyaWJlLkNvbm5lY3Rpb24uQ2xvc2VkJyxcbiAgT1JJRU5UQVRJT05fQ0hBTkdFOiAnU3Vic2NyaWJlLk9yaWVudGF0aW9uLkNoYW5nZScsXG4gIFNUUkVBTUlOR19NT0RFX0NIQU5HRTogJ1N1YnNjcmliZS5TdHJlYW1pbmdNb2RlLkNoYW5nZScsXG4gIFZJREVPX0RJTUVOU0lPTlNfQ0hBTkdFOiAnU3Vic2NyaWJlLlZpZGVvRGltZW5zaW9ucy5DaGFuZ2UnLFxuICBWT0xVTUVfQ0hBTkdFOiAnU3Vic2NyaWJlLlZvbHVtZS5DaGFuZ2UnLFxuICBTRUVLX0NIQU5HRTogJ1N1YnNjcmliZS5TZWVrLkNoYW5nZScsXG4gIFBMQVlCQUNLX1RJTUVfVVBEQVRFOiAnU3Vic2NyaWJlLlRpbWUuVXBkYXRlJyxcbiAgUExBWUJBQ0tfU1RBVEVfQ0hBTkdFOiAnU3Vic2NyaWJlLlBsYXliYWNrLkNoYW5nZScsXG4gIEZVTExfU0NSRUVOX1NUQVRFX0NIQU5HRTogJ1N1YnNjcmliZS5GdWxsU2NyZWVuLkNoYW5nZScsXG4gIEFVVE9fUExBWUJBQ0tfRkFJTFVSRTogJ1N1YnNjcmliZS5BdXRvcGxheS5GYWlsdXJlJyxcbiAgQVVUT19QTEFZQkFDS19NVVRFRDogJ1N1YnNjcmliZS5BdXRvcGxheS5NdXRlZCdcbn0pXG5cbi8qKlxuICogRXZlbnQgdHlwZXMgZGlzcGF0Y2hlZCBmcm9tIGFuZCBzcGVjaWZpYyB0byBgUmVkNVByb1N1YnNjcmliZXJgLlxuICpcbiAqIEBzZWUge1JlZDVQcm9TdWJzY3JpYmVyfVxuICovXG5leHBvcnQgY29uc3QgRmFpbG92ZXJTdWJzY3JpYmVyRXZlbnRUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuICBTVUJTQ1JJQkVSX1JFSkVDVDogJ1N1YnNjcmliZXIuUmVqZWN0JyxcbiAgU1VCU0NSSUJFUl9BQ0NFUFQ6ICdTdWJzY3JpYmVyLkFjY2VwdCdcbn0pXG5cbi8qKlxuICogRXZlbnQgdHlwZXMgZGlzcGF0Y2hlZCBmcm9tIGFuZCBzcGVjaWZpYyB0byBgUlRDU3Vic2NyaWJlcmAuXG4gKlxuICogQHNlZSB7UlRDU3Vic2NyaWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFBFRVJfQ09OTkVDVElPTl9BVkFJTEFCTEU6ICdXZWJSVEMuUGVlckNvbm5lY3Rpb24uQXZhaWxhYmxlJyxcbiAgT0ZGRVJfU1RBUlQ6ICdXZWJSVEMuT2ZmZXIuU3RhcnQnLFxuICBPRkZFUl9FTkQ6ICdXZWJSVEMuT2ZmZXIuRW5kJyxcbiAgQU5TV0VSX1NUQVJUOiAnV2ViUlRDLkFuc3dlci5TdGFydCcsXG4gIEFOU1dFUl9FTkQ6ICdXZWJSVEMuQW5zd2VyLkVuZCcsXG4gIENBTkRJREFURV9TVEFSVDogJ1dlYlJUQy5DYW5kaWRhdGUuU3RhcnQnLFxuICBDQU5ESURBVEVfRU5EOiAnV2ViUlRDLkNhbmRpZGF0ZS5FbmQnLFxuICBQRUVSX0NBTkRJREFURV9FTkQ6ICdXZWJSVEMuUGVlckNvbm5lY3Rpb24uQ2FuZGlkYXRlRW5kJyxcbiAgSUNFX1RSSUNLTEVfQ09NUExFVEU6ICdXZWJSVEMuSWNlVHJpY2tsZS5Db21wbGV0ZScsXG4gIFNPQ0tFVF9NRVNTQUdFOiAnV2ViUlRDLlNvY2tldC5NZXNzYWdlJyxcbiAgREFUQV9DSEFOTkVMX01FU1NBR0U6ICdXZWJSVEMuRGF0YUNoYW5uZWwuTWVzc2FnZScsXG4gIERBVEFfQ0hBTk5FTF9PUEVOOiAnV2ViUlRDLkRhdGFDaGFubmVsLk9wZW4nLFxuICBEQVRBX0NIQU5ORUxfQVZBSUxBQkxFOiAnV2ViUlRDLkRhdGFDaGFubmVsLkF2YWlsYWJsZScsXG4gIERBVEFfQ0hBTk5FTF9DTE9TRTogJ1dlYlJUQy5EYXRhQ2hhbm5lbC5DbG9zZScsXG4gIERBVEFfQ0hBTk5FTF9FUlJPUjogJ1dlYlJUQy5EYXRhQ2hhbm5lbC5FcnJvcicsXG4gIFBFRVJfQ09OTkVDVElPTl9PUEVOOiAnV2ViUlRDLlBlZXJDb25uZWN0aW9uLk9wZW4nLFxuICBPTl9BRERfU1RSRUFNOiAnV2ViUlRDLkFkZC5TdHJlYW0nLFxuICBMSVZFX1NFRUtfRVJST1I6ICdXZWJSVEMuTGl2ZVNlZWsuRXJyb3InLFxuICBMSVZFX1NFRUtfRU5BQkxFRDogJ1dlYlJUQy5MaXZlU2Vlay5FbmFibGVkJyxcbiAgTElWRV9TRUVLX0RJU0FCTEVEOiAnV2ViUlRDLkxpdmVTZWVrLkRpc2FibGVkJyxcbiAgTElWRV9TRUVLX0xPQURJTkc6ICdXZWJSVEMuTGl2ZVNlZWsuRnJhZ21lbnRMb2FkaW5nJyxcbiAgTElWRV9TRUVLX0xPQURFRDogJ1dlYlJUQy5MaXZlU2Vlay5GcmFnbWVudExvYWRlZCdcbn0pXG5cbi8qKlxuICogRXZlbnQgdHlwZSBkaXNwYXRjaGVkIGZyb20gYW5kIHNwZWNpZmljIHRvIGBSVE1QU3Vic2NyaWJlcmAuXG4gKlxuICogQHNlZSB7UlRNUFN1YnNjcmliZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBSVE1QU3Vic2NyaWJlckV2ZW50VHlwZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgRU1CRURfU1VDQ0VTUzogJ0ZsYXNoUGxheWVyLkVtYmVkLlN1Y2Nlc3MnLFxuICBFTUJFRF9GQUlMVVJFOiAnRmxhc2hQbGF5ZXIuRW1iZWQuRmFpbHVyZScsXG4gIC8vIFN0cmVhbSBNYW5hZ2VyICsgQUJSIFNwZWNpZmljXG4gIEFCUl9MRVZFTF9DSEFOR0U6ICdSVE1QLkFkYXB0aXZlQml0cmF0ZS5MZXZlbCdcbn0pXG5cbiIsIi8qKlxuICogQ29tbW9uIGV2ZW50IHR5cGVzIG9uIFNoYXJlZE9iamVjdC5cbiAqXG4gKiBAc2VlIHtSZWQ1UHJvU2hhcmVkT2JqZWN0fVxuICovXG5leHBvcnQgY29uc3QgU2hhcmVkT2JqZWN0RXZlbnRUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuICBDT05ORUNUX1NVQ0NFU1M6ICdDb25uZWN0LlN1Y2Nlc3MnLFxuICBDT05ORUNUX0ZBSUxVUkU6ICdDb25uZWN0LkZhaWx1cmUnLFxuICBQUk9QRVJUWV9VUERBVEU6ICdTaGFyZWRPYmplY3QuUHJvcGVydHlVcGRhdGUnLFxuICBQUk9QRVJUWV9SRU1PVkU6ICdTaGFyZWRPYmplY3QuUHJvcGVydHlSZW1vdmUnLFxuICBNRVRIT0RfVVBEQVRFOiAnU2hhcmVkT2JqZWN0Lk1ldGhvZFVwZGF0ZScsXG4gIENPTk5FQ1RJT05fQ0xPU0VEOiAnU2hhcmVkT2JqZWN0LkNvbm5lY3Rpb24uQ2xvc2VkJ1xufSlcblxuIiwiLyoqXG4gKiBDb21tb24gc3RhdGUgZXZlbnQgdHlwZXMgZnJvbSBhIG1lc3NhZ2UgdHJhbnNwb3J0IGxheWVyIChXZWJTb2NrZXQgb3IgUlRDRGF0YUNoYW5uZWwpLlxuICovXG5leHBvcnQgY29uc3QgTWVzc2FnZVRyYW5zcG9ydFN0YXRlRXZlbnRUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuICBPUEVOOiAnTWVzc2FnZVRyYW5zcG9ydC5PcGVuJyxcbiAgQ0xPU0U6ICdNZXNzYWdlVHJhbnNwb3J0LkNsb3NlJyxcbiAgQ0hBTkdFOiAnTWVzc2FnZVRyYW5zcG9ydC5DaGFuZ2UnLFxuICBFUlJPUjogJ01lc3NhZ2VUcmFuc3BvcnQuRXJyb3InXG59KVxuIiwiZXhwb3J0IGNvbnN0IFJUQ0NvbmZlcmVuY2VQYXJ0aWNpcGFudEV2ZW50VHlwZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgQVVESU9fU1RSRUFNOiAnQ29uZmVyZW5jZS5BdWRpb1N0cmVhbScsXG4gIFZJREVPX1NUUkVBTTogJ0NvbmZlcmVuY2UuVmlkZW9TdHJlYW0nLFxuICBNRURJQV9TVFJFQU06ICdDb25mZXJlbmNlLk1lZGlhU3RyZWFtJ1xufSlcbiIsIi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGV2ZW50cy5cbiAqL1xuY2xhc3MgRXZlbnQge1xuXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBkYXRhID0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fdHlwZSA9IHR5cGVcbiAgICB0aGlzLl9kYXRhID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIFR5cGUgYWNjZXNzb3IuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3R5cGVcbiAgfVxuXG4gIC8qKlxuICAgKiBEYXRhIHJlbGF0ZWQgdG8gZXZlbnQuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBnZXQgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFcbiAgfVxuXG59XG5cbi8qKlxuICogQmFzZSBQdWJsaXNoZXItcmVsYXRlZCBFdmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICovXG5jbGFzcyBQdWJsaXNoZXJFdmVudCBleHRlbmRzIEV2ZW50IHtcblxuICBjb25zdHJ1Y3RvciAodHlwZSwgcHVibGlzaGVyLCBkYXRhKSB7XG4gICAgc3VwZXIodHlwZSwgZGF0YSlcbiAgICB0aGlzLl9wdWJsaXNoZXIgPSBwdWJsaXNoZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgUHVibGlzaGVyIGluc3RhbmNlIHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqXG4gICAqIEBzZWUgUmVkNVByb1B1Ymxpc2hlclxuICAgKiBAc2VlIFJUQ1B1Ymxpc2hlclxuICAgKiBAc2VlIFJUTVBQdWJsaXNoZXJcbiAgICovXG4gIGdldCBwdWJsaXNoZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl9wdWJsaXNoZXJcbiAgfVxuXG59XG5cbi8qKlxuICogQmFzZSBTdWJzY3JpYmVyLXJlbGF0ZWQgRXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgU3Vic2NyaWJlckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBzdWJzY3JpYmVyLCBkYXRhKSB7XG4gICAgc3VwZXIodHlwZSwgZGF0YSlcbiAgICB0aGlzLl9zdWJzY3JpYmVyID0gc3Vic2NyaWJlclxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBTdWJzY3JpYmVyIGluc3RhbmNlIHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqXG4gICAqIEBzZWUgUmVkNVByb1N1YnNjcmliZXJcbiAgICogQHNlZSBSVENTdWJzY3JpYmVyXG4gICAqIEBzZWUgUlRNUFN1YnNjcmliZXJcbiAgICogQHNlZSBITFN1YnNjcmliZXJcbiAgICovXG4gIGdldCBzdWJzY3JpYmVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlclxuICB9XG5cbn1cblxuLyoqXG4gKiBCYXNlIFNoYXJlZE9iamVjdC1yZWxhdGVkIEV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIFNoYXJlZE9iamVjdEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBzaGFyZWRPYmplY3ROYW1lLCBkYXRhKSB7XG4gICAgc3VwZXIodHlwZSwgZGF0YSlcbiAgICB0aGlzLl9uYW1lID0gc2hhcmVkT2JqZWN0TmFtZVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBTaGFyZWQgT2JqZWN0LlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKlxuICAgKiBAc2VlIHtSZWQ1UHJvU2hhcmVkT2JqZWN0fVxuICAgKi9cbiAgZ2V0IG5hbWUgKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lXG4gIH1cblxufVxuXG4vKipcbiAqIEJhc2UgV2ViU29ja2V0UHJveHktcmVsYXRlZCBzdGF0ZSBFdmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICovXG5jbGFzcyBNZXNzYWdlVHJhbnNwb3J0U3RhdGVFdmVudCBleHRlbmRzIEV2ZW50IHtcblxuICBjb25zdHJ1Y3RvciAodHlwZSwgbmFtZSwgZGF0YSkge1xuICAgIHN1cGVyKHR5cGUsIGRhdGEpXG4gICAgdGhpcy5fbmFtZSA9IG5hbWVcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgV2ViU29ja2V0LlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKlxuICAgKiBAc2VlIHtSZWQ1UHJvU2hhcmVkT2JqZWN0fVxuICAgKi9cbiAgZ2V0IG5hbWUgKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lXG4gIH1cblxufVxuXG4vKipcbiAqIEJhc2UgUlRDQ29uZmVyZW5jZVBhcnRpY2lwYW50IHN0YXRlIEV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIFJUQ0NvbmZlcmVuY2VQYXJ0aWNpcGFudEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBwYXJ0aWNpcGFudCwgZGF0YSkge1xuICAgIHN1cGVyKHR5cGUsIGRhdGEpXG4gICAgdGhpcy5fcGFydGljaXBhbnQgPSBwYXJ0aWNpcGFudFxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBSVENDb25mZXJlbmNlUGFydGljaXBhbnQuXG4gICAqXG4gICAqIEB0eXBlIHtSVENDb25mZXJlbmNlUGFydGljaXBhbnR9XG4gICAqXG4gICAqIEBzZWUge1JUQ0NvbmZlcmVuY2VQYXJ0aWNpcGFudH1cbiAgICovXG4gIGdldCBwYXJ0aWNpcGFudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnRpY2lwYW50XG4gIH1cblxufVxuXG5leHBvcnQgeyBFdmVudCBhcyBFdmVudCB9XG5leHBvcnQgeyBQdWJsaXNoZXJFdmVudCBhcyBQdWJsaXNoZXJFdmVudCB9XG5leHBvcnQgeyBTdWJzY3JpYmVyRXZlbnQgYXMgU3Vic2NyaWJlckV2ZW50IH1cbmV4cG9ydCB7IFNoYXJlZE9iamVjdEV2ZW50IGFzIFNoYXJlZE9iamVjdEV2ZW50IH1cbmV4cG9ydCB7IE1lc3NhZ2VUcmFuc3BvcnRTdGF0ZUV2ZW50IGFzIE1lc3NhZ2VUcmFuc3BvcnRTdGF0ZUV2ZW50IH1cbmV4cG9ydCB7IFJUQ0NvbmZlcmVuY2VQYXJ0aWNpcGFudEV2ZW50IGFzIFJUQ0NvbmZlcmVuY2VQYXJ0aWNpcGFudEV2ZW50IH1cbmV4cG9ydCB7IFB1Ymxpc2hlckV2ZW50VHlwZXMgYXMgUHVibGlzaGVyRXZlbnRUeXBlcyB9IGZyb20gJy4vcHVibGlzaGVyLWV2ZW50J1xuZXhwb3J0IHsgUlRDUHVibGlzaGVyRXZlbnRUeXBlcyBhcyBSVENQdWJsaXNoZXJFdmVudFR5cGVzIH0gZnJvbSAnLi9wdWJsaXNoZXItZXZlbnQnXG5leHBvcnQgeyBSVE1QUHVibGlzaGVyRXZlbnRUeXBlcyBhcyBSVE1QUHVibGlzaGVyRXZlbnRUeXBlcyB9IGZyb20gJy4vcHVibGlzaGVyLWV2ZW50J1xuZXhwb3J0IHsgRmFpbG92ZXJQdWJsaXNoZXJFdmVudFR5cGVzIGFzIEZhaWxvdmVyUHVibGlzaGVyRXZlbnRUeXBlcyB9IGZyb20gJy4vcHVibGlzaGVyLWV2ZW50J1xuZXhwb3J0IHsgU3Vic2NyaWJlckV2ZW50VHlwZXMgYXMgU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuL3N1YnNjcmliZXItZXZlbnQnXG5leHBvcnQgeyBSVENTdWJzY3JpYmVyRXZlbnRUeXBlcyBhcyBSVENTdWJzY3JpYmVyRXZlbnRUeXBlcyB9IGZyb20gJy4vc3Vic2NyaWJlci1ldmVudCdcbmV4cG9ydCB7IFJUTVBTdWJzY3JpYmVyRXZlbnRUeXBlcyBhcyBSVE1QU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuL3N1YnNjcmliZXItZXZlbnQnXG5leHBvcnQgeyBGYWlsb3ZlclN1YnNjcmliZXJFdmVudFR5cGVzIGFzIEZhaWxvdmVyU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuL3N1YnNjcmliZXItZXZlbnQnXG5leHBvcnQgeyBTaGFyZWRPYmplY3RFdmVudFR5cGVzIGFzIFNoYXJlZE9iamVjdEV2ZW50VHlwZXMgfSBmcm9tICcuL3NoYXJlZG9iamVjdC1ldmVudCdcbmV4cG9ydCB7IE1lc3NhZ2VUcmFuc3BvcnRTdGF0ZUV2ZW50VHlwZXMgYXMgTWVzc2FnZVRyYW5zcG9ydFN0YXRlRXZlbnRUeXBlcyB9IGZyb20gJy4vbWVzc2FnZS10cmFuc3BvcnQtZXZlbnQnXG5leHBvcnQgeyBSVENDb25mZXJlbmNlUGFydGljaXBhbnRFdmVudFR5cGVzIGFzIFJUQ0NvbmZlcmVuY2VQYXJ0aWNpcGFudEV2ZW50VHlwZXMgfSBmcm9tICcuL3BhcnRpY2lwYW50LWV2ZW50J1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBFdmVudCB9IGZyb20gJy4uLy4uL2V2ZW50J1xuXG4vKipcbiAqIEV2ZW50cyBmb3IgU2xpZGVyIENvbnRyb2wuXG4gKlxuICogQHNlZSB7U2xpZGVyQ29udHJvbH1cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBTbGlkZXJFdmVudCBleHRlbmRzIEV2ZW50IHtcblxuICBjb25zdHJ1Y3RvciAodHlwZSwgY29udHJvbCwgZGF0YSkge1xuICAgIHN1cGVyKHR5cGUsIGRhdGEpXG4gICAgdGhpcy5fY29udHJvbCA9IGNvbnRyb2xcbiAgfVxuXG4gIGdldCBjb250cm9sICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udHJvbFxuICB9XG5cbn1cblxuLyoqXG4gKiBFbnVtZXJhdGlvbiBvZiBTbGlkZXIgRXZlbnQgdHlwZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgU2xpZGVyRXZlbnRUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuICBDSEFOR0VfU1RBUlQ6ICdjaGFuZ2VzdGFydCcsXG4gIENIQU5HRTogJ2NoYW5nZScsXG4gIENIQU5HRV9DT01QTEVURTogJ2NoYW5nZWNvbXBsZXRlJ1xufSlcblxuY29uc3QgU2Vla0V2ZW50VHlwZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgU0VFS19TVEFSVDogJ3NlZWtzdGFydCcsXG4gIFNFRUtfRU5EOiAnc2Vla2VuZCdcbn0pXG5cbmV4cG9ydCB7IFNsaWRlckV2ZW50IGFzIFNsaWRlckV2ZW50IH1cbmV4cG9ydCB7IFNsaWRlckV2ZW50VHlwZXMgYXMgU2xpZGVyRXZlbnRUeXBlcyB9XG5leHBvcnQgeyBTZWVrRXZlbnRUeXBlcyBhcyBTZWVrRXZlbnRUeXBlcyB9XG4iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi8uLi9jb3JlL2V2ZW50LWVtaXR0ZXInXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgeyBTbGlkZXJFdmVudCwgU2xpZGVyRXZlbnRUeXBlcyB9IGZyb20gJy4vZXZlbnQnXG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uLy4uL2xvZydcblxubGV0IE5BTUUgPSAnQ29udHJvbFNsaWRlcidcblxuLyoqXG4gKiBDdXN0b20gc2xpZGVyIGNvbnRyb2wgZm9yIFBsYXliYWNrIENvbnRyb2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENvbnRyb2xTbGlkZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gIGNvbnN0cnVjdG9yICh0eXBlKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMubmFtZSA9IFtOQU1FLCB0eXBlXS5qb2luKCc6OicpXG4gICAgZGVidWcodGhpcy5uYW1lLCAnW2luaXRdJylcbiAgICB0aGlzLl9jb250YWluZXIgPSBlbnZpcm9ubWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHRoaXMuX2J1dHRvbiA9IHRoaXMuY3JlYXRlQnV0dG9uKClcbiAgICB0aGlzLl90cmFjayA9IHRoaXMuY3JlYXRlVHJhY2soKVxuICAgIHRoaXMuX3Byb2dyZXNzQmFyID0gdGhpcy5jcmVhdGVQcm9ncmVzc0JhcigpXG4gICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3RyYWNrKVxuICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9wcm9ncmVzc0JhcilcbiAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fYnV0dG9uKVxuICAgIHRoaXMuX3ZhbHVlID0gMCAvLyAwIC0gMVxuICAgIHRoaXMuX2Rpc2FibGVkID0gZmFsc2VcbiAgICB0aGlzLl9ldmVudFN0YXJ0UG9zaXRpb24gPSAwXG4gICAgdGhpcy5fbGF5b3V0KClcbiAgICB0aGlzLl9tb3VzZXVwSGFuZGxlciA9IHRoaXMuX21vdXNldXAuYmluZCh0aGlzKVxuICAgIHRoaXMuX21vdXNlZG93bkhhbmRsZXIgPSB0aGlzLl9tb3VzZWRvd24uYmluZCh0aGlzKVxuICAgIHRoaXMuX21vdXNlbW92ZUhhbmRsZXIgPSB0aGlzLl9tb3VzZW1vdmUuYmluZCh0aGlzKVxuICAgIHRoaXMuX3RvdWNodXBIYW5kbGVyID0gdGhpcy5fdG91Y2hwcm94eS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fdG91Y2hkb3duSGFuZGxlciA9IHRoaXMuX3RvdWNocHJveHkuYmluZCh0aGlzKVxuICAgIHRoaXMuX3RvdWNobW92ZUhhbmRsZXIgPSB0aGlzLl90b3VjaHByb3h5LmJpbmQodGhpcylcbiAgICB0aGlzLl91cGRhdGVIYW5kbGVycyh0aGlzLl9kaXNhYmxlZClcbiAgfVxuXG4gIC8qKlxuICAgKiBUb3VjaCBldmVudCBwcm94eSB0byBidWJibGUgb3V0IG1vdXNlIGV2ZW50cyBmb3IgaGFuZGxpbmcgaW50ZXJhY3Rpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdG91Y2hwcm94eSAoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSB8fCAoZXZlbnQudHlwZSA9PSBcInRvdWNoZW5kXCIgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggPiAwKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGxldCBldnQgPSBlbnZpcm9ubWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudCcpXG4gICAgbGV0IHR5cGUsIHRvdWNoXG4gICAgY29uc3QgdCA9IGV2ZW50Lm9yaWdpbmFsVGFyZ2V0IHx8IGV2ZW50LnRhcmdldFxuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSAndG91Y2hzdGFydCc6XG4gICAgICAgIHR5cGUgPSAnbW91c2Vkb3duJ1xuICAgICAgICB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICd0b3VjaG1vdmUnOlxuICAgICAgICB0eXBlID0gJ21vdXNlbW92ZSdcbiAgICAgICAgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndG91Y2hlbmQnOlxuICAgICAgICB0eXBlID0gJ21vdXNldXAnXG4gICAgICAgIHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF1cbiAgICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBldnQuaW5pdE1vdXNlRXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSwgdC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LCAwLFxuICAgICAgdG91Y2guc2NyZWVuWCwgdG91Y2guc2NyZWVuWSwgdG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSxcbiAgICAgIGV2ZW50LmN0cmxLZXksIGV2ZW50LmFsdEtleSwgZXZlbnQuc2hpZnRLZXksIGV2ZW50Lm1ldGFLZXksIDAsIG51bGwpXG4gICAgdC5kaXNwYXRjaEV2ZW50KGV2dClcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBtb3VzZSB1cC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tb3VzZXVwICgpIHtcbiAgICB0aGlzLl9ldmVudFN0YXJ0UG9zaXRpb24gPSAwXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fbW91c2Vtb3ZlSGFuZGxlcilcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fbW91c2V1cEhhbmRsZXIpXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fdG91Y2htb3ZlSGFuZGxlcilcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHVwJywgdGhpcy5fdG91Y2h1cEhhbmRsZXIpXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTbGlkZXJFdmVudChTbGlkZXJFdmVudFR5cGVzLkNIQU5HRV9DT01QTEVURSwgdGhpcykpXG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgbW91c2UgbW92ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tb3VzZW1vdmUgKGV2ZW50KSB7XG4gICAgICBjb25zdCBwb3NpdGlvbk9mZnNldCA9IChlbnZpcm9ubWVudC5nZXRNb3VzZVhGcm9tRXZlbnQoZXZlbnQpIC0gdGhpcy5fZXZlbnRTdGFydFBvc2l0aW9uKVxuICAgICAgY29uc3QgcmVjdCA9IHRoaXMuX2J1dHRvbi5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICBsZXQgcG9zaXRpb24gPSAodGhpcy5fZXZlbnRTdGFydFBvc2l0aW9uICsgcG9zaXRpb25PZmZzZXQpIC0gcmVjdC5sZWZ0IC8vIC0gZW52aXJvbm1lbnQuZ2V0U2Nyb2xsWCgpXG4gICAgICBwb3NpdGlvbiA9IE1hdGgubWF4KDAsIHBvc2l0aW9uKVxuICAgICAgcG9zaXRpb24gPSBNYXRoLm1pbihwb3NpdGlvbiwgcmVjdC53aWR0aClcbiAgICAgIGxldCBwZXJjZW50YWdlID0gcG9zaXRpb24gLyByZWN0LndpZHRoXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFNsaWRlckV2ZW50KFNsaWRlckV2ZW50VHlwZXMuQ0hBTkdFLCB0aGlzLCBwZXJjZW50YWdlKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBtb3VzZSBkb3duLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21vdXNlZG93biAoZXZlbnQpIHtcbiAgICAgIHRoaXMuX2V2ZW50U3RhcnRQb3NpdGlvbiA9IGVudmlyb25tZW50LmdldE1vdXNlWEZyb21FdmVudChldmVudClcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU2xpZGVyRXZlbnQoU2xpZGVyRXZlbnRUeXBlcy5DSEFOR0VfU1RBUlQsIHRoaXMpKVxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fbW91c2Vtb3ZlSGFuZGxlcilcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9tb3VzZXVwSGFuZGxlcilcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX3RvdWNobW92ZUhhbmRsZXIpXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHVwJywgdGhpcy5fdG91Y2h1cEhhbmRsZXIpXG4gIH1cblxuICAvKipcbiAgICogQWRkcyBvciByZW1vdmVzIGNvbnRyb2wgaGFubGRlcnMgYmFzZWQgb24gZmxhZyBvZiBvdmVyYWxsIGNvbnRyb2wgYmVpbmcgZGlzYWJsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEaXNhYmxlZFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZUhhbmRsZXJzIChpc0Rpc2FibGVkKSB7XG4gICAgdGhpcy5fZXZlbnRTdGFydFBvc2l0aW9uID0gMFxuICAgIGlmIChpc0Rpc2FibGVkKSB7XG4gICAgICB0aGlzLl90cmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX21vdXNlbW92ZUhhbmRsZXIpXG4gICAgICB0aGlzLl9wcm9ncmVzc0Jhci5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX21vdXNlbW92ZUhhbmRsZXIpXG4gICAgICB0aGlzLl9idXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fbW91c2Vkb3duSGFuZGxlcilcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX21vdXNlbW92ZUhhbmRsZXIpXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fbW91c2V1cEhhbmRsZXIpXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl90b3VjaG1vdmVIYW5kbGVyKVxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2h1cCcsIHRoaXMuX3RvdWNodXBIYW5kbGVyKVxuICAgICAgdGhpcy5fdHJhY2suY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1zbGlkZXItZGlzYWJsZWQnKVxuICAgICAgdGhpcy5fcHJvZ3Jlc3NCYXIuY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1zbGlkZXItZGlzYWJsZWQnKVxuICAgICAgdGhpcy5fYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtc2xpZGVyLWRpc2FibGVkJylcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl90cmFjay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX21vdXNlbW92ZUhhbmRsZXIpXG4gICAgICB0aGlzLl9wcm9ncmVzc0Jhci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX21vdXNlbW92ZUhhbmRsZXIpXG4gICAgICB0aGlzLl9idXR0b24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fbW91c2Vkb3duSGFuZGxlcilcbiAgICAgIHRoaXMuX2J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fdG91Y2hkb3duSGFuZGxlcilcbiAgICAgIHRoaXMuX3RyYWNrLmNsYXNzTGlzdC5yZW1vdmUoJ3JlZDVwcm8tbWVkaWEtc2xpZGVyLWRpc2FibGVkJylcbiAgICAgIHRoaXMuX3Byb2dyZXNzQmFyLmNsYXNzTGlzdC5yZW1vdmUoJ3JlZDVwcm8tbWVkaWEtc2xpZGVyLWRpc2FibGVkJylcbiAgICAgIHRoaXMuX2J1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdyZWQ1cHJvLW1lZGlhLXNsaWRlci1kaXNhYmxlZCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlLWxheW91dCBzdWIgY29udHJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbGF5b3V0ICgpIHtcbiAgICBsZXQgcG9zaXRpb24gPSB0aGlzLl9wcm9ncmVzc0Jhci5wYXJlbnROb2RlLmNsaWVudFdpZHRoICogdGhpcy5fdmFsdWVcbiAgICB0aGlzLl9wcm9ncmVzc0Jhci5zdHlsZS53aWR0aCA9IHBvc2l0aW9uICsgJ3B4J1xuICAgIHRoaXMuX2J1dHRvbi5zdHlsZS5sZWZ0ID0gKHBvc2l0aW9uIC0gKHRoaXMuX2J1dHRvbi5jbGllbnRXaWR0aCAqIDAuNSkpICsgJ3B4J1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIGJ1dHRvbiBlbGVtZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlQnV0dG9uICgpIHtcbiAgICBsZXQgc3BhbiA9IGVudmlyb25tZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgIHNwYW4uY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1zbGlkZXItYnV0dG9uJylcbiAgICByZXR1cm4gc3BhblxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIHByb2dyZXNzIGJhciBlbGVtZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlUHJvZ3Jlc3NCYXIgKCkge1xuICAgIGxldCBzcGFuID0gZW52aXJvbm1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gICAgc3Bhbi5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLXNsaWRlci1wcm9ncmVzcycpXG4gICAgcmV0dXJuIHNwYW5cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSB0cmFjayBlbGVtZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlVHJhY2sgKCkge1xuICAgIGxldCBzcGFuID0gZW52aXJvbm1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gICAgc3Bhbi5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLXNsaWRlci10cmFjaycpXG4gICAgcmV0dXJuIHNwYW5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgdmFsdWUgKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSAwLi4xXG4gICAqL1xuICBzZXQgdmFsdWUgKHBlcmNlbnRWYWx1ZSAvKiAwIC0gMSAqLykge1xuICAgIHRoaXMuX3ZhbHVlID0gcGVyY2VudFZhbHVlXG4gICAgdGhpcy5fbGF5b3V0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGRpc2FibGVkIGZsYWcuXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgZGlzYWJsZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZFxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRpc2FibGVkIGZsYWcuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYm9vbFxuICAgKi9cbiAgc2V0IGRpc2FibGVkIChib29sKSB7XG4gICAgdGhpcy5fZGlzYWJsZWQgPSBib29sXG4gICAgdGhpcy5fdXBkYXRlSGFuZGxlcnMoYm9vbClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0YXJnZXQgY29udGFpbmVyIHRoaXMgY29udHJvbCBpcyBhc3NpZ25lZCB0byBpbiB0aGUgRE9NLlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgZ2V0IHZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lclxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29udHJvbFNsaWRlclxuXG4iLCIvKipcbiAqIEVudW1lcmF0aW9uIG9mIFBsYXliYWNrIFN0YXRlLlxuICpcbiAqIEBzZWUge1N1YnNjcmliZXJQbGF5YmFja0NvbnRyb2xzfVxuICovXG5leHBvcnQgY29uc3QgUGxheWJhY2tTdGF0ZSA9IE9iamVjdC5mcmVlemUoe1xuICBVTkFWQUlMQUJMRTogMTAwMCxcbiAgQVZBSUxBQkxFOiAwLFxuICBJRExFOiAxLFxuICBQTEFZSU5HOiAyLFxuICBQQVVTRUQ6IDNcbn0pXG5cbi8qKlxuICogSHVtYW4gcmVhZGFibGUgcGxheWJhY2sgc3RhdGUuXG4gKlxuICogQHNlZSB7U3Vic2NyaWJlclBsYXliYWNrQ29udHJvbHN9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgUGxheWJhY2tTdGF0ZVJlYWRhYmxlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIDEwMDA6ICdQbGF5YmFjay5VTkFWQUlMQUJMRScsXG4gIDA6ICdQbGF5YmFjay5BVkFJTEFCTEUnLFxuICAxOiAnUGxheWJhY2suSURMRScsXG4gIDI6ICdQbGF5YmFjay5QTEFZSU5HJyxcbiAgMzogJ1BsYXliYWNrLlBBVVNFRCdcbn0pXG4iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi8uLi9jb3JlL2V2ZW50LWVtaXR0ZXInXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgQ29udHJvbFNsaWRlciBmcm9tICcuL3NsaWRlcidcbmltcG9ydCB7IEV2ZW50IH0gZnJvbSAnLi4vLi4vZXZlbnQnXG5pbXBvcnQge1xuICBTbGlkZXJFdmVudFR5cGVzLFxuICBTZWVrRXZlbnRUeXBlc1xufSBmcm9tICcuL2V2ZW50J1xuaW1wb3J0IHsgUGxheWJhY2tTdGF0ZSwgUGxheWJhY2tTdGF0ZVJlYWRhYmxlIH0gZnJvbSAnLi9zdGF0ZSdcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1BsYXliYWNrQ29udHJvbHMnXG5cbi8qKlxuICogSW50ZXJmYWNlIGNvbnRyYWN0IGZvciBwbGF5YmFjayBjb250cm9sbGVyIGFjdGlvbnMuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFN1YnNjcmliZXJQbGF5YmFja0NvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBzdGFydCBwbGF5aW5nIHRoZSBzdHJlYW0uXG4gICAqL1xuICBwbGF5ICgpIHt9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCB0byBwYXVzZSBwbGF5YmFjayBvZiBzdHJlYW0uXG4gICAgICovXG4gIHBhdXNlICgpIHt9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCB0byByZXN1bWUgcGxheWJhY2sgb2Qgc3RyZWFtLlxuICAgICAqL1xuICByZXN1bWUgKCkge31cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IHRvIHN0b3AgcGxheWJhY2sgb2Ygc3RyZWFtLlxuICAgICAqL1xuICBzdG9wICgpIHt9XG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIG11dGUgdGhlIGF1ZGlvIG9mIHRoZSBzdHJlYW0uXG4gICAqL1xuICBtdXRlICgpIHt9XG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIHVubXV0ZSB0aGUgYXVkaW8gb2YgdGhlIHN0cmVhbS5cbiAgICovXG4gIHVubXV0ZSAoKSB7fVxuICAvKipcbiAgICogUmVxdWVzdCB0byBzZXQgdm9sdW1lIG9mIGF1ZGlvIG9mIHN0cmVhbS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqICAgICAgICBGcm9tIDAuLjEuXG4gICAqL1xuICBzZXRWb2x1bWUgKHZhbHVlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIHNldCBwbGF5YmFjayBwb2ludCBpbiB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogICAgICAgIEVpdGhlciB0aGUgcGVyY2VudGFnZSBvZiB0aGUgZHVyYXRpb24gKGlmIHByb3ZpZGVkKSBvciB0aGUgdGltZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb25cbiAgICogICAgICAgIE9wdGlvbmFsIGR1cmF0aW9uIG9mIHZpZGVvICh3aGVuIGtub3duIHRocm91Z2ggVk9EKSB0byB1c2UgdG8gZGV0ZXJtaW5lIHRpbWUgYmFzZWQgb24gZmlyc3QgcGFyYW0gcGFzc2VkIGFzIHBlcmNlbnRhZ2UuXG4gICAqL1xuICBzZWVrVG8gKHZhbHVlLCBkdXJhdGlvbiA9IHVuZGVmaW5lZCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAvKipcbiAgICogUmVxdWVzdCB0byB0b2dnbGUgZnVsbHNjcmVlbiBzdGF0ZS5cbiAgICovXG4gIHRvZ2dsZUZ1bGxTY3JlZW4gKCkge31cblxufVxuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgUGxheWJhY2tDb250cm9scyB1c2VkIGJ5IFN1YnNjcmliZXJzIHdpdGggYGNvbnRyb2xzYCBhbmQgYGNsYXNzPVwicmVkNXByby1tZWRpYWAgZGVmaW5lZCBvbiB0YXJnZXQgZWxlbWVudHMuIFRoaXMgaW50ZXJmYWNlIHNlcnZlcyBhcyBhIHByZXNlbnRhdGlvbiBjb250cm9sbGVyIGFuZCBwbGF5YmFjayBBUEkgZm9yIHRhcmdldCBET00gZWxlbWVudHMuXG4gKlxuICogWW91IGNhbiB1c2UgdGhpcyBhcyBhIHByb3RvdHlwZSBmb3IgY3JlYXRpbmcgYW5kIHByb3ZpZGluZyB5b3VyIG93biBjdXN0b20gUGxheWJhY2sgQ29udHJvbHMuIFRvIGRvIHNvOiBwcm92aWRlIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgQ2xhc3MgYXMgdGhlIGBjb250cm9sc2AgcHJvcGVydHkgb24gdGhlIGluaXRpYWxpemF0aW9uIGNvbmZpZ3VyYXRpb24gbWFwIHByb3ZpZGVkIGluIHRoZSBgaW5pdCgpYCBjYWxsIG9mIGEgU3Vic2NyaWJlci5cbiAqXG4gKiBUT0RPOiBGdWxseSB2ZXQgdGhlIHZpYWJpbGl0eSBvZiBkZXZlbG9wZXJzIGJlaW5nIGFkaGVyZSB0byB0aGlzIGNvbnRyYWN0IGZvciBjdXN0b20gY29udHJvbHMuXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBTdWJzY3JpYmVyUGxheWJhY2tDb250cm9scyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2b2x1bWUgbGV2ZWwuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gMC4uMVxuICAgKi9cbiAgZ2V0Vm9sdW1lICgpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZvbHVtZSBsZXZlbCBvZiBwbGF5YmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqICAgICAgICAwLi4xXG4gICAqL1xuICBzZXRWb2x1bWUgKHZhbHVlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gc2V0IHBsYXliYWNrIHBvaW50IGluIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiAgICAgICAgRWl0aGVyIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBkdXJhdGlvbiAoaWYgcHJvdmlkZWQpIG9yIHRoZSB0aW1lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvblxuICAgKiAgICAgICAgT3B0aW9uYWwgZHVyYXRpb24gb2YgdmlkZW8gKHdoZW4ga25vd24gdGhyb3VnaCBWT0QpIHRvIHVzZSB0byBkZXRlcm1pbmUgdGltZSBiYXNlZCBvbiBmaXJzdCBwYXJhbSBwYXNzZWQgYXMgcGVyY2VudGFnZS5cbiAgICovXG4gIHNldFNlZWtUaW1lICh2YWx1ZSwgZHVyYXRpb24gPSAwKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBsYXliYWNrIGR1cmF0aW9uIG9mIHRoZSBzdHJlYW0sIGlmIGF2YWlsYWJsZSBmcm9tIFZPRCAoVmlkZW8gT24gRGVtYW5kKS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqICAgICAgICBJbiBzZWNvbmRzLlxuICAgKi9cbiAgc2V0UGxheWJhY2tEdXJhdGlvbiAodmFsdWUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBwbGF5YmFjayBzdGF0ZS5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAc2VlIHtQbGF5YmFja1N0YXRlfVxuICAgKi9cbiAgZ2V0U3RhdGUgKCkge31cblxuICAvKipcbiAgICogU2V0IHRoZSBjdXJyZW50IHBsYXliYWNrIHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhdGVcbiAgICogQHNlZSB7UGxheWJhY2tTdGF0ZX1cbiAgICovXG4gIHNldFN0YXRlIChzdGF0ZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuICAgKiBTZXRzIHBsYXliYWNrIGFzIFZPRCAoVmlkZW8gT24gRGVtYW5kKSB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAqL1xuICBzZXRBc1ZPRCAodmFsdWUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgIC8qKlxuICAgKiBFbmFibGVzIGNvbnRyb2xzIGFuZCBldmVudCBoYW5kbGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVuYWJsZSAodmFsdWUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxufVxuXG4vKipcbiAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYFN1YnNjcmliZXJQbGF5YmFja0NvbnRyb2xzYCB1c2VkIGludGVybmFsbHkgaW4gdGhlIFNESy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBTdWJzY3JpYmVyUGxheWJhY2tDb250cm9sc0ltcGwgZXh0ZW5kcyBTdWJzY3JpYmVyUGxheWJhY2tDb250cm9scyB7XG5cbiAgY29uc3RydWN0b3IgKHBsYXllciwgY29udGFpbmVyKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMucGxheWVyID0gcGxheWVyXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXJcbiAgICB0aGlzLl9jb250cm9sYmFyID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcGxheVBhdXNlQnV0dG9uID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fbXV0ZUJ1dHRvbiA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3ZvbHVtZUZpZWxkID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fc2Vla1RpbWVGaWVsZCA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3RpbWVGaWVsZCA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2Z1bGxTY3JlZW5CdXR0b24gPSB1bmRlZmluZWRcbiAgICB0aGlzLl9zdGF0ZSA9IFBsYXliYWNrU3RhdGUuSURMRVxuICAgIHRoaXMuX211dGVkU3RhdGUgPSBmYWxzZVxuICAgIHRoaXMuX3Jlc3VtZUFmdGVyU2VlayA9IGZhbHNlXG4gICAgdGhpcy5fcGxheWJhY2tEdXJhdGlvbiA9IDBcbiAgICB0aGlzLl92b2x1bWVWYWx1ZSA9IDFcbiAgICB0aGlzLl9vblBsYXlQYXVzZUNsaWNrQm91bmQgPSB0aGlzLl9vblBsYXlQYXVzZUNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLmRlY29yYXRlKHRoaXMuY29udGFpbmVyKVxuICB9XG5cbiAgLyoqXG4gICAqIERlY29yYXRlcyB0YXJnZXQgY29udGFpbmVyIHdpdGggcGxheWJhY2sgY29udHJvbCBlbGVtZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXJcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlY29yYXRlIChjb250YWluZXIpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2RlY29yYXRlXScpXG4gICAgbGV0IGNvbnRyb2xiYXIgPSBlbnZpcm9ubWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIGNvbnRyb2xiYXIuY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1jb250cm9sLWJhcicpXG4gICAgdGhpcy5fcGxheVBhdXNlQnV0dG9uID0gdGhpcy5fY3JlYXRlUGxheVBhdXNlQnV0dG9uKClcbiAgICB0aGlzLl9tdXRlQnV0dG9uID0gdGhpcy5fY3JlYXRlTXV0ZUJ1dHRvbigpXG4gICAgdGhpcy5fdm9sdW1lRmllbGQgPSB0aGlzLl9jcmVhdGVWb2x1bWVDb250cm9sKClcbiAgICB0aGlzLl9zZWVrVGltZUZpZWxkID0gdGhpcy5fY3JlYXRlU2Vla0NvbnRyb2woKVxuICAgIHRoaXMuX3RpbWVGaWVsZCA9IHRoaXMuX2NyZWF0ZVBsYXliYWNrVGltZSgpXG4gICAgdGhpcy5fZnVsbFNjcmVlbkJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUZ1bGxTY3JlZW5Ub2dnbGUoKVxuICAgIGNvbnRyb2xiYXIuYXBwZW5kQ2hpbGQodGhpcy5fcGxheVBhdXNlQnV0dG9uKVxuICAgIGNvbnRyb2xiYXIuYXBwZW5kQ2hpbGQodGhpcy5fdGltZUZpZWxkKVxuICAgIGNvbnRyb2xiYXIuYXBwZW5kQ2hpbGQodGhpcy5fc2Vla1RpbWVGaWVsZC52aWV3KVxuICAgIGNvbnRyb2xiYXIuYXBwZW5kQ2hpbGQodGhpcy5fbXV0ZUJ1dHRvbilcbiAgICBjb250cm9sYmFyLmFwcGVuZENoaWxkKHRoaXMuX3ZvbHVtZUZpZWxkLnZpZXcpXG4gICAgY29udHJvbGJhci5hcHBlbmRDaGlsZCh0aGlzLl9mdWxsU2NyZWVuQnV0dG9uKVxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250cm9sYmFyKVxuICAgIHRoaXMuX2NvbnRyb2xiYXIgPSBjb250cm9sYmFyXG5cbiAgICBsZXQgY29udHJvbEJhck9mZlxuICAgIGNvbnN0IGRlbGF5Q29udHJvbEJhck9mZiA9ICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dChjb250cm9sQmFyT2ZmKVxuICAgICAgY29udHJvbEJhck9mZiA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb250cm9sYmFyLmNsYXNzTGlzdC5yZW1vdmUoJ3JlZDVwcm8tbWVkaWEtY29udHJvbC1iYXItc2hvdycpXG4gICAgICB9LCA2MDAwKVxuICAgIH1cblxuICAgIGlmIChlbnZpcm9ubWVudC5pc1RvdWNoRW5hYmxlZCgpKSB7XG4gICAgICBjb250cm9sYmFyLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtY29udHJvbC1iYXItc2hvdycpXG4gICAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsICgpID0+IHtcbiAgICAgICAgY29udHJvbGJhci5jbGFzc0xpc3QudG9nZ2xlKCdyZWQ1cHJvLW1lZGlhLWNvbnRyb2wtYmFyLXNob3cnKVxuICAgICAgICBkZWxheUNvbnRyb2xCYXJPZmYoKVxuICAgICAgfSlcbiAgICAgIGRlbGF5Q29udHJvbEJhck9mZigpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgKCkgPT4ge1xuICAgICAgICBjb250cm9sYmFyLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtY29udHJvbC1iYXItc2hvdycpXG4gICAgICB9KVxuICAgICAgdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnRyb2xiYXIuY2xhc3NMaXN0LnJlbW92ZSgncmVkNXByby1tZWRpYS1jb250cm9sLWJhci1zaG93JylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZShQbGF5YmFja1N0YXRlLklETEUpXG4gICAgICAub25GdWxsU2NyZWVuQ2hhbmdlKGZhbHNlKVxuICAgICAgLnNldFNlZWtUaW1lKDApXG4gICAgICAuZW5hYmxlKGZhbHNlKVxuICB9XG5cbiAgLyoqXG4gICAqIENsaWNrIGhhbmRsZXIgZm9yIHBsYXkvcGF1c2UgY29udHJvbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblBsYXlQYXVzZUNsaWNrICgpIHtcbiAgICBpZiAodGhpcy5nZXRTdGF0ZSgpID09PSBQbGF5YmFja1N0YXRlLlBMQVlJTkcpIHtcbiAgICAgIHRoaXMucGxheWVyLnBhdXNlKHRydWUpXG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuZ2V0U3RhdGUoKSA9PT0gUGxheWJhY2tTdGF0ZS5QQVVTRUQpIHtcbiAgICAgIHRoaXMucGxheWVyLnJlc3VtZSh0cnVlKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyLnBsYXkodHJ1ZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBwbGF5L3BhdXNlIGNvbnRyb2wuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlUGxheVBhdXNlQnV0dG9uICgpIHtcbiAgICBsZXQgYnV0dG9uID0gZW52aXJvbm1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJylcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgJ1RvZ2dsZSBQbGF5YmFjaycpXG4gICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtY29udHJvbC1lbGVtZW50JylcbiAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1lbGVtZW50LWJ1dHRvbicpXG4gICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtcGxheXBhdXNlLWJ1dHRvbicpXG4gICAgcmV0dXJuIGJ1dHRvblxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbXV0ZS91bm11dGUgY29udHJvbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jcmVhdGVNdXRlQnV0dG9uICgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIGxldCBidXR0b24gPSBlbnZpcm9ubWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKVxuICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCAnVG9nZ2xlIE11dGUgQXVkaW8nKVxuICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLWNvbnRyb2wtZWxlbWVudCcpXG4gICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtZWxlbWVudC1idXR0b24nKVxuICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLW11dGV1bm11dGUtYnV0dG9uJylcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICBpZiAoc2VsZi5nZXRNdXRlZFN0YXRlKCkpIHtcbiAgICAgICAgc2VsZi5wbGF5ZXIudW5tdXRlKClcbiAgICAgICAgc2VsZi5zZXRNdXRlZFN0YXRlKGZhbHNlKVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGYucGxheWVyLm11dGUoKVxuICAgICAgICBzZWxmLnNldE11dGVkU3RhdGUodHJ1ZSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBidXR0b25cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHZvbHVtZSBjb250cm9sLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZVZvbHVtZUNvbnRyb2wgKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgbGV0IHNsaWRlciA9IG5ldyBDb250cm9sU2xpZGVyKCd2b2x1bWUnKVxuICAgIHNsaWRlci52aWV3LmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtY29udHJvbC1lbGVtZW50JylcbiAgICBzbGlkZXIudmlldy5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLXZvbHVtZS1zbGlkZXInKVxuICAgIHNsaWRlci52aWV3LmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtc2xpZGVyJylcbiAgICBzbGlkZXIub24oU2xpZGVyRXZlbnRUeXBlcy5DSEFOR0UsIChldmVudCkgPT4ge1xuICAgICAgY29uc3QgcGVyY2VudGFnZSA9IE51bWJlcihldmVudC5kYXRhKVxuICAgICAgc2VsZi5wbGF5ZXIuc2V0Vm9sdW1lKHBlcmNlbnRhZ2UpXG4gICAgfSlcbiAgICByZXR1cm4gc2xpZGVyXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBzZWVrIGNvbnRyb2wuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlU2Vla0NvbnRyb2wgKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgbGV0IHNsaWRlciA9IG5ldyBDb250cm9sU2xpZGVyKCdzZWVrJylcbiAgICBzbGlkZXIudmlldy5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLWNvbnRyb2wtZWxlbWVudCcpXG4gICAgc2xpZGVyLnZpZXcuY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1zZWVrdGltZS1zbGlkZXInKVxuICAgIHNsaWRlci52aWV3LmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtc2xpZGVyJylcbiAgICBzbGlkZXIub24oU2xpZGVyRXZlbnRUeXBlcy5DSEFOR0VfU1RBUlQsICgpID0+IHtcbiAgICAgIGlmIChzZWxmLmdldFN0YXRlKCkgPT09IFBsYXliYWNrU3RhdGUuUExBWUlORykge1xuICAgICAgICBzZWxmLl9yZXN1bWVBZnRlclNlZWsgPSB0cnVlXG4gICAgICAgIHNlbGYucGxheWVyLnBhdXNlKHRydWUsIHRydWUpXG4gICAgICB9XG4gICAgICBzZWxmLnRyaWdnZXIobmV3IEV2ZW50KFNlZWtFdmVudFR5cGVzLlNFRUtfU1RBUlQpKVxuICAgIH0pXG4gICAgc2xpZGVyLm9uKFNsaWRlckV2ZW50VHlwZXMuQ0hBTkdFLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSBOdW1iZXIoZXZlbnQuZGF0YSlcbiAgICAgIHNlbGYucGxheWVyLnNlZWtUbyhwZXJjZW50YWdlLCBzZWxmLl9wbGF5YmFja0R1cmF0aW9uID09PSAwID8gdW5kZWZpbmVkOiBzZWxmLl9wbGF5YmFja0R1cmF0aW9uKVxuICAgICAgc2VsZi5zZXRTZWVrVGltZShwZXJjZW50YWdlICogc2VsZi5fcGxheWJhY2tEdXJhdGlvbiwgc2VsZi5fcGxheWJhY2tEdXJhdGlvbilcbiAgICB9KVxuICAgIHNsaWRlci5vbihTbGlkZXJFdmVudFR5cGVzLkNIQU5HRV9DT01QTEVURSwgKCkgPT4ge1xuICAgICAgaWYgKHNlbGYuX3Jlc3VtZUFmdGVyU2VlayAmJiBzZWxmLmdldFN0YXRlKCkgPT09IFBsYXliYWNrU3RhdGUuUEFVU0VEKSB7XG4gICAgICAgIHNlbGYuX3Jlc3VtZUFmdGVyU2VlayA9IGZhbHNlXG4gICAgICAgIHNlbGYucGxheWVyLnJlc3VtZSh0cnVlLCB0cnVlKVxuICAgICAgfVxuICAgICAgc2VsZi50cmlnZ2VyKG5ldyBFdmVudChTZWVrRXZlbnRUeXBlcy5TRUVLX0VORCkpXG4gICAgfSlcbiAgICByZXR1cm4gc2xpZGVyXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBwbGF5YmFjayB0aW1lIGZpZWxkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZVBsYXliYWNrVGltZSAoKSB7XG4gICAgbGV0IHNwYW4gPSBlbnZpcm9ubWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgICBsZXQgdGV4dCA9IGVudmlyb25tZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHQnLCAnaGVsbG8hJylcbiAgICBzcGFuLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtY29udHJvbC1lbGVtZW50JylcbiAgICBzcGFuLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtdGltZS1maWVsZCcpXG4gICAgc3Bhbi5hcHBlbmRDaGlsZCh0ZXh0KVxuICAgIHJldHVybiBzcGFuXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGZ1bGxzY3JlZW4gdG9nZ2xlIGNvbnRyb2wuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlRnVsbFNjcmVlblRvZ2dsZSAoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICBsZXQgYnV0dG9uID0gZW52aXJvbm1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJylcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgJ1RvZ2dsZSBGdWxsc2NyZWVuJylcbiAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1jb250cm9sLWVsZW1lbnQnKVxuICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLWVsZW1lbnQtYnV0dG9uJylcbiAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1mdWxsc2NyZWVuLWJ1dHRvbicpXG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgc2VsZi5wbGF5ZXIudG9nZ2xlRnVsbFNjcmVlbigpXG4gICAgfSlcbiAgICByZXR1cm4gYnV0dG9uXG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyBjb250cm9scyBhbmQgZXZlbnQgaGFuZGxlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbmFibGUgKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLl9wbGF5UGF1c2VCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgncmVkNXByby1tZWRpYS1lbGVtZW50LWJ1dHRvbi1kaXNhYmxlZCcpXG4gICAgICB0aGlzLl9wbGF5UGF1c2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vblBsYXlQYXVzZUNsaWNrQm91bmQpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fcGxheVBhdXNlQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtZWxlbWVudC1idXR0b24tZGlzYWJsZWQnKVxuICAgICAgdGhpcy5fcGxheVBhdXNlQnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25QbGF5UGF1c2VDbGlja0JvdW5kKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtYXRzIHRoZSB0aW1lIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge3ZhbHVlfSBOdW1iZXJcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZm9ybWF0VGltZSAodmFsdWUpIHtcbiAgICBsZXQgaHJzID0gMFxuICAgIGxldCBtaW5zID0gKHZhbHVlID09PSAwIHx8IGlzTmFOKHZhbHVlKSkgPyAwIDogcGFyc2VJbnQodmFsdWUgLyA2MClcbiAgICBsZXQgc2VjcyA9IDBcbiAgICBpZiAobWlucyA+PSA2MCkge1xuICAgICAgaHJzID0gcGFyc2VJbnQobWlucyAvIDYwKVxuICAgICAgbWlucyA9IG1pbnMgJSA2MFxuICAgIH1cbiAgICBzZWNzID0gKHZhbHVlID09PSAwIHx8IGlzTmFOKHZhbHVlKSkgPyAwIDogcGFyc2VJbnQodmFsdWUgJSA2MClcblxuICAgIGxldCBmb3JtYXR0ZWRBcnIgPSAoaHJzIDwgMTApID8gWycwJyArIGhyc10gOiBbaHJzXVxuICAgIGZvcm1hdHRlZEFyci5wdXNoKChtaW5zIDwgMTApID8gWycwJyArIG1pbnNdIDogW21pbnNdKVxuICAgIGZvcm1hdHRlZEFyci5wdXNoKChzZWNzIDwgMTApID8gWycwJyArIHNlY3NdIDogW3NlY3NdKVxuICAgIHJldHVybiBmb3JtYXR0ZWRBcnIuam9pbignOicpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdm9sdW1lIGxldmVsLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IDAuLjFcbiAgICovXG4gIGdldFZvbHVtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZvbHVtZVZhbHVlXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdm9sdW1lIGxldmVsIG9mIHBsYXliYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogICAgICAgIDAuLjFcbiAgICovXG4gIHNldFZvbHVtZSAodmFsdWUpIHtcbiAgICB0aGlzLl92b2x1bWVGaWVsZC52YWx1ZSA9IHZhbHVlXG4gICAgdGhpcy5fdm9sdW1lVmFsdWUgPSB2YWx1ZVxuICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgdGhpcy5zZXRNdXRlZFN0YXRlKHRydWUpXG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuZ2V0TXV0ZWRTdGF0ZSgpKSB7XG4gICAgICB0aGlzLnNldE11dGVkU3RhdGUoZmFsc2UpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBzZXQgcGxheWJhY2sgcG9pbnQgaW4gdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqICAgICAgICBFaXRoZXIgdGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGR1cmF0aW9uIChpZiBwcm92aWRlZCkgb3IgdGhlIHRpbWUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uXG4gICAqICAgICAgICBPcHRpb25hbCBkdXJhdGlvbiBvZiB2aWRlbyAod2hlbiBrbm93biB0aHJvdWdoIFZPRCkgdG8gdXNlIHRvIGRldGVybWluZSB0aW1lIGJhc2VkIG9uIGZpcnN0IHBhcmFtIHBhc3NlZCBhcyBwZXJjZW50YWdlLlxuICAgKi9cbiAgc2V0U2Vla1RpbWUgKHZhbHVlLCBsZW5ndGggPSAwKSB7XG4gICAgdGhpcy5fc2Vla1RpbWVGaWVsZC52YWx1ZSA9IGxlbmd0aCA9PT0gMCA/IDAgOiAodmFsdWUvbGVuZ3RoKVxuICAgIGlmICh0aGlzLl9wbGF5YmFja0R1cmF0aW9uICE9PSAwICYmIHBhcnNlSW50KHRoaXMuX3BsYXliYWNrRHVyYXRpb24pIDw9IHBhcnNlSW50KHZhbHVlKSkge1xuICAgICAgdGhpcy5fc2Vla1RpbWVGaWVsZC52YWx1ZSA9IDFcbiAgICB9XG4gICAgdGhpcy5fdGltZUZpZWxkLmlubmVyVGV4dCA9IHRoaXMuZm9ybWF0VGltZShNYXRoLmZsb29yKHZhbHVlKSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBsYXliYWNrIGR1cmF0aW9uIG9mIHRoZSBzdHJlYW0sIGlmIGF2YWlsYWJsZSBmcm9tIFZPRCAoVmlkZW8gT24gRGVtYW5kKS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqICAgICAgICBJbiBzZWNvbmRzLlxuICAgKi9cbiAgc2V0UGxheWJhY2tEdXJhdGlvbiAodmFsdWUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3NldHBsYXliYWNrZHVyYXRpb25dOiAnICsgdmFsdWUpXG4gICAgdGhpcy5fcGxheWJhY2tEdXJhdGlvbiA9IHZhbHVlXG4gIH1cblxuICBnZXRQbGF5YmFja0R1cmF0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGxheWJhY2tEdXJhdGlvblxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcGxheWJhY2sgc3RhdGUuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogQHNlZSB7UGxheWJhY2tTdGF0ZX1cbiAgICovXG4gIGdldFN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGVcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGN1cnJlbnQgcGxheWJhY2sgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0ZVxuICAgKiBAc2VlIHtQbGF5YmFja1N0YXRlfVxuICAgKi9cbiAgc2V0U3RhdGUgKHN0YXRlKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tzZXRTdGF0ZV06ICcgKyBQbGF5YmFja1N0YXRlUmVhZGFibGVbc3RhdGVdKVxuICAgIHRoaXMuX3N0YXRlID0gc3RhdGVcbiAgICB0aGlzLm9uU3RhdGVDaGFuZ2UodGhpcy5fc3RhdGUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBwbGF5YmFjayBiZWluZyBtdXRlZC5cbiAgICogVGhpcyBkaWZmZXJzIGZyb20ganVzdCB0aGUgdm9sdW1lIGxldmVsIGJlaW5nIDAuIFRoZSBjb250cm9scyBjYW4gYmUgbXV0ZWQsIGJ1dCBoYXZlIGEgdm9sdW1lIGxldmVsIGdyZWF0ZXIgdGhhbiAwIC0gbWVhbmluZywgdW5tdXRlIHdpbGwgcmV0dXJuIGJhY2sgdG8gdGhlIHZvbHVtZSBsZXZlbCBwcmV2aW91c2x5IHNldC5cbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGdldE11dGVkU3RhdGUgKCkge1xuICAgIHJldHVybiAoJ211dGVkJyBpbiB0aGlzLnBsYXllcikgPyB0aGlzLnBsYXllci5tdXRlZCA6IHRoaXMuX211dGVkU3RhdGVcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtdXRlZCBzdGF0ZSBvZiB0aGUgcGxheWJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RhdGVcbiAgICovXG4gIHNldE11dGVkU3RhdGUgKHN0YXRlKSB7XG4gICAgdGhpcy5fbXV0ZWRTdGF0ZSA9IHN0YXRlXG4gICAgdGhpcy5vbk11dGVkU3RhdGVDaGFuZ2UodGhpcy5fbXV0ZWRTdGF0ZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXIgZm9yIGNoYW5nZSBpbiBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXRlXG4gICAqICAgICAgICBUaGUgUGxheWJhY2tTdGF0ZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25TdGF0ZUNoYW5nZSAoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgPT09IFBsYXliYWNrU3RhdGUuUExBWUlORykge1xuICAgICAgdGhpcy5fcGxheVBhdXNlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ3JlZDVwcm8tbWVkaWEtcGxheS1idXR0b24nKVxuICAgICAgdGhpcy5fcGxheVBhdXNlQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtcGF1c2UtYnV0dG9uJylcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9wbGF5UGF1c2VCdXR0b24uY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1wbGF5LWJ1dHRvbicpXG4gICAgICB0aGlzLl9wbGF5UGF1c2VCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgncmVkNXByby1tZWRpYS1wYXVzZS1idXR0b24nKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXIgZm9yIGNoYW5nZSBpbiBtdXRlIHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN0YXRlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbk11dGVkU3RhdGVDaGFuZ2UgKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICB0aGlzLl9tdXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtbXV0ZS1idXR0b24nKVxuICAgICAgdGhpcy5fbXV0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdyZWQ1cHJvLW1lZGlhLXVubXV0ZS1idXR0b24nKVxuICAgICAgdGhpcy5fdm9sdW1lRmllbGQudmFsdWUgPSAwXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fbXV0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdyZWQ1cHJvLW1lZGlhLW11dGUtYnV0dG9uJylcbiAgICAgIHRoaXMuX211dGVCdXR0b24uY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS11bm11dGUtYnV0dG9uJylcbiAgICAgIHRoaXMuX3ZvbHVtZUZpZWxkLnZhbHVlID0gdGhpcy5fdm9sdW1lVmFsdWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlciBmb3IgY2hhbmdlIGluIGZ1bGxzY3JlZW4gc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNGdWxsU2NyZWVuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbkZ1bGxTY3JlZW5DaGFuZ2UgKGlzRnVsbFNjcmVlbikge1xuICAgIGlmIChpc0Z1bGxTY3JlZW4pIHtcbiAgICAgIHRoaXMuX2Z1bGxTY3JlZW5CdXR0b24uY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1leGl0LWZ1bGxzY3JlZW4tYnV0dG9uJylcbiAgICAgIHRoaXMuX2Z1bGxTY3JlZW5CdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgncmVkNXByby1tZWRpYS1mdWxsc2NyZWVuLWJ1dHRvbicpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fZnVsbFNjcmVlbkJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdyZWQ1cHJvLW1lZGlhLWV4aXQtZnVsbHNjcmVlbi1idXR0b24nKVxuICAgICAgdGhpcy5fZnVsbFNjcmVlbkJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLWZ1bGxzY3JlZW4tYnV0dG9uJylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHBsYXliYWNrIGFzIFZPRCAoVmlkZW8gT24gRGVtYW5kKSB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAqL1xuICBzZXRBc1ZPRCAoaXNWT0QpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3NldEFzVk9EXTogJyArIGlzVk9EKVxuICAgIGlmICghaXNWT0QpIHtcbiAgICAgIHRoaXMuX3NlZWtUaW1lRmllbGQudmFsdWUgPSAwXG4gICAgICB0aGlzLl9zZWVrVGltZUZpZWxkLmRpc2FibGVkID0gdHJ1ZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3NlZWtUaW1lRmllbGQuZGlzYWJsZWQgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGRldGFjaCB0aGUgY29udHJvbCBiYXIgdG8gcHJvdmlkZWQgY29udGFpbmVyLlxuICAgKi9cbiAgZGV0YWNoICgpIHtcbiAgICB0aGlzLmVuYWJsZShmYWxzZSlcbiAgICBpZiAodGhpcy5fY29udHJvbGJhciAmJiB0aGlzLl9jb250cm9sYmFyLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuX2NvbnRyb2xiYXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9jb250cm9sYmFyKVxuICAgIH1cbiAgICB0aGlzLl9jb250cm9sYmFyID0gdW5kZWZpbmVkXG4gICAgdGhpcy5jb250YWluZXIgPSB1bmRlZmluZWRcbiAgfVxuXG59XG5cbmV4cG9ydCBjb25zdCBQbGF5YmFja0NvbnRyb2xsZXIgPSBTdWJzY3JpYmVyUGxheWJhY2tDb250cm9sbGVyXG5leHBvcnQgY29uc3QgUGxheWJhY2tDb250cm9scyA9IFN1YnNjcmliZXJQbGF5YmFja0NvbnRyb2xzXG5leHBvcnQgY29uc3QgUGxheWJhY2tDb250cm9sc0ltcGwgPSBTdWJzY3JpYmVyUGxheWJhY2tDb250cm9sc0ltcGxcblxuIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCB7IFBsYXliYWNrQ29udHJvbGxlciwgUGxheWJhY2tDb250cm9sc0ltcGwgfSBmcm9tICcuL2NvbnRyb2xzJ1xuaW1wb3J0IHsgUGxheWJhY2tTdGF0ZSwgUGxheWJhY2tTdGF0ZVJlYWRhYmxlIH0gZnJvbSAnLi9jb250cm9scy9zdGF0ZSdcbmltcG9ydCB7IFN1YnNjcmliZXJFdmVudCwgU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IGRlYnVnLCBlcnJvciwgd2FybiB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSVENTb3VyY2VIYW5kbGVyJ1xuXG4vKipcbiAqIFNvdXJjZSBIYW5kbGVyIGZvciBXZWJSVEMtYmFzZWQgU3Vic2NyaWJlcnMsIHdoaWNoIHNlcnZlcyBhcyBhIFByZXNlbnRhdGlvbiBDb250cm9sbGVyIGJldHdlZW4gdmlldyBhbmQgc3Vic2NyaWJlci5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqIEBleHRlbmRzIFN1YnNjcmliZXJQbGF5YmFja0NvbnRyb2xsZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBSVENTb3VyY2VIYW5kbGVyIGV4dGVuZHMgUGxheWJhY2tDb250cm9sbGVyIHtcblxuICBjb25zdHJ1Y3RvciAobWVkaWEsIHR5cGUpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5tZWRpYSA9IG1lZGlhXG4gICAgY29uc3QgdXNlUGxheWJhY2tDb250cm9scyA9IGVudmlyb25tZW50Lmhhc0F0dHJpYnV0ZURlZmluZWQodGhpcy5tZWRpYSwgJ2NvbnRyb2xzJykgJiYgZW52aXJvbm1lbnQuaGFzQ2xhc3NEZWZpbmVkKHRoaXMubWVkaWEsICdyZWQ1cHJvLW1lZGlhJylcbiAgICBpZiAodXNlUGxheWJhY2tDb250cm9scykge1xuICAgICAgdGhpcy5jbG9uZSA9IHRoaXMubWVkaWEuY2xvbmVOb2RlKHRydWUpXG4gICAgICB0aGlzLnBhcmVudCA9IHRoaXMubWVkaWEucGFyZW50Tm9kZVxuICAgICAgdGhpcy5ob2xkZXIgPSB0aGlzLl9kZXRlcm1pbmVIb2xkZXIodGhpcy5tZWRpYSlcbiAgICB9XG4gICAgdGhpcy5wbGF5ZXJUeXBlID0gdHlwZVxuICAgIHRoaXMuX2lzVk9EID0gZmFsc2VcbiAgICB0aGlzLl9jb250cm9scyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3BsYXliYWNrTm90aWZpY2F0aW9uQ2VudGVyID0gdGhpcy5tZWRpYVxuICAgIGVudmlyb25tZW50Lm9uRnVsbFNjcmVlblN0YXRlQ2hhbmdlKHRoaXMuX2hhbmRsZUZ1bGxTY3JlZW5DaGFuZ2UuYmluZCh0aGlzKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFc3RhYmxpc2hlZCBET00gRWxlbWVudCBvcmRlciBmb3IgcGxheWJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbWVkaWFcbiAgICogICAgICAgIFRoZSB0YXJnZXQgbWVkaWEgZWxlbWVudDogZS5nLiwgYHZpZGVvYCBvciBgYXVkaW9gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RldGVybWluZUhvbGRlciAobWVkaWEpIHtcbiAgICBpZiAobWVkaWEucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ3JlZDVwcm8tbWVkaWEtY29udGFpbmVyJykpIHtcbiAgICAgIHJldHVybiBtZWRpYS5wYXJlbnROb2RlXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgcGFyZW50ID0gbWVkaWEucGFyZW50Tm9kZVxuICAgICAgY29uc3QgZGl2ID0gZW52aXJvbm1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLWNvbnRhaW5lcicpXG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGRpdiwgbWVkaWEpXG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobWVkaWEpXG4gICAgICBkaXYuYXBwZW5kQ2hpbGQobWVkaWEpXG4gICAgICByZXR1cm4gZGl2XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVzdGFibGlzaGVkIERPTSBFbGVtZW50IG9yZGVyIGZvciBwbGF5YmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBtZWRpYVxuICAgKiAgICAgICAgVGhlIHRhcmdldCBtZWRpYSBlbGVtZW50OiBlLmcuLCBgdmlkZW9gIG9yIGBhdWRpb2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2xlYW5VcCAoKSB7XG4gICAgaWYgKCF0aGlzLmNsb25lKSByZXR1cm5cblxuICAgIC8vIFJldHVybiB0byBwcmlvciBET00gbWFuaXB1bGF0aW9uLlxuICAgIGxldCBlbCA9IHRoaXMubWVkaWFcbiAgICBsZXQgZWxQYXJlbnQgPSBlbC5wYXJlbnROb2RlXG4gICAgbGV0IG1lZGlhSG9sZGVyID0gdGhpcy5ob2xkZXJcbiAgICBpZiAoZWxQYXJlbnQpIHtcbiAgICAgIGVsUGFyZW50LnJlbW92ZUNoaWxkKGVsKVxuICAgICAgLy8gVGhlIG9iamVjdCBwYXJlbnQgY291bGQgYmUgYSB3cmFwcGVyIGNoaWxkIGluIHRoZSBvcmlnaW5hbCBwYXJlbnQgZWxlbWVudC5cbiAgICAgIGlmIChlbFBhcmVudCAhPT0gdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgZWxQYXJlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbFBhcmVudClcbiAgICAgICAgbWVkaWFIb2xkZXIgPSB0aGlzLnBhcmVudFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBlbC5yZW1vdmUoKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB3YXJuKE5BTUUsIGBJc3N1ZSBpbiBET00gY2xlYW51cCBvZiBXZWJSVEMgdmlkZW8gb2JqZWN0OiAke2UubWVzc2FnZX1gKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1lZGlhID0gdGhpcy5jbG9uZS5jbG9uZU5vZGUodHJ1ZSlcbiAgICBtZWRpYUhvbGRlci5hcHBlbmRDaGlsZCh0aGlzLm1lZGlhKVxuICAgIGlmICh0aGlzLl9jb250cm9scykge1xuICAgICAgdGhpcy5fY29udHJvbHMuZGV0YWNoKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXNzaWducyBhbmQgaGFuZGxlcnMgZXZlbnQgbm90aWZpY2lhdGlvbnMgY29taW5nIGZyb20gdGhlIG1lZGlhIG5vdGlmaWVyIChlLmcuLCBgdmlkZW9gIG9yIGBhdWRpb2AgZWxlbWVudCkuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBub3RpZmllclxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FkZFBsYXliYWNrSGFuZGxlcnMgKG5vdGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJvbHMgPSB0aGlzLmdldENvbnRyb2xzKClcbiAgICBjb25zdCBoYXNDb250cm9scyA9IHR5cGVvZiBjb250cm9scyAhPT0gJ3VuZGVmaW5lZCdcblxuICAgIG5vdGlmaWVyLm9uY2FucGxheSA9ICgpID0+IHtcbiAgICAgIGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmV2ZW50XSBjYW5wbGF5JylcbiAgICAgIGlmIChjb250cm9scykge1xuICAgICAgICBjb250cm9scy5lbmFibGUodHJ1ZSlcbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlBMQVlCQUNLX1NUQVRFX0NIQU5HRSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGNvZGU6IFBsYXliYWNrU3RhdGUuQVZBSUxBQkxFLFxuICAgICAgICBzdGF0ZTogUGxheWJhY2tTdGF0ZVJlYWRhYmxlW1BsYXliYWNrU3RhdGUuQVZBSUxBQkxFXVxuICAgICAgfSkpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5WT0xVTUVfQ0hBTkdFLCB1bmRlZmluZWQsIHtcbiAgICAgICAgdm9sdW1lOiBub3RpZmllci52b2x1bWVcbiAgICAgIH0pKVxuICAgIH1cbiAgICBub3RpZmllci5vbmR1cmF0aW9uY2hhbmdlID0gKGV2ZW50KSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmV2ZW50XSBkdXJhdGlvbmNoYW5nZScpXG4gICAgICBpZiAoIWlzTmFOKG5vdGlmaWVyLmR1cmF0aW9uKSAmJiBOdW1iZXIuaXNGaW5pdGUobm90aWZpZXIuZHVyYXRpb24pKSB7XG4gICAgICAgIHRoaXMuaXNWT0QgPSB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoaGFzQ29udHJvbHMpIHtcbiAgICAgICAgY29udHJvbHMuc2V0UGxheWJhY2tEdXJhdGlvbihub3RpZmllci5kdXJhdGlvbilcbiAgICAgIH1cbiAgICB9XG4gICAgbm90aWZpZXIub25lbmRlZCA9ICgpID0+IHtcbiAgICAgIGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmV2ZW50XSBlbmRlZCcpXG4gICAgICBpZiAoaGFzQ29udHJvbHMpIHtcbiAgICAgICAgY29udHJvbHMuc2V0U3RhdGUoUGxheWJhY2tTdGF0ZS5JRExFKVxuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuUExBWUJBQ0tfU1RBVEVfQ0hBTkdFLCB1bmRlZmluZWQsIHtcbiAgICAgICAgY29kZTogUGxheWJhY2tTdGF0ZS5JRExFLFxuICAgICAgICBzdGF0ZTogUGxheWJhY2tTdGF0ZVJlYWRhYmxlW1BsYXliYWNrU3RhdGUuSURMRV1cbiAgICAgIH0pKVxuICAgIH1cbiAgICBub3RpZmllci5vbnRpbWV1cGRhdGUgPSAoZXZlbnQpID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgaWYgKGhhc0NvbnRyb2xzKSB7XG4gICAgICAgIGNvbnRyb2xzLnNldFNlZWtUaW1lKG5vdGlmaWVyLmN1cnJlbnRUaW1lLCBzZWxmLmlzVk9EID8gbm90aWZpZXIuZHVyYXRpb24gOiB1bmRlZmluZWQpXG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5QTEFZQkFDS19USU1FX1VQREFURSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIHRpbWU6IG5vdGlmaWVyLmN1cnJlbnRUaW1lLFxuICAgICAgICBkdXJhdGlvbjogbm90aWZpZXIuZHVyYXRpb25cbiAgICAgIH0pKVxuICAgIH1cbiAgICBub3RpZmllci5vbnNlZWtlZCA9IChldmVudCkgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4vLyAgICAgIGRlYnVnKE5BTUUsICdTZWVrZWQuJylcbiAgICB9XG4gICAgbm90aWZpZXIub25zZWVraW5nID0gKGV2ZW50KSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbi8vICAgICAgZGVidWcoTkFNRSwgJ1NlZWtpbmcuJylcbiAgICB9XG4gICAgbm90aWZpZXIub25wbGF5ID0gKCkgPT4ge1xuICAgICAgZGVidWcoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6ZXZlbnRdIHBsYXknKVxuICAgICAgaWYgKGhhc0NvbnRyb2xzKSB7XG4gICAgICAgIGNvbnRyb2xzLnNldFN0YXRlKFBsYXliYWNrU3RhdGUuUExBWUlORylcbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlBMQVlCQUNLX1NUQVRFX0NIQU5HRSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGNvZGU6IFBsYXliYWNrU3RhdGUuUExBWUlORyxcbiAgICAgICAgc3RhdGU6IFBsYXliYWNrU3RhdGVSZWFkYWJsZVtQbGF5YmFja1N0YXRlLlBMQVlJTkddXG4gICAgICB9KSlcbiAgICB9XG4gICAgbm90aWZpZXIub25wYXVzZSA9ICgpID0+IHtcbiAgICAgIGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmV2ZW50XSBwYXVzZScpXG4gICAgICBpZiAoaGFzQ29udHJvbHMpIHtcbiAgICAgICAgY29udHJvbHMuc2V0U3RhdGUoUGxheWJhY2tTdGF0ZS5QQVVTRUQpXG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5QTEFZQkFDS19TVEFURV9DSEFOR0UsIHVuZGVmaW5lZCwge1xuICAgICAgICBjb2RlOiBQbGF5YmFja1N0YXRlLlBBVVNFRCxcbiAgICAgICAgc3RhdGU6IFBsYXliYWNrU3RhdGVSZWFkYWJsZVtQbGF5YmFja1N0YXRlLlBBVVNFRF1cbiAgICAgIH0pKVxuICAgIH1cbiAgICBub3RpZmllci5vbnZvbHVtZWNoYW5nZSA9IChldmVudCkgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBpZiAoaGFzQ29udHJvbHMgJiYgY29udHJvbHMuZ2V0Vm9sdW1lKCkgIT09IHRoaXMubWVkaWEudm9sdW1lKSB7XG4gICAgICAgIGNvbnRyb2xzLnNldFZvbHVtZSh0aGlzLm1lZGlhLnZvbHVtZSlcbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlZPTFVNRV9DSEFOR0UsIHVuZGVmaW5lZCwge1xuICAgICAgICB2b2x1bWU6IG5vdGlmaWVyLm11dGVkID8gMCA6IG5vdGlmaWVyLnZvbHVtZVxuICAgICAgfSkpXG4gICAgfVxuICAgIC8vIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG4gICAgbm90aWZpZXIub25lbmNyeXB0ZWQgPSAoKSA9PiB7IGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmV2ZW50XSBlbmNyeXB0ZWQnKSB9XG4gICAgbm90aWZpZXIub25lbXB0aWVkID0gKCkgPT4geyBkZWJ1ZyhOQU1FLCAnW3ZpZGVvZWxlbWVudDpldmVudF0gZW1wdGllZCcpIH1cbiAgICBub3RpZmllci5vbmxvYWRlZGRhdGEgPSAoKSA9PiB7IFxuICAgICAgZGVidWcoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6ZXZlbnRdIGxvYWRlZGRhdGEnKVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuVklERU9fRElNRU5TSU9OU19DSEFOR0UsIHVuZGVmaW5lZCwge1xuICAgICAgICB3aWR0aDogdGhpcy5tZWRpYS52aWRlb1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMubWVkaWEudmlkZW9IZWlnaHRcbiAgICAgIH0pKVxuICAgIH1cbiAgICBub3RpZmllci5vbnJlc2l6ZSA9ICgpID0+IHsgXG4gICAgICBkZWJ1ZyhOQU1FLCAnW3ZpZGVvZWxlbWVudDpldmVudF0gcmVzaXplJylcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlZJREVPX0RJTUVOU0lPTlNfQ0hBTkdFLCB1bmRlZmluZWQsIHtcbiAgICAgICAgd2lkdGg6IHRoaXMubWVkaWEudmlkZW9XaWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLm1lZGlhLnZpZGVvSGVpZ2h0XG4gICAgICB9KSlcbiAgICB9XG4gICAgbm90aWZpZXIub25sb2FkZWRtZXRhZGF0YSA9ICgpID0+IHsgXG4gICAgICBkZWJ1ZyhOQU1FLCAnW3ZpZGVvZWxlbWVudDpldmVudF0gbG9hZGVkbWV0YWRhdGEnKVxuICAgIH1cbiAgICBub3RpZmllci5vbmxvYWRzdGFydCA9ICgpID0+IHsgZGVidWcoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6ZXZlbnRdIGxvYWRlZHN0YXJ0JykgfVxuICAgIG5vdGlmaWVyLm9uc3RhbGxlZCA9ICgpID0+IHsgZGVidWcoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6ZXZlbnRdIHN0YWxsZWQnKSB9XG4gICAgbm90aWZpZXIub25zdXNwZW5kID0gKCkgPT4geyBkZWJ1ZyhOQU1FLCAnW3ZpZGVvZWxlbWVudDpldmVudF0gc3VzcGVuZCcpIH1cbiAgICBub3RpZmllci5vbndhaXRpbmcgPSAoKSA9PiB7IGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmV2ZW50XSB3YWl0aW5nJykgfVxuICAgIC8vICAgIG5vdGlmaWVyLm9ucHJvZ3Jlc3MgPSAoKSA9PiB7IGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmV2ZW50XSBwcm9ncmVzcy4gUGxheWVkOiAnICsgbm90aWZpZXIucGxheWVkLmxlbmd0aCArICcsIEJ1ZmZlcmVkOiAnICsgbm90aWZpZXIuYnVmZmVyZWQubGVuZ3RoICsgJy4nKSB9XG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgY2hhbmdlIGluIGZ1bGxzY3JlZW4gc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNGdWxsU2NyZWVuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaGFuZGxlRnVsbFNjcmVlbkNoYW5nZSAoaXNGdWxsU2NyZWVuKSB7XG4gICAgaWYgKGlzRnVsbFNjcmVlbikge1xuICAgICAgaWYgKHRoaXMuaG9sZGVyKSB7XG4gICAgICAgIHRoaXMuaG9sZGVyLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtY29udGFpbmVyLWZ1bGwtc2NyZWVuJylcbiAgICAgIH1cbiAgICAgIHRoaXMubWVkaWEuY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1jb250YWluZXItZnVsbC1zY3JlZW4nKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmhvbGRlcikge1xuICAgICAgICB0aGlzLmhvbGRlci5jbGFzc0xpc3QucmVtb3ZlKCdyZWQ1cHJvLW1lZGlhLWNvbnRhaW5lci1mdWxsLXNjcmVlbicpXG4gICAgICB9XG4gICAgICB0aGlzLm1lZGlhLmNsYXNzTGlzdC5yZW1vdmUoJ3JlZDVwcm8tbWVkaWEtY29udGFpbmVyLWZ1bGwtc2NyZWVuJylcbiAgICB9XG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuRlVMTF9TQ1JFRU5fU1RBVEVfQ0hBTkdFLCB1bmRlZmluZWQsIGlzRnVsbFNjcmVlbikpXG4gfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIHNldHVwIHRoZSBwcmVzZW50YXRpb24gb2YgYSBwbGF5YmFjayBzdHJlYW0gdXNpbmcgV2ViUlRDLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgVGhlIGluaXRpYWxpemF0aW9uIGNvbmZpZ3VyYXRpb24gbWFwLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFkZFNvdXJjZSAob3B0aW9ucykge1xuICAgIGRlYnVnKE5BTUUsICdbYWRkc291cmNlXScpXG4gICAgY29uc3QgdXNlUGxheWJhY2tDb250cm9scyA9IGVudmlyb25tZW50Lmhhc0F0dHJpYnV0ZURlZmluZWQodGhpcy5tZWRpYSwgJ2NvbnRyb2xzJykgJiYgZW52aXJvbm1lbnQuaGFzQ2xhc3NEZWZpbmVkKHRoaXMubWVkaWEsICdyZWQ1cHJvLW1lZGlhJylcbiAgICBpZiAodXNlUGxheWJhY2tDb250cm9scykge1xuICAgICAgdGhpcy5ob2xkZXIgPSB0aGlzLl9kZXRlcm1pbmVIb2xkZXIodGhpcy5tZWRpYSlcbiAgICB9XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBjb25zdCBoYXNEZWZpbmVkQ29udHJvbHMgPSBvcHRpb25zLmNvbnRyb2xzXG4gICAgY29uc3QgaXNNdXRlZCA9IGVudmlyb25tZW50Lmhhc0F0dHJpYnV0ZURlZmluZWQodGhpcy5tZWRpYSwgJ211dGVkJylcbiAgICBpZiAoaGFzRGVmaW5lZENvbnRyb2xzIHx8IHVzZVBsYXliYWNrQ29udHJvbHMpIHtcbiAgICAgIGlmIChoYXNEZWZpbmVkQ29udHJvbHMpIHtcbiAgICAgICAgdGhpcy5fY29udHJvbHMgPSBvcHRpb25zLmNvbnRyb2xzXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fY29udHJvbHMgPSBuZXcgUGxheWJhY2tDb250cm9sc0ltcGwodGhpcywgdGhpcy5ob2xkZXIpXG4gICAgICB9XG4gICAgICB0aGlzLm1lZGlhLmNvbnRyb2xzID0gZmFsc2VcbiAgICAgIHRoaXMuX2NvbnRyb2xzLnNldEFzVk9EKHRoaXMuaXNWT0QpXG4gICAgICB0aGlzLl9jb250cm9scy5zZXRNdXRlZFN0YXRlKGlzTXV0ZWQpXG4gICAgfVxuICAgIHRoaXMuX2FkZFBsYXliYWNrSGFuZGxlcnModGhpcy5fcGxheWJhY2tOb3RpZmljYXRpb25DZW50ZXIpXG4gICAgZGVmZXJyZWQucmVzb2x2ZSgpXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGNvbm5lY3QgdG8gc3RyZWFtLlxuICAgKi9cbiAgY29ubmVjdCAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tjb25uZWN0XScpXG4gIH1cblxuICBhdHRlbXB0QXV0b3BsYXkgKG11dGVPbkF1dG9wbGF5ID0gZmFsc2UpIHtcbiAgICB0aGlzLnBsYXkoKVxuICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICBpZiAobXV0ZU9uQXV0b3BsYXkpIHtcbiAgICAgICAgICB0aGlzLm11dGUoKVxuICAgICAgICAgIHRoaXMucGxheSgpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLkFVVE9fUExBWUJBQ0tfTVVURUQsIHVuZGVmaW5lZCwge2VsZW1lbnQ6IHRoaXMubWVkaWF9KSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQVVUT19QTEFZQkFDS19GQUlMVVJFLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogKGVyci5tZXNzYWdlID8gZXJyLm1lc3NhZ2UgOiBlcnIpLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMubWVkaWFcbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLkFVVE9fUExBWUJBQ0tfRkFJTFVSRSwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICBlcnJvcjogKGUubWVzc2FnZSA/IGUubWVzc2FnZSA6IGUpLFxuICAgICAgICAgICAgZWxlbWVudDogdGhpcy5tZWRpYVxuICAgICAgICAgIH0pKVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG5cbiAgcGxheSAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6YWN0aW9uXSBwbGF5JylcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRyeSB7XG4gICAgICBsZXQgbWF5YmVQcm9taXNlID0gdGhpcy5tZWRpYS5wbGF5KClcbiAgICAgIGlmIChtYXliZVByb21pc2UpIHtcbiAgICAgICAgbWF5YmVQcm9taXNlXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6YWN0aW9uXSBwbGF5IChTVEFSVCknKVxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goZGVmZXJyZWQucmVqZWN0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6YWN0aW9uXSBwbGF5IChTVEFSVCknKVxuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKClcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcihOQU1FLCAnW3ZpZGVvZWxlbWVudDphY3Rpb25dIHBsYXkgKEZBVUxUKSAtICcgKyBlLm1lc3NhZ2UpXG4gICAgICBkZWZlcnJlZC5yZWplY3QoZSlcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIHBhdXNlICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3ZpZGVvZWxlbWVudDphY3Rpb25dIHBhdXNlJylcbiAgICB0cnkge1xuICAgICAgdGhpcy5tZWRpYS5wYXVzZSgpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB3YXJuKE5BTUUsICdbdmlkZW9lbGVtZW50OmFjdGlvbl0gcGF1c2UgKENBVENIOjpGQVVMVCkgLSAnICsgZS5tZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICByZXN1bWUgKCkge1xuICAgIGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmFjdGlvbl0gcmVzdW1lJylcbiAgICB0cnkge1xuICAgICAgbGV0IG1heWJlUHJvbWlzZSA9IHRoaXMubWVkaWEucGxheSgpXG4gICAgICBpZiAobWF5YmVQcm9taXNlKSB7XG4gICAgICAgIG1heWJlUHJvbWlzZS50aGVuKCgpID0+IGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmFjdGlvbl0gcGxheSAoU1RBUlQpJykpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB3YXJuKE5BTUUsICdbdmlkZW9lbGVtZW50OmFjdGlvbl0gcGxheSAoQ0FUQ0g6OkZBVUxUKSAnICsgKGVyci5tZXNzYWdlID8gZXJyLm1lc3NhZ2UgOiBlcnIpKSlcbiAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6YWN0aW9uXSByZXN1bWUgKENBVENIOjpGQVVMVCkgLSAnICsgZS5tZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICBzdG9wICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3ZpZGVvZWxlbWVudDphY3Rpb25dIHN0b3AnKVxuICAgIHRyeSB7XG4gICAgICB0aGlzLm1lZGlhLnN0b3AoKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgLy8gb2suXG4gICAgfVxuICB9XG5cbiAgbXV0ZSAoKSB7XG4gICAgdGhpcy5tZWRpYS5tdXRlZCA9IHRydWVcbiAgICBjb25zdCBjb250cm9scyA9IHRoaXMuZ2V0Q29udHJvbHMoKVxuICAgIGlmIChjb250cm9scykge1xuICAgICAgY29udHJvbHMuc2V0TXV0ZWRTdGF0ZSh0cnVlKVxuICAgIH1cbiAgfVxuXG4gIHVubXV0ZSAoKSB7XG4gICAgdGhpcy5tZWRpYS5tdXRlZCA9IGZhbHNlXG4gICAgY29uc3QgY29udHJvbHMgPSB0aGlzLmdldENvbnRyb2xzKClcbiAgICBpZiAoY29udHJvbHMpIHtcbiAgICAgIGNvbnRyb2xzLnNldE11dGVkU3RhdGUoZmFsc2UpXG4gICAgfVxuICB9XG5cbiAgc2V0Vm9sdW1lICh2YWx1ZSkge1xuICAgIHRoaXMudW5tdXRlKClcbiAgICB0aGlzLm1lZGlhLnZvbHVtZSA9IHZhbHVlXG4gIH1cblxuICBzZWVrVG8gKHBlcmNlbnRhZ2UsIGR1cmF0aW9uID0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSA9IGR1cmF0aW9uID8gcGVyY2VudGFnZSAqIGR1cmF0aW9uIDogcGVyY2VudGFnZVxuICB9XG5cbiAgdG9nZ2xlRnVsbFNjcmVlbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmhvbGRlcikge1xuICAgICAgICBlbnZpcm9ubWVudC50b2dnbGVGdWxsU2NyZWVuKHRoaXMuaG9sZGVyKVxuICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgZTtcbiAgICAgIC8vIG5hZGEuXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmaWNhdGlvbiBvZiBjdXJyZW50IHN0cmVhbSBiZWluZyBpbiBhbiB1bnB1Ymxpc2hlZCBzdGF0ZS5cbiAgICogVGhlIHN0cmVhbSBlbnRlcnMgYW4gdW5wdWJsaXNoZWQgc3RhdGUgd2hlbiB0aGUgYnJvYWRjYXN0ZXIgc3RvcCB0aGUgc3RyZWFtIGFuZCB0aGUgc3Vic2NyaWJlciBpcyBzdGlsbCBjb25uZWN0ZWQuXG4gICAqL1xuICB1bnB1Ymxpc2ggKCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnN0b3AoKVxuICAgICAgdGhpcy5tZWRpYS5vbmVuZGVkLmNhbGwodGhpcy5tZWRpYSlcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIC8vIG5hZGEuXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gZGlzY29ubmVjdCBwbGF5YmFjay5cbiAgICovXG4gIGRpc2Nvbm5lY3QgKCkge1xuICAgIHRoaXMuX2NsZWFuVXAoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc3BvbmRlciB0byBjaGFuZ2UgaW4gb3JpZW50YXRpb24gcmVjZWl2ZWQgdGhyb3VnaCBtZXRhZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9yaWVudGF0aW9uXG4gICAqICAgICAgICBUaGUgb3JpZW50YXRpb24gdmFsdWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVPcmllbnRhdGlvbkNoYW5nZSAob3JpZW50YXRpb24pIHtcbiAgICBpZiAodGhpcy5fY29udHJvbHMgJiYgKG9yaWVudGF0aW9uICUgMTgwICE9PSAwKSkge1xuICAgICAgaWYgKHRoaXMuaG9sZGVyKSB7XG4gICAgICAgIHRoaXMuaG9sZGVyLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtYmFja2dyb3VuZCcpXG4gICAgICB9XG4gICAgICB0aGlzLm1lZGlhLmNsYXNzTGlzdC5yZW1vdmUoJ3JlZDVwcm8tbWVkaWEtYmFja2dyb3VuZCcpXG4gICAgfVxuICB9XG5cbiAgLypcbiAgICogfHwgU0hBUkVEIE9CSkVDVCBJTlRFR1JBVElPTiBOT1QgQVZBSUxBQkxFIEZPUiBITFMgUExBWUJBQ0sgfHxcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBhZGRTaGFyZWRPYmplY3RSZXNwb25zZUhhbmRsZXIgKGhhbmRsZXIpIHt9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIHJlbW92ZVNoYXJlZE9iamVjdFJlc3BvbnNlSGFuZGxlciAoaGFuZGxlcikge31cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgc2VuZFRvU2hhcmVkT2JqZWN0IChuYW1lLCBjYWxsTmFtZSwgbWVzc2FnZSkge31cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgc2VuZFByb3BlcnR5VG9TaGFyZWRPYmplY3QgKG5hbWUsIGtleSwgdmFsdWUpIHt9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIGdldFJlbW90ZVNoYXJlZE9iamVjdCAoc2hhcmVkT2JqZWN0TmFtZSkge31cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgY29ubmVjdFRvU2hhcmVkT2JqZWN0IChzaGFyZWRPYmplY3ROYW1lKSB7fVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBjbG9zZVNoYXJlZE9iamVjdCAoc2hhcmVkT2JqZWN0TmFtZSkge31cblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHBsYXliYWNrIGNvbnRyb2xzIGlmIGF2YWlsYWJsZS5cbiAgICpcbiAgICogQHJldHVybnMge1BsYXliYWNrQ29udHJvbHN9XG4gICAqL1xuICBnZXRDb250cm9scyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRyb2xzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3Vic2NyaWJlciB0eXBlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbnRyb2xsZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXJUeXBlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBmbGFnIG9mIHZpZGVvIGJlaW5nIHJlY29nbml6ZWQgYXMgVk9EIChWaWRlbyBPbiBEZW1hbmQpLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZPRCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVk9EXG4gIH1cblxuICAvKipcbiAgICogU2V0cyBmbGFnIG9mIHZpZGVvIGJlaW5nIGNvbnNpZGVyZWQgYXMgVk9EIChWaWRlbyBPbiBEZW1hbmQpLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAqL1xuICBzZXQgaXNWT0QgKHZhbHVlKSB7XG4gICAgdGhpcy5faXNWT0QgPSB2YWx1ZVxuICAgIGlmICh0aGlzLl9jb250cm9scykge1xuICAgICAgdGhpcy5fY29udHJvbHMuc2V0QXNWT0QodmFsdWUpXG4gICAgfVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUlRDU291cmNlSGFuZGxlclxuXG4iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uL2Vudi9icm93c2VyJ1xuaW1wb3J0IHsgUGxheWJhY2tDb250cm9sbGVyLCBQbGF5YmFja0NvbnRyb2xzSW1wbCB9IGZyb20gJy4vY29udHJvbHMnXG5pbXBvcnQgeyBQbGF5YmFja1N0YXRlLCBQbGF5YmFja1N0YXRlUmVhZGFibGUgfSBmcm9tICcuL2NvbnRyb2xzL3N0YXRlJ1xuaW1wb3J0IHsgXG4gIFN1YnNjcmliZXJFdmVudCxcbiAgU3Vic2NyaWJlckV2ZW50VHlwZXMsXG4gIFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzXG59IGZyb20gJy4uL2V2ZW50J1xuaW1wb3J0IHsgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0IHsgZGVidWcsIGVycm9yLCB3YXJuIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1JUQ1NlZWthYmxlU291cmNlSGFuZGxlcidcbmNvbnN0IE1BWF9UUyA9IDZcbi8qKlxuICogU291cmNlIEhhbmRsZXIgZm9yIFdlYlJUQy1iYXNlZCBTdWJzY3JpYmVycywgd2hpY2ggc2VydmVzIGFzIGEgUHJlc2VudGF0aW9uIENvbnRyb2xsZXIgYmV0d2VlbiB2aWV3IGFuZCBzdWJzY3JpYmVyLlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQGV4dGVuZHMgU3Vic2NyaWJlclBsYXliYWNrQ29udHJvbGxlclxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFJUQ1NlZWthYmxlU291cmNlSGFuZGxlciBleHRlbmRzIFBsYXliYWNrQ29udHJvbGxlciB7XG5cbiAgY29uc3RydWN0b3IgKG1lZGlhLCB0eXBlKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMubWVkaWEgPSBtZWRpYVxuICAgIGNvbnN0IHVzZVBsYXliYWNrQ29udHJvbHMgPSB0cnVlIC8vIGZvcmNlIHRydWUuXG4gICAgaWYgKHVzZVBsYXliYWNrQ29udHJvbHMpIHtcbiAgICAgIHRoaXMuY2xvbmUgPSB0aGlzLm1lZGlhLmNsb25lTm9kZSh0cnVlKVxuICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLm1lZGlhLnBhcmVudE5vZGVcbiAgICAgIHRoaXMuaG9sZGVyID0gdGhpcy5fZGV0ZXJtaW5lSG9sZGVyKHRoaXMubWVkaWEpXG4gICAgfVxuICAgIHRoaXMucGxheWVyVHlwZSA9IHR5cGVcbiAgICB0aGlzLl9pc1ZPRCA9IGZhbHNlXG4gICAgdGhpcy5faXNTZWVrYWJsZSA9IGZhbHNlIC8vIGNhbiBiZSBzZWVrYWJsZSBidXQgbm90IFZPRCB3aGVuIGRvaW5nIGxpdmUgc2NydWIuXG4gICAgdGhpcy5faXNITFNQbGF5YmFja0FjdGl2ZSA9IGZhbHNlIC8vIHdoZW4gd2UgaGF2ZSBzd2l0Y2hlZCBvdmVyIHRvIFZPRCBwbGF5YmFjay5cbiAgICB0aGlzLl9pc0ZyYWdMb2FkaW5nID0gZmFsc2UgLy8gd2hlbiBzY3J1YmJlZCBhbmQgbG9hZGluZyBsYW5kZWQgZnJhZ21lbnQuXG4gICAgdGhpcy5faGxzUmVjb3ZlckZsb3AgPSBmYWxzZSAvLyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9ibG9iL21hc3Rlci9kb2NzL0FQSS5tZCNobHNzd2FwYXVkaW9jb2RlY1xuICAgIHRoaXMuX2hsc1JlY292ZXJBdHRlbXB0cyA9IDBcbiAgICB0aGlzLl9sYXN0RHVyYXRpb25VcGRhdGUgPSAwIC8vIHRoZSBjdXJyZW50VGltZSBvZiB0aGUgUlRDIHN0cmVhbSB3aGVuIHN3aXRjaGVkIHRvIGxpdmUgcGxheWJhY2suXG4gICAgdGhpcy5fY29udHJvbHMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9yZXNpemVPYnNlcnZlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3BsYXliYWNrTm90aWZpY2F0aW9uQ2VudGVyID0gdGhpcy5tZWRpYVxuICAgIGVudmlyb25tZW50Lm9uRnVsbFNjcmVlblN0YXRlQ2hhbmdlKHRoaXMuX2hhbmRsZUZ1bGxTY3JlZW5DaGFuZ2UuYmluZCh0aGlzKSlcblxuICAgIC8vIExpdmUgU2VlayBITFMgU3VwcG9ydFxuICAgIC8vIFBvc3NpYmxlIEhMUy5KUyBpbnN0YW5jZS5cbiAgICB0aGlzLmhscyA9IHVuZGVmaW5lZFxuICAgIC8vIFRoZSBET01FbGVtZW50IGZvciBITFMgcGxheWJhY2suXG4gICAgdGhpcy5obHNFbGVtZW50ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogRXN0YWJsaXNoZWQgRE9NIEVsZW1lbnQgb3JkZXIgZm9yIHBsYXliYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG1lZGlhXG4gICAqICAgICAgICBUaGUgdGFyZ2V0IG1lZGlhIGVsZW1lbnQ6IGUuZy4sIGB2aWRlb2Agb3IgYGF1ZGlvYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXRlcm1pbmVIb2xkZXIgKG1lZGlhKSB7XG4gICAgaWYgKG1lZGlhLnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdyZWQ1cHJvLW1lZGlhLWNvbnRhaW5lcicpKSB7XG4gICAgICByZXR1cm4gbWVkaWEucGFyZW50Tm9kZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IG1lZGlhLnBhcmVudE5vZGVcbiAgICAgIGNvbnN0IGRpdiA9IGVudmlyb25tZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICBkaXYuY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1jb250YWluZXInKVxuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShkaXYsIG1lZGlhKVxuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG1lZGlhKVxuICAgICAgZGl2LmFwcGVuZENoaWxkKG1lZGlhKVxuICAgICAgcmV0dXJuIGRpdlxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdmlkZW8gZWxlbWVudCBmb3IgSExTIHBsYXliYWNrIGFuZCBhZGRzIGl0IGluIGNvbnRhaW5lciBwcm9wZXJseSBvcmRlcmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGhvbGRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG1lZGlhXG4gICAqXG4gICAqIEByZXR1cm5zIERPTUVsZW1lbnRcbiAgICovXG4gIF9nZW5lcmF0ZUhMU0xpdmVQbGF5YmFjayAoaG9sZGVyLCBtZWRpYSkge1xuICAgIGNvbnN0IGlkID0gJ3JlZDVwcm8taGxzLXZvZCdcbiAgICBsZXQgaGxzRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCMke2lkfWApXG4gICAgaWYgKCFobHNFbGVtZW50KSB7XG4gICAgICBobHNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKVxuICAgICAgaGxzRWxlbWVudC5pZCA9ICdyZWQ1cHJvLWhscy12b2QnXG4gICAgICBobHNFbGVtZW50LnBsYXlzaW5saW5lID0gJ3BsYXlzaW5saW5lJ1xuICAgICAgaGxzRWxlbWVudC5zdHlsZS53aWR0aCA9ICcxMDAlJyAvLyBgJHttZWRpYS5jbGllbnRXaWR0aH1weGBcbiAgICAgIGhsc0VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnIC8vIGAke21lZGlhLmNsaWVudEhlaWdodH1weGBcbiAgICAgIGhsc0VsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXG4gICAgICBobHNFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgIGhvbGRlci5pbnNlcnRCZWZvcmUoaGxzRWxlbWVudCwgbWVkaWEpXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbi8vICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4vLyAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuLy8gICAgICAgICAgIGlmIChlbnRyeS5jb250ZW50UmVjdCkge1xuLy8gLy8gICAgICAgICAgICBobHNFbGVtZW50LnN0eWxlLndpZHRoID0gYCR7ZW50cnkuY29udGVudFJlY3Qud2lkdGh9cHhgXG4vLyAvLyAgICAgICAgICAgIGhsc0VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7ZW50cnkuY29udGVudFJlY3QuaGVpZ2h0fXB4YFxuLy8gICAgICAgICAgIH1cbi8vICAgICAgICAgfVxuLy8gICAgICAgfSlcbi8vICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUobWVkaWEpXG4gICAgfVxuICAgIHJldHVybiBobHNFbGVtZW50XG4gIH1cblxuICBfc2hvd0hMU0xpdmVQbGF5YmFjayAoZmxhZywgaGxzTWVkaWEsIG1lZGlhLCBob2xkZXIpIHtcbiAgICBpZiAodGhpcy5faXNITFNQbGF5YmFja0FjdGl2ZSA9PT0gZmxhZykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuX2lzSExTUGxheWJhY2tBY3RpdmUgPSBmbGFnXG4gICAgY29uc3QgaXNNdXRlZCA9IGZsYWcgPyBtZWRpYS5tdXRlZCA6IGhsc01lZGlhLm11dGVkXG4gICAgaWYgKGZsYWcpIHtcbiAgICAgIGhsc01lZGlhLnZvbHVtZSA9IG1lZGlhLnZvbHVtZVxuICAgICAgaGxzTWVkaWEubXV0ZWQgPSBpc011dGVkXG4gICAgICBtZWRpYS5tdXRlZCA9IHRydWVcbiAgICAgIGhsc01lZGlhLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJ1xuICAgICAgbWVkaWEuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgaG9sZGVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJ1xuICAgIH0gZWxzZSB7XG4gICAgICBtZWRpYS52b2x1bWUgPSBobHNNZWRpYS52b2x1bWVcbiAgICAgIGhsc01lZGlhLm11dGVkID0gdHJ1ZVxuICAgICAgbWVkaWEubXV0ZWQgPSBpc011dGVkXG4gICAgICBtZWRpYS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jaydcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghaGxzTWVkaWEucGF1c2VkKSB7XG4gICAgICAgICAgdGhpcy5wYXVzZSh0cnVlKVxuICAgICAgICAgIHRoaXMucGxheSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYXVzZShmYWxzZSlcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB3YXJuKGBDb3VsZCBub3Qgc3RhcnQgcGxheWJhY2s6ICR7ZS5tZXNzYWdlfS5gKVxuICAgICAgfVxuICAgICAgaGxzTWVkaWEuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFc3RhYmxpc2hlZCBET00gRWxlbWVudCBvcmRlciBmb3IgcGxheWJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbWVkaWFcbiAgICogICAgICAgIFRoZSB0YXJnZXQgbWVkaWEgZWxlbWVudDogZS5nLiwgYHZpZGVvYCBvciBgYXVkaW9gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NsZWFuVXAgKCkge1xuICAgIGlmICghdGhpcy5jbG9uZSkgcmV0dXJuXG5cbiAgICAvLyBSZXR1cm4gdG8gcHJpb3IgRE9NIG1hbmlwdWxhdGlvbi5cbiAgICBsZXQgZWwgPSB0aGlzLm1lZGlhXG4gICAgbGV0IGVsUGFyZW50ID0gZWwucGFyZW50Tm9kZVxuICAgIGxldCBtZWRpYUhvbGRlciA9IHRoaXMuaG9sZGVyXG4gICAgdGhpcy5fcmVtb3ZlUGxheWJhY2tIYW5kbGVycyhlbClcbiAgICAvLyBOb3RlOiBlbmFibGVMaXZlU2VlayByZXF1aXJlcyBjdXN0b20gY29udHJvbHMsIHNvIHdlIHNob3VsZCBhbHdheXMgYXJyaXZlIGhlcmUuXG4gICAgaWYgKHRoaXMuaGxzKSB7XG4gICAgICB0aGlzLmhscy5kZXRhY2hNZWRpYSgpXG4gICAgICB0aGlzLmhscyA9IHVuZGVmaW5lZFxuICAgIH1cbiAgICBpZiAodGhpcy5obHNFbGVtZW50KSB7XG4gICAgICB0aGlzLl9yZW1vdmVTZWVrYWJsZUhhbmRsZXJzKHRoaXMuaGxzRWxlbWVudClcbiAgICAgIGlmICh0aGlzLmhsc0VsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmhsc0VsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmhsc0VsZW1lbnQpXG4gICAgICB9XG4gICAgICB0aGlzLmhsc0VsZW1lbnQgPSB1bmRlZmluZWRcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NvbnRyb2xzKSB7XG4gICAgICB0aGlzLl9jb250cm9scy5kZXRhY2goKVxuICAgICAgdGhpcy5fY29udHJvbHMgPSB1bmRlZmluZWRcbiAgICB9XG4gICAgaWYgKGVsUGFyZW50KSB7XG4gICAgICBlbFBhcmVudC5yZW1vdmVDaGlsZChlbClcbiAgICAgIC8vIFRoZSBvYmplY3QgcGFyZW50IGNvdWxkIGJlIGEgd3JhcHBlciBjaGlsZCBpbiB0aGUgb3JpZ2luYWwgcGFyZW50IGVsZW1lbnQuXG4gICAgICBpZiAoZWxQYXJlbnQgIT09IHRoaXMucGFyZW50KSB7XG4gICAgICAgIGVsUGFyZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxQYXJlbnQpXG4gICAgICAgIG1lZGlhSG9sZGVyID0gdGhpcy5wYXJlbnRcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZWwucmVtb3ZlKClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgd2FybihOQU1FLCBgSXNzdWUgaW4gRE9NIGNsZWFudXAgb2YgV2ViUlRDIHZpZGVvIG9iamVjdDogJHtlLm1lc3NhZ2V9YClcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tZWRpYSA9IHRoaXMuY2xvbmUuY2xvbmVOb2RlKHRydWUpXG4gICAgbWVkaWFIb2xkZXIuYXBwZW5kQ2hpbGQodGhpcy5tZWRpYSlcbiAgICBpZiAodGhpcy5fcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZSgpXG4gICAgICB0aGlzLl9yZXNpemVPYnNlcnZlciA9IHVuZGVmaW5lZFxuICAgIH1cbiAgICB0aGlzLl9pc1ZPRCA9IGZhbHNlXG4gICAgdGhpcy5faXNTZWVrYWJsZSA9IGZhbHNlXG4gICAgdGhpcy5faXNITFNQbGF5YmFja0FjdGl2ZSA9IGZhbHNlXG4gICAgdGhpcy5faXNGcmFnTG9hZGluZyA9IGZhbHNlXG4gICAgdGhpcy5faGxzUmVjb3ZlckZsb3AgPSBmYWxzZVxuICAgIHRoaXMuX2hsc1JlY292ZXJBdHRlbXB0cyA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NpZ25zIGFuZCBoYW5kbGVycyBldmVudCBub3RpZmljaWF0aW9ucyBjb21pbmcgZnJvbSB0aGUgbWVkaWEgbm90aWZpZXIgKGUuZy4sIGB2aWRlb2Agb3IgYGF1ZGlvYCBlbGVtZW50KS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG5vdGlmaWVyXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYWRkUGxheWJhY2tIYW5kbGVycyAobm90aWZpZXIpIHtcbiAgICBjb25zdCBjb250cm9scyA9IHRoaXMuZ2V0Q29udHJvbHMoKVxuICAgIG5vdGlmaWVyLm9uY2FucGxheSA9ICgpID0+IHtcbiAgICAgIGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmV2ZW50XSBjYW5wbGF5JylcbiAgICAgIGlmIChjb250cm9scykge1xuICAgICAgICBjb250cm9scy5lbmFibGUodHJ1ZSlcbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlBMQVlCQUNLX1NUQVRFX0NIQU5HRSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGNvZGU6IFBsYXliYWNrU3RhdGUuQVZBSUxBQkxFLFxuICAgICAgICBzdGF0ZTogUGxheWJhY2tTdGF0ZVJlYWRhYmxlW1BsYXliYWNrU3RhdGUuQVZBSUxBQkxFXVxuICAgICAgfSkpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5WT0xVTUVfQ0hBTkdFLCB1bmRlZmluZWQsIHtcbiAgICAgICAgdm9sdW1lOiBub3RpZmllci52b2x1bWVcbiAgICAgIH0pKVxuICAgIH1cblxuICAgIG5vdGlmaWVyLm9uZW5kZWQgPSAoKSA9PiB0aGlzLl9vblJUQ0VuZGVkLmJpbmQodGhpcylcbiAgICBub3RpZmllci5vbmR1cmF0aW9uY2hhbmdlID0gdGhpcy5fb25SVENEdXJhdGlvbkNoYW5nZS5iaW5kKHRoaXMpXG4gICAgbm90aWZpZXIub250aW1ldXBkYXRlID0gdGhpcy5fb25SVENUaW1lVXBkYXRlLmJpbmQodGhpcylcbiAgICBub3RpZmllci5vbnBsYXkgPSB0aGlzLl9vblJUQ1BsYXkuYmluZCh0aGlzKVxuICAgIG5vdGlmaWVyLm9ucGF1c2UgPSB0aGlzLl9vblJUQ1BhdXNlLmJpbmQodGhpcylcblxuICAgIG5vdGlmaWVyLm9udm9sdW1lY2hhbmdlID0gKGV2ZW50KSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIGlmIChjb250cm9scy5nZXRWb2x1bWUoKSAhPT0gdGhpcy5tZWRpYS52b2x1bWUpIHtcbiAgICAgICAgY29udHJvbHMuc2V0Vm9sdW1lKHRoaXMubWVkaWEudm9sdW1lKVxuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuVk9MVU1FX0NIQU5HRSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIHZvbHVtZTogbm90aWZpZXIubXV0ZWQgPyAwIDogbm90aWZpZXIudm9sdW1lXG4gICAgICB9KSlcbiAgICB9XG4gICAgLy8gZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cbiAgICBub3RpZmllci5vbmVuY3J5cHRlZCA9ICgpID0+IHsgZGVidWcoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6ZXZlbnRdIGVuY3J5cHRlZCcpIH1cbiAgICBub3RpZmllci5vbmVtcHRpZWQgPSAoKSA9PiB7IGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmV2ZW50XSBlbXB0aWVkJykgfVxuICAgIG5vdGlmaWVyLm9ubG9hZGVkZGF0YSA9ICgpID0+IHsgXG4gICAgICBkZWJ1ZyhOQU1FLCAnW3ZpZGVvZWxlbWVudDpldmVudF0gbG9hZGVkZGF0YScpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5WSURFT19ESU1FTlNJT05TX0NIQU5HRSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIHdpZHRoOiB0aGlzLm1lZGlhLnZpZGVvV2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5tZWRpYS52aWRlb0hlaWdodFxuICAgICAgfSkpXG4gICAgfVxuICAgIG5vdGlmaWVyLm9ucmVzaXplID0gKCkgPT4geyBcbiAgICAgIGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmV2ZW50XSByZXNpemUnKVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuVklERU9fRElNRU5TSU9OU19DSEFOR0UsIHVuZGVmaW5lZCwge1xuICAgICAgICB3aWR0aDogdGhpcy5tZWRpYS52aWRlb1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMubWVkaWEudmlkZW9IZWlnaHRcbiAgICAgIH0pKVxuICAgIH1cbiAgICBub3RpZmllci5vbmxvYWRlZG1ldGFkYXRhID0gKCkgPT4geyBcbiAgICAgIGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmV2ZW50XSBsb2FkZWRtZXRhZGF0YScpXG4gICAgfVxuICAgIG5vdGlmaWVyLm9ubG9hZHN0YXJ0ID0gKCkgPT4geyBkZWJ1ZyhOQU1FLCAnW3ZpZGVvZWxlbWVudDpldmVudF0gbG9hZGVkc3RhcnQnKSB9XG4gICAgbm90aWZpZXIub25zdGFsbGVkID0gKCkgPT4geyBkZWJ1ZyhOQU1FLCAnW3ZpZGVvZWxlbWVudDpldmVudF0gc3RhbGxlZCcpIH1cbiAgICBub3RpZmllci5vbnN1c3BlbmQgPSAoKSA9PiB7IGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmV2ZW50XSBzdXNwZW5kJykgfVxuICAgIG5vdGlmaWVyLm9ud2FpdGluZyA9ICgpID0+IHsgZGVidWcoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6ZXZlbnRdIHdhaXRpbmcnKSB9XG4gICAgLy8gICAgbm90aWZpZXIub25wcm9ncmVzcyA9ICgpID0+IHsgZGVidWcoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6ZXZlbnRdIHByb2dyZXNzLiBQbGF5ZWQ6ICcgKyBub3RpZmllci5wbGF5ZWQubGVuZ3RoICsgJywgQnVmZmVyZWQ6ICcgKyBub3RpZmllci5idWZmZXJlZC5sZW5ndGggKyAnLicpIH1cbiAgfVxuXG4gIF9yZW1vdmVQbGF5YmFja0hhbmRsZXJzIChub3RpZmllcikge1xuICAgIG5vdGlmaWVyLm9uY2FucGxheSA9IHVuZGVmaW5lZFxuICAgIG5vdGlmaWVyLm9uZW5kZWQgPSB1bmRlZmluZWRcbiAgICBub3RpZmllci5vbmR1cmF0aW9uY2hhbmdlID0gdW5kZWZpbmVkXG4gICAgbm90aWZpZXIub250aW1ldXBkYXRlID0gdW5kZWZpbmVkXG4gICAgbm90aWZpZXIub25wbGF5ID0gdW5kZWZpbmVkXG4gICAgbm90aWZpZXIub25wYXVzZSA9IHVuZGVmaW5lZFxuICAgIG5vdGlmaWVyLm9udm9sdW1lY2hhbmdlID0gdW5kZWZpbmVkXG4gICAgbm90aWZpZXIub25lbmNyeXB0ZWQgPSB1bmRlZmluZWRcbiAgICBub3RpZmllci5vbmVtcHRpZWQgPSB1bmRlZmluZWRcbiAgICBub3RpZmllci5vbmxvYWRlZGRhdGEgPSB1bmRlZmluZWRcbiAgICBub3RpZmllci5vbnJlc2l6ZSA9IHVuZGVmaW5lZFxuICAgIG5vdGlmaWVyLm9ubG9hZGVkbWV0YWRhdGEgPSB1bmRlZmluZWRcbiAgICBub3RpZmllci5vbmxvYWRzdGFydCA9IHVuZGVmaW5lZFxuICAgIG5vdGlmaWVyLm9uc3RhbGxlZCA9IHVuZGVmaW5lZFxuICAgIG5vdGlmaWVyLm9uc3VzcGVuZCA9IHVuZGVmaW5lZFxuICAgIG5vdGlmaWVyLm9ud2FpdGluZyA9IHVuZGVmaW5lZFxuICB9XG5cbiAgX2FkZFNlZWthYmxlSGFuZGxlcnMgKGVsZW1lbnQsIGNvbnRyb2wpIHtcbiAgICBpZiAoY29udHJvbCkgeyAvLyBITFMuSlNcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgY29udHJvbC5vbihlbnZpcm9ubWVudC5nZXRITFNDbGllbnRFdmVudEVudW0oKS5FUlJPUiwgKGV2ZW50LCBkYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGRldGFpbHMsXG4gICAgICAgICAgZmF0YWwsXG4gICAgICAgICAgdXJsXG4gICAgICAgIH0gPSBkYXRhXG4gICAgICAgIGlmICh0eXBlLnRvTG93ZXJDYXNlKCkgPT09ICduZXR3b3JrZXJyb3InKSB7XG4gICAgICAgICAgaWYgKGRldGFpbHMudG9Mb3dlckNhc2UoKSA9PT0gJ2xldmVsZW1wdHllcnJvcicpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLkxJVkVfU0VFS19ESVNBQkxFRCwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgIGhsc0VsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgIGhsc0NvbnRyb2w6IGNvbnRyb2xcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgdGhpcy5pc1NlZWthYmxlID0gZmFsc2VcbiAgICAgICAgICAgIC8vIFRyeSwgdHJ5IGFnYWluLlxuICAgICAgICAgICAgY29udHJvbC5kZXN0cm95KClcbiAgICAgICAgICAgIGxldCB0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0KVxuICAgICAgICAgICAgICB0aGlzLmVuYWJsZUxpdmVTZWVrKHVybCwgZmFsc2UpXG4gICAgICAgICAgICB9LCAzMDAwKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLkxJVkVfU0VFS19FUlJPUiwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgIGhsc0VsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgIGhsc0NvbnRyb2w6IGNvbnRyb2wsXG4gICAgICAgICAgICAgIGVycm9yOiBkYXRhXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoUlRDU3Vic2NyaWJlckV2ZW50VHlwZXMuTElWRV9TRUVLX0VSUk9SLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIGhsc0VsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICBobHNDb250cm9sOiBjb250cm9sLFxuICAgICAgICAgICAgZXJyb3I6IGRhdGFcbiAgICAgICAgICB9KSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlLnRvTG93ZXJDYXNlKCkgPT09ICdtZWRpYWVycm9yJykge1xuICAgICAgICAgIGlmICh0aGlzLl9obHNSZWNvdmVyRmxvcCkge1xuICAgICAgICAgICAgY29udHJvbC5zd2FwQXVkaW9Db2RlYygpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2hsc1JlY292ZXJGbG9wID0gIXRoaXMuX2hsc1JlY292ZXJGbG9wXG4gICAgICAgICAgdGhpcy5faGxzUmVjb3ZlckF0dGVtcHRzID0gdGhpcy5faGxzUmVjb3ZlckF0dGVtcHRzICsgMVxuICAgICAgICAgIGNvbnRyb2wucmVjb3Zlck1lZGlhRXJyb3IoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZhdGFsICYmIHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ25ldHdvcmtlcnJvcicpIHtcbiAgICAgICAgICBjb250cm9sLnN0YXJ0TG9hZCgpXG4gICAgICAgIH1cblxuICAgICAgfSlcbiAgICAgIGNvbnRyb2wub24oZW52aXJvbm1lbnQuZ2V0SExTQ2xpZW50RXZlbnRFbnVtKCkuTUFOSUZFU1RfUEFSU0VELCAoKSA9PiB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGRhdGEubGV2ZWxzWzBdLmRldGFpbHMuZnJhZ21lbnRzKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGVsZW1lbnQucGF1c2UoKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoTkFNRSwgYENvdWxkIG5vdCBwYXVzZSBzZWVrYWJsZSBsaXZlIHN0cmVhbTogJHtlLm1lc3NhZ2V9YClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzU2Vla2FibGUgPSB0cnVlXG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLkxJVkVfU0VFS19FTkFCTEVELCB1bmRlZmluZWQsIHtcbiAgICAgICAgICBobHNFbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgIGhsc0NvbnRyb2w6IGNvbnRyb2xcbiAgICAgICAgfSkpXG4gICAgICB9KVxuICAgICAgY29udHJvbC5vbihlbnZpcm9ubWVudC5nZXRITFNDbGllbnRFdmVudEVudW0oKS5GUkFHX0xPQURfUFJPR1JFU1MsIChldmVudCwgZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc3RhdHM6IHtcbiAgICAgICAgICAgIGxvYWRlZCxcbiAgICAgICAgICAgIHRvdGFsXG4gICAgICAgICAgfVxuICAgICAgICB9ID0gZGF0YVxuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVENTdWJzY3JpYmVyRXZlbnRUeXBlcy5MSVZFX1NFRUtfTE9BRElORywgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgaGxzRWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICBobHNDb250cm9sOiBjb250cm9sLFxuICAgICAgICAgIHByb2dyZXNzOiAobG9hZGVkL3RvdGFsKSoxMDBcbiAgICAgICAgfSkpXG4gICAgICAgIGlmICghdGhpcy5pc0hMU1BsYXliYWNrQWN0aXZlICYmICF0aGlzLl9pc0ZyYWdMb2FkaW5nKSByZXR1cm5cbiAgICAgICAgdGhpcy5faXNGcmFnTG9hZGluZyA9IChsb2FkZWQvdG90YWwgPj0gMSlcbiAgICAgIH0pXG4gICAgICAvLyBjb250cm9sLm9uKGVudmlyb25tZW50LmdldEhMU0NsaWVudEV2ZW50RW51bSgpLkZSQUdfTE9BRF9QUk9HUkVTUywgKGV2ZW50LCBkYXRhKSA9PiB7XG4gICAgICAvLyAgIGNvbnNvbGUubG9nKCdMaXZlU2VlaycsIGRhdGEpXG4gICAgICAvLyB9KVxuICAgICAgY29udHJvbC5vbihlbnZpcm9ubWVudC5nZXRITFNDbGllbnRFdmVudEVudW0oKS5GUkFHX0xPQURFRCwgKGV2ZW50LCBkYXRhKSA9PiB7XG4gICAgICAgIHRoaXMuX2lzRnJhZ0xvYWRpbmcgPSBmYWxzZVxuICAgICAgICBpZiAoIXRoaXMuaXNITFNQbGF5YmFja0FjdGl2ZSkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGZyYWc6IHtcbiAgICAgICAgICAgICAgZW5kRFRTXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSA9IGRhdGFcbiAgICAgICAgICBpZiAoIWVuZERUUykgcmV0dXJuXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBNQVhfVFNcbi8vICAgICAgICAgIGNvbnRyb2xzLnNldFBsYXliYWNrRHVyYXRpb24oZW5kRFRTICsgb2Zmc2V0KVxuICAgICAgICAgIGRlYnVnKE5BTUUsIGBmcmFnbG9hZCwgW0hMUzp2aWRlb2VsZW1lbnQ6ZHVyYXRpb25dICR7ZW5kRFRTfSArICR7b2Zmc2V0fWApXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoUlRDU3Vic2NyaWJlckV2ZW50VHlwZXMuTElWRV9TRUVLX0xPQURFRCwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgaGxzRWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICBobHNDb250cm9sOiBjb250cm9sXG4gICAgICAgIH0pKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBlbGVtZW50Lm9uZHVyYXRpb25jaGFuZ2UgPSB0aGlzLl9vbkhMU0R1cmF0aW9uQ2hhbmdlLmJpbmQodGhpcylcbiAgICBlbGVtZW50Lm9udGltZXVwZGF0ZSA9IHRoaXMuX29uSExTVGltZVVwZGF0ZS5iaW5kKHRoaXMpXG4gICAgZWxlbWVudC5vbnBsYXkgPSB0aGlzLl9vbkhMU1BsYXkuYmluZCh0aGlzKVxuICAgIGVsZW1lbnQub25wYXVzZSA9IHRoaXMuX29uSExTUGF1c2UuYmluZCh0aGlzKVxuICB9XG5cbiAgX3JlbW92ZVNlZWthYmxlSGFuZGxlcnMgKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50Lm9uZHVyYXRpb25jaGFuZ2UgPSB1bmRlZmluZWRcbiAgICBlbGVtZW50Lm9udGltZXVwZGF0ZSA9IHVuZGVmaW5lZFxuICAgIGVsZW1lbnQub25wbGF5ID0gdW5kZWZpbmVkXG4gICAgZWxlbWVudC5vbnBhdXNlID0gdW5kZWZpbmVkXG4gIH1cblxuICBfb25SVENFbmRlZCAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6ZXZlbnRdIGVuZGVkJylcbiAgICAvLyBOb3RlOiBJZiBzY3J1YmJlZCwgd2UgYXJlIHBsYXlpbmcgSExTIFZPRCBhdCBhIHNwZWNpZmljIGZyYWdtZW50IGFuZCBub3QgbGl2ZSBwbGF5YmFjay5cbiAgICBpZiAodGhpcy5pc0hMU1BsYXliYWNrQWN0aXZlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5nZXRDb250cm9scygpLnNldFN0YXRlKFBsYXliYWNrU3RhdGUuSURMRSlcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5QTEFZQkFDS19TVEFURV9DSEFOR0UsIHVuZGVmaW5lZCwge1xuICAgICAgY29kZTogUGxheWJhY2tTdGF0ZS5JRExFLFxuICAgICAgc3RhdGU6IFBsYXliYWNrU3RhdGVSZWFkYWJsZVtQbGF5YmFja1N0YXRlLklETEVdXG4gICAgfSkpXG4gIH1cblxuICBfb25SVENEdXJhdGlvbkNoYW5nZSAoZXZlbnQpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZXZlbnQudGFyZ2V0XG4gICAgZGVidWcoTkFNRSwgJ3ZpZGVvLCBbdmlkZW9lbGVtZW50OmV2ZW50XSBkdXJhdGlvbmNoYW5nZSAoJyArIGVsZW1lbnQuZHVyYXRpb24gKycpJylcbiAgICBpZiAoIXRoaXMuaXNTZWVrYWJsZSkge1xuICAgICAgdGhpcy5nZXRDb250cm9scygpLnNldFBsYXliYWNrRHVyYXRpb24oZWxlbWVudC5kdXJhdGlvbilcbiAgICB9XG4gIH1cblxuICBfb25SVENUaW1lVXBkYXRlIChldmVudCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBldmVudC50YXJnZXRcbiAgICBpZiAodGhpcy5pc1NlZWthYmxlKSB7XG4gICAgICBpZiAoIXRoaXMuX2lzSExTUGxheWJhY2tBY3RpdmUpIHtcbiAgICAgICAgY29uc3QgaGxzRHVyYXRpb24gPSB0aGlzLmhsc0VsZW1lbnQuZHVyYXRpb25cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZWxlbWVudC5jdXJyZW50VGltZSAtIHRoaXMuX2xhc3REdXJhdGlvblVwZGF0ZVxuICAgICAgICBjb25zdCB0aW1lID0gKGlzTmFOKGhsc0R1cmF0aW9uKSB8fCBobHNEdXJhdGlvbiA9PT0gMCkgPyBlbGVtZW50LmN1cnJlbnRUaW1lIDogaGxzRHVyYXRpb24gKyBNQVhfVFMgKyBvZmZzZXRcbiAgICAgICAgdGhpcy5nZXRDb250cm9scygpLnNldFNlZWtUaW1lKHRpbWUsIHRpbWUpXG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlBMQVlCQUNLX1RJTUVfVVBEQVRFLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aW1lXG4gICAgICAgIH0pKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNTZWVrYWJsZSkge1xuICAgICAgdGhpcy5nZXRDb250cm9scygpLnNldFNlZWtUaW1lKGVsZW1lbnQuY3VycmVudFRpbWUsIHVuZGVmaW5lZClcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlBMQVlCQUNLX1RJTUVfVVBEQVRFLCB1bmRlZmluZWQsIHtcbiAgICAgICAgdGltZTogZWxlbWVudC5jdXJyZW50VGltZSxcbiAgICAgICAgZHVyYXRpb246IGVsZW1lbnQuZHVyYXRpb25cbiAgICAgIH0pKVxuICAgIH1cbiAgfVxuXG4gIF9vblJUQ1BsYXkgKCkge1xuICAgIGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmV2ZW50XSBwbGF5JylcbiAgICB0aGlzLmdldENvbnRyb2xzKCkuc2V0U3RhdGUoUGxheWJhY2tTdGF0ZS5QTEFZSU5HKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlBMQVlCQUNLX1NUQVRFX0NIQU5HRSwgdW5kZWZpbmVkLCB7XG4gICAgICBjb2RlOiBQbGF5YmFja1N0YXRlLlBMQVlJTkcsXG4gICAgICBzdGF0ZTogUGxheWJhY2tTdGF0ZVJlYWRhYmxlW1BsYXliYWNrU3RhdGUuUExBWUlOR11cbiAgICB9KSlcbiAgfVxuXG4gIF9vblJUQ1BhdXNlICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3ZpZGVvZWxlbWVudDpldmVudF0gcGF1c2UnKVxuICAgIHRoaXMuZ2V0Q29udHJvbHMoKS5zZXRTdGF0ZShQbGF5YmFja1N0YXRlLlBBVVNFRClcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5QTEFZQkFDS19TVEFURV9DSEFOR0UsIHVuZGVmaW5lZCwge1xuICAgICAgY29kZTogUGxheWJhY2tTdGF0ZS5QQVVTRUQsXG4gICAgICBzdGF0ZTogUGxheWJhY2tTdGF0ZVJlYWRhYmxlW1BsYXliYWNrU3RhdGUuUEFVU0VEXVxuICAgIH0pKVxuICB9XG5cbiAgX29uSExTRHVyYXRpb25DaGFuZ2UgKGV2ZW50KSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGV2ZW50LnRhcmdldFxuICAgIGNvbnN0IG9mZnNldCA9IE1BWF9UU1xuICAgIHRoaXMuX2xhc3REdXJhdGlvblVwZGF0ZSA9IHRoaXMubWVkaWEuY3VycmVudFRpbWVcbiAgICBkZWJ1ZyhOQU1FLCBgW0hMUzp2aWRlb2VsZW1lbnQ6ZHVyYXRpb25dICR7ZWxlbWVudC5kdXJhdGlvbn0sICR7b2Zmc2V0fWApXG4gICAgdGhpcy5nZXRDb250cm9scygpLnNldFBsYXliYWNrRHVyYXRpb24oZWxlbWVudC5kdXJhdGlvbiArIG9mZnNldClcbiAgfVxuXG4gIF9vbkhMU1RpbWVVcGRhdGUgKGV2ZW50KSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGV2ZW50LnRhcmdldFxuICAgIGNvbnN0IGNvbnRyb2xzID0gdGhpcy5nZXRDb250cm9scygpXG4gICAgY29udHJvbHMuc2V0U2Vla1RpbWUoZWxlbWVudC5jdXJyZW50VGltZSwgY29udHJvbHMuZ2V0UGxheWJhY2tEdXJhdGlvbigpKVxuICAgIGlmIChlbGVtZW50LmN1cnJlbnRUaW1lID49IGVsZW1lbnQuZHVyYXRpb24pIHtcbiAgICAgIHRoaXMuX3Nob3dITFNMaXZlUGxheWJhY2soZmFsc2UsIHRoaXMuaGxzRWxlbWVudCwgdGhpcy5tZWRpYSwgdGhpcy5ob2xkZXIpXG4gICAgfVxuICB9XG5cbiAgX29uSExTUGxheSAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tITFM6dmlkZW9lbGVtZW50OmV2ZW50XSBwbGF5JylcbiAgICB0aGlzLmdldENvbnRyb2xzKCkuc2V0U3RhdGUoUGxheWJhY2tTdGF0ZS5QTEFZSU5HKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlBMQVlCQUNLX1NUQVRFX0NIQU5HRSwgdW5kZWZpbmVkLCB7XG4gICAgICBjb2RlOiBQbGF5YmFja1N0YXRlLlBMQVlJTkcsXG4gICAgICBzdGF0ZTogUGxheWJhY2tTdGF0ZVJlYWRhYmxlW1BsYXliYWNrU3RhdGUuUExBWUlOR11cbiAgICB9KSlcbiAgfVxuXG4gIF9vbkhMU1BhdXNlICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW0hMUzp2aWRlb2VsZW1lbnQ6ZXZlbnRdIHBhdXNlJylcbiAgICB0aGlzLmdldENvbnRyb2xzKCkuc2V0U3RhdGUoUGxheWJhY2tTdGF0ZS5QQVVTRUQpXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuUExBWUJBQ0tfU1RBVEVfQ0hBTkdFLCB1bmRlZmluZWQsIHtcbiAgICAgIGNvZGU6IFBsYXliYWNrU3RhdGUuUEFVU0VELFxuICAgICAgc3RhdGU6IFBsYXliYWNrU3RhdGVSZWFkYWJsZVtQbGF5YmFja1N0YXRlLlBBVVNFRF1cbiAgICB9KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBjaGFuZ2UgaW4gZnVsbHNjcmVlbiBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc0Z1bGxTY3JlZW5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVGdWxsU2NyZWVuQ2hhbmdlIChpc0Z1bGxTY3JlZW4pIHtcbiAgICBpZiAoaXNGdWxsU2NyZWVuKSB7XG4gICAgICBpZiAodGhpcy5ob2xkZXIpIHtcbiAgICAgICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1jb250YWluZXItZnVsbC1zY3JlZW4nKVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGxzRWxlbWVudCkge1xuICAgICAgICB0aGlzLmhsc0VsZW1lbnQuY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1jb250YWluZXItZnVsbC1zY3JlZW4nKVxuICAgICAgfVxuICAgICAgdGhpcy5tZWRpYS5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLWNvbnRhaW5lci1mdWxsLXNjcmVlbicpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKHRoaXMuaG9sZGVyKSB7XG4gICAgICAgIHRoaXMuaG9sZGVyLmNsYXNzTGlzdC5yZW1vdmUoJ3JlZDVwcm8tbWVkaWEtY29udGFpbmVyLWZ1bGwtc2NyZWVuJylcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhsc0VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5obHNFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3JlZDVwcm8tbWVkaWEtY29udGFpbmVyLWZ1bGwtc2NyZWVuJylcbiAgICAgIH1cbiAgICAgIHRoaXMubWVkaWEuY2xhc3NMaXN0LnJlbW92ZSgncmVkNXByby1tZWRpYS1jb250YWluZXItZnVsbC1zY3JlZW4nKVxuICAgIH1cbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5GVUxMX1NDUkVFTl9TVEFURV9DSEFOR0UsIHVuZGVmaW5lZCwgaXNGdWxsU2NyZWVuKSlcbiB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gc2V0dXAgdGhlIHByZXNlbnRhdGlvbiBvZiBhIHBsYXliYWNrIHN0cmVhbSB1c2luZyBXZWJSVEMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgaW5pdGlhbGl6YXRpb24gY29uZmlndXJhdGlvbiBtYXAuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYWRkU291cmNlIChvcHRpb25zKSB7XG4gICAgZGVidWcoTkFNRSwgJ1thZGRzb3VyY2VdJylcbiAgICAvLyBGb3JjaW5nIGN1c3RvbSBjb250cm9scyBvbiBTZWVrYWJsZSBpbXBsZW1lbnRhdGlvbi5cbiAgICB0aGlzLm1lZGlhLmNvbnRyb2xzID0gdHJ1ZVxuICAgIHRoaXMubWVkaWEuY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYScpXG4gICAgY29uc3QgdXNlUGxheWJhY2tDb250cm9scyA9IGVudmlyb25tZW50Lmhhc0F0dHJpYnV0ZURlZmluZWQodGhpcy5tZWRpYSwgJ2NvbnRyb2xzJykgJiYgZW52aXJvbm1lbnQuaGFzQ2xhc3NEZWZpbmVkKHRoaXMubWVkaWEsICdyZWQ1cHJvLW1lZGlhJylcbiAgICBpZiAodXNlUGxheWJhY2tDb250cm9scykge1xuICAgICAgdGhpcy5ob2xkZXIgPSB0aGlzLl9kZXRlcm1pbmVIb2xkZXIodGhpcy5tZWRpYSlcbiAgICB9XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBjb25zdCBoYXNEZWZpbmVkQ29udHJvbHMgPSBvcHRpb25zLmNvbnRyb2xzXG4gICAgY29uc3QgaXNNdXRlZCA9IGVudmlyb25tZW50Lmhhc0F0dHJpYnV0ZURlZmluZWQodGhpcy5tZWRpYSwgJ211dGVkJylcbiAgICBpZiAoaGFzRGVmaW5lZENvbnRyb2xzIHx8IHVzZVBsYXliYWNrQ29udHJvbHMpIHtcbiAgICAgIGlmIChoYXNEZWZpbmVkQ29udHJvbHMpIHtcbiAgICAgICAgdGhpcy5fY29udHJvbHMgPSBvcHRpb25zLmNvbnRyb2xzXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fY29udHJvbHMgPSBuZXcgUGxheWJhY2tDb250cm9sc0ltcGwodGhpcywgdGhpcy5ob2xkZXIpXG4gICAgICB9XG4gICAgICB0aGlzLm1lZGlhLmNvbnRyb2xzID0gZmFsc2VcbiAgICAgIHRoaXMuX2NvbnRyb2xzLnNldEFzVk9EKHRoaXMuaXNTZWVrYWJsZSlcbiAgICAgIHRoaXMuX2NvbnRyb2xzLnNldE11dGVkU3RhdGUoaXNNdXRlZClcbiAgICB9XG4gICAgdGhpcy5fYWRkUGxheWJhY2tIYW5kbGVycyh0aGlzLl9wbGF5YmFja05vdGlmaWNhdGlvbkNlbnRlcilcbiAgICBkZWZlcnJlZC5yZXNvbHZlKClcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gY29ubmVjdCB0byBzdHJlYW0uXG4gICAqL1xuICBjb25uZWN0ICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2Nvbm5lY3RdJylcbiAgfVxuXG4gIGF0dGVtcHRBdXRvcGxheSAobXV0ZU9uQXV0b3BsYXkgPSBmYWxzZSkge1xuICAgIHRoaXMucGxheSgpXG4gICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgIGlmIChtdXRlT25BdXRvcGxheSkge1xuICAgICAgICAgIHRoaXMubXV0ZSgpXG4gICAgICAgICAgdGhpcy5wbGF5KClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQVVUT19QTEFZQkFDS19NVVRFRCwgdW5kZWZpbmVkLCB7ZWxlbWVudDogdGhpcy5tZWRpYX0pKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5BVVRPX1BMQVlCQUNLX0ZBSUxVUkUsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgIGVycm9yOiAoZXJyLm1lc3NhZ2UgPyBlcnIubWVzc2FnZSA6IGVyciksXG4gICAgICAgICAgICAgICAgZWxlbWVudDogdGhpcy5tZWRpYVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQVVUT19QTEFZQkFDS19GQUlMVVJFLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIGVycm9yOiAoZS5tZXNzYWdlID8gZS5tZXNzYWdlIDogZSksXG4gICAgICAgICAgICBlbGVtZW50OiB0aGlzLm1lZGlhXG4gICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgZW5hYmxlTGl2ZVNlZWsgKGhsc1VSTCwgaGFzTmF0aXZlU3VwcG9ydCkge1xuICAgIGNvbnN0IGNvbnRyb2xzID0gdGhpcy5nZXRDb250cm9scygpXG4gICAgY29udHJvbHMuc2V0U2Vla1RpbWUoMSwgMSlcbiAgICB0aGlzLmhsc0VsZW1lbnQgPSB0aGlzLl9nZW5lcmF0ZUhMU0xpdmVQbGF5YmFjayh0aGlzLmhvbGRlciwgdGhpcy5tZWRpYSlcbiAgICB0aGlzLl9zaG93SExTTGl2ZVBsYXliYWNrKHRoaXMuaXNITFNQbGF5YmFja0FjdGl2ZSwgdGhpcy5obHNFbGVtZW50LCB0aGlzLm1lZGlhLCB0aGlzLmhvbGRlcilcbiAgICAvLyBFbmZvcmNlIEhMUy5KUyBvbiBTYWZhcmkgYXMgd2VsbC5cbiAgICAvKlxuICAgIGlmIChoYXNOYXRpdmVTdXBwb3J0KSB7XG4gICAgICB0aGlzLl9hZGRTZWVrYWJsZUhhbmRsZXJzKHRoaXMuaGxzRWxlbWVudCwgbnVsbClcbiAgICAgIHRoaXMuaGxzRWxlbWVudC5jb250cm9scyA9IHRydWVcbiAgICAgIGxldCBzcmMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzb3VyY2UnKVxuICAgICAgc3JjLnNyYyA9IGhsc1VSTFxuICAgICAgdGhpcy5obHNFbGVtZW50LmFwcGVuZENoaWxkKHNyYylcbiAgICAgIHRoaXMuaXNTZWVrYWJsZSA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICovXG4gICAgICBsZXQgaGxzID0gZW52aXJvbm1lbnQuY3JlYXRlSExTQ2xpZW50KHtkZWJ1ZzogdHJ1ZSwgYmFja0J1ZmZlckxlbmd0aDogMH0pXG4gICAgICB0aGlzLl9hZGRTZWVrYWJsZUhhbmRsZXJzKHRoaXMuaGxzRWxlbWVudCwgaGxzKVxuICAgICAgaGxzLmF0dGFjaE1lZGlhKHRoaXMuaGxzRWxlbWVudClcbiAgICAgIGhscy5vbihlbnZpcm9ubWVudC5nZXRITFNDbGllbnRFdmVudEVudW0oKS5NRURJQV9BVFRBQ0hFRCwgKCkgPT4ge1xuICAgICAgICBobHMubG9hZFNvdXJjZShobHNVUkwpXG4gICAgICB9KVxuICAgICAgdGhpcy5obHMgPSBobHNcbiAgICAgIHdpbmRvdy5yNXByb19obHNfY29udHJvbCA9IHRoaXMuaGxzXG4gICAgLypcbiAgICB9XG4gICAgKi9cbiAgfVxuXG4gIHBsYXkgKGZyb21Db250cm9scyA9IGZhbHNlKSB7XG4gICAgZGVidWcoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6YWN0aW9uXSBwbGF5JylcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRyeSB7XG4gICAgICBsZXQgbWF5YmVQcm9taXNlXG4gICAgICBpZiAoZnJvbUNvbnRyb2xzICYmIHRoaXMuaGxzRWxlbWVudCAmJiB0aGlzLmhsc0VsZW1lbnQucGF1c2VkKSB7XG4gICAgICAgIG1heWJlUHJvbWlzZSA9IHRoaXMuaGxzRWxlbWVudC5wbGF5KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heWJlUHJvbWlzZSA9IHRoaXMubWVkaWEucGxheSgpXG4gICAgICB9XG4gICAgICBpZiAobWF5YmVQcm9taXNlKSB7XG4gICAgICAgIG1heWJlUHJvbWlzZVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmFjdGlvbl0gcGxheSAoU1RBUlQpJylcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKGRlZmVycmVkLnJlamVjdClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmFjdGlvbl0gcGxheSAoU1RBUlQpJylcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6YWN0aW9uXSBwbGF5IChGQVVMVCkgLSAnICsgZS5tZXNzYWdlKVxuICAgICAgZGVmZXJyZWQucmVqZWN0KGUpXG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICBwYXVzZSAoZnJvbUNvbnRyb2xzID0gZmFsc2UsIGZyb21BY3Rpb25TZWVrID0gZmFsc2UpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3ZpZGVvZWxlbWVudDphY3Rpb25dIHBhdXNlJylcbiAgICB0cnkge1xuICAgICAgaWYgKGZyb21Db250cm9scyAmJiBmcm9tQWN0aW9uU2VlayAmJiB0aGlzLmhsc0VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5obHNFbGVtZW50LnBhdXNlKClcbiAgICAgICAgdGhpcy5tZWRpYS5wYXVzZSgpXG4gICAgICB9IGVsc2UgaWYgKGZyb21Db250cm9scyAmJiAhdGhpcy5obHNFbGVtZW50LnBhdXNlZCAmJiB0aGlzLmhsc0VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5obHNFbGVtZW50LnBhdXNlKClcbiAgICAgIH0gZWxzZSB7IFxuICAgICAgICB0aGlzLm1lZGlhLnBhdXNlKClcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKE5BTUUsICdbdmlkZW9lbGVtZW50OmFjdGlvbl0gcGF1c2UgKENBVENIOjpGQVVMVCkgLSAnICsgZS5tZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICByZXN1bWUgKGZyb21Db250cm9scyA9IGZhbHNlKSB7XG4gICAgZGVidWcoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6YWN0aW9uXSByZXN1bWUnKVxuICAgIHRyeSB7XG4gICAgICBsZXQgbWF5YmVQcm9taXNlID0gdGhpcy5pc0hMU1BsYXliYWNrQWN0aXZlICYmIHRoaXMuaGxzRWxlbWVudCA/IHRoaXMuaGxzRWxlbWVudC5wbGF5KCkgOiB0aGlzLm1lZGlhLnBsYXkoKVxuICAgICAgaWYgKGZyb21Db250cm9scyAmJiB0aGlzLmlzSExTUGxheWJhY2tBY3RpdmUpIHtcbiAgICAgICAgdGhpcy5tZWRpYS5wbGF5KCkuY2F0Y2goKGVycikgPT4gd2FybihOQU1FLCAnW3ZpZGVvZWxlbWVudDphY3Rpb25dIHBsYXkgKENBVENIOjpGQVVMVCkgJyArIChlcnIubWVzc2FnZSA/IGVyci5tZXNzYWdlIDogZXJyKSkpXG4gICAgICB9XG4gICAgICBpZiAobWF5YmVQcm9taXNlKSB7XG4gICAgICAgIG1heWJlUHJvbWlzZS50aGVuKCgpID0+IGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmFjdGlvbl0gcGxheSAoU1RBUlQpJykpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB3YXJuKE5BTUUsICdbdmlkZW9lbGVtZW50OmFjdGlvbl0gcGxheSAoQ0FUQ0g6OkZBVUxUKSAnICsgKGVyci5tZXNzYWdlID8gZXJyLm1lc3NhZ2UgOiBlcnIpKSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKE5BTUUsICdbdmlkZW9lbGVtZW50OmFjdGlvbl0gcmVzdW1lIChDQVRDSDo6RkFVTFQpIC0gJyArIGUubWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgc3RvcCAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6YWN0aW9uXSBzdG9wJylcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuaGxzRWxlbWVudCkge1xuICAgICAgICB0aGlzLmhsc0VsZW1lbnQuc3RvcCgpXG4gICAgICB9XG4gICAgICB0aGlzLm1lZGlhLnN0b3AoKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgLy8gb2suXG4gICAgfVxuICB9XG5cbiAgbXV0ZSAoKSB7XG4gICAgaWYgKHRoaXMuaGxzRWxlbWVudCkge1xuICAgICAgdGhpcy5obHNFbGVtZW50Lm11dGVkID0gdGhpcy5pc0hMU1BsYXliYWNrQWN0aXZlXG4gICAgfVxuICAgIHRoaXMubWVkaWEubXV0ZWQgPSB0cnVlXG4gICAgY29uc3QgY29udHJvbHMgPSB0aGlzLmdldENvbnRyb2xzKClcbiAgICBpZiAoY29udHJvbHMpIHtcbiAgICAgIGNvbnRyb2xzLnNldE11dGVkU3RhdGUodHJ1ZSlcbiAgICB9XG4gIH1cblxuICB1bm11dGUgKCkge1xuICAgIGlmICh0aGlzLmhsc0VsZW1lbnQpIHtcbiAgICAgIHRoaXMuaGxzRWxlbWVudC5tdXRlZCA9ICF0aGlzLmlzSExTUGxheWJhY2tBY3RpdmVcbiAgICAgIHRoaXMubWVkaWEubXV0ZWQgPSB0aGlzLmlzSExTUGxheWJhY2tBY3RpdmVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYS5tdXRlZCA9IGZhbHNlXG4gICAgfVxuICAgIGNvbnN0IGNvbnRyb2xzID0gdGhpcy5nZXRDb250cm9scygpXG4gICAgaWYgKGNvbnRyb2xzKSB7XG4gICAgICBjb250cm9scy5zZXRNdXRlZFN0YXRlKGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIHNldFZvbHVtZSAodmFsdWUpIHtcbiAgICB0aGlzLnVubXV0ZSgpXG4gICAgaWYgKHRoaXMuaGxzRWxlbWVudCAmJiB0aGlzLmlzSExTUGxheWJhY2tBY3RpdmUpIHtcbiAgICAgIHRoaXMuaGxzRWxlbWVudC52b2x1bWUgPSB2YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lZGlhLnZvbHVtZSA9IHZhbHVlXG4gICAgfVxuICB9XG5cbiAgc2Vla1RvIChwZXJjZW50YWdlLCBkdXJhdGlvbiA9IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLmlzU2Vla2FibGUpIHtcbiAgICAgIHRoaXMuX2NvbnRyb2xzLnNldFNlZWtUaW1lKHBlcmNlbnRhZ2UsIGR1cmF0aW9uKVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU0VFS19DSEFOR0UsIHVuZGVmaW5lZCwgeyBzZWVrOiBwZXJjZW50YWdlLCBkdXJhdGlvbjogZHVyYXRpb24gfSkpXG5cbiAgICAgIGlmICh0aGlzLmhsc0VsZW1lbnQgJiYgcGVyY2VudGFnZSA8IDEuMCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuaGxzRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKVxuICAgICAgICAgIHRoaXMuaGxzRWxlbWVudC5jdXJyZW50VGltZSA9IHRoaXMuaGxzRWxlbWVudC5kdXJhdGlvbiAqIHBlcmNlbnRhZ2VcbiAgICAgICAgICB0aGlzLl9pc0ZyYWdMb2FkaW5nID0gdHJ1ZVxuICAgICAgICAgIHRoaXMuX3Nob3dITFNMaXZlUGxheWJhY2sodHJ1ZSwgdGhpcy5obHNFbGVtZW50LCB0aGlzLm1lZGlhLCB0aGlzLmhvbGRlcilcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHdhcm4oTkFNRSwgJ1tobHN2b2Q6YWN0aW9uXSBwbGF5IChDQVRDSDo6RkFVTFQpIC0gJyArIGUubWVzc2FnZSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmhsc0VsZW1lbnQgJiYgcGVyY2VudGFnZSA+PSAxLjApIHtcbiAgICAgICAgdGhpcy5faXNGcmFnTG9hZGluZyA9IGZhbHNlXG4gICAgICAgIHRoaXMuX3Nob3dITFNMaXZlUGxheWJhY2soZmFsc2UsIHRoaXMuaGxzRWxlbWVudCwgdGhpcy5tZWRpYSwgdGhpcy5ob2xkZXIpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWEuY3VycmVudFRpbWUgPSBkdXJhdGlvbiA/IHBlcmNlbnRhZ2UgKiBkdXJhdGlvbiA6IHBlcmNlbnRhZ2VcbiAgICB9XG4gIH1cblxuICB0b2dnbGVGdWxsU2NyZWVuICgpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuaG9sZGVyKSB7XG4gICAgICAgIGVudmlyb25tZW50LnRvZ2dsZUZ1bGxTY3JlZW4odGhpcy5ob2xkZXIpXG4gICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBlO1xuICAgICAgLy8gbmFkYS5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTm90aWZpY2F0aW9uIG9mIGN1cnJlbnQgc3RyZWFtIGJlaW5nIGluIGFuIHVucHVibGlzaGVkIHN0YXRlLlxuICAgKiBUaGUgc3RyZWFtIGVudGVycyBhbiB1bnB1Ymxpc2hlZCBzdGF0ZSB3aGVuIHRoZSBicm9hZGNhc3RlciBzdG9wIHRoZSBzdHJlYW0gYW5kIHRoZSBzdWJzY3JpYmVyIGlzIHN0aWxsIGNvbm5lY3RlZC5cbiAgICovXG4gIHVucHVibGlzaCAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc3RvcCgpXG4gICAgICB0aGlzLm1lZGlhLm9uZW5kZWQuY2FsbCh0aGlzLm1lZGlhKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgLy8gbmFkYS5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBkaXNjb25uZWN0IHBsYXliYWNrLlxuICAgKi9cbiAgZGlzY29ubmVjdCAoKSB7XG4gICAgdGhpcy5fY2xlYW5VcCgpXG4gIH1cblxuICAvKipcbiAgICogUmVzcG9uZGVyIHRvIGNoYW5nZSBpbiBvcmllbnRhdGlvbiByZWNlaXZlZCB0aHJvdWdoIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gb3JpZW50YXRpb25cbiAgICogICAgICAgIFRoZSBvcmllbnRhdGlvbiB2YWx1ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZU9yaWVudGF0aW9uQ2hhbmdlIChvcmllbnRhdGlvbikge1xuICAgIGlmICh0aGlzLl9jb250cm9scyAmJiAob3JpZW50YXRpb24gJSAxODAgIT09IDApKSB7XG4gICAgICBpZiAodGhpcy5ob2xkZXIpIHtcbiAgICAgICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1iYWNrZ3JvdW5kJylcbiAgICAgIH1cbiAgICAgIHRoaXMubWVkaWEuY2xhc3NMaXN0LnJlbW92ZSgncmVkNXByby1tZWRpYS1iYWNrZ3JvdW5kJylcbiAgICB9XG4gIH1cblxuICAvKlxuICAgKiB8fCBTSEFSRUQgT0JKRUNUIElOVEVHUkFUSU9OIE5PVCBBVkFJTEFCTEUgRk9SIEhMUyBQTEFZQkFDSyB8fFxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIGFkZFNoYXJlZE9iamVjdFJlc3BvbnNlSGFuZGxlciAoaGFuZGxlcikge31cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgcmVtb3ZlU2hhcmVkT2JqZWN0UmVzcG9uc2VIYW5kbGVyIChoYW5kbGVyKSB7fVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBzZW5kVG9TaGFyZWRPYmplY3QgKG5hbWUsIGNhbGxOYW1lLCBtZXNzYWdlKSB7fVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBzZW5kUHJvcGVydHlUb1NoYXJlZE9iamVjdCAobmFtZSwga2V5LCB2YWx1ZSkge31cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgZ2V0UmVtb3RlU2hhcmVkT2JqZWN0IChzaGFyZWRPYmplY3ROYW1lKSB7fVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBjb25uZWN0VG9TaGFyZWRPYmplY3QgKHNoYXJlZE9iamVjdE5hbWUpIHt9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIGNsb3NlU2hhcmVkT2JqZWN0IChzaGFyZWRPYmplY3ROYW1lKSB7fVxuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgcGxheWJhY2sgY29udHJvbHMgaWYgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UGxheWJhY2tDb250cm9sc31cbiAgICovXG4gIGdldENvbnRyb2xzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udHJvbHNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdWJzY3JpYmVyIHR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29udHJvbGxlci5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIGdldFR5cGUgKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXllclR5cGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZsYWcgb2YgdmlkZW8gYmVpbmcgcmVjb2duaXplZCBhcyBWT0QgKFZpZGVvIE9uIERlbWFuZCkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVk9EICgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGZsYWcgb2YgdmlkZW8gYmVpbmcgY29uc2lkZXJlZCBhcyBWT0QgKFZpZGVvIE9uIERlbWFuZCkuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICovXG4gIHNldCBpc1ZPRCAodmFsdWUpIHtcbiAgICAvLyBzd2FsbG93XG4gIH1cblxuICBnZXQgaXNTZWVrYWJsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU2Vla2FibGVcbiAgfVxuXG4gIHNldCBpc1NlZWthYmxlICh2YWx1ZSkge1xuICAgIHRoaXMuX2lzU2Vla2FibGUgPSB2YWx1ZVxuICAgIGlmICh0aGlzLl9jb250cm9scykge1xuICAgICAgdGhpcy5fY29udHJvbHMuc2V0QXNWT0QodmFsdWUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmxhZyBvZiBjdXJyZW50IHBsYXliYWNrIHN0YXRlIGJlaW5nIFwic2NydWJiZWRcIiAoaWYgZW5hYmxlTGl2ZVNlZWsgaXMgdHJ1ZSBhbmQgbm90IGF0IGhlYWQgdGltZSkuXG4gICAqXG4gICAqIFNldHRlciBpcyBwcml2YXRlIGludGVybmFsLlxuICAgKlxuICAgKiBAcmV0dXJuIEJvb2xlYW5cbiAgICovXG4gIGdldCBpc0hMU1BsYXliYWNrQWN0aXZlICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNITFNQbGF5YmFja0FjdGl2ZVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUlRDU2Vla2FibGVTb3VyY2VIYW5kbGVyXG5cbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vY29yZS9ldmVudC1lbWl0dGVyJ1xuaW1wb3J0IHsgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdNZXNzYWdlVHJhbnNwb3J0J1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIE1lc3NhZ2VUcmFuc3BvcnQgaW1wbGVtZW50YXRpb25zLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZXNzYWdlVHJhbnNwb3J0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAobmFtZSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9uYW1lID0gbmFtZSB8fCBOQU1FXG4gICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycyA9IFtdXG4gICAgdGhpcy5fYXN5bmNUaWNrZXRzID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIHBhcnNlIEpTT04gZnJvbSBtZXNzYWdlIHJlY2VpdmVkIG92ZXIgV2ViU29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZVxuICAgKiAgICAgICAgU3RyaW5nIG9yIE9iamVjdC5cbiAgICovXG4gIGdldEpzb25Gcm9tU29ja2V0TWVzc2FnZSAobWVzc2FnZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG1lc3NhZ2UuZGF0YSA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKG1lc3NhZ2UuZGF0YSkgOiBtZXNzYWdlLmRhdGFcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4odGhpcy5fbmFtZSwgJ0NvdWxkIG5vdCBwYXJzZSBtZXNzYWdlIGFzIEpTT04uIE1lc3NhZ2U9ICcgKyBtZXNzYWdlLmRhdGEgKyAnLiBFcnJvcj0gJyArIGUubWVzc2FnZSlcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgcmVzcG9uc2UgaGFuZGxlciB0byBiZSBpbnZva2VkIHdpdGggYHJlc3BvbmQoKWAgdG8gbWVzc2FnZSBhbmQgcmV0dXJuIGEgYm9vbGVhbiBvZiB3aGV0aGVyIHRoZSBoYW5kbGVyIGhhbmRsZWQgdGhlIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyXG4gICAqICAgICAgICBIYW5kbGVyIG9iamVjdCB0aGF0IGhhcyB0aGUgbWVzc2FnZSBgcmVzcG9uZChtZXNzYWdlKWAgb24gaXRzIEFQSS5cbiAgICovXG4gIGFkZFJlc3BvbnNlSGFuZGxlciAoaGFuZGxlcikge1xuICAgIHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMucHVzaChoYW5kbGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc3BvbmRzIHRvIG1lc3NhZ2VzIGNvbWluZyBvdmVyIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2VcbiAgICovXG4gIHJlc3BvbmQgKG1lc3NhZ2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHdhcm4odGhpcy5fbmFtZSwgJ3Jlc3BvbmQoKSBzaG91bGQgYmUgb3ZlcnJpZGVuLicpXG4gIH1cblxuICAvKipcbiAgICogUG9zdHMgcmVxdWVzdCBvdmVyIG1lc3NhZ2UgbGF5ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fVxuICAgKiAgICAgICAgUmVxdWVzdCBvYmplY3QgdG8gYmUgdHVybmVkIGludG8gSlNPTiBzdHJpbmcgZm9yIHRyYW5zcG9ydC5cbiAgICovXG4gIHBvc3QgKHJlcXVlc3QpIHsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB3YXJuKHRoaXMuX25hbWUsICdwb3N0KCkgc2hvdWxkIGJlIG92ZXJyaWRlbi4nKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gcG9zdCBkYXRhIG92ZXIgbWVzc2FnZSBsYXllciBhbmQgcmVjZWl2ZSBhIGNhbGwgYmFjayBhc3luY2hyb25vdXNseSBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZW5kUmVxdWVzdFxuICAgKi9cbiAgcG9zdEFzeW5jIChzZW5kUmVxdWVzdCkge1xuICAgIGNvbnN0IHAgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBjb25zdCBpZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDApLnRvU3RyaW5nKDE2KVxuICAgIHNlbmRSZXF1ZXN0LmlkID0gaWRcbiAgICBzZW5kUmVxdWVzdC5hc3luYyA9IHRydWVcbiAgICB0aGlzLl9hc3luY1RpY2tldHMucHVzaCh7aWQ6IGlkLCBwcm9taXNlOiBwfSlcbiAgICB0aGlzLnBvc3Qoc2VuZFJlcXVlc3QpXG4gICAgcmV0dXJuIHAucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBTaGFyZWRPYmplY3QgcmVzcG9uc2UgaGFuZGxlci4gSGFuZGxlcnMgYXJlIHJlcXVlc3RlZCB0byByZXNwb25kIHRvIGEgbWVzc2FnZSBpbiBgaGFuZGxlTWVzc2FnZVJlc3BvbnNlYC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJcbiAgICovXG4gIGFkZFNoYXJlZE9iamVjdFJlc3BvbnNlSGFuZGxlciAoaGFuZGxlcikge1xuICAgIHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMucHVzaChoYW5kbGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBTaGFyZWRPYmplY3QgcmVzcG9uc2UgaGFuZGxlci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJcbiAgICovXG4gIHJlbW92ZVNoYXJlZE9iamVjdFJlc3BvbnNlSGFuZGxlciAoaGFuZGxlcikge1xuICAgIGxldCBpID0gdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5sZW5ndGhcbiAgICBsZXQgckhhbmRsZXJcbiAgICB3aGlsZSgtLWkgPiAtMSkge1xuICAgICAgckhhbmRsZXIgPSB0aGlzLl9yZXNwb25zZUhhbmRsZXJzW2ldXG4gICAgICBpZiAockhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5zcGxpY2UoaSwgMSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYXZlcnNlcyBsaXN0IG9mIHJlc3BvbnNlIGhhbmRsZXJzIGFuZCByZXR1cm5zIGZsYWcgb2YgaXQgYmVpbmcgaGFuZGxlZCB3aXRoaW4gdGhlIGNoYWluLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaGFuZGxlTWVzc2FnZVJlc3BvbnNlIChtZXNzYWdlKSB7XG4gICAgbGV0IGksIGhhbmRsZXJcbiAgICBsZXQgbGVuZ3RoID0gdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGhhbmRsZXIgPSB0aGlzLl9yZXNwb25zZUhhbmRsZXJzW2ldXG4gICAgICBpZiAoaGFuZGxlci5yZXNwb25kKG1lc3NhZ2UpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gZ2V0IFNoYXJlZE9iamVjdCBmcm9tIHNlcnZlciBvdmVyIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICovXG4gIGdldFJlbW90ZVNoYXJlZE9iamVjdCAobmFtZSkge1xuICAgIHRoaXMucG9zdCh7XG4gICAgICBzaGFyZWRPYmplY3RHZXRSZW1vdGU6IHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBjb25uZWN0IHRvIFNoYXJlZE9iamVjdCBmcm9tIHNlcnZlciBvdmVyIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICovXG4gIGNvbm5lY3RUb1NoYXJlZE9iamVjdCAobmFtZSkge1xuICAgIHRoaXMucG9zdCh7XG4gICAgICBzaGFyZWRPYmplY3RDb25uZWN0OiB7XG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gc2VuZCBtZXRob2QgY2FsbCB0byBTaGFyZWRPYmplY3Qgb3ZlciBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2ROYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuICBzZW5kVG9TaGFyZWRPYmplY3QgKG5hbWUsIG1ldGhvZE5hbWUsIGRhdGEpIHtcbiAgICB0aGlzLnBvc3Qoe1xuICAgICAgc2hhcmVkT2JqZWN0U2VuZDoge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZE5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IGRhdGFcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gdXBkYXRlIHByb3BlcnR5IG9uIFNoYXJlZE9iamVjdCBvdmVyIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNlbmRQcm9wZXJ0eVRvU2hhcmVkT2JqZWN0IChuYW1lLCBrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5wb3N0KHtcbiAgICAgIHNoYXJlZE9iamVjdFNldFByb3BlcnR5OiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gY2xvc2UgdGhlIFNoYXJlZE9iamVjdCBjb25uZWN0aW9uIG92ZXIgV2ViU29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKi9cbiAgY2xvc2VTaGFyZWRPYmplY3QgKG5hbWUpIHtcbiAgICB0aGlzLnBvc3Qoe1xuICAgICAgc2hhcmVkT2JqZWN0Q2xvc2U6IHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCAqIGFzIHdlYnNvY2tldCBmcm9tICcuLi9hZGFwdGVyL3dlYnNvY2tldCdcbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCBNZXNzYWdlVHJhbnNwb3J0IGZyb20gJy4vbWVzc2FnZS10cmFuc3BvcnQnXG5pbXBvcnQge1xuICBNZXNzYWdlVHJhbnNwb3J0U3RhdGVFdmVudCxcbiAgTWVzc2FnZVRyYW5zcG9ydFN0YXRlRXZlbnRUeXBlc1xufSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCB7IGluZm8sIGRlYnVnLCB3YXJuIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvU29ja2V0UHJveHknXG5cbi8qKlxuICogQmFzZSBQcm94eSBmb3IgY29tbXVuaWNhdGlvbiB3aXRoIFdlYlNvY2tldC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBTb2NrZXRIZWxwZXIgZXh0ZW5kcyBNZXNzYWdlVHJhbnNwb3J0IHtcblxuICBjb25zdHJ1Y3RvciAocmVzcG9uZGVyLCBuYW1lKSB7XG4gICAgc3VwZXIobmFtZSB8fCBOQU1FKVxuICAgIHRoaXMuX3Jlc3BvbmRlciA9IHJlc3BvbmRlclxuICAgIHRoaXMuX3BlbmRpbmdQb3N0UmVxdWVzdHMgPSBbXVxuICAgIHRoaXMuX3dlYnNvY2tldCA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycyA9IFtdXG4gICAgdGhpcy5faXNUZXJtaW5hdGVkID0gZmFsc2VcbiAgICB0aGlzLl9yZXRyeUNvdW50ID0gMFxuICAgIHRoaXMuX3JldHJ5TGltaXQgPSAxXG4gICAgdGhpcy5fcmVhZHlDaGVja0NvdW50ID0gMFxuICAgIHRoaXMuX3JlYWR5Q2hlY2tMaW1pdCA9IDEwXG4gICAgdGhpcy5fb3BlblN0YXRlID0gMFxuICAgIHRoaXMuX29uY2xvc2UgPSB0aGlzLnRlYXJEb3duLmJpbmQodGhpcylcblxuICAgIHRoaXMuX29ub3BlblRpbWVvdXQgPSAwXG4gIH1cblxuICBfcmVzZXRPbm9wZW5UaW1lb3V0ICh3cywgcHJvbWlzZSkge1xuICAgIC8vIGNvbnN0IGZvcmNlUmVjb25uZWN0ID0gZW52aXJvbm1lbnQuZ2V0SXNNb3ooKSB8fCBlbnZpcm9ubWVudC5nZXRJc0VkZ2UoKVxuICAgIGxldCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dClcbiAgICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSAxKSB7XG4gICAgICAgIGluZm8odGhpcy5fbmFtZSwgJ1t3ZWJzb2NrZXRvcGVuXScpXG4gICAgICAgIHRoaXMuX29wZW5TdGF0ZSA9IDFcbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlbmRpbmdQb3N0UmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMucG9zdCh0aGlzLl9wZW5kaW5nUG9zdFJlcXVlc3RzLnNoaWZ0KCkpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Jlc3BvbmRlciAmJiB0aGlzLl9yZXNwb25kZXIub25Tb2NrZXRPcGVuKSB7XG4gICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU29ja2V0T3BlbigpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBNZXNzYWdlVHJhbnNwb3J0U3RhdGVFdmVudChNZXNzYWdlVHJhbnNwb3J0U3RhdGVFdmVudFR5cGVzLk9QRU4sIHRoaXMuX25hbWUsIHtzb2NrZXQ6IHRoaXN9KSlcbiAgICAgIH0gZWxzZSBpZih3cy5yZWFkeVN0YXRlID09PSAwKSB7XG4gICAgICAgIGlmICgrK3RoaXMuX3JlYWR5Q2hlY2tDb3VudCA+IHRoaXMuX3JlYWR5Q2hlY2tMaW1pdCkge1xuICAgICAgICAgIHdhcm4odGhpcy5fbmFtZSwgYFdlYlNvY2tldCBjb25uZWN0aW9uIGlzc3VlLiBXZSBoYXZlIHdhaXRlZCBmb3IgJHt0aGlzLl9yZWFkeUNoZWNrQ291bnQtMX0gc2FtcGxlcywgd2l0aG91dCBhbnkgY29ubmVjdGlvbi5gKVxuICAgICAgICAgIC8vIElmIEZpcmVmb3gvRWRnZSwgdHJ5IGEgc2Vjb25kIGNvbm5lY3Rpb24gYXR0ZW1wdCBvciBmYWlsLlxuICAgICAgICAgIC8qXG4gICAgICAgICAgaWYgKGZvcmNlUmVjb25uZWN0ICYmICsrdGhpcy5fcmV0cnlDb3VudCA8IHRoaXMuX3JldHJ5TGltaXQpIHtcbiAgICAgICAgICAgIHdhcm4odGhpcy5fbmFtZSwgYFdlYlNvY2tldCBhdHRlbXB0aW5nIHJldHJ5Li4uYClcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVNvY2tldEhhbmRsZXJzKHdzKVxuICAgICAgICAgICAgdGhpcy5fb25vcGVuVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fb25vcGVuVGltZW91dClcbiAgICAgICAgICAgICAgdGhpcy5zZXRVcCh3cy51cmwsIHByb21pc2UpXG4gICAgICAgICAgICB9LCAyMDAwKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9taXNlLnJlamVjdCh7dHlwZTogJ1RpbWVvdXQnfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgKi9cbiAgICAgICAgICB0aGlzLmNsZWFyUmV0cnkoKVxuICAgICAgICAgIHByb21pc2UucmVqZWN0KHt0eXBlOiAnVGltZW91dCd9KVxuICAgICAgICAgIHRoaXMudGVhckRvd24oKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZm8odGhpcy5fbmFtZSwgYFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIHN0aWxsIG9wZW5pbmcsIHdpbGwgbGV0IGl0IGNvbnRpbnVlICgke3RoaXMuX3JlYWR5Q2hlY2tDb3VudH0pLi4uYClcbiAgICAgICAgICB0aGlzLl9vbm9wZW5UaW1lb3V0ID0gdGhpcy5fcmVzZXRPbm9wZW5UaW1lb3V0KHdzLCBwcm9taXNlKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvKHRoaXMuX25hbWUsIGBXZWJTb2NrZXQgY29ubmVjdGlvbiBhdHRlbXB0cyBoYXZlIGVuZGVkIHdpdGggc3RhdGUgKCR7d3MucmVhZHlTdGF0ZX0pLmApXG4gICAgICB9XG4gICAgfSwgNTAwKVxuICAgIHJldHVybiB0aW1lb3V0XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBldmVudCBoYW5kbGVycyBmcm9tIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJTb2NrZXR9IHdzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVtb3ZlU29ja2V0SGFuZGxlcnMgKHdzKSB7XG4gICAgaWYgKHdzKSB7XG4gICAgICB3cy5vbm9wZW4gPSB1bmRlZmluZWRcbiAgICAgIHdzLm9ubWVzc2FnZSA9IHVuZGVmaW5lZFxuICAgICAgd3Mub25lcnJvciA9IHVuZGVmaW5lZFxuICAgICAgd3Mub25jbG9zZSA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NpZ25zIGV2ZW50IGhhbmRsZXIgdG8gV2ViU29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYlNvY2tldH0gd3NcbiAgICogQHBhcmFtIHtQcm9taXNlfVxuICAgKiAgICAgICAgVGhlIGBQcm9taXNlYCB0byByZWplY3Qgb24gZXJyb3IgaW4gY29ubmVjdGlvbiB0byBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYWRkU29ja2V0SGFuZGxlcnMgKHdzLCBwcm9taXNlKSB7XG5cbiAgICAvKiBcbiAgICAgKiBSZW1vdmluZyB0aGlzIGluIGZhdm9yIG9mIGNoZWNraW5nIHJlYWR5U3RhdGUgZm9yIHZlcmlmaWNhdGlvbiBvZiBvcGVuLlxuICAgICAqXG4gICAgd3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgaW5mbyh0aGlzLl9uYW1lLCAnW3dlYnNvY2tldG9wZW5dJylcbiAgICAgIHdoaWxlICh0aGlzLl9wZW5kaW5nUG9zdFJlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5wb3N0KHRoaXMuX3BlbmRpbmdQb3N0UmVxdWVzdHMuc2hpZnQoKSlcbiAgICAgIH1cbiAgICB9XG4gICAgKi9cblxuICAgIHRoaXMuX29wZW5TdGF0ZSA9IDBcbiAgICB0aGlzLl9yZWFkeUNoZWNrQ291bnQgPSAwXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX29ub3BlblRpbWVvdXQpXG4gICAgdGhpcy5fb25vcGVuVGltZW91dCA9IHRoaXMuX3Jlc2V0T25vcGVuVGltZW91dCh3cywgcHJvbWlzZSlcblxuICAgIHdzLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgIHdhcm4odGhpcy5fbmFtZSwgYFt3ZWJzb2NrZXRlcnJvcl06IEVycm9yIGZyb20gV2ViU29ja2V0LiAke2Vycm9yLnR5cGV9LmApXG4gICAgICB0aGlzLmNsZWFyUmV0cnkoKVxuICAgICAgcHJvbWlzZS5yZWplY3QoZXJyb3IpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IE1lc3NhZ2VUcmFuc3BvcnRTdGF0ZUV2ZW50KE1lc3NhZ2VUcmFuc3BvcnRTdGF0ZUV2ZW50VHlwZXMuRVJST1IsIHRoaXMuX25hbWUsIHtzb2NrZXQ6IHRoaXMsIGVycm9yOiBlcnJvcn0pKVxuICAgIH1cblxuICAgIHdzLm9ubWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICB0aGlzLnJlc3BvbmQobWVzc2FnZSlcbiAgICB9XG5cbiAgICB3cy5vbmNsb3NlID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuY29kZSA+IDEwMDApIHtcbiAgICAgICAgd2Fybih0aGlzLl9uYW1lLCBgW3dlYnNvY2tldGNsb3NlXTogJHtldmVudC5jb2RlfWApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1Zyh0aGlzLl9uYW1lLCBgW3dlYnNvY2tldGNsb3NlXTogJHtldmVudC5jb2RlfWApXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcmVzcG9uZGVyICYmIHRoaXMuX3Jlc3BvbmRlci5vblNvY2tldENsb3NlKSB7XG4gICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNvY2tldENsb3NlKGV2ZW50KVxuICAgICAgfVxuICAgICAgdGhpcy5jbGVhclJldHJ5KClcbiAgICAgIHRoaXMuX3JlbW92ZVNvY2tldEhhbmRsZXJzKHdzIHx8IHRoaXMuX3dlYnNvY2tldClcbiAgICAgIHRoaXMuX29wZW5TdGF0ZSA9IDBcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgTWVzc2FnZVRyYW5zcG9ydFN0YXRlRXZlbnQoTWVzc2FnZVRyYW5zcG9ydFN0YXRlRXZlbnRUeXBlcy5DTE9TRSwgdGhpcy5fbmFtZSwge3NvY2tldDogdGhpcywgZXZlbnQ6IGV2ZW50fSkpXG4gICAgfVxuXG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlciBmb3IgdW5leHBlY3RlZCBlcnJvciB0aHJvdWdoIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVycm9yXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25VbmV4cGVjdGVkU29ja2V0RXJyb3IgKGVycm9yKSB7XG4gICAgaWYgKHRoaXMuX3Jlc3BvbmRlciAmJiB0aGlzLl9yZXNwb25kZXIub25Tb2NrZXRDbG9zZSkge1xuICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU29ja2V0Q2xvc2UoZXJyb3IpXG4gICAgfVxuICAgIHRoaXMudHJpZ2dlcihuZXcgTWVzc2FnZVRyYW5zcG9ydFN0YXRlRXZlbnQoTWVzc2FnZVRyYW5zcG9ydFN0YXRlRXZlbnRUeXBlcy5DTE9TRSwgdGhpcy5fbmFtZSwge3NvY2tldDogdGhpc30pKVxuICAgIHdhcm4odGhpcy5fbmFtZSwgYFt3ZWJzb2NrZXRlcnJvcl06IFBvc3NpYmxlIFVuZXhwZWN0ZWQgRXJyb3IgZnJvbSBXZWJTb2NrZXQuICR7ZXJyb3IudHlwZX0sICR7ZXJyb3IuZGV0YWlsfWApXG4gICAgdGhpcy5jbGVhclJldHJ5KClcbiAgICB0aGlzLl9yZW1vdmVTb2NrZXRIYW5kbGVycyh0aGlzLl93ZWJzb2NrZXQpXG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSByZXRyeSBjb3VudCB0byBhbGxvdyBmb3Igc2luZ2xlIHB1Ymxpc2hlciB0byByZXRyeSBhZ2FpbiBhZnRlciBhbiB1bnB1Ymxpc2guXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjbGVhclJldHJ5ICgpIHtcbiAgICB0aGlzLl9yZXRyeUNvdW50ID0gMFxuICAgIHRoaXMuX3JlYWR5Q2hlY2tDb3VudCA9IDBcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fb25vcGVuVGltZW91dClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIHNldHVwIFdlYlNvY2tldCBjb25uZWN0aW9uIGZvciBjb21tdW5pY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gICAqICAgICAgICBFbmRwb2ludCBVUkwgb2YgdGhlIHNvY2tldCB0byBjb25uZWN0IHRvLlxuICAgKiBAcGFyYW0ge1Byb21pc2V9IHNldHVwUHJvbWlzZVxuICAgKiAgICAgICAgVGhlIGBQcm9taXNlYCB0byByZXNvbHZlIG9yIHJlamVjdCBvbiBzdWNjZXNzIG9mIHNldHVwIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgKi9cbiAgc2V0VXAgKHVybCwgc2V0dXBQcm9taXNlKSB7XG4gICAgY29uc3QgZm9yY2VSZWNvbm5lY3QgPSBlbnZpcm9ubWVudC5nZXRJc01veigpIHx8IGVudmlyb25tZW50LmdldElzRWRnZSgpXG4gICAgZGVidWcodGhpcy5fbmFtZSwgYFt3ZWJzb2NrZXQ6c2V0dXBdICR7dXJsfS5gKVxuICAgIHRoaXMudGVhckRvd24oKVxuICAgIHRoaXMuX2lzVGVybWluYXRlZCA9IGZhbHNlXG4gICAgdGhpcy5fY29ubmVjdGlvblByb21pc2UgPSBzZXR1cFByb21pc2VcbiAgICBlbnZpcm9ubWVudC5hZGRDbG9zZUhhbmRsZXIodGhpcy5fb25jbG9zZSlcbiAgICB0aGlzLl93ZWJzb2NrZXQgPSB3ZWJzb2NrZXQuY3JlYXRlKHVybClcbiAgICB0aGlzLl9hZGRTb2NrZXRIYW5kbGVycyh0aGlzLl93ZWJzb2NrZXQsIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlKVxuICAgIGlmIChmb3JjZVJlY29ubmVjdCAmJiB0aGlzLl9yZXRyeUNvdW50KysgPCB0aGlzLl9yZXRyeUxpbWl0KSB7XG4gICAgICBkZWJ1Zyh0aGlzLl9uYW1lLCAnV2UgaGF2ZSBkZXRlcm1pbmVkIGl0IGlzIEZpcmVmb3ggYW5kIGFyZSBzZXR0aW5nIHVwIGEgcmV0cnkgbGltaXQuJylcbiAgICAgIGxldCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl93ZWJzb2NrZXQgJiYgdGhpcy5fd2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IDApIHtcbiAgICAgICAgICBkZWJ1Zyh0aGlzLl9uYW1lLCBgW3dlYnNvY2tldDpGRi10aW1lb3V0XWApXG4gICAgICAgICAgZGVidWcodGhpcy5fbmFtZSwgJ091ciBjb25uZWN0aW9uIG9uIEZpcmVmb3ggdG8gdGhlIHdzcyBlbmRwb2ludCBoYXMgdGltZWQgb3V0LiBMZXRcXCdzIHRyeSB0aGF0IGFnYWluLicpXG4gICAgICAgICAgdGhpcy5fcmVtb3ZlU29ja2V0SGFuZGxlcnModGhpcy5fd2Vic29ja2V0KVxuICAgICAgICAgIHRoaXMuc2V0VXAodXJsLCBzZXR1cFByb21pc2UpXG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgICB9LCAyMDAwKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIHNldHVwIFdlYlNvY2tldCBjb25uZWN0aW9uIGZvciBjb21tdW5pY2F0aW9uLlxuICAgKiBVU0UgV0lUSCBDQVVUSU9OLiBJdCBpcyBhc3N1bWVkIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZyBieSBwcm92aWRpbmcgYSBwcmV2aW91c2x5IGVzdGFibGlzaGVkIFdlYlNvY2tldCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJTb2NrZXR9IHNvY2tldFxuICAgKiAgICAgICAgUHJldmlvdXNseSBlc3RhYmxpc2hlZCBXZWJTb2NrZXQgdG8gdXNlIGZvciBjb21tdW5pY2F0aW9uIGFuZCBtb25pdG9yaW5nLlxuICAgKiBAcGFyYW0ge1Byb21pc2V9IHNldHVwUHJvbWlzZVxuICAgKiAgICAgICAgVGhlIGBQcm9taXNlYCB0byByZXNvbHZlIG9yIHJlamVjdCBvbiBzdWNjZXNzIG9mIHNldHVwIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgKi9cbiAgc2V0VXBXaXRoU29ja2V0IChzb2NrZXQsIHNldHVwUHJvbWlzZSkge1xuICAgIGRlYnVnKHRoaXMuX25hbWUsIGBbd2Vic29ja2V0OnNldHVwV2l0aFNvY2tldF0gJHtzb2NrZXQudXJsfS5gKVxuICAgIHRoaXMudGVhckRvd24oKVxuICAgIHRoaXMuX2lzVGVybWluYXRlZCA9IGZhbHNlXG4gICAgdGhpcy5fY29ubmVjdGlvblByb21pc2UgPSBzZXR1cFByb21pc2VcbiAgICBlbnZpcm9ubWVudC5hZGRDbG9zZUhhbmRsZXIodGhpcy5fb25jbG9zZSlcbiAgICB0aGlzLl93ZWJzb2NrZXQgPSBzb2NrZXRcbiAgICB0aGlzLl9hZGRTb2NrZXRIYW5kbGVycyh0aGlzLl93ZWJzb2NrZXQsIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldmVycyAoY2hvcHMpIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgdGhyb3VnaCBhIFBPU1QgcmVxdWVzdC5cbiAgICovXG4gIHNldmVyIChyZXF1ZXN0KSB7XG4gICAgZGVidWcodGhpcy5fbmFtZSwgJ1t3ZWJzb2NrZXQ6c2V2ZXJdJylcbiAgICBpZiAodGhpcy5fd2Vic29ja2V0KSB7XG4gICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICB0aGlzLnBvc3QocmVxdWVzdClcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbW92ZVNvY2tldEhhbmRsZXJzKHRoaXMuX3dlYnNvY2tldClcbiAgICAgIHRoaXMudGVhckRvd24oKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIHRlYXIgZG93biBhbnkgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAqL1xuICB0ZWFyRG93biAoKSB7XG4gICAgdGhpcy5fcGVuZGluZ1Bvc3RSZXF1ZXN0cy5sZW5ndGggPSAwXG4gICAgaWYgKHR5cGVvZiB0aGlzLl93ZWJzb2NrZXQgIT09ICd1bmRlZmluZWQnICYmICF0aGlzLl9pc1Rlcm1pbmF0ZWQpIHtcbiAgICAgIGRlYnVnKHRoaXMuX25hbWUsICdbdGVhcmRvd25dID4+JylcbiAgICAgIGRlYnVnKHRoaXMuX25hbWUsIGBbV2ViU29ja2V0KCR7dGhpcy5fd2Vic29ja2V0LnVybH0pXSBjbG9zZSgpID4+YClcbiAgICAgIC8vICAgICAgdGhpcy5fcmVtb3ZlU29ja2V0SGFuZGxlcnModGhpcy5fd2Vic29ja2V0KVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0LmNsb3NlKClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgd2Fybih0aGlzLl9uYW1lLCBgQXR0ZW1wdCB0byBjbG9zZSBXZWJTb2NrZXQgZmFpbGVkOiAke2UubWVzc2FnZX0uYClcbiAgICAgICAgdGhpcy5fcmVtb3ZlU29ja2V0SGFuZGxlcnModGhpcy5fd2Vic29ja2V0KVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRoaXMuX3dlYnNvY2tldCkge1xuICAgICAgICAgIGRlYnVnKHRoaXMuX25hbWUsIGA8PCBbV2ViU29ja2V0KCR7dGhpcy5fd2Vic29ja2V0LnVybH0pXSBjbG9zZSgpYClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVidWcodGhpcy5fbmFtZSwgJzw8IFt0ZWFyZG93bl0nKVxuICAgIH1cbiAgICB0aGlzLl93ZWJzb2NrZXQgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9pc1Rlcm1pbmF0ZWQgPSB0cnVlXG4gICAgdGhpcy5fb3BlblN0YXRlID0gMFxuICAgIHdoaWxlKHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5zaGlmdCgpXG4gICAgfVxuICAgIGVudmlyb25tZW50LnJlbW92ZUNsb3NlSGFuZGxlcih0aGlzLl9vbmNsb3NlKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gcG9zdCBub3RpZmljYXRpb24gb2YgZW5kIG9mIGNhbmRpZGF0ZXMgaW4gV2ViUlRDIHNjZW5hcmlvLlxuICAgKi9cbiAgcG9zdEVuZE9mQ2FuZGlkYXRlcyAoc3RyZWFtTmFtZSkge1xuICAgIHRoaXMucG9zdCh7XG4gICAgICBoYW5kbGVDYW5kaWRhdGU6IHN0cmVhbU5hbWUsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNhbmRpZGF0ZToge1xuICAgICAgICAgIHR5cGU6ICdjYW5kaWRhdGUnLFxuICAgICAgICAgIGNhbmRpZGF0ZTogJydcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBwb3N0IGRhdGEgb3ZlciBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgICogUXVldWVzIG1lc3NhZ2VzIGlmIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIHN0aWxsIGJlaW5nIGVzdGFibGlzaGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2VuZFJlcXVlc3RcbiAgICovXG4gIHBvc3QgKHNlbmRSZXF1ZXN0KSB7XG4gICAgaWYgKHRoaXMuX3dlYnNvY2tldCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX29wZW5TdGF0ZSA9PT0gMSAvKiBXZWJTb2NrZXQuT1BFTiAqLykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGVidWcodGhpcy5fbmFtZSwgJ1t3ZWJzb2NrZXQtcG9zdF06ICcgKyBKU09OLnN0cmluZ2lmeShzZW5kUmVxdWVzdCwgbnVsbCwgMikpXG4gICAgICAgIHRoaXMuX3dlYnNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHNlbmRSZXF1ZXN0KSlcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGRlYnVnKHRoaXMuX25hbWUsIGBDb3VsZCBub3Qgc2VuZCByZXF1ZXN0OiAke3NlbmRSZXF1ZXN0fS4gJHtlfWApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLl93ZWJzb2NrZXQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAodGhpcy5fd2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IDIgfHwgdGhpcy5fd2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IDMpKSAvKiBXZWJTb2NrZXQuKENMT1NJTkcgfCBDTE9TRUQpICovIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLl9pc1Rlcm1pbmF0ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdQb3N0UmVxdWVzdHMucHVzaChzZW5kUmVxdWVzdClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc3BvbmRzIHRvIG1lc3NhZ2VzIGNvbWluZyBvdmVyIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2VcbiAgICovXG4gIHJlc3BvbmQgKG1lc3NhZ2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGxldCBoYW5kbGVkID0gdGhpcy5oYW5kbGVNZXNzYWdlUmVzcG9uc2UobWVzc2FnZSlcbiAgICBpZiAoIWhhbmRsZWQgJiYgbWVzc2FnZS5kYXRhKSB7XG4gICAgICBsZXQganNvbiA9IHRoaXMuZ2V0SnNvbkZyb21Tb2NrZXRNZXNzYWdlKG1lc3NhZ2UpXG4gICAgICBpZiAoanNvbiA9PT0gbnVsbCkge1xuICAgICAgICB3YXJuKHRoaXMuX25hbWUsICdEZXRlcm1pbmVkIHdlYnNvY2tldCByZXNwb25zZSBub3QgaW4gY29ycmVjdCBmb3JtYXQuIEFib3J0aW5nIG1lc3NhZ2UgaGFuZGxlLicpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZGVidWcodGhpcy5fbmFtZSwgJ1t3ZWJzb2NrZXQtcmVzcG9uc2VdOiAnICsgSlNPTi5zdHJpbmdpZnkoanNvbiwgbnVsbCwgMikpXG4gICAgICBpZiAoanNvbi5pc0F2YWlsYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5pc0F2YWlsYWJsZSA9PT0gJ2Jvb2xlYW4nICYmIGpzb24uaXNBdmFpbGFibGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5fcmVzcG9uZGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25TdHJlYW1BdmFpbGFibGUoanNvbilcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5fcmVzcG9uZGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25TdHJlYW1VbmF2YWlsYWJsZShqc29uKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGpzb24uYXN5bmMgJiYganNvbi5pZCkge1xuICAgICAgICBjb25zdCB0aWNrZXQgPSB0aGlzLl9hc3luY1RpY2tldHMuZmluZChlbCA9PiBlbC5pZCA9PT0ganNvbi5pZClcbiAgICAgICAgY29uc3QgeyBwcm9taXNlIH0gPSB0aWNrZXRcbiAgICAgICAgaWYgKHByb21pc2UgJiYganNvbi5kYXRhKSB7XG4gICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKGpzb24uZGF0YSlcbiAgICAgICAgfSBlbHNlIGlmIChwcm9taXNlICYmIGpzb24uZXJyb3IpIHtcbiAgICAgICAgICBwcm9taXNlLnJlamVjdChqc29uLmVycm9yKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGpzb24uZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0ganNvblxuICAgICAgICBpZiAoZGF0YS5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoZGF0YS50eXBlID09PSAnZXJyb3InICYmIHRoaXMuX3Jlc3BvbmRlcikge1xuICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU29ja2V0TWVzc2FnZUVycm9yKGRhdGEubWVzc2FnZSwgZGF0YS5kZXRhaWwpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdzdGF0dXMnKSB7XG4gICAgICAgICAgaWYgKGRhdGEuY29kZSA9PT0gJ05ldENvbm5lY3Rpb24uQ29ubmVjdC5TdWNjZXNzJykge1xuICAgICAgICAgICAgdGhpcy5fd2Vic29ja2V0Lm9uZXJyb3IgPSB0aGlzLl9vblVuZXhwZWN0ZWRTb2NrZXRFcnJvci5iaW5kKHRoaXMpXG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZS5yZXNvbHZlKHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS5jb2RlID09PSAnTmV0Q29ubmVjdGlvbi5EYXRhQ2hhbm5lbC5BdmFpbGFibGUnKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25EYXRhQ2hhbm5lbEF2YWlsYWJsZShkYXRhLmRlc2NyaXB0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEuY29kZSA9PT0gJ05ldENvbm5lY3Rpb24uQ29ubmVjdC5SZWplY3RlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlLnJlamVjdCgnTmV0Q29ubmVjdGlvbi5Db25uZWN0LlJlamVjdGVkJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgIGlmIChkYXRhLmNvZGUgPT09ICdOZXRDb25uZWN0aW9uLkNvbm5lY3QuUmVqZWN0ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZS5yZWplY3QoJ05ldENvbm5lY3Rpb24uQ29ubmVjdC5SZWplY3RlZCcpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS5jb2RlID09PSAnTmV0Q29ubmVjdGlvbi5Db25uZWN0LkZhaWxlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlLnJlamVjdCgnTmV0Q29ubmVjdGlvbi5Db25uZWN0LkZhaWxlZCcpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlZFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmxhZyBvZiBzb2NrZXQgYmVpbmcgY2xvc2VkIGFuZCB0ZW1yaW5hdGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBpc1Rlcm1pbmF0ZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Rlcm1pbmF0ZWRcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNvY2tldEhlbHBlclxuIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBTb2NrZXRIZWxwZXIgZnJvbSAnLi9zb2NrZXQtaGVscGVyJ1xuaW1wb3J0IHsgaXNPYmplY3RFbXB0eSB9IGZyb20gJy4uL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgd2FybiwgZXJyb3IgfSBmcm9tICcuLi9sb2cnIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuY29uc3QgTkFNRSA9ICdSNVByb1N1YnNjcmlwdGlvblNvY2tldCdcblxuLyoqXG4gKiBTdWJzY3JpYmVyLWJhc2VkIGV4dGVuc2lvbiBvZiBgU29ja2V0SGVscGVyYC5cbiAqXG4gKiBAZXh0ZW5kcyB7U29ja2V0SGVscGVyfVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFN1YnNjcmlwdGlvblNvY2tldEhlbHBlciBleHRlbmRzIFNvY2tldEhlbHBlciB7XG5cbiAgY29uc3RydWN0b3IgKHJlc3BvbmRlcikge1xuICAgIHN1cGVyKHJlc3BvbmRlciwgTkFNRSlcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0byByZXNwb25kIHRvIG1lc3NhZ2VzIGNvbWluZyBvdmVyIFdlYlNvY2tldC5cbiAgICovXG4gIHJlc3BvbmQgKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZS5kYXRhKSB7XG4gICAgICBsZXQganNvbiA9IHRoaXMuZ2V0SnNvbkZyb21Tb2NrZXRNZXNzYWdlKG1lc3NhZ2UpXG4gICAgICBpZiAoIXN1cGVyLnJlc3BvbmQobWVzc2FnZSkpIHtcbiAgICAgICAgaWYgKGpzb24uZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGpzb24uZGF0YS5zZHAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGpzb24uZGF0YS5zZHAudHlwZSA9PT0gJ29mZmVyJykge1xuICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25TRFBPZmZlcihqc29uLmRhdGEpXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChqc29uLmRhdGEuY2FuZGlkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdEVtcHR5KGpzb24uZGF0YS5jYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbkVtcHR5Q2FuZGlkYXRlKClcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbkFkZEljZUNhbmRpZGF0ZShqc29uLmRhdGEuY2FuZGlkYXRlKVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoanNvbi5kYXRhLnR5cGUgPT09ICdzdGF0dXMnKSB7XG4gICAgICAgICAgICBpZiAoanNvbi5kYXRhLmNvZGUgPT09ICdOZXRDb25uZWN0aW9uLklDRS5UcmljbGVDb21wbGV0ZWQnIHx8XG4gICAgICAgICAgICAgICBqc29uLmRhdGEuY29kZSA9PT0gJ05ldENvbm5lY3Rpb24uSUNFLlRyaWNrbGVDb21wbGV0ZWQnKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNvY2tldEljZUNhbmRpZGF0ZUVuZCgpXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGpzb24uZGF0YS5jb2RlID09PSAnTmV0U3RyZWFtLlBsYXkuVW5wdWJsaXNoTm90aWZ5Jykge1xuICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25VbnB1Ymxpc2goKVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChqc29uLmRhdGEuY29kZSA9PT0gJ05ldENvbm5lY3Rpb24uQ29ubmVjdC5DbG9zZWQnKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbkNvbm5lY3Rpb25DbG9zZWQoKVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU3Vic2NyaWJlclN0YXR1cyhqc29uLmRhdGEpXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChqc29uLmRhdGEuaGFzT3duUHJvcGVydHkoJ3N0YXR1cycpKSB7XG4gICAgICAgICAgICBpZiAoanNvbi5kYXRhLnN0YXR1cyA9PT0gJ05ldFN0cmVhbS5QbGF5LlVucHVibGlzaE5vdGlmeScpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uVW5wdWJsaXNoKClcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGpzb24udHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoanNvbi50eXBlID09PSAnbWV0YWRhdGEnKSB7XG4gICAgICAgICAgICAgIC8vIEl0IGlzIGEgYHNlbmRgIEFQSSBpbnZvY2F0aW9uLlxuICAgICAgICAgICAgICBpZiAoanNvbi5tZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNlbmRSZWNlaXZlZChqc29uLm1ldGhvZCwganNvbi5kYXRhKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uTWV0YURhdGEoanNvbi5kYXRhKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoanNvbi50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoanNvbi50eXBlID09PSAnbWV0YWRhdGEnKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25NZXRhRGF0YShqc29uLm1ldGFkYXRhKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU29ja2V0TWVzc2FnZSh0aGlzLCBtZXNzYWdlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKE5BTUUsICdbd3Mub25tZXNzYWdlXSAtIE5vIE1lc3NhZ2UgRGF0YS4nKVxuICAgIH1cbiAgfVxuXG59XG5leHBvcnQgZGVmYXVsdCBTdWJzY3JpcHRpb25Tb2NrZXRIZWxwZXJcbiIsImltcG9ydCAqIGFzIHdlYnJ0YyBmcm9tICcuLi9hZGFwdGVyL3dlYnJ0YydcbmltcG9ydCBNZXNzYWdlVHJhbnNwb3J0IGZyb20gJy4vbWVzc2FnZS10cmFuc3BvcnQnXG5pbXBvcnQge1xuICBNZXNzYWdlVHJhbnNwb3J0U3RhdGVFdmVudCxcbiAgTWVzc2FnZVRyYW5zcG9ydFN0YXRlRXZlbnRUeXBlc1xufSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IGRlYnVnLCB3YXJuLCBlcnJvciB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSNVByb1dlYlJUQ1BlZXInXG5cbmNsYXNzIFdlYlJUQ1BlZXJIZWxwZXIgZXh0ZW5kcyBNZXNzYWdlVHJhbnNwb3J0IHtcblxuICBjb25zdHJ1Y3RvciAocmVzcG9uZGVyLCBuYW1lKSB7XG4gICAgc3VwZXIobmFtZSB8fCBOQU1FKVxuICAgIHRoaXMuX3Jlc3BvbmRlciA9IHJlc3BvbmRlclxuICAgIHRoaXMuX2RhdGFDaGFubmVsID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcGVlckNvbm5lY3Rpb24gPSB1bmRlZmluZWRcbiAgICB0aGlzLl9vbkRhdGFDaGFubmVsTWVzc2FnZSA9IHRoaXMuX29uRGF0YUNoYW5uZWxNZXNzYWdlLmJpbmQodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgaGFuZGxlcnMgYXNzaWduZWQgdG8gdGhlIG9wdGlvbmFsIGRhdGEgY2hhbm5lbCBvbiB0aGUgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtSVENEYXRhQ2hhbm5lbH0gZGF0YUNoYW5uZWxcbiAgICovXG4gIF9yZW1vdmVEYXRhQ2hhbm5lbEhhbmRsZXJzIChkYXRhQ2hhbm5lbCkge1xuICAgIGRhdGFDaGFubmVsLm9ub3BlbiA9IHVuZGVmaW5lZFxuICAgIGRhdGFDaGFubmVsLm9uZXJyb3IgPSB1bmRlZmluZWRcbiAgICBkYXRhQ2hhbm5lbC5vbmNsb3NlID0gdW5kZWZpbmVkXG4gICAgZGF0YUNoYW5uZWwub25tZXNzYWdlID0gdW5kZWZpbmVkXG4gIH1cblxuICAvKiogXG4gICAqIEFzc2lnbnMgZXZlbnQgaGFuZGxlcnMgdG8gdGhlIG9wdGlvbmFsIGRhdGEgY2hhbm5lbCBvbiB0aGUgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtSVENEYXRhQ2hhbm5lbH0gZGF0YUNoYW5uZWxcbiAgICovXG4gIF9hZGREYXRhQ2hhbm5lbEhhbmRsZXJzIChkYXRhQ2hhbm5lbCkge1xuICAgIGRhdGFDaGFubmVsLm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbkRhdGFDaGFubmVsRXJyb3IoZGF0YUNoYW5uZWwsIGV2ZW50LmVycm9yLm1lc3NhZ2UpXG4gICAgfVxuICAgIGRhdGFDaGFubmVsLm9ubWVzc2FnZSA9IHRoaXMuX29uRGF0YUNoYW5uZWxNZXNzYWdlXG4gICAgZGF0YUNoYW5uZWwub25vcGVuID0gKCkgPT4ge1xuICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uRGF0YUNoYW5uZWxPcGVuKGRhdGFDaGFubmVsKVxuICAgIH1cbiAgICBkYXRhQ2hhbm5lbC5vbmNsb3NlID0gKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLl9yZXNwb25kZXIub25EYXRhQ2hhbm5lbENsb3NlKGRhdGFDaGFubmVsKVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBNZXNzYWdlVHJhbnNwb3J0U3RhdGVFdmVudChNZXNzYWdlVHJhbnNwb3J0U3RhdGVFdmVudFR5cGVzLkNMT1NFLCB0aGlzLl9uYW1lLCB7c29ja2V0OiB0aGlzLCBldmVudDogZXZlbnR9KSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBoYW5kbGVycyBhc3NpZ25lZCB0byB0aGUgcGVlciBjb25uZWN0aW9uIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JUQ1BlZXJDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgX3JlbW92ZUNvbm5lY3Rpb25IYW5kbGVycyAoY29ubmVjdGlvbikge1xuICAgIHdhcm4odGhpcy5fbmFtZSwgJ19yZW1vdmVDb25uZWN0aW9uSGFuZGxlcnMgaXMgYWJzdHJhY3QuJylcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NpZ25zIGhhbmRsZXJzIHRvIGV2ZW50cyBvbiB0aGUgcGVlciBjb25uZWN0aW9uIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JUQ1BlZXJDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gICAqIEBwYXJhbSB7UHJvbWlzZX0gcHJvbWlzZVxuICAgKiAgICAgICAgVGhlIGBQcm9taXNlYCB0byByZXNvbHZlIG9yIHJlamVjdCBvbiBzdWNjZXNzIG9mIGNvbm5lY3Rpb24uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgX2FkZENvbm5lY3Rpb25IYW5kbGVycyAoY29ubmVjdGlvbiwgcHJvbWlzZSkgeyBcbiAgICB3YXJuKHRoaXMuX25hbWUsICdfYWRkQ29ubmVjdGlvbkhhbmRsZXJzIGlzIGFic3RyYWN0LicpXG4gIH1cblxuICAvKipcbiAgICogTWVzc2FnZSBldmVudCBsaXN0ZW5lciBvbiBSVENEYXRhQ2hhbm5lbFxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uRGF0YUNoYW5uZWxNZXNzYWdlIChldmVudCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBldmVudFxuICAgIGlmICh0aGlzLmhhbmRsZU1lc3NhZ2VSZXNwb25zZShtZXNzYWdlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgbGV0IGpzb24gPSB0aGlzLmdldEpzb25Gcm9tU29ja2V0TWVzc2FnZShtZXNzYWdlKVxuICAgIGlmIChqc29uID09PSBudWxsKSB7XG4gICAgICB3YXJuKHRoaXMuX25hbWUsICdEZXRlcm1pbmVkIHdlYnNvY2tldCByZXNwb25zZSBub3QgaW4gY29ycmVjdCBmb3JtYXQuIEFib3J0aW5nIG1lc3NhZ2UgaGFuZGxlLicpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZGVidWcodGhpcy5fbmFtZSwgJ1tkYXRhY2hhbm5lbC1yZXNwb25zZV06ICcgKyBKU09OLnN0cmluZ2lmeShqc29uLCBudWxsLCAyKSlcbiAgICBjb25zdCB7IFxuICAgICAgZGF0YSxcbiAgICAgIG1ldGhvZCxcbiAgICAgIHR5cGUsXG4gICAgICBpZFxuICAgIH0gPSBqc29uXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5tZXNzYWdlICYmIGRhdGEudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uRGF0YUNoYW5uZWxFcnJvcih0aGlzLl9kYXRhQ2hhbm5lbCwgZGF0YS5tZXNzYWdlKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGlmIChkYXRhICYmIGRhdGEuY29kZSAmJiBkYXRhLnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbkRhdGFDaGFubmVsRXJyb3IodGhpcy5fZGF0YUNoYW5uZWwsIGRhdGEuY29kZSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChtZXRob2QpIHtcbiAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNlbmRSZWNlaXZlZChtZXRob2QsIGRhdGEpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ21ldGFkYXRhJykge1xuICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uTWV0YURhdGEoZGF0YSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChkYXRhICYmIGRhdGEudHlwZSA9PT0gJ3N0YXR1cycpIHtcbiAgICAgIGlmIChkYXRhLmNvZGUgPT09ICdOZXRDb25uZWN0aW9uLkNvbm5lY3QuQ2xvc2VkJykge1xuICAgICAgICB0aGlzLl9yZXNwb25kZXIub25Db25uZWN0aW9uQ2xvc2VkKClcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGRlYnVnKE5BTUUsIGBbZGF0YWNoYW5uZWwubWVzc2FnZV0gc3RhdHVzIDo6ICR7ZGF0YS5jb2RlfWApXG4gICAgfSBlbHNlIGlmIChqc29uLmFzeW5jICYmIGlkKSB7XG4gICAgIGNvbnN0IHRpY2tldCA9IHRoaXMuX2FzeW5jVGlja2V0cy5maW5kKGVsID0+IGVsLmlkID09PSBpZClcbiAgICAgIGNvbnN0IHsgcHJvbWlzZSB9ID0gdGlja2V0XG4gICAgICBpZiAocHJvbWlzZSAmJiBqc29uLmRhdGEpIHtcbiAgICAgICAgcHJvbWlzZS5yZXNvbHZlKGpzb24uZGF0YSlcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gZWxzZSBpZiAocHJvbWlzZSAmJiBqc29uLmVycm9yKSB7XG4gICAgICAgIHByb21pc2UucmVqZWN0KGpzb24uZXJyb3IpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQuXG4gICAqIFJlcXVlc3QgdG8gc2V0dXAgdGhlIHByb3hpZWQgUGVlciBDb25uZWN0aW9uIGluc3RhbmNlLlxuICAgKiBVc2UgZWl0aGVyIGBzZXRVcGAgb3IgYHNldFVwV2l0aFBlZXJDb25maWd1cmF0aW9uYC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gaWNlU2VydmVyc1xuICAgKiAgICAgICAgTGlzdCBvZiBJQ0Ugc2VydmVycyB0byB1c2UgaW4gdGhlIGNvbm5lY3Rpb24uXG4gICAqIEBwYXJhbSB7UHJvbWlzZX0gc2V0VXBQcm9taXNlXG4gICAqICAgICAgICBUaGUgYFByb21pc2VgIHRvIHJlc29sdmUgb3IgcmVqZWN0IG9uIGluIHN1Y2Nlc3MgaW4gc2V0dGluZyB1cCB0aGUgUGVlciBDb25uZWN0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcnRjcE11eFBvbGljeVxuICAgKiAgICAgICAgVGhlIHR5cGUgb2YgbXV4IHBvbGljeSB0byB1c2UuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqXG4gICAqIEBub3RlIE1hcmtlZCBmb3IgZGVwcmVjYXRpb24gYWZ0ZXIgNS40LjAgcmVsZWFzZS5cbiAgICovXG4gIHNldFVwIChpY2VTZXJ2ZXJzLCBzZXRVcFByb21pc2UgPSB1bmRlZmluZWQsIHJ0Y3BNdXhQb2xpY3kgPSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnRlYXJEb3duKClcbiAgICBjb25zdCBwID0gc2V0VXBQcm9taXNlIHx8IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRyeSB7XG4gICAgICBsZXQgcGVlckNvbmZpZyA9IHtcbiAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVycyxcbiAgICAgICAgaWNlQ2FuZGlkYXRlUG9vbFNpemU6IDIsXG4gICAgICAgIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHJ0Y3BNdXhQb2xpY3kgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBlZXJDb25maWcucnRjcE11eFBvbGljeSA9IHJ0Y3BNdXhQb2xpY3lcbiAgICAgIH1cbiAgICAgIGRlYnVnKE5BTUUsIGBbcGVlcmNvbm5lY3Rpb246c2V0dXBdOiAke0pTT04uc3RyaW5naWZ5KHBlZXJDb25maWcsIG51bGwsIDIpfWApXG4gICAgICBsZXQgcGVlciA9IG5ldyB3ZWJydGMuUlRDUGVlckNvbm5lY3Rpb24ocGVlckNvbmZpZyxcbiAgICAgICAge1xuICAgICAgICAgIG9wdGlvbmFsOiBbXG4gICAgICAgICAgICB7UnRwRGF0YUNoYW5uZWxzOiBmYWxzZX0sXG4gICAgICAgICAgICB7Z29vZ0NwdU92ZXJ1c2VEZXRlY3Rpb246IHRydWV9XG4gICAgICAgICAgXVxuICAgICAgICB9KVxuICAgICAgdGhpcy5fYWRkQ29ubmVjdGlvbkhhbmRsZXJzKHBlZXIpXG4gICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbiA9IHBlZXJcbiAgICAgIHAucmVzb2x2ZShwZWVyKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oTkFNRSwgYENvdWxkIG5vdCBlc3RhYmxpc2ggYSBQZWVyQ29ubmVjdGlvbi4gJHtlLm1lc3NhZ2V9YClcbiAgICAgIHAucmVqZWN0KGUubWVzc2FnZSlcbiAgICB9XG4gICAgcmV0dXJuIHAuaGFzT3duUHJvcGVydHkoJ3Byb21pc2UnKSA/IHAucHJvbWlzZSA6IHBcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIHNldHVwIHRoZSBwcm94aWVkIFBlZXIgQ29ubmVjdGlvbiBpbnN0YW5jZSB3aXRoIGRlZmluZWQgUlRDQ29uZmlndXJhdGlvbi5cbiAgICogVXNlIGVpdGhlciBgc2V0VXBgIG9yIGBzZXRVcFdpdGhQZWVyQ29uZmlndXJhdGlvbmAuXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENQZWVyQ29ubmVjdGlvbi9SVENQZWVyQ29ubmVjdGlvbiNSVENDb25maWd1cmF0aW9uX2RpY3Rpb25hcnlcbiAgICpcbiAgICogQHBhcmFtIHtSVENDb25maWd1cmF0aW9ufSBjb25maWd1cmF0aW9uXG4gICAqICAgICAgICBBIGN1c3RvbSBSVENDb25maWd1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YUNoYW5uZWxDb25maWd1cmF0aW9uXG4gICAqICAgICAgICBBbiBvYmplY3QgZGV0YWlsaW5nIG9wdGlvbmFsIGRhdGEgY2hhbm5lbCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7UHJvbWlzZX0gc2V0VXBQcm9taXNlXG4gICAqICAgICAgICBUaGUgYFByb21pc2VgIHRvIHJlc29sdmUgb3IgcmVqZWN0IG9uIGluIHN1Y2Nlc3MgaW4gc2V0dGluZyB1cCB0aGUgUGVlciBDb25uZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgc2V0VXBXaXRoUGVlckNvbmZpZ3VyYXRpb24gKGNvbmZpZ3VyYXRpb24sIGRhdGFDaGFubmVsQ29uZmlndXJhdGlvbiA9IHVuZGVmaW5lZCwgc2V0VXBQcm9taXNlID0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy50ZWFyRG93bigpXG4gICAgY29uc3QgcCA9IHNldFVwUHJvbWlzZSB8fCBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICB0cnkge1xuICAgICAgZGVidWcoTkFNRSwgYFtwZWVyY29ubmVjdGlvbjpzZXRVcFdpdGhQZWVyQ29uZmlndXJhdGlvbl06ICR7SlNPTi5zdHJpbmdpZnkoY29uZmlndXJhdGlvbiwgbnVsbCwgMil9YClcbiAgICAgIGxldCBwZWVyID0gbmV3IHdlYnJ0Yy5SVENQZWVyQ29ubmVjdGlvbihjb25maWd1cmF0aW9uKVxuICAgICAgaWYgKGRhdGFDaGFubmVsQ29uZmlndXJhdGlvbikge1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbCA9IHBlZXIuY3JlYXRlRGF0YUNoYW5uZWwoZGF0YUNoYW5uZWxDb25maWd1cmF0aW9uLm5hbWUsIHtvcmRlcmVkOiB0cnVlfSlcbiAgICAgICAgdGhpcy5fYWRkRGF0YUNoYW5uZWxIYW5kbGVycyh0aGlzLl9kYXRhQ2hhbm5lbClcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FkZENvbm5lY3Rpb25IYW5kbGVycyhwZWVyKVxuICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24gPSBwZWVyXG4gICAgICBwLnJlc29sdmUocGVlcilcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKE5BTUUsIGBDb3VsZCBub3QgZXN0YWJsaXNoIGEgUGVlckNvbm5lY3Rpb24uICR7ZS5tZXNzYWdlfWApXG4gICAgICBwLnJlamVjdChlLm1lc3NhZ2UpXG4gICAgfVxuICAgIHJldHVybiBwLmhhc093blByb3BlcnR5KCdwcm9taXNlJykgPyBwLnByb21pc2UgOiBwXG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byB0ZWFyIGRvd24gcHJveGllZCBQZWVyIENvbm5lY3Rpb24gaW5zdGFuY2UuXG4gICAqL1xuICB0ZWFyRG93biAoKSB7XG4gICAgaWYgKHRoaXMuX2RhdGFDaGFubmVsKSB7XG4gICAgICB0aGlzLl9yZW1vdmVEYXRhQ2hhbm5lbEhhbmRsZXJzKHRoaXMuX2RhdGFDaGFubmVsKVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwuY2xvc2UoKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB3YXJuKE5BTUUsIGBbZGF0YWNoYW5uZWwuY2xvc2VdIGVycm9yOiAke2UubWVzc2FnZX1gKVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwgPSB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX3BlZXJDb25uZWN0aW9uKSB7XG4gICAgICBkZWJ1ZyhOQU1FLCAnW3RlYXJkb3duXScpXG4gICAgICB0aGlzLl9yZW1vdmVDb25uZWN0aW9uSGFuZGxlcnModGhpcy5fcGVlckNvbm5lY3Rpb24pXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jbG9zZSgpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHdhcm4oTkFNRSwgYFtwZWVyY29ubmVjdGlvbi5jbG9zZV0gZXJyb3I6ICR7ZS5tZXNzYWdlfWApXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbiA9IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIHNldCBsb2NhbCBkZXNjcmlwdGlvbiBvbiB0aGUgUGVlciBDb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2Vzc2lvbkRlc2NyaXB0aW9uXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBzZXRMb2NhbERlc2NyaXB0aW9uIChzZXNzaW9uRGVzY3JpcHRpb24pIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3NldGxvY2FsZGVzY3JpcHRpb25dJylcbiAgICByZXR1cm4gdGhpcy5fcGVlckNvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihzZXNzaW9uRGVzY3JpcHRpb24pXG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBzZXQgcmVtb3RlIGRlc2NyaXB0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2RwXG4gICAqICAgICAgICBUaGUgU2Vzc2lvbiBEZXNjcmlwdGlvbiB0b3Qgc2V0IG9uIHRoZSBQZWVyIENvbm5lY3Rpb24uXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBzZXRSZW1vdGVEZXNjcmlwdGlvbiAoc2RwKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tzZXRyZW1vdGVkZXNjcmlwdGlvbl0nKVxuICAgIHJldHVybiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbihuZXcgd2VicnRjLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbihzZHApKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gYWRkIElDRSBjYW5kaWRhdGUgdG8gUGVlciBDb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FuZGlkYXRlXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBhZGRJY2VDYW5kaWRhdGUgKGNhbmRpZGF0ZSkge1xuICAgIGRlYnVnKE5BTUUsICdbYWRkY2FuZGlkYXRlXScpXG4gICAgcmV0dXJuIHRoaXMuX3BlZXJDb25uZWN0aW9uLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpXG4gIH1cblxuICAvKipcbiAgICogUG9zdHMgcmVxdWVzdCBvdmVyIG9wdGlvbmFsIFJUQ0RhdGFDaGFubmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH1cbiAgICogICAgICAgIFJlcXVlc3Qgb2JqZWN0IHRvIGJlIHR1cm5lZCBpbnRvIEpTT04gc3RyaW5nIGZvciB0cmFuc3BvcnQuXG4gICAqL1xuICBwb3N0IChyZXF1ZXN0KSB7XG4gICAgaWYgKHRoaXMuX2RhdGFDaGFubmVsKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gdHlwZW9mIHJlcXVlc3QgPT09ICdzdHJpbmcnID8gcmVxdWVzdCA6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QsIG51bGwsIDIpXG4gICAgICBkZWJ1ZyhOQU1FLCBgW2RhdGFjaGFubmVsLnNlbmRdIG1lc3NhZ2U6ICR7bWVzc2FnZX1gKVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwuc2VuZChtZXNzYWdlKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVycm9yKE5BTUUsIGVyci5oYXNPd25Qcm9wZXJ0eSgnbWVzc2FnZScpID8gZXJyLm1lc3NhZ2UgOiBlcnIpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEFjY2Vzc29yIGZvciB0aGUgcHJveGllZCBSVENQZWVyQ29ubmVjdGlvbiBpbnN0YW5jZS5cbiAgICpcbiAgICogQHJldHVybiB7UlRDUGVlckNvbm5lY3Rpb259XG4gICAqL1xuICBnZXQgY29ubmVjdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlZXJDb25uZWN0aW9uXG4gIH1cblxuICAvKipcbiAgICogQWNjZXNzb3IgZm9yIHRoZSBvcHRpb25hbCB1bmRlcmx5aW5nIFJUQ0RhdGFDaGFubmVsIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtSVENEYXRhQ2hhbm5lbH1cbiAgICovXG4gIGdldCBkYXRhQ2hhbm5lbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFDaGFubmVsXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBXZWJSVENQZWVySGVscGVyXG4iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0ICogYXMgd2VicnRjIGZyb20gJy4uL2FkYXB0ZXIvd2VicnRjJ1xuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uL2Vudi9icm93c2VyJ1xuaW1wb3J0IFdlYlJUQ1BlZXJIZWxwZXIgZnJvbSAnLi93ZWJydGMtaGVscGVyJ1xuaW1wb3J0IHsgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0IHsgZGVidWcsIHdhcm4sIGVycm9yIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvU3Vic2NyaXB0aW9uUGVlcidcblxuLyoqXG4gKiBVdGlsaXR5IHRvIGNoZWNrIGlmIGNhbmRpZGF0ZSBpcyBlbXB0eSwgYW5kIGNvbnNpZGVyZWQgdGhlIGVuZCBvZiB0aGUgdHJpY2tsZSBuZWdvdGlhdGlvbiBmb3IgYSBzdWJzY3JpYmVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYW5kaWRhdGVcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBpc0VtcHR5Q2FuZGlkYXRlID0gKGNhbmRpZGF0ZSkgPT4ge1xuICByZXR1cm4gdHlwZW9mIGNhbmRpZGF0ZSA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAodHlwZW9mIGNhbmRpZGF0ZSA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLmxlbmd0aCA9PT0gMClcbn1cblxuLyoqXG4gKiBQcm94eSB0byBQZWVyIENvbm5lY3Rpb24gZm9yIFN1YnNjcmliZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFN1YnNjcmlwdGlvblBlZXJIZWxwZXIgZXh0ZW5kcyBXZWJSVENQZWVySGVscGVyIHtcblxuICBjb25zdHJ1Y3RvciAocmVzcG9uZGVyKSB7XG4gICAgc3VwZXIocmVzcG9uZGVyLCBOQU1FKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgaGFuZGxlcnMgYXNzaWduZWQgdG8gdGhlIHBlZXIgY29ubmVjdGlvbiBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtSVENQZWVyQ29ubmVjdGlvbn0gY29ubmVjdGlvblxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbW92ZUNvbm5lY3Rpb25IYW5kbGVycyAoY29ubmVjdGlvbikge1xuICAgIGNvbm5lY3Rpb24ub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSB1bmRlZmluZWRcbiAgICBjb25uZWN0aW9uLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gdW5kZWZpbmVkXG4gICAgY29ubmVjdGlvbi5vbmljZWNhbmRpZGF0ZSA9IHVuZGVmaW5lZFxuLy8gICAgY29ubmVjdGlvbi5vbmFkZHN0cmVhbSA9IHVuZGVmaW5lZFxuICAgIGNvbm5lY3Rpb24ub250cmFjayA9IHVuZGVmaW5lZFxuICAgIGNvbm5lY3Rpb24ub25kYXRhY2hhbm5lbCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbnMgaGFuZGxlcnMgdG8gZXZlbnRzIG9uIHRoZSBwZWVyIGNvbm5lY3Rpb24gaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UlRDUGVlckNvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAgICogQHBhcmFtIHtQcm9taXNlfSBwcm9taXNlXG4gICAqICAgICAgICBUaGUgYFByb21pc2VgIHRvIHJlc29sdmUgb3IgcmVqZWN0IG9uIHN1Y2Nlc3Mgb2YgY29ubmVjdGlvbi5cbiAgICpcbiAgICogIEBwcml2YXRlXG4gICAqL1xuICBfYWRkQ29ubmVjdGlvbkhhbmRsZXJzIChjb25uZWN0aW9uLCBwcm9taXNlKSB7XG5cbiAgICBsZXQgcmVjb25uZWN0VGltZW91dFxuICAgIGNvbnN0IHRpbWVvdXRMaW1pdCA9IDUwMDBcblxuICAgIGNvbm5lY3Rpb24ub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBkZWJ1ZyhOQU1FLCBgW3BlZXIub25jb25uZWN0aW9uc3RhdGVjaGFuZ2VdIC0gU3RhdGU6ICR7Y29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdGV9YClcbiAgICAgIGlmIChjb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgZGVidWcoTkFNRSwgJ1twZWVyY29ubmVjdGlvbjpvcGVuXScpXG4gICAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHRoaXMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uUGVlckNvbm5lY3Rpb25PcGVuKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcgfHxcbiAgICAgICAgY29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgIHdhcm4oTkFNRSwgJ1twZWVyY29ubmVjdGlvbjplcnJvcl0nKVxuICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgIHByb21pc2UucmVqZWN0KClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbm5lY3Rpb24ub25pY2VjYW5kaWRhdGUgPSAoZXZlbnQpID0+IHtcbiAgICAgIGRlYnVnKE5BTUUsIGBbcGVlci5vbmljZWNhbmRpZGF0ZV0gLSBQZWVyIENhbmRpZGF0ZTogJHtldmVudC5jYW5kaWRhdGV9YClcbiAgICAgIGlmIChldmVudC5jYW5kaWRhdGUpIHtcbiAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uSWNlQ2FuZGlkYXRlKGV2ZW50LmNhbmRpZGF0ZSlcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQuY2FuZGlkYXRlID09PSBudWxsICYmIHRoaXMuX3BlbmRpbmdNZWRpYVN0cmVhbSkge1xuICAgICAgICAvLyBudWxsIG1lYW5zIHRoZXkgaGF2ZSBmaW5pc2hlZCBzZW5kaW5nIGNhbmRpZGF0ZXMgYmFjayBhbmQgZm9ydGg/XG4gICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbkljZUNhbmRpZGF0ZVRyaWNrbGVFbmQodGhpcy5fcGVuZGluZ01lZGlhU3RyZWFtKVxuICAgICAgICB0aGlzLl9wZW5kaW5nTWVkaWFTdHJlYW0gPSB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgIGNvbm5lY3Rpb24ub25hZGRzdHJlYW0gPSAoZXZlbnQpID0+IHtcbiAgICAgIGRlYnVnKE5BTUUsIGAob25hZGRzdHJlYW0pIFBlZXIgQWRkIFN0cmVhbTogJHtldmVudC5zdHJlYW19YClcbiAgICAgIGlmIChldmVudC5zdHJlYW0gJiYgdGhpcy5fcGVuZGluZ01lZGlhU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ01lZGlhU3RyZWFtID0gZXZlbnQuc3RyZWFtXG4gICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbkFuc3dlck1lZGlhU3RyZWFtKGV2ZW50LnN0cmVhbSlcbiAgICAgIH1cbiAgICB9XG4gICAgKi9cblxuICAgIC8vIFBpY2tlZCB1cCBieSBGaXJlZm94LCBhbGwgb3RoZXJzIFRDZSBgb25hZGRzdHJlYW1gLCBidXQgYWRhcHRlci5qcyB3aWxsIGNhbGwgYm90aCwgc28gd2UgbGltaXQuXG4gICAgY29ubmVjdGlvbi5vbnRyYWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICBkZWJ1ZyhOQU1FLCBgKG9udHJhY2spIFBlZXIgQWRkIFN0cmVhbTogJHtldmVudC5zdHJlYW1zfWApXG4gICAgICBpZiAoZXZlbnQuc3RyZWFtcyAmJiBldmVudC5zdHJlYW1zLmxlbmd0aCA+IDAgJiYgdGhpcy5fcGVuZGluZ01lZGlhU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ01lZGlhU3RyZWFtID0gZXZlbnQuc3RyZWFtc1swXVxuICAgICAgICB0aGlzLl9yZXNwb25kZXIub25BbnN3ZXJNZWRpYVN0cmVhbShldmVudC5zdHJlYW1zWzBdKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbm5lY3Rpb24ub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gY29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGVcbiAgICAgIGRlYnVnKE5BTUUsIGBbcGVlci5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZV0gLSBTdGF0ZTogJHtzdGF0ZX1gKVxuICAgICAgaWYgKHN0YXRlID09PSAnY29ubmVjdGVkJyAmJiBlbnZpcm9ubWVudC5nZXRJc0VkZ2UoKSkge1xuICAgICAgICAvLyBTdXBwb3J0IGZvciBPUlRDIG9yZGVyIG9mIGNhbmRpZGF0ZXMuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgaW52b2tlZCBmcm9tIGEgYG9uaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2VgIGV2ZW50IG9uIHRoZSBDb25uZWN0aW9uLlxuICAgICAgICAvLyBFZGdlIGRvZXNuJ3Qgbm90aWZ5IG9uIHRoYXQgZXZlbnQuXG4gICAgICAgIGRlYnVnKE5BTUUsICdbZWRnZS9vcnRjOm5vdGlmeSBjb21wbGV0ZV0nKVxuICAgICAgICB0aGlzLl9yZXNwb25kZXIub25QZWVyR2F0aGVyaW5nQ29tcGxldGUoKVxuICAgICAgICAvLyBUcmljayBmb3IgZWRnZSB0byByZWNlaXZlIG51bGwgY2FuZGlkYXRlIGFuZCBzdGFydCBwbGF5YmFjay5cbiAgICAgICAgLy8gVE9ETzogRml4IG1lP1xuICAgICAgICBjb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlKHtjYW5kaWRhdGU6bnVsbH0pXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgaWYgKHJlY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQocmVjb25uZWN0VGltZW91dClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNwb25kZXIub25QZWVyQ29ubmVjdGlvbkZhaWwoKTtcbiAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uUGVlckNvbm5lY3Rpb25DbG9zZShldmVudClcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAvLyBtYXkgcmVjZWl2ZSBhIGRpc2Nvbm5lY3QgdGVtcG9yYXJpbHkgdGhhdCB3aWxsIHRoZW4gcmV0dXJuIHRvIGEgY29ubmVjdGlvbi5cbiAgICAgICAgcmVjb25uZWN0VGltZW91dCA9IHNldFRpbWVvdXQoICgpID0+IHtcbiAgICAgICAgICBkZWJ1ZyhOQU1FLCBgW3BlZXIub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2VdIC0gUmVjb25uZWN0IHRpbWVvdXQgcmVhY2hlZC4gQ2xvc2luZyBQZWVyQ29ubmVjdGlvbi5gKVxuICAgICAgICAgIGNsZWFyVGltZW91dChyZWNvbm5lY3RUaW1lb3V0KVxuICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblBlZXJDb25uZWN0aW9uQ2xvc2UoZXZlbnQpXG4gICAgICAgIH0sIHRpbWVvdXRMaW1pdClcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAocmVjb25uZWN0VGltZW91dCkge1xuICAgICAgICAgIGRlYnVnKE5BTUUsIGBbcGVlci5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZV0gLSBDbGVhcmluZyB0aW1lb3V0IGZvciByZWNvbm5lY3QuYClcbiAgICAgICAgICBjbGVhclRpbWVvdXQocmVjb25uZWN0VGltZW91dClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbm5lY3Rpb24ub25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gY29ubmVjdGlvbi5pY2VHYXRoZXJpbmdTdGF0ZVxuICAgICAgZGVidWcoTkFNRSwgYFtwZWVyLm9uaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2VdIC0gU3RhdGU6ICR7c3RhdGV9YClcbiAgICAgIGlmIChzdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICB0aGlzLl9yZXNwb25kZXIub25QZWVyR2F0aGVyaW5nQ29tcGxldGUoKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbm5lY3Rpb24ub25yZW1vdmVzdHJlYW0gPSAoKSA9PiB7XG4gICAgICBkZWJ1ZyhOQU1FLCBgW3BlZXIub25yZW1vdmVzdHJlYW1dYClcbiAgICB9XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXNzYWdlIGV2ZW50IGxpc3RlbmVyIG9uIFJUQ0RhdGFDaGFubmVsXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25EYXRhQ2hhbm5lbE1lc3NhZ2UgKGV2ZW50KSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGV2ZW50XG4gICAgaWYgKHN1cGVyLl9vbkRhdGFDaGFubmVsTWVzc2FnZShldmVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGxldCBqc29uID0gdGhpcy5nZXRKc29uRnJvbVNvY2tldE1lc3NhZ2UobWVzc2FnZSlcbiAgICBpZiAoanNvbiA9PT0gbnVsbCkge1xuICAgICAgd2Fybih0aGlzLl9uYW1lLCAnRGV0ZXJtaW5lZCB3ZWJzb2NrZXQgcmVzcG9uc2Ugbm90IGluIGNvcnJlY3QgZm9ybWF0LiBBYm9ydGluZyBtZXNzYWdlIGhhbmRsZS4nKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRlYnVnKHRoaXMuX25hbWUsICdbZGF0YWNoYW5uZWwtcmVzcG9uc2VdOiAnICsgSlNPTi5zdHJpbmdpZnkoanNvbiwgbnVsbCwgMikpXG4gICAgY29uc3QgeyBcbiAgICAgIGRhdGFcbiAgICB9ID0ganNvblxuICAgIGlmIChkYXRhICYmIGRhdGEudHlwZSA9PT0gJ3N0YXR1cycpIHtcbiAgICAgIGlmIChkYXRhLmNvZGUgPT09ICdOZXRTdHJlYW0uUGxheS5VbnB1Ymxpc2hOb3RpZnknKSB7XG4gICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblVucHVibGlzaCgpXG4gICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbkNvbm5lY3Rpb25DbG9zZWQoKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgZGVidWcoTkFNRSwgYFtkYXRhY2hhbm5lbC5tZXNzYWdlXSBzdGF0dXMgOjogJHtkYXRhLmNvZGV9YClcbiAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblN1YnNjcmliZXJTdGF0dXMoZGF0YSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChkYXRhICYmIGRhdGEuc3RhdHVzICYmIGRhdGEuc3RhdHVzID09PSAgJ05ldFN0cmVhbS5QbGF5LlVucHVibGlzaE5vdGlmeScpIHtcbiAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblVucHVibGlzaCgpXG4gICAgICB0aGlzLl9yZXNwb25kZXIub25Db25uZWN0aW9uQ2xvc2VkKClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHRoaXMuX3Jlc3BvbmRlci5vbkRhdGFDaGFubmVsTWVzc2FnZSh0aGlzLl9kYXRhQ2hhbm5lbCwgbWVzc2FnZSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGNyZWF0ZSBhbnN3ZXIgb24gUGVlciBDb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2RwXG4gICAqICAgICAgICBUaGUgU2Vzc2lvbiBEZXNjcmlwdGlvbiB0byBzZXQgYXMgcmVtb3RlIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgY3JlYXRlQW5zd2VyIChzZHApIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2NyZWF0ZWFuc3dlcl0nKVxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG5cbiAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbihzZHApXG4gICAgICAudGhlbih0aGlzLl9yZXNwb25kZXIub25TRFBTdWNjZXNzKVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU0RQRXJyb3IoZXJyKVxuICAgICAgfSlcbiAgICAvLyBoZXJlIHRoZSBhbnN3ZXIgc2RwIGhhcyB0byBiZSBtdW5nZWQgb3Igc3RlcmVvIGZyb20gdGhlIG9mZmVyIHdvbnQgYmUgZW5hYmxlZCBpbiBjaHJvbWVcbiAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jcmVhdGVBbnN3ZXIoKVxuICAgICAgLnRoZW4oc2Vzc2lvbkRlc2NyaXB0aW9uID0+IHtcbiAgICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uLnNkcCA9IHdlYnJ0Yy5mb3JjZVN0ZXJlb09uTG9jYWxBbnN3ZXIoc2Vzc2lvbkRlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLnNldExvY2FsRGVzY3JpcHRpb24oc2Vzc2lvbkRlc2NyaXB0aW9uKVxuICAgICAgICAgIC50aGVuKHRoaXMuX3Jlc3BvbmRlci5vblNEUFN1Y2Nlc3MpXG4gICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNEUEVycm9yKGVycilcbiAgICAgICAgICB9KVxuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHNlc3Npb25EZXNjcmlwdGlvbilcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZGVmZXJyZWQucmVqZWN0KVxuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGFkZCBJQ0UgY2FuZGlkYXRlIHRvIFBlZXIgQ29ubmVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhbmRpZGF0ZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgYWRkSWNlQ2FuZGlkYXRlIChjYW5kaWRhdGUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnY2hlY2tpbmcgaWYgZW1wdHkuLi4nKVxuICAgIGlmIChpc0VtcHR5Q2FuZGlkYXRlKGNhbmRpZGF0ZSkpIHtcbiAgICAgIGRlYnVnKE5BTUUsICdbYWRkaWNlY2FuZGlkYXRlXTo6IGVtcHR5JylcbiAgICB9IGVsc2UgaWYgKGNhbmRpZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgZGVidWcoTkFNRSwgJ1thZGRpY2VjYW5kaWRhdGVdIDo6IG5vbi1lbXB0eScpXG4gICAgICBsZXQgaWNlQ2FuZGlkYXRlID0gbmV3IHdlYnJ0Yy5SVENJY2VDYW5kaWRhdGUoe1xuICAgICAgICBzZHBNTGluZUluZGV4OiBjYW5kaWRhdGUuc2RwTUxpbmVJbmRleCxcbiAgICAgICAgY2FuZGlkYXRlOiBjYW5kaWRhdGUuY2FuZGlkYXRlXG4gICAgICB9KVxuICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uYWRkSWNlQ2FuZGlkYXRlKGljZUNhbmRpZGF0ZSlcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIC8vIG5hZGFcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgZXJyb3IoTkFNRSwgYEVycm9yIGluIGFkZCBvZiBJQ0UgQ2FuZGlkaWF0ZSArICR7ZXJyfWApXG4gICAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKE5BTUUsICdbYWRkaWNlY2FuZGlkYXRlXSA6OiBudWxsJylcbiAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAvLyBuYWRhXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIGVycm9yKE5BTUUsIGBFcnJvciBpbiBhZGQgb2YgSUNFIENhbmRpZGlhdGUgKyAke2Vycn1gKVxuICAgICAgICB9KVxuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFN1YnNjcmlwdGlvblBlZXJIZWxwZXJcblxuIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCB7IGRlYnVnLCBlcnJvciB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSNVByb1BsYXliYWNrVmlldydcbmNvbnN0IHBsYXliYWNrSWQgPSAncmVkNXByby1zdWJzY3JpYmVyJ1xuXG4vKipcbiAqIEJyaWRnZSBiZXR3ZWVuIERPTSBFbGVtZW50IHZpZXcgYW5kIFN1YnNjcmliZXIgaW1wbGVtZW50YXRpb24uXG4gKiBTdGlsbCB1c2VkLCBidXQgaW50ZXJuYWxpemVkIGFzIG9mIDQuMC4wLiBVcCBmb3IgZGVwcmVjYXRpb24sIHVwIGZvciBkaXNjdXNzaW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBQbGF5YmFja1ZpZXcge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZWxlbWVudElkXG4gICAqICAgICAgICBUaGUgZWxlbWVudCBgaWRgIHRvIHVzZSBmb3IgcGxheWJhY2sgZGlzcGxheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yIChlbGVtZW50SWQgPSBwbGF5YmFja0lkKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRhcmdldCB2aWRlby9hdWRpbyBlbGVtZW50LlxuICAgICAgdGhpcy5fdGFyZ2V0RWxlbWVudCA9IGVudmlyb25tZW50LnJlc29sdmVFbGVtZW50KGVsZW1lbnRJZClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcihOQU1FLCBgQ291bGQgbm90IGluc3RhbnRpYXRlIGEgbmV3IGluc3RhbmNlIG9mIFJlZDVQcm9TdWJzY3JpYmVyLiBSZWFzb246ICR7ZS5tZXNzYWdlfWApXG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzc29jaWF0ZXMgU3Vic2NyaWJlciBpbnN0YW5jZSB3aXRoIHRoaXMgdmlldyBtYW5hZ2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3Vic2NyaWJlclxuICAgKiAgICAgICAgVGhlIFN1YnNjcmliZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhdHRhY2hTdWJzY3JpYmVyIChzdWJzY3JpYmVyKSB7XG4gICAgZGVidWcoTkFNRSwgJ1thdHRhY2hzdWJzY3JpYmVyXScpXG4gICAgc3Vic2NyaWJlci5zZXRWaWV3KHRoaXMsIGVudmlyb25tZW50LmdldEVsZW1lbnRJZCh0aGlzLl90YXJnZXRFbGVtZW50KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NpZ24gdGhlIGBNZWRpYVN0cmVhbWAgb2JqZWN0IHRvIHRoZSB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBtZWRpYVN0cmVhbVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXR0YWNoU3RyZWFtIChtZWRpYVN0cmVhbSkge1xuICAgIGxldCBhdXRvcGxheSA9IHRoaXMuaXNBdXRvcGxheVxuICAgIGRlYnVnKE5BTUUsICdbYXR0YWNoc3RyZWFtXScpXG4gICAgZW52aXJvbm1lbnQuc2V0VmlkZW9Tb3VyY2UodGhpcy5fdGFyZ2V0RWxlbWVudCwgbWVkaWFTdHJlYW0sIGF1dG9wbGF5KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGBNZWRpYVN0cmVhbWAgb2JqZWN0IGZyb20gdGhlIHZpZXcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXRhY2hTdHJlYW0gKCkge1xuICAgIGRlYnVnKE5BTUUsICdbZGV0YWNoc3RyZWFtXScpXG4gICAgZW52aXJvbm1lbnQuc2V0VmlkZW9Tb3VyY2UodGhpcy5fdGFyZ2V0RWxlbWVudCwgbnVsbCwgdGhpcy5pc0F1dG9wbGF5KVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgcmVjb2duaXplZCBgYXV0b3BsYXlgIGF0dHJpYnV0ZSBvbiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgaXNBdXRvcGxheSAoKSB7XG4gICAgcmV0dXJuIGVudmlyb25tZW50Lmhhc0F0dHJpYnV0ZURlZmluZWQodGhpcy5fdGFyZ2V0RWxlbWVudCwgJ2F1dG9wbGF5JylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCB2aWV3ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0RWxlbWVudFxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGxheWJhY2tWaWV3XG4iLCIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBSZWNlbnQgY2hhbmdlcyBoYXZlIG1vdmVkIHRoZSBXZWJTb2NrZXQgcG9ydCBvZiB0aGUgc2VydmVyIHRvIDUwODAgb3IgNDQzLlxuICogT3VyIHByZXZpb3VzIHJlY29tbWVuZGF0aW9uIHdhcyB0byB1c2UgODA4MSBvciA4MDgzLlxuICpcbiAqIFRoaXMgaXMgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYW5kIHNob3VsZCBiZSB1cGdyYWRlZCB0byBERVBSRUNBVElPTi5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBnZXRCYWNrZ3JvdW5kQ29tcGF0V2ViU29ja2V0UG9ydCA9IChwb3J0KSA9PiB7XG4gIHN3aXRjaCAocG9ydCkge1xuICAgIGNhc2UgODA4MzpcbiAgICBjYXNlICc4MDgzJzpcbiAgICAgIGNvbnNvbGUud2FybignVGhlIGRlZmF1bHQgV2ViU29ja2V0IHBvcnQgb24gdGhlIHNlcnZlciBoYXMgY2hhbmdlZCBmcm9tIDgwODMgdG8gNDQzIGZvciBzZWN1cmUgY29ubmVjdGlvbnMuJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICByZXR1cm4gNDQzXG4gICAgY2FzZSA4MDgxOlxuICAgIGNhc2UgJzgwODEnOlxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnVGhlIGRlZmF1bHQgV2ViU29ja2V0IHBvcnQgb24gdGhlIHNlcnZlciBoYXMgY2hhbmdlZCBmcm9tIDgwODEgdG8gNTA4MCBvciA4MCBmb3Igc2VjdXJlIGNvbm5lY3Rpb25zLidcbiAgICAgICkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICByZXR1cm4gNTA4MFxuICB9XG4gIHJldHVybiBwb3J0XG59XG5cbi8qKlxuICogRW5jb2RlIHRoZSB2YWx1ZSBvZiBlYWNoIGtleSBhbmQgcmV0dXJuIGEgbmV3IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVPYmplY3RcbiAqICAgICAgICBUaGUgb2JqZWN0IHdob3NlIHZhbHVlcyBzaG91bGQgYmUgZW5jb2RlZC5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlS2V5VmFsdWVzID0gKHZhbHVlT2JqZWN0KSA9PiB7XG4gIGxldCBlbmNvZGVkID0ge31cbiAgT2JqZWN0LmtleXModmFsdWVPYmplY3QpLmZvckVhY2goKGtleSwgaW5kZXgpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgZW5jb2RlZFtrZXldID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlT2JqZWN0W2tleV0pXG4gIH0pXG4gIHJldHVybiBlbmNvZGVkXG59XG5cbi8qKlxuICogQ29uc3RydWN0IGVuZHBvaW50IHRvIHVzZSBmb3IgV2ViU29ja2V0IGNvbm5lY3Rpb24gYmFzZWQgb24gY29uZmlndXJhdGlvbiBvYmplY3QgYW5kIG9wdGlvbmFsIHBhcmFtcyB0byBhcHBlbmQgdG8gcXVlcnkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHByb3ZpZGVkIGluIGBpbml0KClgIG9mIFdlYlJUQyBiYXNlZCBwdWJsaXNoZXIgb3Igc3Vic2NyaWJlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAqICAgICAgICBUaGUgb3B0aW9uYWwgcGFyYW1zIHRvIGFwcGVuZCB0byB0aGUgZW5kcG9pbnQuIFVzZWQgYnkgc2VydmVyIGluIGNvbm5lY3Rpb24gcGFyc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgcnRjU29ja2V0RW5kcG9pbnRGcm9tT3B0aW9ucyA9IChvcHRpb25zLCBwYXJhbXMgPSB1bmRlZmluZWQpID0+IHtcbiAgY29uc3QgcHJvdG9jb2wgPSBvcHRpb25zLndzcHJvdG9jb2wgfHwgb3B0aW9ucy5wcm90b2NvbFxuICBjb25zdCBwb3J0ID0gZ2V0QmFja2dyb3VuZENvbXBhdFdlYlNvY2tldFBvcnQob3B0aW9ucy53c3BvcnQgfHwgb3B0aW9ucy5wb3J0KVxuICBjb25zdCBhcHBFbmRwb2ludCA9IG9wdGlvbnMuY29udGV4dCA/IFtvcHRpb25zLmFwcCwgb3B0aW9ucy5jb250ZXh0XS5qb2luKCcvJykgOiBvcHRpb25zLmFwcFxuICBsZXQgZW5kcG9pbnQgPSBgJHtwcm90b2NvbH06Ly8ke29wdGlvbnMuaG9zdH06JHtwb3J0fS8ke2FwcEVuZHBvaW50fS9gXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5jb25uZWN0aW9uUGFyYW1zICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IGVuY29kZWRQYXJhbXMgPSBlbmNvZGVLZXlWYWx1ZXMob3B0aW9ucy5jb25uZWN0aW9uUGFyYW1zKVxuICAgIHBhcmFtcyA9IE9iamVjdC5hc3NpZ24ocGFyYW1zLCBlbmNvZGVkUGFyYW1zKVxuICB9XG4gIGlmICh0eXBlb2YgcGFyYW1zICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxldCBrdiA9IFtdXG4gICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKChrZXksIGluZGV4KSA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBrdi5wdXNoKFtrZXksIHBhcmFtc1trZXldXS5qb2luKCc9JykpXG4gICAgfSlcbiAgICBpZiAoa3YubGVuZ3RoID4gMCkge1xuICAgICAgZW5kcG9pbnQgKz0gJz8nICsga3Yuam9pbignJicpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVuZHBvaW50XG59XG5cbi8qKlxuICogQ29uc3RydWN0IGVuZHBvaW50IHRvIHVzZSBmb3IgV2ViU29ja2V0IGNvbm5lY3Rpb24gYmFzZWQgb24gY29uZmlndXJhdGlvbiBvYmplY3QgYW5kIG9wdGlvbmFsIHBhcmFtcyB0byBhcHBlbmQgdG8gcXVlcnkuXG4gKiBUaGlzIGFsbG93cyBmb3Igc3VjaCB0aGluZ3MgYXMgYXV0aGVudGljYXRpb24gcHJpb3IgdG8gcmVxdWVzdCBvZiBwbGF5YmFjayBvZiBITFMgZmlsZS5cbiAqIFJlcXVpcmVzIGEgYHNvY2tldFBhcmFtc2AgYXR0cmlidXRlIGluIHRoZSBpbml0IGNvbmZpZ3VyYXRpb24gdGhhdCBkZXNjcmliZSB0aGUgV2ViU29ja2V0IGVuZHBvaW50IHRvIG1ha2UgdGhlIHJlcXVlc3Qgb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHByb3ZpZGVkIGluIGBpbml0KClgIG9mIEhMUyBiYXNlZCBzdWJzY3JpYmVyLlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICogICAgICAgIFRoZSBvcHRpb25hbCBwYXJhbXMgdG8gYXBwZW5kIHRvIHRoZSBlbmRwb2ludC4gVXNlZCBieSBzZXJ2ZXIgaW4gY29ubmVjdGlvbiBwYXJzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogIHZhciBzdWJzY3JpYmVyID0gbmV3IEhMU3Vic2NyaWJlcigpXG4gKiAgc3Vic2NyaWJlci5pbml0KHtcbiAqICAgIHByb3RvY29sOiAnaHR0cHMnLFxuICogICAgaG9zdDogJ215Y29tcGFueS5vcmcnLFxuICogICAgYXBwOiAnbGl2ZScsXG4gKiAgICBzdHJlYW1OYW1lOiAnbXlzdHJlYW0nLFxuICogICAgc29ja2V0UGFyYW1zOiB7XG4gKiAgICAgIHByb3RvY29sOiAnd3NzJyxcbiAqICAgICAgaG9zdDogJ215Y29tcGFueS5vcmcnLFxuICogICAgICBhcHA6ICdsaXZlJ1xuICogICAgfSxcbiAqICAgIGNvbm5lY3Rpb25QYXJhbXM6IHtcbiAqICAgICAgdXNlcjogJ2ZvbycsXG4gKiAgICAgIHBhc3N3b3JkOiAnYmFyJ1xuICogICAgfVxuICogIH0pXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgaGxzU29ja2V0RW5kcG9pbnRGcm9tT3B0aW9ucyA9IChvcHRpb25zLCBwYXJhbXMgPSB1bmRlZmluZWQpID0+IHtcbiAgY29uc3QgeyBzb2NrZXRQYXJhbXMsIGNvbm5lY3Rpb25QYXJhbXMgfSA9IG9wdGlvbnNcbiAgY29uc3QgcHJvdG9jb2wgPSBzb2NrZXRQYXJhbXMucHJvdG9jb2xcbiAgY29uc3QgcG9ydCA9IGdldEJhY2tncm91bmRDb21wYXRXZWJTb2NrZXRQb3J0KHNvY2tldFBhcmFtcy5wb3J0IHx8IChwcm90b2NvbCA9PT0gJ3dzcycgPyA0NDMgOiA1MDgwKSlcbiAgbGV0IGVuZHBvaW50ID0gYCR7cHJvdG9jb2x9Oi8vJHtzb2NrZXRQYXJhbXMuaG9zdH06JHtwb3J0fS8ke3NvY2tldFBhcmFtcy5hcHB9L2BcbiAgaWYgKGNvbm5lY3Rpb25QYXJhbXMpIHtcbiAgICBjb25zdCBlbmNvZGVkUGFyYW1zID0gZW5jb2RlS2V5VmFsdWVzKG9wdGlvbnMuY29ubmVjdGlvblBhcmFtcylcbiAgICBwYXJhbXMgPSBPYmplY3QuYXNzaWduKHBhcmFtcywgZW5jb2RlZFBhcmFtcylcbiAgfVxuICBpZiAocGFyYW1zKSB7XG4gICAgbGV0IGt2ID0gW11cbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSwgaW5kZXgpID0+IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIGt2LnB1c2goW2tleSwgcGFyYW1zW2tleV1dLmpvaW4oJz0nKSlcbiAgICB9KVxuICAgIGlmIChrdi5sZW5ndGggPiAwKSB7XG4gICAgICBlbmRwb2ludCArPSAnPycgKyBrdi5qb2luKCcmJylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZW5kcG9pbnRcbn1cblxuLyoqXG4gKiBVdGlsIHRvIHJldHVybiB0aGUgZW5kcG9pbnQgZm9yIGFuIEhMUyB2aWRlbyBmaWxlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgVGhlIGluaXRpYWxpemF0aW9uIG9iamVjdC5cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3Qgb3B0aW9uc1RvSGxzVVJMID0gKG9wdGlvbnMpID0+IHtcbiAgY29uc3QgeyBob3N0LCBobHNwcm90b2NvbCwgcHJvdG9jb2wsIGhsc3BvcnQsIHBvcnQsIGNvbnRleHQsIGFwcCwgc3RyZWFtTmFtZSwgY29ubmVjdGlvblBhcmFtcywgYXBpVmVyc2lvbiB9ID0gb3B0aW9uc1xuICBsZXQgdGhlSG9zdCA9IGhvc3RcbiAgbGV0IHRoZVByb3RvY29sID0gaGxzcHJvdG9jb2wgfHwgKHByb3RvY29sID09PSAnd3MnID8gJ2h0dHAnIDogJ2h0dHBzJylcbiAgbGV0IHRoZVBvcnQgPSBobHNwb3J0IHx8IChwb3J0ID09PSA1MDgwID8gNTA4MCA6IDQ0MylcbiAgbGV0IGFwcEVuZHBvaW50ID0gY29udGV4dCA/IFthcHAsIGNvbnRleHRdLmpvaW4oJy8nKSA6IGFwcFxuICBsZXQgdGhlVmVyc2lvbiA9IGFwaVZlcnNpb24gfHwgJzQuMCdcbiAgaWYgKGNvbm5lY3Rpb25QYXJhbXMgJiYgYXBwID09PSAnc3RyZWFtbWFuYWdlcicpIHtcbiAgICAvLyBodHRwczovL3N0cmVhbW1hbmFnZXIucmVkNXByby5jbG91ZC9zdHJlYW1tYW5hZ2VyL2FwaS80LjAvZmlsZS97YXBwX25hbWV9L3tzdHJlYW1fbmFtZX1cbiAgICByZXR1cm4gYCR7dGhlUHJvdG9jb2x9Oi8vJHt0aGVIb3N0fToke3RoZVBvcnR9L3N0cmVhbW1hbmFnZXIvYXBpLyR7dGhlVmVyc2lvbn0vZmlsZS8ke2Nvbm5lY3Rpb25QYXJhbXMuYXBwfS8ke3N0cmVhbU5hbWV9Lm0zdThgXG4gIH1cbiAgcmV0dXJuIGAke3RoZVByb3RvY29sfTovLyR7dGhlSG9zdH06JHt0aGVQb3J0fS8ke2FwcEVuZHBvaW50fS8ke3N0cmVhbU5hbWV9Lm0zdThgXG59XG5cbmV4cG9ydCBjb25zdCBvcHRpb25zRnJvbVdoaXBXaGVwVXJsID0gKHVybCkgPT4ge1xuICAvLyBodHRwOi8vMTAuMC4wLjM1OjUwODAvbGl2ZS93aGlwL2VuZHBvaW50L3N0cmVhbTFcbiAgbGV0IGhvc3QsIHByb3RvY29sLCBwb3J0LCBhcHAsIHN0cmVhbU5hbWVcbiAgY29uc3QgcGF0dGVybiA9IG5ldyBVUkwodXJsKVxuICBjb25zdCBwYXRocyA9IHBhdHRlcm4ucGF0aG5hbWUuc3BsaXQoJy8nKS5maWx0ZXIoKHApID0+IHAubGVuZ3RoID4gMClcbiAgcHJvdG9jb2wgPSBwYXR0ZXJuLnByb3RvY29sXG4gIGhvc3QgPSBwYXR0ZXJuLmhvc3RuYW1lXG4gIHBvcnQgPSBwYXR0ZXJuLnBvcnQubGVuZ3RoID4gMCA/IHBhdHRlcm4ucG9ydCA6IDQ0M1xuICBhcHAgPSBwYXRoc1swXVxuICBzdHJlYW1OYW1lID0gcGF0aHNbcGF0aHMubGVuZ3RoIC0gMV1cbiAgcmV0dXJuIHsgcHJvdG9jb2wsIHBvcnQsIGFwcCwgaG9zdCwgc3RyZWFtTmFtZSB9XG59XG4iLCIvKipcbiAqIEVudW1lcmF0aW9uIG9mIFBsYXliYWNrIFR5cGVzLlxuICovXG5leHBvcnQgY29uc3QgUGxheWJhY2tUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuICBSVEM6ICdydGMnLFxuICBSVE1QOiAncnRtcCcsXG4gIEhMUzogJ2hscydcbn0pXG5cbi8qKlxuICogRW51bWVyYXRpb24gb2YgQXVkaW8gRW5jb2RlciB0eXBlcyB0byByZXF1ZXN0IGZvciBQbGF5YmFja1xuICovXG5leHBvcnQgY29uc3QgUGxheWJhY2tBdWRpb0VuY29kZXIgPSBPYmplY3QuZnJlZXplKHtcbiAgT1BVUzogJ09wdXMnLFxuICBQQ01VOiAnUENNVScsXG4gIFBDTUE6ICdQQ01BJyxcbiAgU1BFRVg6ICdTcGVleCcsXG4gIE5PTkU6ICdOT05FJ1xufSlcblxuLyoqXG4gKiBFbnVtZXJhdGlvbiBvZiBWaWRlbyBFbmNvZGVyIHR5cGVzIHRvIHJlcXVlc3QgZm9yIFBsYXliYWNrLlxuICovXG5leHBvcnQgY29uc3QgUGxheWJhY2tWaWRlb0VuY29kZXIgPSBPYmplY3QuZnJlZXplKHtcbiAgVlA4OiAnVlA4JyxcbiAgSDI2NDogJ0gyNjQnLFxuICBOT05FOiAnTk9ORSdcbn0pXG4iLCIvKipcbiAqIEVudW1lcmF0aW9uIG9mIFN1cHBvcnQgSUNFIFRyYW5zcG9ydCB0eXBlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IEljZVRyYW5zcG9ydFR5cGVzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFVEUDogJ3VkcCcsXG4gIFRDUDondGNwJ1xufSlcbiIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgeyBhcHBseU9yaWVudGF0aW9uIH0gZnJvbSAnLi4vZW52L3RyYW5zbGF0aW9uLXV0aWwnXG5pbXBvcnQgKiBhcyB3ZWJydGMgZnJvbSAnLi4vYWRhcHRlci93ZWJydGMnXG5pbXBvcnQgKiBhcyB3ZWJzb2NrZXQgZnJvbSAnLi4vYWRhcHRlci93ZWJzb2NrZXQnXG5pbXBvcnQgUlRDU291cmNlSGFuZGxlciBmcm9tICcuL3JlZDVwcm8tc291cmNlLWhhbmRsZXItcnRjJ1xuaW1wb3J0IFJUQ1NlZWthYmxlU291cmNlSGFuZGxlciBmcm9tICcuL3JlZDVwcm8tc291cmNlLWhhbmRsZXItcnRjLXNlZWthYmxlJ1xuaW1wb3J0IFN1YnNjcmlwdGlvblNvY2tldEhlbHBlciBmcm9tICcuLi9oZWxwZXIvc29ja2V0LWhlbHBlci1zdWInXG5pbXBvcnQgU3Vic2NyaXB0aW9uUGVlckhlbHBlciBmcm9tICcuLi9oZWxwZXIvd2VicnRjLWhlbHBlci1zdWInXG5pbXBvcnQgUGxheWJhY2tWaWV3IGZyb20gJy4uL3ZpZXcvcGxheWJhY2snXG5pbXBvcnQgeyBQbGF5YmFja0NvbnRyb2xsZXIgfSBmcm9tICcuL2NvbnRyb2xzJ1xuaW1wb3J0IHsgbWV0YWRhdGFSZXNvbHV0aW9uVG9PYmplY3QgfSBmcm9tICcuLi91dGlsL29iamVjdCdcbmltcG9ydCB7IG9wdGlvbnNUb0hsc1VSTCB9IGZyb20gJy4uL3V0aWwvdXJsLWVuZHBvaW50J1xuaW1wb3J0IHsgcnRjU29ja2V0RW5kcG9pbnRGcm9tT3B0aW9ucyBhcyBlbmRwb2ludEZyb21PcHRpb25zIH0gZnJvbSAnLi4vdXRpbC91cmwtZW5kcG9pbnQnXG5pbXBvcnQgeyBTdWJzY3JpYmVyRXZlbnQgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCB7IE1lc3NhZ2VUcmFuc3BvcnRTdGF0ZUV2ZW50LCBNZXNzYWdlVHJhbnNwb3J0U3RhdGVFdmVudFR5cGVzIH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgeyBQbGF5YmFja1R5cGVzLCBQbGF5YmFja0F1ZGlvRW5jb2RlciwgUGxheWJhY2tWaWRlb0VuY29kZXIgfSBmcm9tICcuLi9lbnVtL3BsYXliYWNrJ1xuaW1wb3J0IHsgSWNlVHJhbnNwb3J0VHlwZXMgfSBmcm9tICcuLi9lbnVtL3dlYnJ0YydcbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IFN1YnNjcmliZXJFdmVudFR5cGVzLCBSVENTdWJzY3JpYmVyRXZlbnRUeXBlcyB9IGZyb20gJy4uL2V2ZW50J1xuaW1wb3J0IHsgZGVidWcsIHdhcm4sIGVycm9yLCBMRVZFTFMgfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IHN1YlN0YXJ0UmVnZXggPSAvKC4qKSBzdGFydGluZy9pXG5jb25zdCBOQU1FID0gJ1JUQ1N1YnNjcmliZXInXG5cbi8qKlxuICogU2ltcGxlIGdlbmVyYXRpb24gb2YgdW5pcXVlIHN1YnNjcmliZXIgaWQuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGdlbmVyYXRlU3Vic2NyaXB0aW9uSWQgPSAoKSA9PiB7XG4gIGNvbnN0IGlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgxMDAwMCkudG9TdHJpbmcoMTYpXG4gIHJldHVybiBgc3Vic2NyaWJlci0ke2lkfWBcbn1cblxuLy8gRGVmYXVsdCB0byBzZWN1cmUgc2V0dGluZ3MuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgcHJvdG9jb2w6ICd3c3MnLFxuICBwb3J0OiA0NDMsXG4gIGFwcDogJ2xpdmUnLFxuICBhdXRvTGF5b3V0T3JpZW50YXRpb246IHRydWUsXG4gIG1lZGlhRWxlbWVudElkOiAncmVkNXByby1zdWJzY3JpYmVyJyxcbiAgcnRjQ29uZmlndXJhdGlvbjoge1xuICAgIGljZVNlcnZlcnM6IFt7IHVybHM6ICdzdHVuOnN0dW4yLmwuZ29vZ2xlLmNvbToxOTMwMicgfV0sXG4gICAgaWNlQ2FuZGlkYXRlUG9vbFNpemU6IDIsXG4gICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gIH0sIC8vIEZhdm9yZWQgb3ZlciBpY2VTZXJ2ZXJzLlxuICBpY2VTZXJ2ZXJzOiB1bmRlZmluZWQsIC8vIERlcHJlY2F0ZWQuIFByZXNlcnZlZCBmb3IgYmFja3dhcmQtY29tcGF0aWJpbGl0eS5cbiAgaWNlVHJhbnNwb3J0OiBJY2VUcmFuc3BvcnRUeXBlcy5VRFAsXG4gIG11dGVPbkF1dG9wbGF5UmVzdHJpY3Rpb246IHRydWUsXG4gIG1haW50YWluQ29ubmVjdGlvbk9uU3Vic2NyaWJlRXJyb3JzOiBmYWxzZSxcbiAgc2lnbmFsaW5nU29ja2V0T25seTogdHJ1ZSxcbiAgZGF0YUNoYW5uZWxDb25maWd1cmF0aW9uOiB1bmRlZmluZWQsXG4gIHNvY2tldFN3aXRjaERlbGF5OiAxMDAwLFxuICBieXBhc3NBdmFpbGFibGU6IGZhbHNlLFxuICBtYWludGFpblN0cmVhbVZhcmlhbnQ6IGZhbHNlLFxuICBlbmFibGVMaXZlU2VlazogZmFsc2UsXG59XG5cbi8qKlxuICogTWFpbiBlbnRyeSBmb3IgV2ViUlRDLWJhc2VkIFN1YnNjcmliZXIuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAZXh0ZW5kcyBTdWJzY3JpYmVyUGxheWJhY2tDb250cm9sbGVyXG4gKi9cbmNsYXNzIFJUQ1N1YnNjcmliZXIgZXh0ZW5kcyBQbGF5YmFja0NvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fdmlldyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX29wdGlvbnMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wZWVySGVscGVyID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fc29ja2V0SGVscGVyID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fbWVzc2FnZVRyYW5zcG9ydCA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2Nvbm5lY3Rpb25DbG9zZWQgPSB0cnVlXG4gICAgdGhpcy5fc291cmNlSGFuZGxlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX21lZGlhU3RyZWFtID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fdmlld1Jlc29sdmVyID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdGhpcy5fYXZhaWxhYmlsaXR5UmVzb2x2ZXIgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25SZXNvbHZlciA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRoaXMuX29yaWVudGF0aW9uID0gMFxuICAgIHRoaXMuX3N0cmVhbWluZ01vZGUgPSAnVmlkZW8vQXVkaW8nXG4gICAgdGhpcy5fc3dpdGNoQ2hhbm5lbFJlcXVlc3QgPSB1bmRlZmluZWRcbiAgfVxuXG4gIF9nZXRWaWV3UmVzb2x2ZXJQcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3UmVzb2x2ZXIucHJvbWlzZVxuICB9XG5cbiAgX2dldEF2YWlsYWJpbGl0eVJlc29sdmVyUHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXZhaWxhYmlsaXR5UmVzb2x2ZXIucHJvbWlzZVxuICB9XG5cbiAgX2dldFN1YnNjcmlwdGlvblJlc29sdmVyUHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3Vic2NyaXB0aW9uUmVzb2x2ZXIucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIEdsb21zIHRoZSBQbGF5YmFjayBDb250cm9scyBBUEkgb250byB0aGlzIGluc3RhbmNlIHRvIHByb3ZpZGUgZWFzZSBpbiAzc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyXG4gICAqICAgICAgICBUaGUgbWV0aG9kIHJlcXVlc3QgaGFuZGxlciB0byBiaW5kIGFuZCBmb3J3YXJkIGNhbGxzIG9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dsb21Tb3VyY2VIYW5kbGVyQVBJKGhhbmRsZXIpIHtcbiAgICB0aGlzLnBsYXkgPSBoYW5kbGVyLnBsYXkuYmluZChoYW5kbGVyKVxuICAgIHRoaXMucGF1c2UgPSBoYW5kbGVyLnBhdXNlLmJpbmQoaGFuZGxlcilcbiAgICB0aGlzLnJlc3VtZSA9IGhhbmRsZXIucmVzdW1lLmJpbmQoaGFuZGxlcilcbiAgICB0aGlzLnN0b3AgPSBoYW5kbGVyLnN0b3AuYmluZChoYW5kbGVyKVxuICAgIHRoaXMubXV0ZSA9IGhhbmRsZXIubXV0ZS5iaW5kKGhhbmRsZXIpXG4gICAgdGhpcy51bm11dGUgPSBoYW5kbGVyLnVubXV0ZS5iaW5kKGhhbmRsZXIpXG4gICAgdGhpcy5zZXRWb2x1bWUgPSBoYW5kbGVyLnNldFZvbHVtZS5iaW5kKGhhbmRsZXIpXG4gICAgdGhpcy5zZWVrVG8gPSBoYW5kbGVyLnNlZWtUby5iaW5kKGhhbmRsZXIpXG4gICAgdGhpcy50b2dnbGVGdWxsU2NyZWVuID0gaGFuZGxlci50b2dnbGVGdWxsU2NyZWVuLmJpbmQoaGFuZGxlcilcbiAgICBoYW5kbGVyLm9uKCcqJywgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChldmVudC50eXBlLCB0aGlzLCBldmVudC5kYXRhKSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFN0aWxsIGluIHVzZSwgYnV0IGhvbGQtb3ZlciBvZiBwcmV2aW91cyAzLnggU0RLIHZlcnNpb25zIGRlc2lnbmVkIHRvIHBhaXIgdmlld3MgYW5kIHN1YnNjcmliZXJzLiBJbiA0LjAuMCBpdCBoYXMgYmVlbiBpbnRlcm5hbGl6ZWQuXG4gICAqIEFQSSBkZXByZWNhdGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldFZpZXdJZk5vdEV4aXN0KGN1cnJlbnRWaWV3LCBtZWRpYUVsZW1lbnRJZCA9IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgY3VycmVudFZpZXcgPT09ICd1bmRlZmluZWQnICYmIG1lZGlhRWxlbWVudElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCB2aWV3ID0gbmV3IFBsYXliYWNrVmlldyhtZWRpYUVsZW1lbnRJZClcbiAgICAgIHZpZXcuYXR0YWNoU3Vic2NyaWJlcih0aGlzKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIGluaXRpYWxpemUgdGhlIHN1YnNjcmlwdGlvbiBoYW5kbGVyIGZvciBXZWJSVEMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgaW5pdGlhbGl6YXRpb24gY29uZmlndXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJcbiAgICogICAgICAgIFRoZSBoYW5kbGVyIGluc3RhbmNlIHRoYXQgd2lsbCBtYW5hZ2UgdmlldyBpbnRlcmFjdGlvbiBhbmQgZXZlbnRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRIYW5kbGVyKG9wdGlvbnMsIGhhbmRsZXIpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyLm9uKCcqJywgdGhpcy5fYm91bmRCdWJibGVTdWJzY3JpYmVyRXZlbnRzKVxuICAgICAgaGFuZGxlci5hZGRTb3VyY2Uob3B0aW9ucylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCBhdmFpbGFibGUgc3RyZWFtIGJ5IG5hbWUgb24gc2VydmVyIHRocm91Z2ggV2ViU29ja2V0IHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJlYW1OYW1lXG4gICAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgc3RyZWFtIHRvIGxvb2sgdXAuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVxdWVzdEF2YWlsYWJpbGl0eShzdHJlYW1OYW1lKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tyZXF1ZXN0YXZhaWxhYmlsaXR5XScpXG4gICAgLy8gbWVzc2FnZSBvbiBzb2NrZXQgcmV0dXJucyAtPiBvblN0cmVhbShVbilBdmFpbGFibGVcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdCh7XG4gICAgICBpc0F2YWlsYWJsZTogc3RyZWFtTmFtZSxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3Qgb2ZmZXIgb3ZlciBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJlYW1OYW1lXG4gICAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgc3RyZWFtIHRvIHN1YnNjcmliZSB0by5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN1YnNjcmlwdGlvbklkXG4gICAqICAgICAgICBUaGUgdW5pcXVlIGlkIG9mIHRoaXMgc3Vic2NyaWJlci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydFxuICAgKiAgICAgICAgVGhlIHRyYW5zcG9ydCB0eXBlIHRvIHVzZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSB1c2VEYXRhQ2hhbm5lbFxuICAgKiAgICAgICAgV2hldGhlciB0byB1c2UgZGF0YSBjaGFubmVsIGZvciBzaWduYWxsaW5nLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1haW50YWluVmFyaWFudFxuICAgKiAgICAgICAgV2hldGhlciB0byBub3RpZnkgdGhlIHNlcnZlciB0byBrZWVwIHRoZSBzcGVjaWZpZWQgc3RyZWFtIG5hbWUgd2hlbiB0cmFuc2NvZGluZywgYW5kIG5vdCBzd2l0Y2ggdG8gdmFyaWFudHMgb24gbmV0d29yayBjb25kaXRpb25zLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdkVuY29kaW5nXG4gICAqICAgICAgICBPcHRpb25hbCBlbmNvZGluZyB0eXBlIGZvciB2aWRlby4gRGVmYXVsdHMgdG8gc2VydmVyIHNlbGVjdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFFbmNvZGluZ1xuICAgKiAgICAgICAgT3B0aW9uYWwgZW5jb2RpbmcgdHlwZSBmb3IgYXVkaW8uIERlZmF1bHRzIHRvIHNlcnZlciBzZWxlY3Rpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVxdWVzdE9mZmVyKFxuICAgIHN0cmVhbU5hbWUsXG4gICAgc3Vic2NyaXB0aW9uSWQsXG4gICAgdHJhbnNwb3J0LFxuICAgIHVzZURhdGFDaGFubmVsLFxuICAgIG1haW50YWluVmFyaWFudCxcbiAgICB2RW5jb2RpbmcgPSB1bmRlZmluZWQsXG4gICAgYUVuY29kaW5nID0gdW5kZWZpbmVkXG4gICkge1xuICAgIGRlYnVnKE5BTUUsICdbcmVxdWVzdG9mZmVyXScpXG4gICAgbGV0IG9mZmVyID0ge1xuICAgICAgcmVxdWVzdE9mZmVyOiBzdHJlYW1OYW1lLFxuICAgICAgcmVxdWVzdElkOiBzdWJzY3JpcHRpb25JZCxcbiAgICAgIHRyYW5zcG9ydDogdHJhbnNwb3J0LFxuICAgICAgZGF0YWNoYW5uZWw6IHVzZURhdGFDaGFubmVsLFxuICAgICAgZG9Ob3RTd2l0Y2g6IG1haW50YWluVmFyaWFudCxcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2RW5jb2RpbmcgIT09ICd1bmRlZmluZWQnICYmIHZFbmNvZGluZyAhPT0gUGxheWJhY2tWaWRlb0VuY29kZXIuTk9ORSkge1xuICAgICAgb2ZmZXIudmlkZW9FbmNvZGluZyA9IHZFbmNvZGluZ1xuICAgIH0gZWxzZSBpZiAoZW52aXJvbm1lbnQuZ2V0SXNFZGdlKCkpIHtcbiAgICAgIC8vIEZvcmNlIFZQOCBvbiBFZGdlIGlmIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGluaXQgY29uZmlnLlxuICAgICAgLy8gb2ZmZXIudmlkZW9FbmNvZGluZyA9IFBsYXliYWNrVmlkZW9FbmNvZGVyLlZQOFxuICAgIH1cbiAgICBpZiAodHlwZW9mIGFFbmNvZGluZyAhPT0gJ3VuZGVmaW5lZCcgJiYgYUVuY29kaW5nICE9PSBQbGF5YmFja0F1ZGlvRW5jb2Rlci5OT05FKSB7XG4gICAgICBvZmZlci5hdWRpb0VuY29kaW5nID0gYUVuY29kaW5nXG4gICAgfVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLk9GRkVSX1NUQVJULCB0aGlzKSlcbiAgICAvLyBtZXNzYWdlIG9uIHNvY2tldCByZXR1cm5zIC0+IG9uU0RQT2ZmZXJcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdChvZmZlcilcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIHNlbmRzIGFuIGFuc3dlciBiYXNlZCBvbiBwcm92aWRlZCBTRFAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZHBcbiAgICogICAgICAgIFRoZSBTRFAgb2JqZWN0IHRvIHVzZSBpbiBjcmVhdGluZyBhbiBTRFAgYW5zd2VyIHRvIHNlbmQgYmFjay5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXF1ZXN0QW5zd2VyKHNkcCkge1xuICAgIGRlYnVnKE5BTUUsICdbcmVxdWVzdGFuc3dlcl0nKVxuICAgIC8vIGludm9rZXMgLT4gc2VuZEFuc3dlclxuICAgIHRoaXMuX3BlZXJIZWxwZXJcbiAgICAgIC5jcmVhdGVBbnN3ZXIoc2RwKVxuICAgICAgLnRoZW4oKHNlc3Npb25EZXNjcmlwdGlvbikgPT4ge1xuICAgICAgICBkZWJ1ZyhOQU1FLCAnW29uYW5zd2VyY3JlYXRlZF0nKVxuICAgICAgICBkZWJ1ZyhOQU1FLCAnWz4gc2VuZGFuc3dlcl0nKVxuICAgICAgICB0aGlzLl9zZW5kQW5zd2VyKHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSwgdGhpcy5fb3B0aW9ucy5zdWJzY3JpcHRpb25JZCwgc2Vzc2lvbkRlc2NyaXB0aW9uKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy5vblNEUEVycm9yKGVycm9yKVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQb3N0cyBTRFAgYW5zd2VyIHRvIHNlcnZlciBvdmVyIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmVhbU5hbWVcbiAgICogICAgICAgIFRoZSB0YXJnZXQgc3RyZWFtIG5hbWUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdWJzY3JpcHRpb25JZFxuICAgKiAgICAgICAgVGhlIHVuaXF1ZSBpZCBvZiB0aGlzIHN1YnNjcmliZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZHBcbiAgICogICAgICAgIFRoZSBTRFAgdG8gc2VuZCBhcyBhbiBhbnN3ZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VuZEFuc3dlcihzdHJlYW1OYW1lLCBzdWJzY3JpcHRpb25JZCwgc2RwKSB7XG4gICAgZGVidWcoTkFNRSwgYFtzZW5kYW5zd2VyXTogc3RyZWFtbmFtZSgke3N0cmVhbU5hbWV9KSwgc3Vic2NyaXB0aW9uaWQoJHtzdWJzY3JpcHRpb25JZH0pYClcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVENTdWJzY3JpYmVyRXZlbnRUeXBlcy5BTlNXRVJfU1RBUlQsIHRoaXMsIHNkcCkpXG4gICAgLy8gbWVzc2FnZSBvbiBzb2NrZXQgcmVzcG9uc2UgLT4gb25BZGRJY2VDYW5kaWRhdGVcbiAgICAvLyBtZXNzYWdlIG9uIHBlZXIgcmVzcG9uc2UgLT4gb25hZGRzdHJlYW1cbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdCh7XG4gICAgICBoYW5kbGVBbnN3ZXI6IHN0cmVhbU5hbWUsXG4gICAgICByZXF1ZXN0SWQ6IHN1YnNjcmlwdGlvbklkLFxuICAgICAgZGF0YToge1xuICAgICAgICBzZHA6IHNkcCxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGNhbmRpZGF0ZSB0byB0aGUgc2VydmVyIG92ZXIgV2ViU29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FuZGlkYXRlXG4gICAqICAgICAgICBUaGUgcGVlciBjYW5kaWRhdGUgZGVzY3JpcHRpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VuZENhbmRpZGF0ZShjYW5kaWRhdGUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3NlbmRjYW5kaWRhdGVdJylcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVENTdWJzY3JpYmVyRXZlbnRUeXBlcy5DQU5ESURBVEVfU1RBUlQsIHRoaXMsIGNhbmRpZGF0ZSkpXG4gICAgLy8gbWVzc2FnZSBvbiBwZWVyIHJlc3BvbnNlIC0+IG9uaWNlY2FuZGlkYXRlXG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnBvc3Qoe1xuICAgICAgaGFuZGxlQ2FuZGlkYXRlOiB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUsXG4gICAgICByZXF1ZXN0SWQ6IHRoaXMuX29wdGlvbnMuc3Vic2NyaXB0aW9uSWQsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNhbmRpZGF0ZTogY2FuZGlkYXRlLFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIGFuZCBjb25uZWN0IHRvIGJlZ2luIGEgc3Vic2NyaXB0aW9uLlxuICAgKiBUaGlzIGlzIGludm9rZWQgb25jZSB0aGUgYXZhaWxhYmlsaXR5IG9mIHRoZSBzdHJlYW0gaXMgcmVjb2duaXplZCBvbiB0aGUgc2VydmVyIGFuZCBub3RpZmllZCBvbiB0aGlzIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JUQ0NvbmZpZ3VyYXRpb259IHJ0Y0NvbmZpZ3VyYXRpb25cbiAgICogICAgICAgIEEgY3VzdG9tIFJUQ0NvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFDaGFubmVsQ29uZmlndXJhdGlvblxuICAgKiAgICAgICAgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBmb3IgZGF0YSBjaGFubmVsIGNvbW11bmljYXRvbi5cbiAgICogQHBhcmFtIHtBcnJheX0gaWNlU2VydmVyc1xuICAgKiAgICAgICAgVGhlIElDRSBzZXJ2ZXIgbGlzdCB0byB1c2UgaW4gdHJpY2tsZS5cbiAgICogQG5vdGUgRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIGtlZXBpbmcgYXJndW1lbnRzIGFzIG9wdGlvbmFsLCB3aXRoIGF0IGxlYXN0IG9uZSBiZWluZyBmdWxmaWxsZWQuIFRoZSBgY29uZmlndXJhdGlvbmAgcGFyYW0gd2lsbCBiZSBmYXZvcmVkIGFmdGVyIDUuNC4wLCBgaWNlU2VydmVyc2AgaXMgdXAgZm9yIGRlcHJlY2F0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Nvbm5lY3QoY29uZmlndXJhdGlvbiwgZGF0YUNoYW5uZWxDb25maWd1cmF0aW9uID0gdW5kZWZpbmVkLCBpY2VTZXJ2ZXJzID0gdW5kZWZpbmVkKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tjb25uZWN0XScpXG4gICAgaWYgKGljZVNlcnZlcnMgJiYgY29uZmlndXJhdGlvbikge1xuICAgICAgd2FybihcbiAgICAgICAgJ1RoZSBpY2VTZXJ2ZXJzIGNvbmZpZ3VyYXRpb24gcHJvcGVydHkgaXMgY29uc2lkZXJlZCBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRoZSBydGNDb25maWd1cmF0aW9uIGNvbmZpZ3VyYXRpb24gcHJvcGVydHkgdXBvbiB3aGljaCB5b3UgY2FuIGFzc2lnbiBpY2VTZXJ2ZXJzLiBSZWZlcmVuY2U6IGh0dHBzOi8vd3d3LnJlZDVwcm8uY29tL2RvY3Mvc3RyZWFtaW5nL21pZ3JhdGlvbmd1aWRlLmh0bWwnXG4gICAgICApXG5cbiAgICAgIGNvbmZpZ3VyYXRpb24uaWNlU2VydmVycyA9IGljZVNlcnZlcnNcbiAgICB9XG4gICAgdGhpcy5fb3B0aW9ucy5pY2VTZXJ2ZXJzID0gY29uZmlndXJhdGlvbiA/IGNvbmZpZ3VyYXRpb24uaWNlU2VydmVycyA6IGljZVNlcnZlcnNcbiAgICBsZXQgcFxuICAgIGlmIChjb25maWd1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHAgPSB0aGlzLl9wZWVySGVscGVyLnNldFVwV2l0aFBlZXJDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24sIGRhdGFDaGFubmVsQ29uZmlndXJhdGlvbiwgdW5kZWZpbmVkKVxuICAgIH0gZWxzZSB7XG4gICAgICBwID0gdGhpcy5fcGVlckhlbHBlci5zZXRVcCh0aGlzLl9vcHRpb25zLmljZVNlcnZlcnMsIHVuZGVmaW5lZCwgdGhpcy5fb3B0aW9ucy5ydGNwTXV4UG9saWN5KVxuICAgIH1cbiAgICBwLnRoZW4oKGNvbm5lY3Rpb24pID0+IHtcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLlBFRVJfQ09OTkVDVElPTl9BVkFJTEFCTEUsIHRoaXMsIGNvbm5lY3Rpb24pKVxuICAgICAgdGhpcy5fcmVxdWVzdE9mZmVyKFxuICAgICAgICB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUsXG4gICAgICAgIHRoaXMuX29wdGlvbnMuc3Vic2NyaXB0aW9uSWQsXG4gICAgICAgIHRoaXMuX29wdGlvbnMuaWNlVHJhbnNwb3J0LFxuICAgICAgICB0aGlzLl9vcHRpb25zLnNpZ25hbGluZ1NvY2tldE9ubHksXG4gICAgICAgIHRoaXMuX29wdGlvbnMubWFpbnRhaW5TdHJlYW1WYXJpYW50LFxuICAgICAgICB0aGlzLl9vcHRpb25zLnZpZGVvRW5jb2RpbmcsXG4gICAgICAgIHRoaXMuX29wdGlvbnMuYXVkaW9FbmNvZGluZ1xuICAgICAgKVxuICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICB3YXJuKE5BTUUsICdDb3VsZCBub3QgZXN0YWJsaXNoIFJUQ1BlZXJDb25uZWN0aW9uLicpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5DT05ORUNUX0ZBSUxVUkUsIHRoaXMpKVxuICAgIH0pXG4gICAgLy8gIFRPRE86IE5vcm1hbGl6ZSByZXR1cm5zIHRvIGVpdGhlciBhbGwgYmUgY2hhaW5hYmxlIG9yIG5vdCBiZSBjaGFpbmFibGVcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3QgYW5kIHRlYXJkb3duIGFmdGVyIGNsb3NlIG9mIHN1YnNjcmlwdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kaXNjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLl9zb2NrZXRIZWxwZXIpIHtcbiAgICAgIGRlYnVnKE5BTUUsICdbZGlzY29ubmVjdDpzb2NrZXRdJylcbiAgICAgIHRoaXMuX3NvY2tldEhlbHBlci50ZWFyRG93bigpXG4gICAgfVxuICAgIGlmICh0aGlzLl9wZWVySGVscGVyKSB7XG4gICAgICBkZWJ1ZyhOQU1FLCAnW2Rpc2Nvbm5lY3Q6cGVlcl0nKVxuICAgICAgdGhpcy5fcGVlckhlbHBlci50ZWFyRG93bigpXG4gICAgfVxuICAgIGlmICh0aGlzLl92aWV3KSB7XG4gICAgICB0aGlzLl92aWV3LmRldGFjaFN0cmVhbSgpXG4gICAgfVxuICAgIHRoaXMuX3NvY2tldEhlbHBlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3BlZXJIZWxwZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9tZXNzYWdlVHJhbnNwb3J0ID0gdW5kZWZpbmVkXG4gICAgaWYgKHRoaXMuX3NvdXJjZUhhbmRsZXIpIHtcbiAgICAgIGRlYnVnKE5BTUUsICdbZGlzY29ubmVjdDpzb3VyY2VdJylcbiAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIuZGlzY29ubmVjdCgpXG4gICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyID0gdW5kZWZpbmVkXG4gICAgfVxuICAgIHRoaXMuX2Nvbm5lY3Rpb25DbG9zZWQgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBraWNrIG9mZiBhdXRvcGxheSBpZiBzZXR0aW5nIGlzIGZsYWdnZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgaW5pdGlhbGl6YXRpb24gb2JqZWN0LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHZpZXdcbiAgICogICAgICAgIFRoZSB0YXJnZXQgZWxlbWVudCB2aWV3IHRoYXQgd2lsbCBwbGF5YmFjayB0aGUgc3RyZWFtLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BsYXlJZkF1dG9wbGF5U2V0KG9wdGlvbnMsIHZpZXcpIHtcbiAgICBpZiAob3B0aW9ucyAmJiB2aWV3KSB7XG4gICAgICBvcHRpb25zLmF1dG9wbGF5ID0gZW52aXJvbm1lbnQuaGFzQXR0cmlidXRlRGVmaW5lZCh2aWV3LnZpZXcsICdhdXRvcGxheScpXG4gICAgICBpZiAob3B0aW9ucy5hdXRvcGxheSkge1xuICAgICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLmF0dGVtcHRBdXRvcGxheShvcHRpb25zLm11dGVPbkF1dG9wbGF5UmVzdHJpY3Rpb24pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gZW5hYmxlZCBzY3J1YmJhYmxlL3NlZWtlYWJsZSBwbGF5YmFjayB3aXRoIEhMUy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zdGFydFNlZWthYmxlKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGVuYWJsZUxpdmVTZWVrIH0gPSBvcHRpb25zXG4gICAgaWYgKCFlbmFibGVMaXZlU2VlaykgcmV0dXJuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChlbnZpcm9ubWVudC5zdXBwb3J0c0hMUygpIHx8IGVudmlyb25tZW50LnN1cHBvcnRzTm9uTmF0aXZlSExTKCkpIHtcbiAgICAgICAgdGhpcy5fc291cmNlSGFuZGxlci5lbmFibGVMaXZlU2VlayhvcHRpb25zVG9IbHNVUkwob3B0aW9ucyksIGVudmlyb25tZW50LnN1cHBvcnRzSExTKCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yKFxuICAgICAgICBOQU1FLFxuICAgICAgICBgQ291bGQgbm90IHV0aWxpemUgdGhlICdlbmFibGVMaXZlU2VlaycgcmVxdWVzdC4gVGhpcyBmZWF0dXJlIHJlcXVpcmVzIGVpdGhlciBuYXRpdmUgSExTIHBsYXliYWNrIG9yIGhscy5qcyBhcyBhIGRlcGVuZW5jeS5gXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gYmVnaW4gc3Vic2NyaXB0aW9uIG9uIHNlcnZlciBvdmVyIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZW5kU3Vic2NyaWJlKCkge1xuICAgIGRlYnVnKE5BTUUsICdbc2VuZHN1YnNjcmliZV0nKVxuICAgIHRoaXMuX3NvY2tldEhlbHBlci5wb3N0KHtcbiAgICAgIHN1YnNjcmliZTogdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lLFxuICAgICAgcmVxdWVzdElkOiB0aGlzLl9vcHRpb25zLnN1YnNjcmlwdGlvbklkLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBpbml0aWFsaXplIHRoZSBXZWJSVEMtYmFzZWQgU3Vic2NyaWJlciBiYXNlZCBvbiBjb25maWd1cmF0aW9uLlxuICAgKiBUaGUgcmV0dXJuZWQgYFByb21pc2VgIHdpbGwgZWl0aGVyIHJlc29sdmUgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlIG9yIHJlamVjdCB3aXRoIGFuIGVycm9yIGBTdHJpbmdgIGluIGZhaWx1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgaW5pdGlhbGl6YXRpb24gY29uZmlndXJhdGlvbiBtYXAuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBpbml0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGlmICghd2VicnRjLmlzU3VwcG9ydGVkKCkgfHwgIXdlYnNvY2tldC5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICBkZWZlcnJlZC5yZWplY3QoXG4gICAgICAgICdDYW5ub3QgY3JlYXRlIFdlYlJUQyBwbGF5YmFjayBpbnN0YW5jZS4gWW91ciBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFdlYlJUQyBhbmQvb3IgV2ViU29ja2V0cy4nXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2Rpc2Nvbm5lY3QoKVxuICAgICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKVxuICAgICAgdGhpcy5fb3B0aW9ucy5zdWJzY3JpcHRpb25JZCA9IHRoaXMuX29wdGlvbnMuc3Vic2NyaXB0aW9uSWQgfHwgZ2VuZXJhdGVTdWJzY3JpcHRpb25JZCgpXG5cbiAgICAgIHRoaXMuX3BlZXJIZWxwZXIgPSBuZXcgU3Vic2NyaXB0aW9uUGVlckhlbHBlcih0aGlzKVxuICAgICAgdGhpcy5fc29ja2V0SGVscGVyID0gbmV3IFN1YnNjcmlwdGlvblNvY2tldEhlbHBlcih0aGlzKVxuICAgICAgdGhpcy5fbWVzc2FnZVRyYW5zcG9ydCA9IHRoaXMuX21lc3NhZ2VUcmFuc3BvcnQgfHwgdGhpcy5fc29ja2V0SGVscGVyXG4gICAgICBjb25zdCBzb2NrZXRQcm9taXNlID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgICBjb25zdCBzb2NrZXR1cmwgPSBlbmRwb2ludEZyb21PcHRpb25zKHRoaXMuX29wdGlvbnMsIHtcbiAgICAgICAgaWQ6IHRoaXMuX29wdGlvbnMuc3Vic2NyaXB0aW9uSWQsXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXRQcm9taXNlLnByb21pc2VcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUodGhpcylcbiAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uQ2xvc2VkID0gZmFsc2VcbiAgICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5DT05ORUNUX1NVQ0NFU1MsIHRoaXMpKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKVxuICAgICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLkNPTk5FQ1RfRkFJTFVSRSwgdGhpcywgZXJyb3IpKVxuICAgICAgICB9KVxuXG4gICAgICB0aGlzLl9zb2NrZXRIZWxwZXIuc2V0VXAoc29ja2V0dXJsLCBzb2NrZXRQcm9taXNlKVxuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIFN0aWxsIGluIHVzZSBmb3IgYXNzaWduaW5nIGRvY3VtZW50IGVsZW1lbnQgdmlldyBtYW5hZ2VtZW50IHRvIHRoaXMgaW5zdGFuY2UuXG4gICAqIEFQSSBkZXByZWNhdGVkIGluIDQuMC4wLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0Vmlldyh2aWV3KSB7XG4gICAgdGhpcy5fdmlldyA9IHZpZXdcbiAgICB0aGlzLl92aWV3UmVzb2x2ZXIucmVzb2x2ZSh0aGlzLl92aWV3KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBiZWdpbiBzdWJzY3JpYmluZyB0byBhIHN0cmVhbS5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICAgICAgICAgVGhlIHJldHVybmVkIGBQcm9taXNlYCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IG9uIHN1Y2Nlc3NmdWwgc3RhcnQgb2YgcGxheWJhY2suXG4gICAqICAgICAgICBUaGVyZSBhcmUgc2V2ZXJhbCBwcm9jZXNzZXMgdGhhdCBvY2N1ciBpbiBvcmRlciB0byBlc3RhYmxpc2ggYSBXZWJSVEMgc3Vic2NyaXB0aW9uIHRoYXQgaW52b2x2ZSAtIGJ1dCBhcmUgbm90IGxpbWl0ZWQgdG8gLSBJQ0UgY29tbXVuaWNhdGlvbiBhbmQgYXNzaWduaW5nIG9mIGxvY2FsIGFuZCByZW1vdGUgU0RQcyBvbiBwZWVyIGNvbm5lY3Rpb25zLlxuICAgKi9cbiAgc3Vic2NyaWJlKCkge1xuICAgIGNvbnN0IHsgc3RyZWFtTmFtZSwgbWVkaWFFbGVtZW50SWQsIHJ0Y0NvbmZpZ3VyYXRpb24sIGVuYWJsZUxpdmVTZWVrIH0gPSB0aGlzLl9vcHRpb25zXG4gICAgbGV0IHsgc2lnbmFsaW5nU29ja2V0T25seSwgZGF0YUNoYW5uZWxDb25maWd1cmF0aW9uIH0gPSB0aGlzLl9vcHRpb25zXG4gICAgLy8gU2V0IGRlZmF1bHQgZGF0YSBjaGFubmVsIGNvbmZpZ3VyYXRpb24gaWYgbm90IGRlZmluZWQgYW5kIHNldmVyaW5nIHNvY2tldCBvbiBzaWduYWwgZW5kLlxuICAgIC8vIFRPRE86IFNldCB0aGlzIGFzIG1vcmUgXCJwcml2YXRlXCIgd2l0aCBgcmVkNXByby08c3RyZWFtbmFtZT5gXG4gICAgY29uc3QgZGF0YUNoYW5uZWxBbGxvd2VkID0gc2lnbmFsaW5nU29ja2V0T25seSAmJiB3ZWJydGMuc3VwcG9ydHNEYXRhQ2hhbm5lbCgpXG4gICAgaWYgKGRhdGFDaGFubmVsQWxsb3dlZCAmJiAhZGF0YUNoYW5uZWxDb25maWd1cmF0aW9uKSB7XG4gICAgICBkYXRhQ2hhbm5lbENvbmZpZ3VyYXRpb24gPSB7XG4gICAgICAgIG5hbWU6IGByZWQ1cHJvYCxcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fb3B0aW9ucy5zaWduYWxpbmdTb2NrZXRPbmx5ID0gZGF0YUNoYW5uZWxBbGxvd2VkXG5cbiAgICB0aGlzLl9nZXRWaWV3UmVzb2x2ZXJQcm9taXNlKClcbiAgICAgIC50aGVuKCh2aWV3KSA9PiB7XG4gICAgICAgIGlmIChlbmFibGVMaXZlU2Vlaykge1xuICAgICAgICAgIGlmIChlbnZpcm9ubWVudC5zdXBwb3J0c0hMUygpIHx8IGVudmlyb25tZW50LnN1cHBvcnRzTm9uTmF0aXZlSExTKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIgPSBuZXcgUlRDU2Vla2FibGVTb3VyY2VIYW5kbGVyKHZpZXcudmlldywgdGhpcy5nZXRUeXBlKCkpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICBOQU1FLFxuICAgICAgICAgICAgICBgQ291bGQgbm90IHV0aWxpemUgdGhlICdlbmFibGVMaXZlU2VlaycgcmVxdWVzdC4gVGhpcyBmZWF0dXJlIHJlcXVpcmVzIGVpdGhlciBuYXRpdmUgSExTIHBsYXliYWNrIG9yIGhscy5qcyBhcyBhIGRlcGVuZW5jeS5gXG4gICAgICAgICAgICApXG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyID0gbmV3IFJUQ1NvdXJjZUhhbmRsZXIodmlldy52aWV3LCB0aGlzLmdldFR5cGUoKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc291cmNlSGFuZGxlciA9IG5ldyBSVENTb3VyY2VIYW5kbGVyKHZpZXcudmlldywgdGhpcy5nZXRUeXBlKCkpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2xvbVNvdXJjZUhhbmRsZXJBUEkodGhpcy5fc291cmNlSGFuZGxlcilcbiAgICAgICAgdGhpcy5faW5pdEhhbmRsZXIodGhpcy5fb3B0aW9ucywgdGhpcy5fc291cmNlSGFuZGxlcilcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAvLyBwYXNzZWQgdXAgdGhyb3VnaCBvdmVyYXJjaGluZyBwcm9taXNlLlxuICAgICAgfSlcbiAgICB0aGlzLl9nZXRBdmFpbGFiaWxpdHlSZXNvbHZlclByb21pc2UoKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLl9jb25uZWN0KHJ0Y0NvbmZpZ3VyYXRpb24sIGRhdGFDaGFubmVsQ29uZmlndXJhdGlvbiwgdGhpcy5fb3B0aW9ucy5pY2VTZXJ2ZXJzKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgIC8vIHBhc3NlZCB1cCB0aHJvdWdoIG92ZXJhcmNoaW5nIHByb21pc2UuXG4gICAgICB9KVxuICAgIHRoaXMuX3NldFZpZXdJZk5vdEV4aXN0KHRoaXMuX3ZpZXcsIG1lZGlhRWxlbWVudElkKVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmJ5cGFzc0F2YWlsYWJsZSkge1xuICAgICAgdGhpcy5fYXZhaWxhYmlsaXR5UmVzb2x2ZXIucmVzb2x2ZSh0aGlzKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXF1ZXN0QXZhaWxhYmlsaXR5KHN0cmVhbU5hbWUpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9nZXRTdWJzY3JpcHRpb25SZXNvbHZlclByb21pc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gc3RvcCBhIHN1YnNjcmlwdGlvbi5cbiAgICogVGhlIHJldHVybmVkIGBQcm9taXNlYCB3aWxsIGVpdGhlciByZXNvbHZlIG9yIHJlamVjdCBvbiBzdWNjZXNzZnVsIHN0b3Agb2Ygc3Vic2NyaXB0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgdW5zdWJzY3JpYmUoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1t1bnN1YnNjcmliZV0nKVxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdGhpcy5zdG9wKClcbiAgICB0aGlzLl9kaXNjb25uZWN0KClcbiAgICB0aGlzLl9tZWRpYVN0cmVhbSA9IHVuZGVmaW5lZFxuICAgIGRlZmVycmVkLnJlc29sdmUodGhpcylcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfU1RPUCwgdGhpcykpXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBzdHJlYW0gYmVpbmcgYXZhaWxhYmxlIG9uIHNlcnZlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uU3RyZWFtQXZhaWxhYmxlKHJlY2VpcHQpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW29uc3RyZWFtYXZhaWxhYmxlXTogJyArIEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpKVxuICAgIHRoaXMuX2F2YWlsYWJpbGl0eVJlc29sdmVyLnJlc29sdmUodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBzdHJlYW0gYmVpbmcgdW5hdmFpbGFibGUgb24gc2VydmVyLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25TdHJlYW1VbmF2YWlsYWJsZShyZWNlaXB0KSB7XG4gICAgZGVidWcoTkFNRSwgYFN0cmVhbSAke3RoaXMuX29wdGlvbnMuc3RyZWFtTmFtZX0gZG9lcyBub3QgZXhpc3QuYClcbiAgICBkZWJ1ZyhOQU1FLCAnW29uc3RyZWFtdW5hdmFpbGFibGVdOiAnICsgSlNPTi5zdHJpbmdpZnkocmVjZWlwdCwgbnVsbCwgMikpXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX0lOVkFMSURfTkFNRSwgdGhpcykpXG4gICAgdGhpcy5fYXZhaWxhYmlsaXR5UmVzb2x2ZXIucmVqZWN0KGBTdHJlYW0gJHt0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWV9IGRvZXMgbm90IGV4aXN0LmApXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uUmVzb2x2ZXIucmVqZWN0KGBTdHJlYW0gJHt0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWV9IGRvZXMgbm90IGV4aXN0LmApXG4gICAgaWYgKCF0aGlzLl9vcHRpb25zLm1haW50YWluQ29ubmVjdGlvbk9uU3Vic2NyaWJlRXJyb3JzKSB7XG4gICAgICB0aGlzLl9kaXNjb25uZWN0KClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVzZXQgcHJvbWlzZSBmb3IgcG9zc2libGUgcmV0cnkuXG4gICAgICB0aGlzLl9hdmFpbGFiaWxpdHlSZXNvbHZlciA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uUmVzb2x2ZXIgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3Igc3VjY2VzcyBvZiBTRFAgYmVpbmcgYWRkZWQgcmVtb3RlbHkgYW5kIGxvY2FsbHkgdGhyb3VnaCB0aGUgUGVlciBDb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVjZWlwdFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25TRFBTdWNjZXNzKHJlY2VpcHQpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW29uc2Rwc3VjY2Vzc106ICcgKyBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBzdWNjZXNzIGluIFNEUCBvZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlY2VpcHRcbiAgICogICAgICAgIFRoZSBvcHRpb25hbCBzdWNjZXNzZnVsIG9iamVjdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uU0RQT2ZmZXIocmVjZWlwdCkge1xuICAgIGRlYnVnKE5BTUUsICdbb25zZHBvZmZlcl06ICcgKyBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKSlcbiAgICAvKlxuICAgIC8vIENvbW1lbnQgb3V0IGluIGZhdm9yIG9mIGBkYXRhY2hhbm5lbDp0cnVlYCBpbiByZXF1ZXN0IG9mZmVyLlxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNpZ25hbGluZ1NvY2tldE9ubHkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2RwXG4gICAgICB9ID0gcmVjZWlwdFxuICAgICAgY29uc3QgdWZyYWdyZWd4ID0gL2E9aWNlLXVmcmFnOiguKikvZ1xuICAgICAgY29uc3QgcHdkcmVneCA9IC9hPWljZS1wd2Q6KC4qKS9nXG4gICAgICBjb25zdCBmaW5nZXJwcmludHJlZ3ggPSAvYT1maW5nZXJwcmludDooLiopL2dcbiAgICAgIHJlY2VpcHQuc2RwLnNkcCA9IHNkcC5zZHAucmVwbGFjZSgnYT1ncm91cDpCVU5ETEUgYXVkaW8gdmlkZW8nLCAnYT1ncm91cDpCVU5ETEUgYXVkaW8gdmlkZW8gMicpXG4gICAgICAvLyBCZWxvdyBpcyByZW1vdGUuXG4gICAgICAvLyByZWNlaXB0LnNkcC5zZHAgKz0gYG09YXBwbGljYXRpb24gOSBVRFAvRFRMUy9TQ1RQIDUwMDBcXHJcXG5jPUlOIElQNCA3My4xNDMuMzYuMjE3XFxyXFxuYT1pY2UtdWZyYWc6JHt1ZnJhZ3JlZ3guZXhlYyhzZHAuc2RwKVsxXX1cXHJcXG5hPWljZS1wd2Q6JHtwd2RyZWd4LmV4ZWMoc2RwLnNkcClbMV19XFxyXFxuYT1maW5nZXJwcmludDoke2ZpbmdlcnByaW50cmVneC5leGVjKHNkcC5zZHApWzFdfVxcclxcbmE9c2V0dXA6cGFzc2l2ZVxcclxcbmE9bWlkOjJcXHJcXG5hPXNlbmRyZWN2XFxyXFxuYT1zY3RwbWFwOjUwMDAgd2VicnRjLWRhdGFjaGFubmVsIDEwMjRgXG5cbiAgICAgIC8vIEJlbG93IGlzIGxvY2FsLlxuICAgICAgcmVjZWlwdC5zZHAuc2RwICs9IGBtPWFwcGxpY2F0aW9uIDkgVURQL0RUTFMvU0NUUCB3ZWJydGMtZGF0YWNoYW5uZWxcXHJcXG5jPUlOIElQNCAwLjAuMC4wXFxyXFxuYT1pY2UtdWZyYWc6JHt1ZnJhZ3JlZ3guZXhlYyhzZHAuc2RwKVsxXX1cXHJcXG5hPWljZS1wd2Q6JHtwd2RyZWd4LmV4ZWMoc2RwLnNkcClbMV19XFxyXFxuYT1pY2Utb3B0aW9uczp0cmlja2xlXFxyXFxuYT1maW5nZXJwcmludDoke2ZpbmdlcnByaW50cmVneC5leGVjKHNkcC5zZHApWzFdfVxcclxcbmE9c2V0dXA6YWN0cGFzc1xcclxcbmE9bWlkOjJcXHJcXG5hPXNjdHAtcG9ydDo1MDAwXFxyXFxuYT1tYXgtbWVzc2FnZS1zaXplOjI2MjE0NFxcclxcbmBcbiAgICB9XG4gICAgKi9cbiAgICBjb25zdCBzZXNzaW9uRGVzY3JpcHRpb24gPSBuZXcgd2VicnRjLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbihyZWNlaXB0LnNkcClcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVENTdWJzY3JpYmVyRXZlbnRUeXBlcy5PRkZFUl9FTkQsIHRoaXMpKVxuICAgIHRoaXMuX3JlcXVlc3RBbnN3ZXIoc2Vzc2lvbkRlc2NyaXB0aW9uKVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIGFsbCBlcnJvcnMgcmVsYXRlZCB0byBTRFAgdGhyb3VnaCB0aGUgUGVlciBDb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVjZWlwdFxuICAgKiAgICAgICAgVGhlIG9wdGlvbmFsIGVycm9yIG9iamVjdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uU0RQRXJyb3IocmVjZWlwdCkge1xuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9GQUlMLCB0aGlzLCByZWNlaXB0KSlcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25SZXNvbHZlci5yZWplY3QoJ0ludmFsaWQgU0RQLicpXG4gICAgZXJyb3IoTkFNRSwgJ1tvbnNkcGVycm9yXScpXG4gICAgZXJyb3IoTkFNRSwgcmVjZWlwdClcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciByZWNlaXB0IG9mIGEgYE1lZGlhU3RyZWFtYC5cbiAgICpcbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gc3RyZWFtXG4gICAqICAgICAgICBUaGUgc3RyZWFtIHJldHVybmVkIG9uIHRoZSBQZWVyIENvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbkFuc3dlck1lZGlhU3RyZWFtKHN0cmVhbSA9IHVuZGVmaW5lZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVENTdWJzY3JpYmVyRXZlbnRUeXBlcy5BTlNXRVJfRU5ELCB0aGlzKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIG9uIHJlY2VpcHQgb2YgSUNFIGNhbmRpZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhbmRpZGF0ZVxuICAgKiAgICAgICAgVGhlIElDRSBjYW5kaWRhdGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbkljZUNhbmRpZGF0ZShjYW5kaWRhdGUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW29uaWNlY2FuZGlkYXRlXScpXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoUlRDU3Vic2NyaWJlckV2ZW50VHlwZXMuQ0FORElEQVRFX0VORCwgdGhpcykpXG4gICAgdGhpcy5fc2VuZENhbmRpZGF0ZShjYW5kaWRhdGUpXG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgZW5kIG9mIElDRSBjb21tdW5pY2F0aW9uICh0cmlja2xlKS5cbiAgICpcbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gc3RyZWFtXG4gICAqICAgICAgICBUaGUgYE1lZGlhU3RyZWFtYCB0aGF0IGhhcyBiZWNvbWUgYXZhaWxhYmxlIHBvc3QtdHJpY2tsZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uSWNlQ2FuZGlkYXRlVHJpY2tsZUVuZChzdHJlYW0pIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW29uaWNldHJpY2tsZWVuZF0nKVxuICAgIHRoaXMuX2dldFZpZXdSZXNvbHZlclByb21pc2UoKS50aGVuKCh2aWV3KSA9PiB7XG4gICAgICB2aWV3LmF0dGFjaFN0cmVhbShzdHJlYW0pXG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbSA9IHN0cmVhbVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoUlRDU3Vic2NyaWJlckV2ZW50VHlwZXMuT05fQUREX1NUUkVBTSwgdGhpcywgdGhpcy5fbWVkaWFTdHJlYW0pKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciB0byBhZGQgSUNFIGNhbmRpZGF0ZSB0byBQZWVyIENvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYW5kaWRhdGVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uQWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSkge1xuICAgIGRlYnVnKE5BTUUsICdbb25hZGRpY2VjYW5kaWRhdGVdJylcbiAgICB0aGlzLl9wZWVySGVscGVyLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpXG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgcmVjZWlwdCBvZiBlbXB0eSBjYW5kaWRhdGUgZHVyaW5nIElDRSBuZWdvdGlhdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uRW1wdHlDYW5kaWRhdGUoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tpY2VjYW5kaWRhdGV0cmlja2xlOmVtcHR5XScpXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoUlRDU3Vic2NyaWJlckV2ZW50VHlwZXMuUEVFUl9DQU5ESURBVEVfRU5EKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBjb21wbGV0aW9uIG9mIHBlZXIgaWNlIGNhbmRpZGF0ZSBnYXRoZXJpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvblBlZXJHYXRoZXJpbmdDb21wbGV0ZSgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2ljZWNhbmRpZGF0ZWdhdGhlcmluZzplbmRdJylcbiAgICBpZiAodGhpcy5fc29ja2V0SGVscGVyKSB7XG4gICAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdEVuZE9mQ2FuZGlkYXRlcyh0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIG5vdGlmaWNhdGlvbiBvZiBlbmQgaW4gaWNlIGNhbmRpZGF0ZXMgb3ZlciB0aGUgV2ViU29ja2V0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25Tb2NrZXRJY2VDYW5kaWRhdGVFbmQoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tvbnNvY2tldGljZWNhbmRpZGF0ZWVuZF0nKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLklDRV9UUklDS0xFX0NPTVBMRVRFLCB0aGlzKSlcbiAgICB0aGlzLl9zZW5kU3Vic2NyaWJlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmFsIGV2ZW50IGhhbmRsZXIgZm9yIGFsbCBtZXNzYWdlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uU29ja2V0TWVzc2FnZShzb2NrZXQsIG1lc3NhZ2UpIHtcbiAgICB0aGlzLnRyaWdnZXIoXG4gICAgICBuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLlNPQ0tFVF9NRVNTQUdFLCB0aGlzLCB7XG4gICAgICAgIHNvY2tldDogc29ja2V0LFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgfSlcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhbCBldmVudCBoYW5kbGVyIGZvciBlcnJvcnMgY29taW5nIG92ZXIgdGhlIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGRldGFpbFxuICAgKiAgICAgICAgT3B0aW9uYWwgYWRkaXRpb25hbCBkZXRhaWwuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvblNvY2tldE1lc3NhZ2VFcnJvcihtZXNzYWdlLCBkZXRhaWwgPSB1bmRlZmluZWQpIHtcbiAgICBlcnJvcihOQU1FLCBgRXJyb3IgaW4gc3RyZWFtIHN1YnNjcmlwdGlvbjogJHttZXNzYWdlfS5cXG5bT3B0aW9uYWwgZGV0YWlsXTogJHtkZXRhaWx9YClcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25SZXNvbHZlci5yZWplY3QoYEVycm9yIGluIHN0cmVhbSBzdWJzY3JpcHRpb246ICR7bWVzc2FnZX0uYClcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfRkFJTCwgdGhpcywgbWVzc2FnZSkpXG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgY2xvc2Ugb24gdGhlIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gY2xvc2VFdmVudFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25Tb2NrZXRDbG9zZShjbG9zZUV2ZW50KSB7XG4gICAgZGVidWcoTkFNRSwgJ1tvbnNvY2tldGNsb3NlXScpXG4gICAgaWYgKHRoaXMuX3BlZXJIZWxwZXIpIHtcbiAgICAgIHRoaXMuX3BlZXJIZWxwZXIudGVhckRvd24oKVxuICAgIH1cbiAgICB0aGlzLm9uQ29ubmVjdGlvbkNsb3NlZChjbG9zZUV2ZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIGZhaWwgaW4gUGVlciBDb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25QZWVyQ29ubmVjdGlvbkZhaWwoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tvbnBlZXJjb25uZWN0aW9uZmFpbF0nKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9GQUlMLCB0aGlzLCAnZmFpbCcpKVxuICAgIHRoaXMuX3N1YnNjcmlwdGlvblJlc29sdmVyLnJlamVjdCgnUGVlciBDb25uZWN0aW9uIEZhaWxlZC4nKVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIGNsb3NlIG9mIFBlZXIgQ29ubmVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uUGVlckNvbm5lY3Rpb25DbG9zZShldmVudCkge1xuICAgIGRlYnVnKE5BTUUsICdbb25wZWVyY29ubmVjdGlvbmNsb3NlXScpXG4gICAgaWYgKHRoaXMuX3NvY2tldEhlbHBlcikge1xuICAgICAgdGhpcy5fc29ja2V0SGVscGVyLnRlYXJEb3duKClcbiAgICB9XG4gICAgdGhpcy5vblNvY2tldENsb3NlKGV2ZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIG9wZW4gb2YgUGVlciBDb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25QZWVyQ29ubmVjdGlvbk9wZW4oKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tvbnBlZXJjb25uZWN0aW9ub3Blbl0nKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLlBFRVJfQ09OTkVDVElPTl9PUEVOKSwgdGhpcywgdGhpcy5nZXRQZWVyQ29ubmVjdGlvbigpKVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIGBVbnB1Ymxpc2hgIG9mIHN0cmVhbSBzdWJzY3JpYmVkIHRvLiBPY2N1cnMgd2hlbiBhIGJyb2FkY2FzdGVyIHN0b3BzIHRoZWlyIHN0cmVhbSB3aGlsZSB0aGlzIHN1YnNjcmlwdGlvbiBzdHJlYW0gaXMgb3Blbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uVW5wdWJsaXNoKCkge1xuICAgIGRlYnVnKE5BTUUsICdbb251bnB1Ymxpc2hdJylcbiAgICBpZiAodGhpcy5fc291cmNlSGFuZGxlcikge1xuICAgICAgdGhpcy5fc291cmNlSGFuZGxlci51bnB1Ymxpc2goKVxuICAgIH1cbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5QTEFZX1VOUFVCTElTSCwgdGhpcykpXG4gICAgdGhpcy51bnN1YnNjcmliZSgpXG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgY29ubmVjdGlvbiBvbiBzdHJlYW0gYmVpbmcgY2xvc2VkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25Db25uZWN0aW9uQ2xvc2VkKGV2ZW50ID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCF0aGlzLl9jb25uZWN0aW9uQ2xvc2VkKSB7XG4gICAgICBkZWJ1ZyhOQU1FLCAnW29uY29ubmVjdGlvbmNsb3NlZF0nKVxuICAgICAgdGhpcy5fZGlzY29ubmVjdCgpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5DT05ORUNUSU9OX0NMT1NFRCwgdGhpcywgZXZlbnQpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBhY2NlcHRpbmcgZGF0YSB0aHJvdWdoIHRoZSBgc2VuZGAgQVBJIG9mIGEgUHVibGlzaGVyLiBUaGlzIGlzIHRoZSByZWNlaXZpbmcgZW5kIG9mIHRoZSBjb21tdW5pY2F0aW9uIGNoYW5uZWwgaW4gd2hpY2ggYSBQdWJsaXNoZXIgY2FuIHNlbmQgZGF0YSB0byBhbGwgc3Vic2NyaWJlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2ROYW1lXG4gICAqICAgICAgICBUaGUgdGFyZ2V0IG1ldGhvZCBuYW1lIGFzc29jaWF0ZWQgd2l0aCB0aGUgY29tbXVuaWNhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogICAgICAgIFRoZSBkYXRhIGJlaW5nIHNlbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvblNlbmRSZWNlaXZlZChtZXRob2ROYW1lLCBkYXRhKSB7XG4gICAgaWYgKG1ldGhvZE5hbWUgPT09ICdvbk1ldGFEYXRhJykge1xuICAgICAgdGhpcy5vbk1ldGFEYXRhKGRhdGEpXG4gICAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAnb25QdWJsaXNoZXJOZXR3b3JrQ29uZ2VzdGlvbicpIHtcbiAgICAgIHRoaXMub25QdWJsaXNoZXJOZXR3b3JrQ29uZ2VzdGlvbihkYXRhKVxuICAgIH0gZWxzZSBpZiAobWV0aG9kTmFtZSA9PT0gJ29uUHVibGlzaGVyTmV0d29ya1JlY292ZXJ5Jykge1xuICAgICAgdGhpcy5vblB1Ymxpc2hlck5ldHdvcmtSZWNvdmVyeShkYXRhKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbnZpcm9ubWVudC5pbnZva2UobWV0aG9kTmFtZSwgZGF0YSlcbiAgICAgIHRoaXMudHJpZ2dlcihcbiAgICAgICAgbmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfU0VORF9JTlZPS0UsIHRoaXMsIHtcbiAgICAgICAgICBtZXRob2ROYW1lOiBtZXRob2ROYW1lLFxuICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIHN0YXR1cyBub3RpZmljYXRpb25zIG9mIHRoZSBzdWJzY3JpcHRpb24gc3RyZWFtIGNvbWluZyBvdmVyIHRoZSBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0dXNcbiAgICogICAgICAgIFRoZSBzdGF0dXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25TdWJzY3JpYmVyU3RhdHVzKHN0YXR1cykge1xuICAgIGRlYnVnKE5BTUUsICdbc3Vic2NyaWJlcnN0YXR1c10gLSAnICsgSlNPTi5zdHJpbmdpZnkoc3RhdHVzLCBudWxsLCAyKSlcbiAgICBjb25zdCBzdGFydFJlc3VsdCA9IHN1YlN0YXJ0UmVnZXguZXhlYyhzdGF0dXMubWVzc2FnZSlcbiAgICBpZiAoc3RhcnRSZXN1bHQgJiYgc3RhcnRSZXN1bHRbMV0gPT09IHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSkge1xuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uUmVzb2x2ZXIucmVzb2x2ZSh0aGlzKVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX1NUQVJULCB0aGlzKSlcbiAgICAgIHRoaXMuX3BsYXlJZkF1dG9wbGF5U2V0KHRoaXMuX29wdGlvbnMsIHRoaXMuX3ZpZXcpXG4gICAgICB0aGlzLl9zdGFydFNlZWthYmxlKHRoaXMuX29wdGlvbnMsIHRoaXMuX3ZpZXcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9TVEFUVVMsIHRoaXMsIHN0YXR1cykpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGxpc3RlbmVyIGZvciBEYXRhIENoYW5uZWwgYmVpbmcgb3BlbiBvbiBzZXJ2ZXIgdG8gc3dpdGNoIHNpZ25hbGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uRGF0YUNoYW5uZWxBdmFpbGFibGUoY2hhbm5lbE5hbWUpIHtcbiAgICBkZWJ1ZygnW29uZGF0YWNoYW5uZWw6OmF2YWlsYWJsZV0nKVxuICAgIHRoaXMuX3N3aXRjaENoYW5uZWxSZXF1ZXN0ID0ge1xuICAgICAgc3dpdGNoQ2hhbm5lbDogY2hhbm5lbE5hbWUgfHwgJ3JlZDVwcm8nLFxuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zaWduYWxpbmdTb2NrZXRPbmx5KSB7XG4gICAgICBsZXQgdCA9IHNldFRpbWVvdXQoXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodClcbiAgICAgICAgICBpZiAodGhpcy5fc29ja2V0SGVscGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9zb2NrZXRIZWxwZXIuc2V2ZXIodGhpcy5fc3dpdGNoQ2hhbm5lbFJlcXVlc3QpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX21lc3NhZ2VUcmFuc3BvcnQgPSB0aGlzLl9wZWVySGVscGVyXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKFxuICAgICAgICAgICAgbmV3IE1lc3NhZ2VUcmFuc3BvcnRTdGF0ZUV2ZW50KE1lc3NhZ2VUcmFuc3BvcnRTdGF0ZUV2ZW50VHlwZXMuQ0hBTkdFLCB0aGlzLCB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXI6IHRoaXMsXG4gICAgICAgICAgICAgIHRyYW5zcG9ydDogdGhpcy5fbWVzc2FnZVRyYW5zcG9ydCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICB9LFxuICAgICAgICB0aGlzLl9zb2NrZXRIZWxwZXIgPyB0aGlzLl9vcHRpb25zLnNvY2tldFN3aXRjaERlbGF5IDogMTAwXG4gICAgICApXG4gICAgfVxuICAgIHRoaXMudHJpZ2dlcihcbiAgICAgIG5ldyBTdWJzY3JpYmVyRXZlbnQoUlRDU3Vic2NyaWJlckV2ZW50VHlwZXMuREFUQV9DSEFOTkVMX0FWQUlMQUJMRSwgdGhpcywge1xuICAgICAgICBuYW1lOiBjaGFubmVsTmFtZSxcbiAgICAgICAgZGF0YUNoYW5uZWw6IHRoaXMuZ2V0RGF0YUNoYW5uZWwoKSxcbiAgICAgIH0pXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIG5vdGlmaWNhdGlvbnMgb2YgZXJyb3Igb24gb3B0aW9uYWwgZGF0YSBjaGFubmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge1JUQ0RhdGFDaGFubmVsfSBkYXRhQ2hhbm5lbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXJyb3JcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uRGF0YUNoYW5uZWxFcnJvcihkYXRhQ2hhbm5lbCwgZXJyb3IpIHtcbiAgICB0aGlzLnRyaWdnZXIoXG4gICAgICBuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLkRBVEFfQ0hBTk5FTF9FUlJPUiwgdGhpcywge1xuICAgICAgICBkYXRhQ2hhbm5lbDogZGF0YUNoYW5uZWwsXG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgIH0pXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIG5vdGlmaWNhdGlvbnMgb2YgbWVzc2FnZSBvbiBvcHRpb25hbCBkYXRhIGNoYW5uZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7UlRDRGF0YUNoYW5uZWx9IGRhdGFDaGFubmVsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbkRhdGFDaGFubmVsTWVzc2FnZShkYXRhQ2hhbm5lbCwgbWVzc2FnZURhdGEpIHtcbiAgICB0aGlzLnRyaWdnZXIoXG4gICAgICBuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLkRBVEFfQ0hBTk5FTF9NRVNTQUdFLCB0aGlzLCB7XG4gICAgICAgIGRhdGFDaGFubmVsOiBkYXRhQ2hhbm5lbCxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZURhdGEsXG4gICAgICB9KVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBvcGVuIG5vdGlmaWNhdGlvbiBvbiBvcHRpb25hbCBkYXRhIGNoYW5uZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7UlRDRGF0YUNoYW5uZWx9IGRhdGFDaGFubmVsXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbkRhdGFDaGFubmVsT3BlbihkYXRhQ2hhbm5lbCkge1xuICAgIHRoaXMudHJpZ2dlcihcbiAgICAgIG5ldyBTdWJzY3JpYmVyRXZlbnQoUlRDU3Vic2NyaWJlckV2ZW50VHlwZXMuREFUQV9DSEFOTkVMX09QRU4sIHRoaXMsIHtcbiAgICAgICAgZGF0YUNoYW5uZWw6IGRhdGFDaGFubmVsLFxuICAgICAgfSlcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgY2xvc2Ugbm90aWZpY2F0aW9uIG9uIG9wdGlvbmFsIGRhdGEgY2hhbm5lbC5cbiAgICpcbiAgICogQHBhcmFtIHtSVENEYXRhQ2hhbm5lbH0gZGF0YUNoYW5uZWxcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uRGF0YUNoYW5uZWxDbG9zZShkYXRhQ2hhbm5lbCkge1xuICAgIHRoaXMudHJpZ2dlcihcbiAgICAgIG5ldyBTdWJzY3JpYmVyRXZlbnQoUlRDU3Vic2NyaWJlckV2ZW50VHlwZXMuREFUQV9DSEFOTkVMX0NMT1NFLCB0aGlzLCB7XG4gICAgICAgIGRhdGFDaGFubmVsOiBkYXRhQ2hhbm5lbCxcbiAgICAgIH0pXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIG1ldGFkYXRhIGJlaW5nIHNlbnQgcmVsYXRlZCB0byB0aGUgc3Vic2NyaXB0aW9uIHN0cmVhbSBjb21pbmcgb3ZlciB0aGUgV2ViU29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YWRhdGFcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uTWV0YURhdGEobWV0YWRhdGEpIHtcbiAgICBjb25zdCB7IG9yaWVudGF0aW9uLCBzdHJlYW1pbmdNb2RlIH0gPSBtZXRhZGF0YVxuICAgIGNvbnN0IHByZXZpb3VzU3RyZWFtaW5nTW9kZSA9IHRoaXMuX3N0cmVhbWluZ01vZGVcbiAgICBpZiAodHlwZW9mIG9yaWVudGF0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBvcmllbnRhdGlvbiAhPT0gdGhpcy5fb3JpZW50YXRpb24pIHtcbiAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gb3JpZW50YXRpb25cbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLmF1dG9MYXlvdXRPcmllbnRhdGlvbikge1xuICAgICAgICBhcHBseU9yaWVudGF0aW9uKHRoaXMuX3ZpZXcudmlldywgcGFyc2VJbnQob3JpZW50YXRpb24sIDEwKSwgbWV0YWRhdGFSZXNvbHV0aW9uVG9PYmplY3QobWV0YWRhdGEucmVzb2x1dGlvbikpXG4gICAgICAgIGlmICh0aGlzLl9zb3VyY2VIYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5fc291cmNlSGFuZGxlci5oYW5kbGVPcmllbnRhdGlvbkNoYW5nZShwYXJzZUludChvcmllbnRhdGlvbiwgMTApKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIoXG4gICAgICAgIG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuT1JJRU5UQVRJT05fQ0hBTkdFLCB0aGlzLCB7XG4gICAgICAgICAgb3JpZW50YXRpb246IHBhcnNlSW50KG9yaWVudGF0aW9uLCAxMCksXG4gICAgICAgICAgdmlld0VsZW1lbnQ6IHRoaXMuX3ZpZXcudmlldyxcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzdHJlYW1pbmdNb2RlICE9PSAndW5kZWZpbmVkJyAmJiBzdHJlYW1pbmdNb2RlICE9PSBwcmV2aW91c1N0cmVhbWluZ01vZGUpIHtcbiAgICAgIHRoaXMuX3N0cmVhbWluZ01vZGUgPSBzdHJlYW1pbmdNb2RlXG4gICAgICB0aGlzLnRyaWdnZXIoXG4gICAgICAgIG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1RSRUFNSU5HX01PREVfQ0hBTkdFLCB0aGlzLCB7XG4gICAgICAgICAgc3RyZWFtaW5nTW9kZTogc3RyZWFtaW5nTW9kZSxcbiAgICAgICAgICBwcmV2aW91c1N0cmVhbWluZ01vZGU6IHByZXZpb3VzU3RyZWFtaW5nTW9kZSxcbiAgICAgICAgICB2aWV3RWxlbWVudDogdGhpcy5fdmlldy52aWV3LFxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH1cbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfTUVUQURBVEEsIHRoaXMsIG1ldGFkYXRhKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBuZXR3b3JrIGNvbmdlc3Rpb24gbWV0YWRhdGEgY29taW5nIGluIGZyb20gc2VydmVyIHJlbGF0ZWQgdG8gcHVibGlzaGVyIGJyb2FkY2FzdCBjb25kaXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25QdWJsaXNoZXJOZXR3b3JrQ29uZ2VzdGlvbihkYXRhKSB7XG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX1BVQkxJU0hFUl9DT05HRVNUSU9OLCB0aGlzLCBkYXRhKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBuZXR3b3JrIHJlY292ZXJ5IG1ldGFkYXRhIGNvbWluZyBpbiBmcm9tIHNlcnZlciByZWxhdGVkIHRvIHB1Ymxpc2hlciBicm9hZGNhc3QgY29uZGl0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uUHVibGlzaGVyTmV0d29ya1JlY292ZXJ5KGRhdGEpIHtcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfUFVCTElTSEVSX1JFQ09WRVJZLCB0aGlzLCBkYXRhKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGludm9rZSBhIG1ldGhvZCBvbiB0aGUgQXBwbGljYXRpb24gQWRhcHRlciByZWxhdGVkIHRvIHRoZSBgYXBwYCBjb25maWcgc2V0dGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZE5hbWVcbiAgICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlIG9uIHRodyBBcHBsaWNhdGlvbiBBZGFwdGVyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAgICogICAgICAgIFRoZSBvcmRlcmVkIGxpc3Qgb2YgYXJndW1lbnRzIHRvIGludm9rZSBvbiB0aGUgbWV0aG9kLiBEbyBub3QgcHJvdmlkZSBhbnl0aGluZyBpZiB0aGUgbWV0aG9kIHRha2VzIG5vIGFyZ3VtZW50cy5cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIGNhbGxTZXJ2ZXIobWV0aG9kTmFtZSwgYXJncykge1xuICAgIHJldHVybiB0aGlzLmdldE1lc3NhZ2VUcmFuc3BvcnQoKS5wb3N0QXN5bmMoe1xuICAgICAgY2FsbEFkYXB0ZXI6IHtcbiAgICAgICAgbWV0aG9kOiBtZXRob2ROYW1lLFxuICAgICAgICBhcmd1bWVudHM6IGFyZ3MsXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYW4gUlBDIGxvZyB0byB0aGUgc2VydmVyIHdoaWNoIHdpbGwgYmUgcHJpbnRlZCBvdXQgaW4gc2VydmVyIGxvZ3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsZXZlbFxuICAgKiAgICAgICAgVmFsaWQgdmFsdWVzOiBUUkFDRSwgSU5GTywgREVCVUcsIFdBUk4gb3IgRVJST1JcbiAgICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2VcbiAgICogICAgICAgIEVpdGhlciBhIFN0cmluZyBvciBhIEpTT04tc2VyaWFsaXphYmxlIE9iamVjdC4gVGhpcyBwYXJhbSB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIHN0cmluZyB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAqL1xuICBzZW5kTG9nKGxldmVsLCBtZXNzYWdlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRoZUxldmVsID0gT2JqZWN0LmtleXMoTEVWRUxTKS5maW5kKChsKSA9PiBsLnRvTG93ZXJDYXNlKCkgPT09IGxldmVsLnRvTG93ZXJDYXNlKCkpID8gbGV2ZWwgOiBMRVZFTFMuREVCVUdcbiAgICAgIGNvbnN0IHRoZU1lc3NhZ2UgPSB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyBtZXNzYWdlIDogSlNPTi5zdHJpbmdpZnkobWVzc2FnZSlcbiAgICAgIHRoaXMuZ2V0TWVzc2FnZVRyYW5zcG9ydCgpLnBvc3Qoe1xuICAgICAgICBsb2c6IHRoZUxldmVsLnRvVXBwZXJDYXNlKCksXG4gICAgICAgIG1lc3NhZ2U6IHRoZU1lc3NhZ2UsXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlLm1lc3NhZ2UgfHwgZVxuICAgICAgZXJyb3IoTkFNRSwgYENvdWxkIG5vdCBzZW5kIGxvZyB0byBzZXJ2ZXIuIE1lc3NhZ2UgcGFyYW1ldGVyIGV4cGVjdGVkIHRvIGJlIFN0cmluZyBvciBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QuYClcbiAgICAgIGVycm9yKE5BTUUsIG1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVudGVycyBzdWJzY3JpYmVyIGludG8gc3RhbmRieSBtb2RlIC0ga2VlcGluZyBjb25uZWN0aW9uIG9wZW4gYnV0IG5vdCBib3RoZXJpbmcgdG8gY29uc3VtZSB2aWRlbyBvciBhdWRpby5cbiAgICovXG4gIGVuYWJsZVN0YW5kYnkoKSB7XG4gICAgdGhpcy5nZXRNZXNzYWdlVHJhbnNwb3J0KCkucG9zdCh7XG4gICAgICAvLyAgICAgIHN0YW5kYnk6IHRydWVcbiAgICAgIG11dGU6IHtcbiAgICAgICAgbXV0ZUF1ZGlvOiB0cnVlLFxuICAgICAgICBtdXRlVmlkZW86IHRydWUsXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBzdWJzY3JpYmVyIGZyb20gc3RhbmRieSBtb2RlIC0gdHVybmluZyB0aGUgYXVkaW8gYW5kIHZpZGVvIGJhY2sgb24gYW5kIGNvbnN1bWFibGUgYWZ0ZXIgYSBtdXRlIHJlcXVlc3QuXG4gICAqL1xuICBkaXNhYmxlU3RhbmRieSgpIHtcbiAgICB0aGlzLmdldE1lc3NhZ2VUcmFuc3BvcnQoKS5wb3N0KHtcbiAgICAgIC8vICAgICAgc3RhbmRieTogZmFsc2VcbiAgICAgIG11dGU6IHtcbiAgICAgICAgbXV0ZUF1ZGlvOiBmYWxzZSxcbiAgICAgICAgbXV0ZVZpZGVvOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBNdXRlcyBhdWRpbyBiZWluZyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgc3Vic2NyaWJlci4gQXVkaW8gcGFja2V0cyB3aWxsIGJlIGhlbGQgZnJvbSB0aGUgc3Vic2NyaWJlciBvbiB0aGUgc2VydmVyLXNpZGUuXG4gICAqL1xuICBtdXRlQXVkaW8oKSB7XG4gICAgdGhpcy5nZXRNZXNzYWdlVHJhbnNwb3J0KCkucG9zdCh7XG4gICAgICBtdXRlOiB7XG4gICAgICAgIG11dGVBdWRpbzogdHJ1ZSxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVbm11dGVzIGF1ZGlvIGJlaW5nIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBzdWJzY3JpYmVyLiBBdWRpbyBwYWNrZXRzIHdpbGwgcmVzdW1lIGJlaW5nIHNlbnQgdG8gdGhlIHN1YnNjcmliZXIuXG4gICAqL1xuICB1bm11dGVBdWRpbygpIHtcbiAgICB0aGlzLmdldE1lc3NhZ2VUcmFuc3BvcnQoKS5wb3N0KHtcbiAgICAgIG11dGU6IHtcbiAgICAgICAgbXV0ZUF1ZGlvOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBNdXRlcyB2aWRlbyBiZWluZyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgc3Vic2NyaWJlci4gVmlkZW8gcGFja2V0cyB3aWxsIGJlIGhlbGQgZnJvbSB0aGUgc3Vic2NyaWJlciBvbiB0aGUgc2VydmVyLXNpZGUuXG4gICAqL1xuICBtdXRlVmlkZW8oKSB7XG4gICAgdGhpcy5nZXRNZXNzYWdlVHJhbnNwb3J0KCkucG9zdCh7XG4gICAgICBtdXRlOiB7XG4gICAgICAgIG11dGVWaWRlbzogdHJ1ZSxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVbm11dGVzIHZpZGVvIGJlaW5nIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBzdWJzY3JpYmVyLiBWaWRlbyBwYWNrZXRzIHdpbGwgcmVzdW1lIGJlaW5nIHNlbnQgdG8gdGhlIHN1YnNjcmliZXIuXG4gICAqL1xuICB1bm11dGVWaWRlbygpIHtcbiAgICB0aGlzLmdldE1lc3NhZ2VUcmFuc3BvcnQoKS5wb3N0KHtcbiAgICAgIG11dGU6IHtcbiAgICAgICAgbXV0ZVZpZGVvOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBNZXNzYWdlIFRyYW5zcG9ydCBpbnN0YW5jZSB0aGF0IHBvc3RzIHJlcXVlc3RzIHRvIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqICBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICAgICAgIEVpdGhlciB0aGUgc29ja2VyIHByb3h5IG9yIHRoZSBwZWVyIGNvbm5lY3Rpb24gcHJveHlcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE1lc3NhZ2VUcmFuc3BvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lc3NhZ2VUcmFuc3BvcnRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IFdlYlNvY2tldCBjb25uZWN0aW9uIGhlbHBlciBpZiBlc3RhYmxpc2hlZC5cbiAgICogVXNlZCBpbiBTaGFyZWRPYmplY3QgY29tbXVuaWNhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7UHVibGlzaGVyU29ja2V0SGVscGVyfVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Q29ubmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc29ja2V0SGVscGVyXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBSVENQZWVyQ29ubmVjdGlvbiBoZWxwZXIgaWYgZXN0YWJsaXNoZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge1JUQ1BlZXJDb25uZWN0aW9ufVxuICAgKi9cbiAgZ2V0UGVlckNvbm5lY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlZXJIZWxwZXIgPyB0aGlzLl9wZWVySGVscGVyLmNvbm5lY3Rpb24gOiB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb25hbCBSVENEYXRhQ2hhbm5lbCBvbiB0aGUgb3BlbmVkIHBlZXIgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7UlRDRGF0YUNoYW5uZWx9XG4gICAqL1xuICBnZXREYXRhQ2hhbm5lbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGVlckhlbHBlciA/IHRoaXMuX3BlZXJIZWxwZXIuZGF0YUNoYW5uZWwgOiB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgTWVkaWFTdHJlYW1gIGluc3RhbmNlIGlmIGdlbmVyYXRlZCB0aHJvdWdoIGBnZXRVc2VyTWVkaWFgIGFuZCBleGlzdHMgZm9yIGJyb2FkY2FzdC5cbiAgICpcbiAgICogQHJldHVybiB7TWVkaWFTdHJlYW19XG4gICAqL1xuICBnZXRNZWRpYVN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHJlZmVyZW5jZSB0byBwbGF5YmFjayBjb250cm9scyBpZiBhdmFpbGFibGUuXG4gICAqXG4gICAqIEByZXR1cm4ge1BsYXliYWNrQ29udHJvbHN9XG4gICAqL1xuICBnZXRDb250cm9scygpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlSGFuZGxlciA/IHRoaXMuX3NvdXJjZUhhbmRsZXIuZ2V0Q29udHJvbHMoKSA6IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRhcmdldCB2aWV3IEVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBnZXRQbGF5ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXcudmlld1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluaXRpYWxpemF0aW9uIGNvbmZpZ3VyYXRpb24gdXNlZCBpbiBgaW5pdCgpYC5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHR5cGUgb2YgaW1wbGVtZW50YXRpb246IGBSVENgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiBQbGF5YmFja1R5cGVzLlJUQy50b1VwcGVyQ2FzZSgpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUlRDU3Vic2NyaWJlclxuIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuL2Jyb3dzZXInXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5cbi8qKlxuICogUmVwbGFjZXMgYSBgdmlkZW9gIGVsZW1lbnQgd2l0aCBhIGNvbnRhaW5lciBmb3IgZW1iZWRkaW5nIGEgRmxhc2ggb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0RWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRQYXJlbnRcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgZGVmaW5lRW1iZWRFbGVtZW50ID0gKHRhcmdldEVsZW1lbnQsIHRhcmdldFBhcmVudCkgPT4ge1xuICBsZXQgZGZkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gIGNvbnN0IGVsZW1lbnRJZCA9IHRhcmdldEVsZW1lbnQuaWRcbiAgaWYgKHRhcmdldEVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvJykge1xuICAgIGxldCBkaXYgPSBlbnZpcm9ubWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIGRpdi5pZCA9IGVsZW1lbnRJZCArICdfcnRtcCdcbiAgICB0YXJnZXRQYXJlbnQuYXBwZW5kQ2hpbGQoZGl2KVxuICAgIGlmICh0YXJnZXRFbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIHRhcmdldEVsZW1lbnQucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0YXJnZXRFbGVtZW50KVxuICAgIH1cbiAgICBkZmQucmVzb2x2ZShkaXYuaWQpXG4gIH0gZWxzZSB7XG4gICAgZGZkLnJlc29sdmUoZWxlbWVudElkKVxuICB9XG4gIHJldHVybiBkZmQucHJvbWlzZVxufVxuXG4vKipcbiAqIFJlcXVlc3QgdG8gZW1iZWQgYSBGbGFzaCBvYmplY3QgdXNpbmcgU1dGT2JqZWN0IGxpYnJhcnkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkTmFtZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICBJbml0aWFsaXphdGlvbiBjb25maWd1cmF0aW9uIG1hcC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBmbGFzaHZhcnNcbiAqICAgICAgICBUaGUgRmxhc2hWYXJzIHRvIHBhc3MgaW50byB0aGUgZW1iZWRkZWQgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHN3Zm9iamVjdFxuICogICAgICAgIFRoZSBsb2FkZWQgU1dGT2JqZWN0IGxpYnJhcnkgdXRpbC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBlbGVtZW50SWRcbiAqICAgICAgICBUaGUgaWQgb2YgdGhlIEVsZW1lbnQgdG8gZW1iZWQuXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBlbWJlZFN3Zk9iamVjdCA9IChpZE5hbWUsIG9wdGlvbnMsIGZsYXNodmFycywgc3dmb2JqZWN0LCBlbGVtZW50SWQpID0+IHtcbiAgbGV0IGRmZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICBsZXQgcGFyYW1zID0ge1xuICAgIHF1YWxpdHk6ICdoaWdoJyxcbiAgICB3bW9kZTogJ29wYXF1ZScsXG4gICAgYmdjb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IgfHwgJyMwMDAnLFxuICAgIGFsbG93c2NyaXB0YWNjZXNzOiAnYWx3YXlzJyxcbiAgICBhbGxvd2Z1bGxzY3JlZW46ICd0cnVlJyxcbiAgICBhbGxvd25ldHdvcmtpbmc6ICdhbGwnXG4gIH1cbiAgbGV0IGF0dHJpYnV0ZXMgPSB7XG4gICAgaWQ6IGlkTmFtZSxcbiAgICBuYW1lOiBpZE5hbWUsXG4gICAgYWxpZ246ICdtaWRkbGUnXG4gIH1cbiAgaWYgKHN3Zm9iamVjdC5oYXNGbGFzaFBsYXllclZlcnNpb24ob3B0aW9ucy5taW5GbGFzaFZlcnNpb24pKSB7XG4gICAgc3dmb2JqZWN0LmVtYmVkU1dGKFxuICAgICAgb3B0aW9ucy5zd2YsXG4gICAgICBlbGVtZW50SWQsXG4gICAgICBvcHRpb25zLmVtYmVkV2lkdGggfHwgNjQwLFxuICAgICAgb3B0aW9ucy5lbWJlZEhlaWdodCB8fCA0ODAsXG4gICAgICBvcHRpb25zLm1pbkZsYXNoVmVyc2lvbixcbiAgICAgIG9wdGlvbnMucHJvZHVjdEluc3RhbGxVUkwsXG4gICAgICBmbGFzaHZhcnMsXG4gICAgICBwYXJhbXMsXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgKHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICBkZmQucmVzb2x2ZSgpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGZkLnJlamVjdCgnRmxhc2ggT2JqZWN0IGVtYmVkIGZhaWxlZC4nKVxuICAgICAgICB9XG4gICAgICB9KVxuICB9IGVsc2Uge1xuICAgIGRmZC5yZWplY3QoJ0ZsYXNoIFBsYXllciBWZXJzaW9uIGlzIG5vdCBzdXBwb3J0ZWQuJylcbiAgfVxuICByZXR1cm4gZGZkLnByb21pc2Vcbn1cblxuIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCB7IGRlYnVnLCB3YXJuIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvUlRNUFNoYXJlZE9iamVjdEhhbmRsZXInXG5cbi8qKlxuICogRmxhc2gtYmFzZWQgU2hhcmVkT2JqZWN0IGhhbmRsZXIuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUlRNUFNoYXJlZE9iamVjdEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycyA9IFtdXG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHJlc3BvbnNlIGhhbmRsZXIgZm9yIFNoYXJlZE9iamVjdCBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyXG4gICAqL1xuICBhZGRSZXNwb25zZUhhbmRsZXIgKGhhbmRsZXIpIHtcbiAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLnB1c2goaGFuZGxlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgcmVzcG9uc2UgaGFuZGxlciBmcm9tIFNoYXJlZE9iamVjdCBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyXG4gICAqL1xuICByZW1vdmVSZXNwb25zZUhhbmRsZXIgKGhhbmRsZXIpIHtcbiAgICBsZXQgaSA9IHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMubGVuZ3RoXG4gICAgbGV0IHJIYW5kbGVyXG4gICAgd2hpbGUoLS1pID4gLTEpIHtcbiAgICAgIHJIYW5kbGVyID0gdGhpcy5fcmVzcG9uc2VIYW5kbGVyc1tpXVxuICAgICAgaWYgKHJIYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMuc3BsaWNlKGksIDEpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGFuIGV2ZW50IGZyb20gYSBTaGFyZWRPYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKi9cbiAgaGFuZGxlU2hhcmVkT2JqZWN0RXZlbnQgKGV2ZW50KSB7XG4gICAgZGVidWcoTkFNRSwgJ1tzaGFyZWRvYmplY3Q6ZXZlbnRdJylcbiAgICBsZXQgaVxuICAgIGxldCBsZW5ndGggPSB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLmxlbmd0aFxuICAgIGxldCBoYW5kbGVyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBoYW5kbGVyID0gdGhpcy5fcmVzcG9uc2VIYW5kbGVyc1tpXVxuICAgICAgaWYgKGhhbmRsZXIucmVzcG9uZChKU09OLnBhcnNlKGV2ZW50KSkpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXNzaWducyBhIGdsb2JhbCByZXNwb25zZSBoYW5kbGVyIGZvciBTaGFyZWRPYmplY3QgY29tbXVuaWNhdGlvbiB0aHJvdWdoIEZsYXNoIG9iamVjdCBvdmVyIEV4dGVybmFsSW50ZXJmYWNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqICAgICAgICBUaGUgb2JqZWN0IGVtYmVkIGVsZW1lbnQuXG4gICAqL1xuICBhc3NpZ25TaGFyZWRPYmplY3RSZXNwb25kZXIgKG5hbWUsIGVsKSB7XG4gICAgY29uc3QgX2hhbmRsZVNoYXJlZE9iamVjdEV2ZW50ID0gdGhpcy5oYW5kbGVTaGFyZWRPYmplY3RFdmVudC5iaW5kKHRoaXMpXG4gICAgY29uc3QgZWxJZCA9IGVsLmlkLnNwbGl0KCctJykuam9pbignXycpXG4gICAgY29uc3QgaGFuZGxlck5hbWUgPSBbJ2hhbmRsZVNoYXJlZE9iamVjdEV2ZW50JywgZWxJZF0uam9pbignXycpXG4gICAgZGVidWcoTkFNRSwgYFthc3NpZ246c2hhcmVkb2JqZWN0OnJlc3BvbmRlcl0gOjogJHtlbElkfWApXG4gICAgZGVidWcoTkFNRSwgYFtzaGFyZWRvamVjdDpyZXNwb25kZXJdIDo6ICR7aGFuZGxlck5hbWV9YClcbiAgICBlbC5zZXRTaGFyZWRPYmplY3RSZXNwb25kZXIobmFtZSwgaGFuZGxlck5hbWUpXG4gICAgZW52aXJvbm1lbnQuc2V0R2xvYmFsKGhhbmRsZXJOYW1lLCBfaGFuZGxlU2hhcmVkT2JqZWN0RXZlbnQpXG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBjb25uZWN0IHRvIFNoYXJlZE9iamVjdC5cbiAgICovXG4gIGNvbm5lY3QgKHN3ZklkKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IGVudmlyb25tZW50LmdldEVtYmVkT2JqZWN0KHN3ZklkKVxuICAgIGlmICghdGhpcy5fZWxlbWVudCkge1xuICAgICAgd2FybihgQ291bGQgbm90IGxvY2F0ZSBlbWJlZGRlZCBGbGFzaCBvYmplY3QgZm9yIGlkOiAke3N3ZklkfWApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gZGlzY29ubmVjdCB0byBTaGFyZWRPYmplY3QuXG4gICAqL1xuICBkaXNjb25uZWN0ICgpIHtcbiAgICB3aGlsZSAodGhpcy5fcmVzcG9uc2VIYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLnNoaWZ0KClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdCB0byBzZW5kIG1ldGhvZCB1cGRhdGUgdG8gU2hhcmVkT2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2FsbE5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2VcbiAgICogICAgICAgIFN0cmluZyBvciBPYmplY3QgdGhhdCB3aWxsIGJlIHNlcmlhbGl6ZWQgdG8gYSBKU09OIHN0cmluZy5cbiAgICovXG4gIHNlbmRUb1NoYXJlZE9iamVjdCAobmFtZSwgbWV0aG9kTmFtZSwgbWVzc2FnZSkge1xuICAgIGRlYnVnKE5BTUUsICdbc2VuZFRvU2hhcmVkT2JqZWN0XScpXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2hhcmVkT2JqZWN0U2VuZChuYW1lLCBtZXRob2ROYW1lLCB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyBtZXNzYWdlIDogSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB3YXJuKCdDb3VsZCBub3Qgc2VuZCB0byBzaGFyZWQgb2JqZWN0ICgnICsgbmFtZSArICcpLiBFcnJvcjogJyArIGUubWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdCB0byB1cGRhdGUgcHJvcGVydHkgb24gU2hhcmVkT2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgKi9cbiAgc2VuZFByb3BlcnR5VG9TaGFyZWRPYmplY3QgKG5hbWUsIGtleSwgdmFsdWUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3NlbmRQcm9wZXJ0eVRvU2hhcmVkT2JqZWN0XScpXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2hhcmVkT2JqZWN0U2VuZFByb3BlcnR5KG5hbWUsIGtleSwgdmFsdWUpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB3YXJuKCdDb3VsZCBub3Qgc2VuZCB0byBzaGFyZWQgb2JqZWN0ICgnICsgbmFtZSArICcpLiBFcnJvcjogJyArIGUubWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBnZXQgcmVtb3RlIFNoYXJlT2JqZWN0IGJ5IG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaGFyZWRPYmplY3ROYW1lXG4gICAqL1xuICBnZXRSZW1vdGVTaGFyZWRPYmplY3QgKHNoYXJlZE9iamVjdE5hbWUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2dldFJlbW90ZVNoYXJlZE9iamVjdF0nKVxuICAgIHRyeSB7XG4gICAgICB0aGlzLmFzc2lnblNoYXJlZE9iamVjdFJlc3BvbmRlcihzaGFyZWRPYmplY3ROYW1lLCB0aGlzLl9lbGVtZW50KVxuICAgICAgdGhpcy5fZWxlbWVudC5nZXRSZW1vdGVTaGFyZWRPYmplY3Qoc2hhcmVkT2JqZWN0TmFtZSlcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oJ0NvdWxkIG5vdCBnZXQgcmVtb3RlIHNoYXJlZCBvYmplY3QgKCcgKyBuYW1lICsgJykuIEVycm9yOiAnICsgZS5tZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGNvbm5lY3QgdG8gU2hhcmVkT2JqZWN0IGJ5IG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaGFyZWRPYmplY3ROYW1lXG4gICAqL1xuICBjb25uZWN0VG9TaGFyZWRPYmplY3QgKHNoYXJlZE9iamVjdE5hbWUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2Nvbm5lY3RUb1NoYXJlZE9iamVjdF0nKVxuICAgIHRyeSB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNvbm5lY3RUb1NoYXJlZE9iamVjdChzaGFyZWRPYmplY3ROYW1lKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgd2FybignQ291bGQgbm90IGNvbm5lY3QgdG8gc2hhcmVkIG9iamVjdCAoJyArIG5hbWUgKyAnKS4gRXJyb3I6ICcgKyBlLm1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gY2xvc2UgU2hhcmVkT2JqZWN0IGNvbm5lY3Rpb24gYnkgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNoYXJlZE9iamVjdE5hbWVcbiAgICovXG4gIGNsb3NlU2hhcmVkT2JqZWN0IChzaGFyZWRPYmplY3ROYW1lKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tkaXNjb25uZWN0VG9TaGFyZWRPYmplY3RdJylcbiAgICB0cnkge1xuICAgICAgdGhpcy5fZWxlbWVudC5kaXNjb25uZWN0RnJvbVNoYXJlZE9iamVjdChzaGFyZWRPYmplY3ROYW1lKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgd2FybignQ291bGQgbm90IGRpc2Nvbm5lY3QgdG8gc2hhcmVkIG9iamVjdCAoJyArIG5hbWUgKyAnKS4gRXJyb3I6ICcgKyBlLm1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUlRNUFNoYXJlZE9iamVjdEhhbmRsZXJcblxuIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCAqIGFzIGVtYmVkIGZyb20gJy4uL2Vudi9lbWJlZCdcbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCBSVE1QU2hhcmVkT2JqZWN0SGFuZGxlciBmcm9tICcuLi9oZWxwZXIvc2hhcmVkb2JqZWN0LWhlbHBlci1ydG1wJ1xuaW1wb3J0IHsgUGxheWJhY2tDb250cm9sbGVyLCBQbGF5YmFja0NvbnRyb2xzSW1wbCB9IGZyb20gJy4vY29udHJvbHMnXG5pbXBvcnQgeyBQbGF5YmFja1N0YXRlLCBQbGF5YmFja1N0YXRlUmVhZGFibGUgfSBmcm9tICcuL2NvbnRyb2xzL3N0YXRlJ1xuaW1wb3J0IHsgU3Vic2NyaWJlckV2ZW50LCBTdWJzY3JpYmVyRXZlbnRUeXBlcyB9IGZyb20gJy4uL2V2ZW50J1xuaW1wb3J0IHsgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0IHsgZGVidWcsIHdhcm4gfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUlRNUFNvdXJjZUhhbmRsZXInXG5cbi8qKlxuICogU2ltcGxlIHV0aWwgdG8gY29udmVydCB2YWx1ZSB0byBJbnRlZ2VyLlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgdG9JbnQgPSAodmFsdWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKVxuICB9XG59XG5cbi8qKlxuICogUXVpY2sgdGVzdCBpZiBzdHJlYW1OYW1lIGhhcyBhbiBleHRlbnNpb24gd2hpY2ggaW5mZXJzIFZPRC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJlYW1OYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgaXNWT0RTdHJlYW1OYW1lID0gKHN0cmVhbU5hbWUpID0+IHtcbiAgcmV0dXJuIC9eLipcXC4oZmx2fG1wNHxtcDMpLy50ZXN0KHN0cmVhbU5hbWUpXG59XG5cbi8qKlxuICogU291cmNlIEhhbmRsZXIgZm9yIEZsYXNoLWJhc2VkIFN1YnNjcmliZXJzLCB3aGljaCBzZXJ2ZXMgYXMgYSBQcmVzZW50YXRpb24gQ29udHJvbGxlciBiZXR3ZWVuIHZpZXcgYW5kIHN1YnNjcmliZXIuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAZXh0ZW5kcyBTdWJzY3JpYmVyUGxheWJhY2tDb250cm9sbGVyXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUlRNUFNvdXJjZUhhbmRsZXIgZXh0ZW5kcyBQbGF5YmFja0NvbnRyb2xsZXIge1xuXG4gIGNvbnN0cnVjdG9yIChub3RpZmljYXRpb25DZW50ZXIsIG1lZGlhLCB0eXBlLCBzb1Jlc3BvbmRlciA9IHVuZGVmaW5lZCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLm1lZGlhID0gbWVkaWFcbiAgICB0aGlzLmNsb25lID0gdGhpcy5tZWRpYS5jbG9uZU5vZGUodHJ1ZSlcbiAgICB0aGlzLnBhcmVudCA9IHRoaXMubWVkaWEucGFyZW50Tm9kZVxuICAgIHRoaXMuaG9sZGVyID0gdGhpcy5fZGV0ZXJtaW5lSG9sZGVyKHRoaXMubWVkaWEpXG4gICAgdGhpcy5wbGF5ZXJUeXBlID0gdHlwZVxuICAgIHRoaXMuX3N3ZklkID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fY29udHJvbHMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9zb1Jlc3BvbmRlciA9IHNvUmVzcG9uZGVyIHx8IG5ldyBSVE1QU2hhcmVkT2JqZWN0SGFuZGxlcigpXG4gICAgdGhpcy5fcGxheWJhY2tOb3RpZmljYXRpb25DZW50ZXIgPSBub3RpZmljYXRpb25DZW50ZXJcbiAgICBlbnZpcm9ubWVudC5vbkZ1bGxTY3JlZW5TdGF0ZUNoYW5nZSh0aGlzLl9oYW5kbGVGdWxsU2NyZWVuQ2hhbmdlLmJpbmQodGhpcykpXG4gIH1cblxuICAvKipcbiAgICogRXN0YWJsaXNoZWQgRE9NIEVsZW1lbnQgb3JkZXIgZm9yIHBsYXliYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG1lZGlhXG4gICAqICAgICAgICBUaGUgdGFyZ2V0IG1lZGlhIGVsZW1lbnQ6IGUuZy4sIGB2aWRlb2Agb3IgYGF1ZGlvYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXRlcm1pbmVIb2xkZXIgKG1lZGlhKSB7XG4gICAgaWYgKG1lZGlhLnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdyZWQ1cHJvLW1lZGlhLWNvbnRhaW5lcicpKSB7XG4gICAgICByZXR1cm4gbWVkaWEucGFyZW50Tm9kZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IG1lZGlhLnBhcmVudE5vZGVcbiAgICAgIGNvbnN0IGRpdiA9IGVudmlyb25tZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICBkaXYuY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1jb250YWluZXInKVxuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShkaXYsIG1lZGlhKVxuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG1lZGlhKVxuICAgICAgZGl2LmFwcGVuZENoaWxkKG1lZGlhKVxuICAgICAgcmV0dXJuIGRpdlxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCBvZiBET00gRWxlbWVudCBvcmRlciB1cG9uIHN0b3Agb2YgcGxheWJhY2suXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2xlYW5VcCAoKSB7XG4gICAgLy8gUmV0dXJuIHRvIHByaW9yIERPTSBtYW5pcHVsYXRpb24uXG4gICAgbGV0IGVsID0gdGhpcy5nZXRFbWJlZGRlZFZpZXcoKVxuICAgIGxldCBlbFBhcmVudCA9IGVsLnBhcmVudE5vZGVcbiAgICBsZXQgbWVkaWFIb2xkZXIgPSB0aGlzLmhvbGRlclxuICAgIGlmIChlbFBhcmVudCkge1xuICAgICAgZWxQYXJlbnQucmVtb3ZlQ2hpbGQoZWwpXG4gICAgICAvLyBUaGUgb2JqZWN0IHBhcmVudCBjb3VsZCBiZSBhIHdyYXBwZXIgY2hpbGQgaW4gdGhlIG9yaWdpbmFsIHBhcmVudCBlbGVtZW50LlxuICAgICAgaWYgKGVsUGFyZW50ICE9PSB0aGlzLnBhcmVudCkge1xuICAgICAgICBlbFBhcmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsUGFyZW50KVxuICAgICAgICBtZWRpYUhvbGRlciA9IHRoaXMucGFyZW50XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVsLnJlbW92ZSgpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHdhcm4oTkFNRSwgYElzc3VlIGluIERPTSBjbGVhbnVwIG9mIGZsYXNoIG9iamVjdCBlbWJlZDogJHtlLm1lc3NhZ2V9YClcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tZWRpYSA9IHRoaXMuY2xvbmUuY2xvbmVOb2RlKHRydWUpXG4gICAgbWVkaWFIb2xkZXIuYXBwZW5kQ2hpbGQodGhpcy5tZWRpYSlcbiAgICBpZiAodGhpcy5fY29udHJvbHMpIHtcbiAgICAgIHRoaXMuX2NvbnRyb2xzLmRldGFjaCgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbnMgYW5kIGhhbmRsZXJzIGV2ZW50IG5vdGlmaWNpYXRpb25zIGNvbWluZyBmcm9tIHRoZSBtZWRpYSBub3RpZmllciAoZS5nLiwgYHZpZGVvYCBvciBgYXVkaW9gIGVsZW1lbnQpLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbm90aWZpZXJcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hZGRQbGF5YmFja0hhbmRsZXJzIChub3RpZmllcikge1xuICAgIGNvbnN0IGNvbnRyb2xzID0gdGhpcy5nZXRDb250cm9scygpXG4gICAgaWYgKHR5cGVvZiBjb250cm9scyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBub3RpZmllci5vbihTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfU1RBUlQsICgpID0+IHtcbiAgICAgIGNvbnRyb2xzLnNldFN0YXRlKFBsYXliYWNrU3RhdGUuUExBWUlORylcbiAgICB9KVxuICAgIG5vdGlmaWVyLm9uKFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9TVE9QLCAoKSA9PiB7XG4gICAgICBjb250cm9scy5zZXRTdGF0ZShQbGF5YmFja1N0YXRlLklETEUpXG4gICAgfSlcbiAgICBub3RpZmllci5vbihTdWJzY3JpYmVyRXZlbnRUeXBlcy5QTEFZX1VOUFVCTElTSCwgKCkgPT4ge1xuICAgICAgY29udHJvbHMuc2V0U3RhdGUoUGxheWJhY2tTdGF0ZS5JRExFKVxuICAgIH0pXG4gICAgbm90aWZpZXIub24oU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX01FVEFEQVRBLCAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kYXRhLmR1cmF0aW9uKSB7XG4gICAgICAgIGNvbnRyb2xzLnNldFBsYXliYWNrRHVyYXRpb24oZXZlbnQuZGF0YS5kdXJhdGlvbilcbiAgICAgIH1cbiAgICB9KVxuICAgIG5vdGlmaWVyLm9uKFN1YnNjcmliZXJFdmVudFR5cGVzLlZPTFVNRV9DSEFOR0UsIChldmVudCkgPT4ge1xuICAgICAgY29udHJvbHMuc2V0Vm9sdW1lKGV2ZW50LmRhdGEudm9sdW1lKVxuICAgIH0pXG4gICAgbm90aWZpZXIub24oU3Vic2NyaWJlckV2ZW50VHlwZXMuUExBWUJBQ0tfU1RBVEVfQ0hBTkdFLCAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kYXRhLmNvZGUgPT09IFBsYXliYWNrU3RhdGUuQVZBSUxBQkxFKSB7XG4gICAgICAgIGNvbnRyb2xzLmVuYWJsZSh0cnVlKVxuICAgICAgfVxuICAgICAgY29udHJvbHMuc2V0U3RhdGUoZXZlbnQuZGF0YS5jb2RlKVxuICAgIH0pXG4gICAgbm90aWZpZXIub24oU3Vic2NyaWJlckV2ZW50VHlwZXMuUExBWUJBQ0tfVElNRV9VUERBVEUsIChldmVudCkgPT4ge1xuICAgICAgY29udHJvbHMuc2V0U2Vla1RpbWUoZXZlbnQuZGF0YS50aW1lLCBldmVudC5kYXRhLmR1cmF0aW9uKVxuICAgIH0pXG4gICAgbm90aWZpZXIub24oU3Vic2NyaWJlckV2ZW50VHlwZXMuRlVMTF9TQ1JFRU5fU1RBVEVfQ0hBTkdFLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnRyb2xzLm9uRnVsbFNjcmVlbkNoYW5nZShldmVudC5kYXRhKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgY2hhbmdlIGluIGZ1bGxzY3JlZW4gc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNGdWxsU2NyZWVuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaGFuZGxlRnVsbFNjcmVlbkNoYW5nZSAoaXNGdWxsU2NyZWVuKSB7XG4gICAgY29uc3Qgc3dmb2JqZWN0ID0gdGhpcy5nZXRFbWJlZGRlZFZpZXcoKVxuICAgIGlmIChpc0Z1bGxTY3JlZW4pIHtcbiAgICAgIHRoaXMuaG9sZGVyLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtY29udGFpbmVyLWZ1bGwtc2NyZWVuJylcbiAgICAgIHN3Zm9iamVjdC5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLWNvbnRhaW5lci1mdWxsLXNjcmVlbicpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LnJlbW92ZSgncmVkNXByby1tZWRpYS1jb250YWluZXItZnVsbC1zY3JlZW4nKVxuICAgICAgc3dmb2JqZWN0LmNsYXNzTGlzdC5yZW1vdmUoJ3JlZDVwcm8tbWVkaWEtY29udGFpbmVyLWZ1bGwtc2NyZWVuJylcbiAgICB9XG4gICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5GVUxMX1NDUkVFTl9TVEFURV9DSEFOR0UsIHVuZGVmaW5lZCwgaXNGdWxsU2NyZWVuKSlcbiB9XG5cbiAgLyoqXG4gICAqIEVzdGFibGlzaGVzIGV2ZW50IGhhbmRsZXIgZm9yIHJlY29nbml6aW5nIGNvbXBsZXRlIG9uIGVtYmVkIGFuZCBpbml0aWFsaXphdGlvbiBvZiBGbGFzaC1iYXNlZCBzdWJzY3JpYmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1Byb21pc2V9IHByb21pc2VcbiAgICogICAgICAgIFRoZSB0YXJnZXQgYFByb21pc2VgIG9iamVjdCB0byByZXNvbHZlIG9yIHJlamVjdCB1cG9uIGNvbXBsZXRpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0VXBJbml0Q2FsbGJhY2sgKHByb21pc2UpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIGVudmlyb25tZW50LmFkZFN1YnNjcmlwdGlvbkFzc2lnbm1lbnRIYW5kbGVyKHN1Y2Nlc3NJZCA9PiB7XG4gICAgICBkZWJ1ZyhOQU1FLCBgRW1iZWQgYW5kIGluaXQoKSBjb21wbGV0ZSBmb3Igc3Vic2NyaWJlciBzd2YuIHN1Y2Nlc3NJZCgke3N1Y2Nlc3NJZH0pLmApXG4gICAgICBwcm9taXNlLnJlc29sdmUoc3VjY2Vzc0lkKVxuICAgICAgc2VsZi5fdGVhckRvd25Jbml0Q2FsbGJhY2soKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVGVhcnMgZG93biBlc3RhYmxpc2hlZCBoYW5kbGVyIGZvciBjb21wbGV0aW9uIG9mIEZsYXNoIGVtYmVkIGFuZCBpbml0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RlYXJEb3duSW5pdENhbGxiYWNrICgpIHt9XG5cbiAvKipcbiAgICogUmVxdWVzdCB0byBzZXR1cCB0aGUgcHJlc2VudGF0aW9uIG9mIGEgcGxheWJhY2sgc3RyZWFtIHVzaW5nIEhMUy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICAgKiAgICAgICAgVGhlIGVuZHBvaW50IFVSTCBmb3IgcGxheWJhY2suXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgaW5pdGlhbGl6YXRpb24gY29uZmlndXJhdGlvbiBtYXAuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzd2ZVcmxcbiAgICogICAgICAgIFRoZSBlbmRwb2ludCB1cmwgdG8gdGhlIFNXRiB0byBlbWJlZC4gRGVmYXVsdHMgdG8gcmVsYXRpdmUgbGluayB0byByZWQ1cHJvLXN1YnNjcmliZXIuc3dmIG9mIHRoZSBTREsgZGlzdHJpYnV0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWluRmxhc2hWZXJzaW9uXG4gICAqICAgICAgICBUaGUgbWluaW11bSBGbGFzaCB2ZXJzaW9uIGZvciBzdXBwb3J0IG9mIHBsYXliYWNrLiBEZWZhdWx0OiBgMTAuMC4wYC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhZGRTb3VyY2UgKHN3ZklkLCBvcHRpb25zLCBzd2ZVcmwgPSBudWxsLCBtaW5GbGFzaFZlcnNpb24gPSBudWxsKSB7XG4gICAgZGVidWcoTkFNRSwgJ1thZGRzb3VyY2VdJylcbiAgICB0aGlzLl9zd2ZJZCA9IHN3ZklkO1xuICAgIHRoaXMuaG9sZGVyID0gdGhpcy5fZGV0ZXJtaW5lSG9sZGVyKHRoaXMubWVkaWEpXG4gICAgY29uc3Qgc29SZXNwb25kZXIgPSB0aGlzLl9zb1Jlc3BvbmRlclxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgY29uc3QgaGFzRGVmaW5lZENvbnRyb2xzID0gb3B0aW9ucy5jb250cm9sc1xuICAgIGNvbnN0IGlzTXV0ZWQgPSBlbnZpcm9ubWVudC5oYXNBdHRyaWJ1dGVEZWZpbmVkKHRoaXMubWVkaWEsICdtdXRlZCcpXG4gICAgY29uc3QgdXNlUGxheWJhY2tDb250cm9scyA9IGVudmlyb25tZW50Lmhhc0F0dHJpYnV0ZURlZmluZWQodGhpcy5tZWRpYSwgJ2NvbnRyb2xzJykgJiYgZW52aXJvbm1lbnQuaGFzQ2xhc3NEZWZpbmVkKHRoaXMubWVkaWEsICdyZWQ1cHJvLW1lZGlhJylcbiAgICBvcHRpb25zLnN3ZiA9IHN3ZlVybCB8fCBvcHRpb25zLnN3ZlxuICAgIG9wdGlvbnMubWluRmxhc2hWZXJzaW9uID0gbWluRmxhc2hWZXJzaW9uIHx8IG9wdGlvbnMubWluRmxhc2hWZXJzaW9uXG4gICAgdGhpcy5fc2V0VXBJbml0Q2FsbGJhY2soZGVmZXJyZWQpXG4gICAgY29uc3QgY2xhc3NMaXN0ID0gdGhpcy5tZWRpYS5jbGFzc0xpc3RcbiAgICBlbWJlZC5kZWZpbmVFbWJlZEVsZW1lbnQodGhpcy5tZWRpYSwgdGhpcy5ob2xkZXIpXG4gICAgICAudGhlbihlbGVtZW50SWQgPT4ge1xuICAgICAgICBsZXQgZmxhc2h2YXJzID0ge1xuICAgICAgICAgIHN0cmVhbTogb3B0aW9ucy5zdHJlYW1OYW1lLFxuICAgICAgICAgIGFwcDogb3B0aW9ucy5jb250ZXh0ID8gYCR7b3B0aW9ucy5hcHB9LyR7b3B0aW9ucy5jb250ZXh0fWAgOiBvcHRpb25zLmFwcCxcbiAgICAgICAgICBob3N0OiBvcHRpb25zLmhvc3QsXG4gICAgICAgICAgbXV0ZWQ6IGVudmlyb25tZW50Lmhhc0F0dHJpYnV0ZURlZmluZWQodGhpcy5tZWRpYSwgJ211dGVkJyksXG4gICAgICAgICAgYXV0b3BsYXk6IGVudmlyb25tZW50Lmhhc0F0dHJpYnV0ZURlZmluZWQodGhpcy5tZWRpYSwgJ2F1dG9wbGF5JyksXG4gICAgICAgICAgdXNlQWRhcHRpdmVCaXRyYXRlQ29udHJvbGxlcjogb3B0aW9ucy51c2VBZGFwdGl2ZUJpdHJhdGVDb250cm9sbGVyXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgICAgZmxhc2h2YXJzLmJhY2tncm91bmRDb2xvciA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYnVmZmVyICYmICFpc05hTihOdW1iZXIob3B0aW9ucy5idWZmZXIpKSkge1xuICAgICAgICAgIGZsYXNodmFycy5idWZmZXIgPSBvcHRpb25zLmJ1ZmZlclxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLndpZHRoICYmICFpc05hTihvcHRpb25zLndpZHRoKSkge1xuICAgICAgICAgIGZsYXNodmFycy53aWR0aCA9IHRvSW50KG9wdGlvbnMud2lkdGgpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaGVpZ2h0ICYmICFpc05hTihvcHRpb25zLmhlaWdodCkpIHtcbiAgICAgICAgICBmbGFzaHZhcnMuaGVpZ2h0ID0gdG9JbnQob3B0aW9ucy5oZWlnaHQpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW1iZWRXaWR0aCA9PT0gJzEwMCUnIHx8IG9wdGlvbnMuZW1iZWRIZWlnaHQgPT09ICcxMDAlJykge1xuICAgICAgICAgIGZsYXNodmFycy5hdXRvc2l6ZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zd2ZJZCA9IHN3ZklkO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29ubmVjdGlvblBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBmbGFzaHZhcnMuY29ubmVjdGlvblBhcmFtcyA9IGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShvcHRpb25zLmNvbm5lY3Rpb25QYXJhbXMpKVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hYnJWYXJpYW50cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBmbGFzaHZhcnMuYWJyVmFyaWFudHMgPSBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5hYnJWYXJpYW50cykpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmFiclZhcmlhbnRVcGdyYWRlU2V0dGluZ3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZmxhc2h2YXJzLmFiclZhcmlhbnRVcGdyYWRlU2V0dGluZ3MgPSBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5hYnJWYXJpYW50VXBncmFkZVNldHRpbmdzKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW1iZWQuZW1iZWRTd2ZPYmplY3Qoc3dmSWQsIG9wdGlvbnMsIGZsYXNodmFycywgZW52aXJvbm1lbnQuZ2V0U3dmT2JqZWN0KCksIGVsZW1lbnRJZClcbiAgICAgIH0pXG4gICAgICAudGhlbiggKCkgPT4ge1xuICAgICAgICBpZiAoaGFzRGVmaW5lZENvbnRyb2xzIHx8IHVzZVBsYXliYWNrQ29udHJvbHMpIHtcbiAgICAgICAgICBpZiAoaGFzRGVmaW5lZENvbnRyb2xzKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250cm9scyA9IG9wdGlvbnMuY29udHJvbHNcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jb250cm9scyA9IG5ldyBQbGF5YmFja0NvbnRyb2xzSW1wbCh0aGlzLCB0aGlzLmhvbGRlcilcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5tZWRpYS5jb250cm9scyA9IGZhbHNlXG4gICAgICAgICAgdGhpcy5fY29udHJvbHMuc2V0QXNWT0QoaXNWT0RTdHJlYW1OYW1lKG9wdGlvbnMuc3RyZWFtTmFtZSkpXG4gICAgICAgICAgdGhpcy5fY29udHJvbHMuc2V0TXV0ZWRTdGF0ZShpc011dGVkKVxuICAgICAgICAgIGNvbnN0IGVtYmVkZGVkID0gdGhpcy5nZXRFbWJlZGRlZFZpZXcoKVxuICAgICAgICAgIGxldCBpbmRleCA9IGNsYXNzTGlzdC5sZW5ndGgsIGNsYXp6XG4gICAgICAgICAgd2hpbGUgKC0taW5kZXggPiAtMSkge1xuICAgICAgICAgICAgY2xhenogPSBjbGFzc0xpc3QuaXRlbShpbmRleClcbiAgICAgICAgICAgIGVtYmVkZGVkLmNsYXNzTGlzdC5hZGQoY2xhenopXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FkZFBsYXliYWNrSGFuZGxlcnModGhpcy5fcGxheWJhY2tOb3RpZmljYXRpb25DZW50ZXIpXG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlBMQVlCQUNLX1NUQVRFX0NIQU5HRSwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgY29kZTogUGxheWJhY2tTdGF0ZS5BVkFJTEFCTEUsXG4gICAgICAgICAgc3RhdGU6IFBsYXliYWNrU3RhdGVSZWFkYWJsZVtQbGF5YmFja1N0YXRlLkFWQUlMQUJMRV1cbiAgICAgICAgfSkpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgICAgLnRoZW4oICgpID0+IHtcbiAgICAgICAgc29SZXNwb25kZXIuY29ubmVjdChzd2ZJZClcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZSA9PiBkZWZlcnJlZC5yZWplY3QoZSkpXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGNvbm5lY3QgdG8gc3RyZWFtLlxuICAgKi9cbiAgY29ubmVjdCAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tjb25uZWN0XScpXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZ2V0RW1iZWRkZWRWaWV3KCkuY29ubmVjdCgpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cbiAgcGxheSAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZ2V0RW1iZWRkZWRWaWV3KCkucGxheSgpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cblxuICBwYXVzZSAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZ2V0RW1iZWRkZWRWaWV3KCkucGF1c2UoKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfVxuXG4gIHJlc3VtZSAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZ2V0RW1iZWRkZWRWaWV3KCkucmVzdW1lKClcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH1cblxuICBzdG9wICgpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5nZXRFbWJlZGRlZFZpZXcoKS5zdG9wKClcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH1cblxuICBtdXRlICgpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5nZXRFbWJlZGRlZFZpZXcoKS5tdXRlKClcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH1cblxuICB1bm11dGUgKCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmdldEVtYmVkZGVkVmlldygpLnVubXV0ZSgpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cbiAgc2V0Vm9sdW1lICh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmdldEVtYmVkZGVkVmlldygpLnNldFZvbHVtZSh2YWx1ZSlcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH1cblxuICBzZWVrVG8gKHZhbHVlLCBkdXJhdGlvbiA9IHVuZGVmaW5lZCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmdldEVtYmVkZGVkVmlldygpLnNlZWtUbyh2YWx1ZSwgZHVyYXRpb24pXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cbiAgdG9nZ2xlRnVsbFNjcmVlbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGVudmlyb25tZW50LnRvZ2dsZUZ1bGxTY3JlZW4odGhpcy5ob2xkZXIpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RpZmljYXRpb24gb2YgY3VycmVudCBzdHJlYW0gYmVpbmcgaW4gYW4gdW5wdWJsaXNoZWQgc3RhdGUuXG4gICAqIFRoZSBzdHJlYW0gZW50ZXJzIGFuIHVucHVibGlzaGVkIHN0YXRlIHdoZW4gdGhlIGJyb2FkY2FzdGVyIHN0b3AgdGhlIHN0cmVhbSBhbmQgdGhlIHN1YnNjcmliZXIgaXMgc3RpbGwgY29ubmVjdGVkLlxuICAgKi9cbiAgdW5wdWJsaXNoICgpIHtcbiAgICB0aGlzLnN0b3AoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gZGlzY29ubmVjdCBmcm9tIHRoZSBwbGF5YmFjayBzdHJlYW0uXG4gICAqL1xuICBkaXNjb25uZWN0ICgpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5nZXRFbWJlZGRlZFZpZXcoKS5kaXNjb25uZWN0KClcbiAgICAgIGRlYnVnKE5BTUUsICdbZGlzY29ubmVjdF0nKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIG5hZGEuXG4gICAgfVxuICAgIHRoaXMuX2NsZWFuVXAoKVxuICAgIHRoaXMuX3NvUmVzcG9uZGVyLmRpc2Nvbm5lY3QoKVxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbiByZXNwb25zZSBoYW5kbGVyIGZvciBTaGFyZWRPYmplY3QgY29tbXVuaWNhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFkZFNoYXJlZE9iamVjdFJlc3BvbnNlSGFuZGxlciAoaGFuZGxlcikge1xuICAgIHRoaXMuX3NvUmVzcG9uZGVyLmFkZFJlc3BvbnNlSGFuZGxlcihoYW5kbGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSByZXNwb25zZSBoYW5kbGVyIGZyb20gU2hhcmVkT2JqZWN0IGNvbW11bmljYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZW1vdmVTaGFyZWRPYmplY3RSZXNwb25zZUhhbmRsZXIgKGhhbmRsZXIpIHtcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5yZW1vdmVSZXNwb25zZUhhbmRsZXIoaGFuZGxlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIG1lc3NhZ2Ugb24gU2hhcmVkT2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiAgICAgICAgVGhlIG5hbWUgb2YgdGhlIFNoYXJlZE9iamVjdC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGNhbGxOYW1lXG4gICAqICAgICAgICBUaGUgbWV0aG9kIG5hbWUgdG8gaW52b2tlIG9uIHRoZSBTaGFyZWRPYmplY3QuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqICAgICAgICBUaGUgbWVzc2FnZSB0byBzZW5kIGFsb25nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2VuZFRvU2hhcmVkT2JqZWN0IChuYW1lLCBjYWxsTmFtZSwgbWVzc2FnZSkge1xuICAgIHRoaXMuX3NvUmVzcG9uZGVyLnNlbmRUb1NoYXJlZE9iamVjdChuYW1lLCBjYWxsTmFtZSwgbWVzc2FnZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIHByb3BlcnR5IHVwZGF0ZSB0byBTaGFyZWRPYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgU2hhcmVkT2JqZWN0LlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqICAgICAgICBUaGUgcHJvcGVydHkgbmFtZSB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgVGhlIHByb3BlcnR5IHZhbHVlIHRvIHNldC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlbmRQcm9wZXJ0eVRvU2hhcmVkT2JqZWN0IChuYW1lLCBrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5fc29SZXNwb25kZXIuc2VuZFByb3BlcnR5VG9TaGFyZWRPYmplY3QobmFtZSwga2V5LCB2YWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGdldCB0aGUgcmVtb3RlIFNoYXJlZE9iamVjdCBvbiB0aGUgc2VydmVyIGJ5IG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaGFyZWRPYmplY3ROYW1lXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRSZW1vdGVTaGFyZWRPYmplY3QgKHNoYXJlZE9iamVjdE5hbWUpIHtcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5nZXRSZW1vdGVTaGFyZWRPYmplY3Qoc2hhcmVkT2JqZWN0TmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGNvbm5lY3QgdG8gU2hhcmVkT2JqZWN0IGJ5IG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaGFyZWRPYmplY3ROYW1lXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25uZWN0VG9TaGFyZWRPYmplY3QgKHNoYXJlZE9iamVjdE5hbWUpIHtcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5jb25uZWN0VG9TaGFyZWRPYmplY3Qoc2hhcmVkT2JqZWN0TmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGNsb3NlIHRoZSBTaGFyZWRPYmplY3QgYnkgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNoYXJlZE9iamVjdE5hbWVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNsb3NlU2hhcmVkT2JqZWN0IChzaGFyZWRPYmplY3ROYW1lKSB7XG4gICAgdGhpcy5fc29SZXNwb25kZXIuY2xvc2VTaGFyZWRPYmplY3Qoc2hhcmVkT2JqZWN0TmFtZSlcbiAgfVxuXG4gIC8qXG4gICAqIFJlcXVlc3QgdG8gc3RhcnQgdGhlIEFkYXB0aXZlIEJpdHJhdGUgQ29udHJvbGxlciB0byBhdXRvbWF0aWNhbGx5IGRvd25ncmFkZSBhbmQgdXBncmFkZSBzdHJlYW1zIGJhc2VkIG9uIE5ldFN0YXR1cyBhbmQgYmFuZHdpZHRoLlxuICAgKiBUaGUgQUJSIGlzIHN0YXJ0ZWQgYXV0b21hdGljYWxseSB3aGVuIHByb3ZpZGluZyB0aGUgYHVzZUFkYXB0aXZlQml0cmF0ZUNvbnRyb2xsZXJgIGNvbmZpZ3VyYXRpb24gcHJvcGVydHkuXG4gICAqXG4gICAqIE5PVEU6IEFkYXB0aXZlIEJpdHJhdGUgQ29udHJvbGxlciBBUEkgaXMgb25seSBhdmFpbGFibGUgd2hlbiB1c2luZyBBdXRvc2NhbGUtRW5hYmxlZCBSZWQ1IFBybyBTZXJ2ZXIuXG4gICAqL1xuICBzdGFydEFCUkNvbnRyb2xsZXIgKCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmdldEVtYmVkZGVkVmlldygpLnN0YXJ0QUJSQ29udHJvbGxlcigpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoTkFNRSwgYENvdWxkIG5vdCBzdGFydCB0aGUgQWRhcHRpdmUgQml0cmF0ZSBDb250cm9sbGVyOiAke2UubWVzc2FnZX1gKVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAqIFJlcXVlc3QgdG8gc3RvcCB0aGUgQWRhcHRpdmUgQml0cmF0ZSBDb250cm9sbGVyIGZyb20gYXV0b21hdGljYWxseSBkb3duZ3JhZGluZyBhbmQgdXBncmFkaW5nIHN0cmVhbXMgYmFzZWQgb24gTmV0U3RhdHVzIGFuZCBiYW5kd2lkdGguXG4gICAqXG4gICAqIE5PVEU6IEFkYXB0aXZlIEJpdHJhdGUgQ29udHJvbGxlciBBUEkgaXMgb25seSBhdmFpbGFibGUgd2hlbiB1c2luZyBBdXRvc2NhbGUtRW5hYmxlZCBSZWQ1IFBybyBTZXJ2ZXIuXG4gICAqL1xuICBzdG9wQUJSQ29udHJvbGxlciAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZ2V0RW1iZWRkZWRWaWV3KCkuc3RvcEFCUkNvbnRyb2xsZXIoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKE5BTUUsIGBDb3VsZCBub3Qgc3RvcCB0aGUgQWRhcHRpdmUgQml0cmF0ZSBDb250cm9sbGVyOiAke2UubWVzc2FnZX1gKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIHVzZSB0aGUgcHJvdmlkZSBBQlIgVmFyaWFudHMgd2hlbiBwZXJmb3JtaW5nIEFkYXB0aXZlIEJpdHJhdGUgQ29udHJvbC5cbiAgICogUmVxdWlyZXMgdGhlIGB1c2VBZGFwdGl2ZUJpdHJhdGVDb250cm9sbGVyYCBpbnRpdGlhbGl6YXRpb24gY29uZmlndXJhdGlvbiBwcm9wZXJ0eSB0byBiZSBgdHJ1ZWAuXG4gICAqIE5PVEU6IEFkYXB0aXZlIEJpdHJhdGUgQ29udHJvbGxlciBBUEkgaXMgb25seSBhdmFpbGFibGUgd2hlbiB1c2luZyBBdXRvc2NhbGUtRW5hYmxlZCBSZWQ1IFBybyBTZXJ2ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhYnJTZXR0aW5nc1xuICAgKiAgICAgICAgVE9ETzogUHJvdmlkZSBBQlIgVmFyaWFudCBvYmplY3Qgc2NoZW1hIGV4cGVjdGVkLlxuICAgKiBAcGFyYW0ge2ludH0gbGV2ZWxcbiAgICogICAgICAgIFRoZSBsZXZlbCB0byBzdGFydCBvdXQgb24gZm9yIEFCUi5cbiAgICovXG4gIHNldEFCUlZhcmlhbnRzIChhYnJWYXJpYW50cywgbGV2ZWwpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0eXBlb2YgYWJyVmFyaWFudHMgPT09ICdzdHJpbmcnID8gZW5jb2RlVVJJQ29tcG9uZW50KGFiclZhcmlhbnRzKSA6IGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShhYnJWYXJpYW50cykpXG4gICAgICB0aGlzLmdldEVtYmVkZGVkVmlldygpLnNldEFCUlZhcmlhbnRzKHZhbHVlLCBsZXZlbCB8fCAxKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKE5BTUUsIGBDb3VsZCBub3Qgc2V0IEFCUiBWYXJpYW50czogJHtlLm1lc3NhZ2V9YClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBzZXQgQUJSIGxldmVsIGV4cGxpY2l0bHkuIFRoZSBTREsgYXR0ZW1wdHMgdG8gcHJvcGVybHkgY2hvb3NlIHRoZSBjb3JyZWN0IGxldmVsIGJhc2VkIG9uIGJhbmR3aWR0aCwgYnV0IHRoaXMgQVBJIGFsbG93cyBmb3IgdGhlIGxldmVsIHRvIGJlIHNldCBleHBsaWNpdGx5LlxuICAgKlxuICAgKiBOT1RFOiBBZGFwdGl2ZSBCaXRyYXRlIENvbnRyb2xsZXIgQVBJIGlzIG9ubHkgYXZhaWxhYmxlIHdoZW4gdXNpbmcgQXV0b3NjYWxlLUVuYWJsZWQgUmVkNSBQcm8gU2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge2ludH0gbGV2ZWxcbiAgICogICAgICAgIFRoZSBsZXZlbCB0byBzZXQgdGhlIEFCUiBiYXNlZCBvbiB0aGUgdmFyaWFudHMgcHJvdmlkZWQgaW4gYHNldEFCUlZhcmlhbnRzYC5cbiAgICogQHBhcmFtIHtib29sZWFufSBmaXJtXG4gICAqICAgICAgICBGbGFnIHRvIHNldCBsZXZlbCBmaXJtbHksIGRpc2FibGluZyB0aGUgYXV0b21hdGljIHN3aXRjaGluZyBvZiB0aGUgQWRhcHRpdmUgQml0cmF0ZSBDb250cm9sbGVyLlxuICAgKi9cbiAgc2V0QUJSTGV2ZWwgKGxldmVsLCBmaXJtKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZ2V0RW1iZWRkZWRWaWV3KCkuc2V0QUJSTGV2ZWwobGV2ZWwsICEhZmlybSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZyhOQU1FLCBgQ291bGQgbm90IHNldCBBQlIgbGV2ZWw6ICR7ZS5tZXNzYWdlfWApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIHRoZSB1cGdyYWRlIHNldHRpbmdzIHRvIHVzZSBieSB0aGUgQWRhcHRpdmUgQml0cmF0ZSBDb250cm9sIGluIHVwZ3JhZGluZyBwcmV2aW91c2x5IGRvd25ncmFkZWQgc3RyZWFtcy5cbiAgICpcbiAgICogTk9URTogQWRhcHRpdmUgQml0cmF0ZSBDb250cm9sbGVyIEFQSSBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIHVzaW5nIEF1dG9zY2FsZS1FbmFibGVkIFJlZDUgUHJvIFNlcnZlci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFiclZhcmlhbnRVcGdyYWRlc1xuICAgKiAgICAgICAgQSBjb25maWd1cmF0aW9uIG9iamVjdCB0aGF0IGRlZmluZXMgdGhlIGFzc29jaWF0ZWQgcmV0cnkgbGltaXRzIGJhc2VkIG9uIGxldmVscyBvZiB0aGUgUHJvdmlzaW9uIFZhcmlhbnRzLlxuICAgKiBAZXhhbXBsZVxuICAgKiB7XG4gICAqICBtaW5pbXVtRG93bmdyYWRlUGxheWJhY2tTcGFuOiAyMDAwLFxuICAgKiAgdXBncmFkZTogW1xuICAgKiAgICB7XG4gICAqICAgICAgbGV2ZWw6IDEsXG4gICAqICAgICAgcmV0cnlUaW1lb3V0OiAwXG4gICAqICAgIH0sXG4gICAqICAgIHtcbiAgICogICAgICBsZXZlbDogMixcbiAgICogICAgICByZXRyeVRpbWVvdXQ6IDIwMDBcbiAgICogICAgfSxcbiAgICogICAge1xuICAgKiAgICAgIGxldmVsOiAzLFxuICAgKiAgICAgIHJldHJ5VGltZW91dDogNDAwMFxuICAgKiAgICB9XG4gICAqICBdXG4gICAqIH1cbiAgICovXG4gIHNldEFCUlZhcmlhbnRVcGdyYWRlU2V0dGluZ3MgKGFiclZhcmlhbnRVcGdyYWRlcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiBhYnJWYXJpYW50cyA9PT0gJ3N0cmluZycgPyBlbmNvZGVVUklDb21wb25lbnQoYWJyVmFyaWFudFVwZ3JhZGVzKSA6IGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShhYnJWYXJpYW50VXBncmFkZXMpKVxuICAgICAgdGhpcy5nZXRFbWJlZGRlZFZpZXcoKS5zZXRBQlJWYXJpYW50VXBncmFkZVNldHRpbmdzKHZhbHVlKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKE5BTUUsIGBDb3VsZCBub3Qgc2V0IEFCUiBWYXJpYW50czogJHtlLm1lc3NhZ2V9YClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZW1iZWRkZWQgRmxhc2ggb2JqZWN0IGlmIGF2YWlsYWJsZS5cbiAgICpcbiAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAqL1xuICBnZXRFbWJlZGRlZFZpZXcgKCkge1xuICAgIHJldHVybiBlbnZpcm9ubWVudC5nZXRFbWJlZE9iamVjdCh0aGlzLl9zd2ZJZClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHBsYXliYWNrIGNvbnRyb2xzIGlmIGF2YWlsYWJsZS5cbiAgICpcbiAgICogQHJldHVybnMge1BsYXliYWNrQ29udHJvbHN9XG4gICAqL1xuICBnZXRDb250cm9scyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRyb2xzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3Vic2NyaWJlciB0eXBlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbnRyb2xsZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXJUeXBlXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBSVE1QU291cmNlSGFuZGxlclxuIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCBSVE1QU291cmNlSGFuZGxlciBmcm9tICcuL3JlZDVwcm8tc291cmNlLWhhbmRsZXItcnRtcCdcbmltcG9ydCBQbGF5YmFja1ZpZXcgZnJvbSAnLi4vdmlldy9wbGF5YmFjaydcbmltcG9ydCB7IFBsYXliYWNrQ29udHJvbGxlciB9IGZyb20gJy4vY29udHJvbHMnXG5pbXBvcnQgeyBTdWJzY3JpYmVyRXZlbnQgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCB7IFBsYXliYWNrVHlwZXMgfSBmcm9tICcuLi9lbnVtL3BsYXliYWNrJ1xuaW1wb3J0IHtcbiAgU3Vic2NyaWJlckV2ZW50VHlwZXMsXG4gIFJUTVBTdWJzY3JpYmVyRXZlbnRUeXBlc1xufSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCB7IFBsYXliYWNrU3RhdGVSZWFkYWJsZSB9IGZyb20gJy4vY29udHJvbHMvc3RhdGUnXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UsIEZ1dHVyZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IGRlYnVnLCB3YXJuLCBlcnJvciB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSVE1QU3ViY3JpYmVyJ1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgcHJvdG9jb2w6ICdydG1wJyxcbiAgcG9ydDogMTkzNSxcbiAgd2lkdGg6IDMyMCwgLy8gbWVkaWEgcGxheWJhY2tcbiAgaGVpZ2h0OiAyNDAsIC8vIG1lZGlhIHBsYXliYWNrXG4gIGVtYmVkV2lkdGg6ICcxMDAlJywgLy8gRE9NIGRpc3BsYXkgc3R5bGVcbiAgZW1iZWRIZWlnaHQ6ICcxMDAlJywgLy8gRE9NIGRpc3BsYXkgc3R5bGVcbiAgbWluRmxhc2hWZXJzaW9uOiAnMTAuMC4wJyxcbiAgc3dmOiAnbGliL3JlZDVwcm8vcmVkNXByby1zdWJzY3JpYmVyLnN3ZicsXG4gIHN3Zm9iamVjdFVSTDogJ2xpYi9zd2ZvYmplY3Qvc3dmb2JqZWN0LmpzJyxcbiAgcHJvZHVjdEluc3RhbGxVUkw6ICdsaWIvc3dmb2JqZWN0L3BsYXllclByb2R1Y3RJbnN0YWxsLnN3ZicsXG4gIG1lZGlhRWxlbWVudElkOiAncmVkNXByby1zdWJzY3JpYmVyJyxcbiAgLy8gd2l0aCBBdXRvc2NhbGUgZW5hYmxlZCBzZXJ2ZXIgb25seSA9PlxuICB1c2VBZGFwdGl2ZUJpdHJhdGVDb250cm9sbGVyOiBmYWxzZSxcbiAgYWJyVmFyaWFudHM6IHVuZGVmaW5lZCxcbiAgYWJyVmFyaWFudFVwZ3JhZGVTZXR0aW5nczoge1xuICAgIG1pbmltdW1Eb3duZ3JhZGVQbGF5YmFja1NwYW46IDEwMDAwLCAvLyBBbW91bnQgb2YgdGltZSBwbGF5YmFjayBuZWVkcyB0byBleGNlZWQgYmV0d2VlbiBwbGF5YmFjayBhbmQgZG93bmdyYWRlIGluIG9yZGVyIHRvIGJlIGVsaWdpYmxlIGZvciB1cGdyYWRlXG4gICAgdXBncmFkZTogW1xuICAgICAge1xuICAgICAgICBsZXZlbDogMSxcbiAgICAgICAgcmV0cnlUaW1lb3V0OiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBsZXZlbDogMixcbiAgICAgICAgcmV0cnlUaW1lb3V0OiAxMDAwMCAvLyBJZiBvbiBsZXZlbCAyLCBpbiAxMCBzZWNvbmRzIGFmdGVyIHBsYXliYWNrLCB0cnkgYW5kIHN3aXRjaCB1cC5cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGxldmVsOiAzLFxuICAgICAgICByZXRyeVRpbWVvdXQ6IDIwMDAwIC8vIElmIG9uIGxldmVsIDMsIGluIDIwIHNlY29uZHMgYWZ0ZXIgcGxheWJhY2ssIHRyeSBhbmQgc3dpdGNoIHVwLlxuICAgICAgfVxuICAgIF1cbiAgfVxufVxuXG4vKipcbiAqIE1haW4gZW50cnkgZm9yIEZsYXNoLWJhc2VkIFN1YnNjcmliZXIgb3ZlciBSVE1QLlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQGV4dGVuZHMgU3Vic2NyaWJlclBsYXliYWNrQ29udHJvbGxlclxuICovXG5jbGFzcyBSVE1QU3Vic2NyaWJlciBleHRlbmRzIFBsYXliYWNrQ29udHJvbGxlciB7XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9vcHRpb25zID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fdmlldyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9lbGVtZW50SWQgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9lbWJlZFByb21pc2UgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9nZXRFbWJlZFByb21pc2UoKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLm9uRW1iZWRDb21wbGV0ZSgpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB0aGlzLm9uRW1iZWRGYWlsdXJlKGVycikpXG4gICAgdGhpcy5fdmlld1Jlc29sdmVyID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uUmVzb2x2ZXIgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICB0aGlzLl9vcmllbnRhdGlvbiA9IDBcbiAgICB0aGlzLl9zdHJlYW1pbmdNb2RlID0gJ1ZpZGVvL0F1ZGlvJ1xuICB9XG5cbiAgX2dldFZpZXdSZXNvbHZlclByb21pc2UgKCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3UmVzb2x2ZXIucHJvbWlzZVxuICB9XG5cbiAgX2dldFN1YnNjcmlwdGlvblJlc29sdmVyUHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3Vic2NyaXB0aW9uUmVzb2x2ZXIucHJvbWlzZVxuICB9XG5cbiAgX2dldEVtYmVkUHJvbWlzZSAoKSB7XG4gICAgdGhpcy5fZW1iZWRQcm9taXNlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fZW1iZWRQcm9taXNlKVxuICAgIHJldHVybiB0aGlzLl9lbWJlZFByb21pc2UucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIEdsb21zIHRoZSBQbGF5YmFjayBDb250cm9scyBBUEkgb250byB0aGlzIGluc3RhbmNlIHRvIHByb3ZpZGUgZWFzZSBpbiB1c2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyXG4gICAqICAgICAgICBUaGUgbWV0aG9kIHJlcXVlc3QgaGFuZGxlciB0byBiaW5kIGFuZCBmb3J3YXJkIGNhbGxzIG9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dsb21Tb3VyY2VIYW5kbGVyQVBJIChoYW5kbGVyKSB7XG4gICAgLypcbiAgICAgKiB8fCBOb3RlIHx8XG4gICAgICogcGxheSgpIGlzIG5vdCBnbG9tbWVkIGFzIGl0IG5lZWRzIHRvIGJlIGhhbmRsZWQgZGlmZmVyZW50bHkuXG4gICAgICovXG5cbiAgICB0aGlzLnBhdXNlID0gaGFuZGxlci5wYXVzZS5iaW5kKGhhbmRsZXIpXG4gICAgdGhpcy5yZXN1bWUgPSBoYW5kbGVyLnJlc3VtZS5iaW5kKGhhbmRsZXIpXG4gICAgdGhpcy5zdG9wID0gaGFuZGxlci5zdG9wLmJpbmQoaGFuZGxlcilcbiAgICB0aGlzLm11dGUgPSBoYW5kbGVyLm11dGUuYmluZChoYW5kbGVyKVxuICAgIHRoaXMudW5tdXRlID0gaGFuZGxlci51bm11dGUuYmluZChoYW5kbGVyKVxuICAgIHRoaXMuc2V0Vm9sdW1lID0gaGFuZGxlci5zZXRWb2x1bWUuYmluZChoYW5kbGVyKVxuICAgIHRoaXMuc2Vla1RvID0gaGFuZGxlci5zZWVrVG8uYmluZChoYW5kbGVyKVxuICAgIHRoaXMudG9nZ2xlRnVsbFNjcmVlbiA9IGhhbmRsZXIudG9nZ2xlRnVsbFNjcmVlbi5iaW5kKGhhbmRsZXIpXG5cbiAgICAvLyBBZGFwdGl2ZSBCaXRyYXRlIENvbnRyb2xsZXIgLSBBdXRvc2NhbGUgZW5hYmxlZCBvbmx5LlxuICAgIHRoaXMuc2V0QUJSTGV2ZWwgPSBoYW5kbGVyLnNldEFCUkxldmVsLmJpbmQoaGFuZGxlcilcbiAgICB0aGlzLnNldEFCUlZhcmlhbnRzID0gaGFuZGxlci5zZXRBQlJWYXJpYW50cy5iaW5kKGhhbmRsZXIpXG4gICAgdGhpcy5zdG9wQUJSQ29udHJvbGxlciA9IGhhbmRsZXIuc3RvcEFCUkNvbnRyb2xsZXIuYmluZChoYW5kbGVyKVxuICAgIHRoaXMuc3RhcnRBQlJDb250cm9sbGVyID0gaGFuZGxlci5zdGFydEFCUkNvbnRyb2xsZXIuYmluZChoYW5kbGVyKVxuICAgIHRoaXMuc2V0QUJSVmFyaWFudFVwZ3JhZGVTZXR0aW5ncyA9IGhhbmRsZXIuc2V0QUJSVmFyaWFudFVwZ3JhZGVTZXR0aW5ncy5iaW5kKGhhbmRsZXIpXG5cbiAgICBoYW5kbGVyLm9uKCcqJywgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChldmVudC50eXBlLCB0aGlzLCBldmVudC5kYXRhKSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFN0aWxsIGluIHVzZSwgYnV0IGhvbGQtb3ZlciBvZiBwcmV2aW91cyAzLnggU0RLIHZlcnNpb25zIGRlc2lnbmVkIHRvIHBhaXIgdmlld3MgYW5kIHN1YnNjcmliZXJzLiBJbiA0LjAuMCBpdCBoYXMgYmVlbiBpbnRlcm5hbGl6ZWQuXG4gICAqIEFQSSBkZXByZWNhdGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldFZpZXdJZk5vdEV4aXN0IChjdXJyZW50VmlldywgbWVkaWFFbGVtZW50SWQgPSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgY3VycmVudFZpZXcgPT09ICd1bmRlZmluZWQnICYmIG1lZGlhRWxlbWVudElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHZpZXcgPSBuZXcgUGxheWJhY2tWaWV3KG1lZGlhRWxlbWVudElkKVxuICAgICAgICB2aWV3LmF0dGFjaFN1YnNjcmliZXIodGhpcylcbiAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgZ2xvYmFsIGZ1bmN0aW9uIGhhbmRsZXJzIGZvciBFeHRlcm5hbEludGVyZmFjZSB0byBpbnZva2UgZm9yIEFQSSBjb21tdW5pY2F0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2VzdGFibGlzaEV4dEludEhhbmRsZXJzIChpZCkge1xuICAgIGRlYnVnKE5BTUUsIGBTdWJzY3JpYmVyIElEIHByb3ZpZGVkIHRvIGNsaWVudDogKCR7aWR9KS5gKVxuICAgIGNvbnN0IGludm9rZUZuID0gKGxhYmVsKSA9PiB7XG4gICAgICByZXR1cm4gWydzdWJzY3JpYmVyJywgbGFiZWwsIGlkLnNwbGl0KCctJykuam9pbignXycpXS5qb2luKCdfJylcbiAgICB9XG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb0Nvbm5lY3RDbG9zZWQnKV0gPSAoKSA9PiB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5DT05ORUNUSU9OX0NMT1NFRCwgdGhpcykpXG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb0Nvbm5lY3RTdWNjZXNzJyldID0gKCkgPT4gdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQ09OTkVDVF9TVUNDRVNTLCB0aGlzKSlcbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvQ29ubmVjdEZhaWx1cmUnKV0gPSAoKSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5DT05ORUNUX0ZBSUxVUkUsIHRoaXMpKVxuICAgIH1cbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvU3Vic2NyaWJlU3RvcCcpXSA9ICgpID0+IHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9TVE9QLCB0aGlzKSlcbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvU3Vic2NyaWJlTWV0YWRhdGEnKV0gPSAobWV0YWRhdGEpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIHN0cmVhbWluZ01vZGVcbiAgICAgIH0gPSBKU09OLnBhcnNlKG1ldGFkYXRhKVxuICAgICAgY29uc3Qgb3JpZW50YXRpb25JbnQgPSBwYXJzZUludChvcmllbnRhdGlvbiwgMTApXG4gICAgICBjb25zdCBwcmV2aW91c1N0cmVhbWluZ01vZGUgPSB0aGlzLl9zdHJlYW1pbmdNb2RlXG4gICAgICBpZiAodGhpcy5fb3JpZW50YXRpb24gIT09IG9yaWVudGF0aW9uSW50KSB7XG4gICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gb3JpZW50YXRpb25JbnRcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuT1JJRU5UQVRJT05fQ0hBTkdFLCB0aGlzLCB7IG9yaWVudGF0aW9uOiBvcmllbnRhdGlvbkludCB9KSlcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2aW91c1N0cmVhbWluZ01vZGUgIT09IHN0cmVhbWluZ01vZGUpIHtcbiAgICAgICAgdGhpcy5fc3RyZWFtaW5nTW9kZSA9IHN0cmVhbWluZ01vZGVcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1RSRUFNSU5HX01PREVfQ0hBTkdFLCB0aGlzLCB7IFxuICAgICAgICAgIHN0cmVhbWluZ01vZGU6IHN0cmVhbWluZ01vZGUsXG4gICAgICAgICAgcHJldmlvdXNTdHJlYW1pbmdNb2RlOiBwcmV2aW91c1N0cmVhbWluZ01vZGVcbiAgICAgICAgfSkpXG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfTUVUQURBVEEsIHRoaXMsIEpTT04ucGFyc2UobWV0YWRhdGEpKSlcbiAgICB9XG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1N1YnNjcmliZVVucHVibGlzaCcpXSA9ICgpID0+IHtcbiAgICAgIHRoaXMub25VbnB1Ymxpc2goKVxuICAgIH1cbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvU3Vic2NyaWJlUHVibGlzaGVyQ29uZ2VzdGlvbicpXSA9IChkYXRhKSA9PiB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfUFVCTElTSEVSX0NPTkdFU1RJT04sIHRoaXMsIEpTT04ucGFyc2UoZGF0YSkpKVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9TdWJzY3JpYmVQdWJsaXNoZXJSZWNvdmVyeScpXSA9IChkYXRhKSA9PiB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfUFVCTElTSEVSX1JFQ09WRVJZLCB0aGlzLCBKU09OLnBhcnNlKGRhdGEpKSlcbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvU3Vic2NyaWJlU2VuZEludm9rZScpXSA9IChwYXlsb2FkKSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfU0VORF9JTlZPS0UsIHRoaXMsIHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UocGF5bG9hZCkgOiBwYXlsb2FkKSlcbiAgICB9XG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1N1YnNjcmliZVBsYXlSZXF1ZXN0JyldID0gKCkgPT4ge1xuICAgICAgdGhpcy5wbGF5KClcbiAgICB9XG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1N1YnNjcmliZVN0YXJ0JyldID0gKCkgPT4ge1xuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uUmVzb2x2ZXIucmVzb2x2ZSh0aGlzKVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX1NUQVJULCB0aGlzKSlcbiAgICB9XG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1N1YnNjcmliZUludmFsaWROYW1lJyldID0gKCkgPT4ge1xuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uUmVzb2x2ZXIucmVqZWN0KCdOZXRTdHJlYW0uUGxheS5TdHJlYW1Ob3RGb3VuZCcsIHRoaXMpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfSU5WQUxJRF9OQU1FLCB0aGlzKSlcbiAgICB9XG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1N1YnNjcmliZUZhaWwnKV0gPSAoKSA9PiB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25SZXNvbHZlci5yZWplY3QoJ05ldFN0cmVhbS5GYWlsZWQnLCB0aGlzKVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX0ZBSUwsIHRoaXMpKVxuICAgIH1cbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvU3Vic2NyaWJlVm9sdW1lQ2hhbmdlJyldID0gKHBheWxvYWQpID0+IHtcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlZPTFVNRV9DSEFOR0UsIHRoaXMsIHtcbiAgICAgICAgdm9sdW1lOiBKU09OLnBhcnNlKHBheWxvYWQpLnZvbHVtZVxuICAgICAgfSkpXG4gICAgfVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9TdWJzY3JpYmVQbGF5YmFja1N0YWxsZWQnKV0gPSAoKSA9PiB7XG4gICAgICBkZWJ1ZyhOQU1FLCAncGxheWJhY2sgaGFzIHN0YWxsZWQuLi4nKVxuICAgIH1cbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvU3Vic2NyaWJlUGxheWJhY2tUaW1lQ2hhbmdlJyldID0gKHBheWxvYWQpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHBheWxvYWQpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5QTEFZQkFDS19USU1FX1VQREFURSwgdGhpcywge1xuICAgICAgICB0aW1lOiBkYXRhLnZhbHVlLFxuICAgICAgICBkdXJhdGlvbjogZGF0YS5kdXJhdGlvblxuICAgICAgfSkpXG4gICAgfVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9TdWJzY3JpYmVQbGF5YmFja1N0YXRlQ2hhbmdlJyldID0gKHBheWxvYWQpID0+IHtcbiAgICAgIGNvbnN0IGNvZGUgPSBKU09OLnBhcnNlKHBheWxvYWQpLmNvZGVcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlBMQVlCQUNLX1NUQVRFX0NIQU5HRSwgdGhpcywge1xuICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICBzdGF0ZTogUGxheWJhY2tTdGF0ZVJlYWRhYmxlW2NvZGVdXG4gICAgICB9KSlcbiAgICB9XG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1N1YnNjcmliZUFCUkxldmVsQ2hhbmdlJyldID0gKHBheWxvYWQpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHBheWxvYWQpXG4gICAgICBjb25zdCB7IGxldmVsLCBzdHJlYW0gfSA9IGRhdGFcbiAgICAgIGNvbnN0IHNldHRpbmdzID0gSlNPTi5wYXJzZShkZWNvZGVVUklDb21wb25lbnQoc3RyZWFtKSlcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUTVBTdWJzY3JpYmVyRXZlbnRUeXBlcy5BQlJfTEVWRUxfQ0hBTkdFLCB0aGlzLCB7XG4gICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgc3RyZWFtOiBzZXR0aW5nc1xuICAgICAgfSkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gaW5pdGlhbGl6ZSB0aGUgSExTLWJhc2VkIFN1YnNjcmliZXIgYmFzZWQgb24gY29uZmlndXJhdGlvbi5cbiAgICogVGhlIHJldHVybmVkIGBQcm9taXNlYCB3aWxsIGVpdGhlciByZXNvbHZlIHdpdGggYSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZSBvciByZWplY3Qgd2l0aCBhbiBlcnJvciBgU3RyaW5nYCBpbiBmYWlsdXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgVGhlIGluaXRpYWxpemF0aW9uIGNvbmZpZ3VyYXRpb24gbWFwLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgaW5pdCAob3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgY29uc3QgdmVyc2lvbiA9IG9wdGlvbnMubWluRmxhc2hWZXJzaW9uIHx8IGRlZmF1bHRPcHRpb25zLm1pbkZsYXNoVmVyc2lvblxuICAgIGlmICghZW52aXJvbm1lbnQuc3VwcG9ydHNGbGFzaFZlcnNpb24odmVyc2lvbikpIHtcbiAgICAgIHdhcm4oTkFNRSwgYENvdWxkIG5vdCByZXNvbHZlIFJUTVBTdWJzY3JpYmVyIGluc3RhbmNlLiBSZXF1aXJlcyBtaW5pbXVtIEZsYXNoIFBsYXllciBpbnN0YWxsIG9mICR7dmVyc2lvbn0uYClcbiAgICAgIGRlZmVycmVkLnJlamVjdChgQ291bGQgbm90IHJlc29sdmUgUlRNUFN1YnNjcmliZXIgaW5zdGFuY2UuIFJlcXVpcmVzIG1pbmltdW0gRmxhc2ggUGxheWVyIGluc3RhbGwgb2YgJHt2ZXJzaW9ufS5gKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucylcbiAgICAgIGNvbnN0IGVzdGFibGlzaFNvdXJjZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgdGhpcy5fZ2V0Vmlld1Jlc29sdmVyUHJvbWlzZSgpXG4gICAgICAgIC50aGVuKHZpZXcgPT4ge1xuICAgICAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIgPSBuZXcgUlRNUFNvdXJjZUhhbmRsZXIodGhpcywgdmlldy52aWV3LCB0aGlzLmdldFR5cGUoKSlcbiAgICAgICAgICB0aGlzLl9nbG9tU291cmNlSGFuZGxlckFQSSh0aGlzLl9zb3VyY2VIYW5kbGVyKVxuICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBkZmQgPSB0aGlzLl9lbWJlZFByb21pc2VcbiAgICAgICAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIuYWRkU291cmNlKHRoaXMuX2VsZW1lbnRJZCwgdGhpcy5fb3B0aW9ucylcbiAgICAgICAgICAgICAgLnRoZW4oc3Vic2NyaWJlcklkID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lc3RhYmxpc2hFeHRJbnRIYW5kbGVycyhzdWJzY3JpYmVySWQpXG4gICAgICAgICAgICAgICAgZGZkLnJlc29sdmUodGhpcylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBkZmQucmVqZWN0KGVycikpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBlbnZpcm9ubWVudC5pbmplY3RTY3JpcHQodGhpcy5fb3B0aW9ucy5zd2ZvYmplY3RVUkwpXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW1iZWREZmQgPSB0aGlzLl9lbWJlZFByb21pc2VcbiAgICAgICAgICAgIGRlYnVnKE5BTUUsICdTV0ZPYmplY3QgZW1iZWRkZWQuJylcbiAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2VIYW5kbGVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIuYWRkU291cmNlKHRoaXMuX2VsZW1lbnRJZCwgdGhpcy5fb3B0aW9ucylcbiAgICAgICAgICAgICAgICAudGhlbihzdWJzY3JpYmVySWQgPT4ge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fZXN0YWJsaXNoRXh0SW50SGFuZGxlcnMoc3Vic2NyaWJlcklkKVxuICAgICAgICAgICAgICAgICAgZW1iZWREZmQucmVzb2x2ZSh0aGlzKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICBlbWJlZERmZC5yZWplY3QoZXJyKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRFbWJlZFByb21pc2UoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXN0YWJsaXNoU291cmNlSGFuZGxlcigpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc2V0Vmlld0lmTm90RXhpc3QodGhpcy5fdmlldywgdGhpcy5fb3B0aW9ucy5tZWRpYUVsZW1lbnRJZClcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUodGhpcylcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgZXJyb3IoTkFNRSwgYENvdWxkIG5vdCBlbWJlZCBGbGFzaC1iYXNlZCBSVE1QIFBsYXllci4gUmVhc29uOiAke2Vycn1gKVxuICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc291cmNlSGFuZGxlci5kaXNjb25uZWN0KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycilcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUTVBTdWJzY3JpYmVyRXZlbnRUeXBlcy5FTUJFRF9GQUlMVVJFLCB0aGlzKSlcbiAgICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QoYENvdWxkIG5vdCBpbmplY3QgRmxhc2gtYmFzZWQgUGxheWVyIGludG8gdGhlIHBhZ2UuIFJlYXNvbjogJHtlLm1lc3NhZ2V9YClcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoUlRNUFN1YnNjcmliZXJFdmVudFR5cGVzLkVNQkVEX0ZBSUxVUkUsIHRoaXMpKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIFN0aWxsIGluIHVzZSBmb3IgYXNzaWduaW5nIGRvY3VtZW50IGVsZW1lbnQgdmlldyBtYW5hZ2VtZW50IHRvIHRoaXMgaW5zdGFuY2UuXG4gICAqIEFQSSBkZXByZWNhdGVkIGluIDQuMC4wLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0VmlldyAodmlldywgZWxlbWVudElkKSB7XG4gICAgdGhpcy5fdmlldyA9IHZpZXdcbiAgICB0aGlzLl9lbGVtZW50SWQgPSBlbGVtZW50SWRcbiAgICB0aGlzLl92aWV3UmVzb2x2ZXIucmVzb2x2ZSh0aGlzLl92aWV3KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBiZWdpbiBzdWJzY3JpYmluZyB0byBhIHN0cmVhbS5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICAgICAgICAgVGhlIHJldHVybmVkIGBQcm9taXNlYCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IG9uIHN1Y2Nlc3NmdWwgc3RhcnQgb2YgcGxheWJhY2suXG4gICAqL1xuICBzdWJzY3JpYmUgKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdWJzY3JpcHRpb25SZXNvbHZlclByb21pc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gc3RvcCBhIHN1YnNjcmlwdGlvbi5cbiAgICogVGhlIHJldHVybmVkIGBQcm9taXNlYCB3aWxsIGVpdGhlciByZXNvbHZlIG9yIHJlamVjdCBvbiBzdWNjZXNzZnVsIHN0b3Agb2Ygc3Vic2NyaXB0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgdW5zdWJzY3JpYmUgKCkge1xuICAgIGRlYnVnKE5BTUUsICdbdW5zdWJzY3JpYmVdJyk7XG4gICAgY29uc3QgY2IgPSAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUubWVzc2FnZSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGNiKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gc3RhcnQgcGxheWluZyB0aGUgc3RyZWFtLlxuICAgKi9cbiAgcGxheSAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1twbGF5XScpO1xuICAgIHRoaXMuX2dldEVtYmVkUHJvbWlzZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5fc291cmNlSGFuZGxlci5wbGF5KClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIGNvbXBsZXRpb24gb2YgZW1iZWRkaW5nIEZsYXNoIGVsZW1lbnQgaW50byBwYWdlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25FbWJlZENvbXBsZXRlICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2VtYmVkOmNvbXBsZXRlXScpXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoUlRNUFN1YnNjcmliZXJFdmVudFR5cGVzLkVNQkVEX1NVQ0NFU1MsIHRoaXMpKVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIGZhaWx1cmUgaW4gZW1iZWRkaW5nIEZsYXNoIGVsZW1lbnQgaW50byBwYWdlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25FbWJlZEZhaWx1cmUgKGVycikge1xuICAgIGRlYnVnKE5BTUUsIGBbZW1iZWQ6ZmFpbHVyZV0gLSAke2Vycn1gKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUTVBTdWJzY3JpYmVyRXZlbnRUeXBlcy5FTUJFRF9GQUlMVVJFLCB0aGlzKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBgVW5wdWJsaXNoYCBvZiBzdHJlYW0gc3Vic2NyaWJlZCB0by4gT2NjdXJzIHdoZW4gYSBicm9hZGNhc3RlciBzdG9wcyB0aGVpciBzdHJlYW0gd2hpbGUgdGhpcyBzdWJzY3JpcHRpb24gc3RyZWFtIGlzIG9wZW4uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvblVucHVibGlzaCAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tvbnVucHVibGlzaF0nKVxuICAgIGlmICh0aGlzLl9zb3VyY2VIYW5kbGVyKSB7XG4gICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLnVucHVibGlzaCgpXG4gICAgfVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlBMQVlfVU5QVUJMSVNILCB0aGlzKSlcbiAgICBpZiAodGhpcy5fc291cmNlSGFuZGxlcikge1xuICAgICAgLy8gVGhpcyBkaWZmZXJzIHNsaWdodGx5IGZyb20gaG93IHRoZSBXZWJSVEMgc3Vic2NyaWJlciB3b3JrcyBvbiBVbnB1Ymxpc2ggbm90aWZpY2F0aW9uLlxuICAgICAgLy8gRm9yIFdlYlJUQyBzdWJzY3JpYmVycywgdGhlcmUgaXMgYW4gaW1tZWRpYXRlIGRpc2NvbmVjdGlvbiBkaXNwYXRjaGVkIEZST00gVEhFIFNFUlZFUiBhcyBhIG5vdGlmaWNhdGlvbi5cbiAgICAgIC8vIEluIEZsYXNoLCBhbiB1bnB1Ymxpc2ggaXMgbm90IGEgZGlyZWN0IGNvcnJlbGF0aW9uIHRvIGEgZGlzY29ubmVjdCBmb3IgYSBzdWJzY3JpYmVyLCBhcyBhIE5ldFN0cmVhbVxuICAgICAgLy8gICAgY2FuIHN0YXkgb3BlbiB3aXRob3V0IHN0cmVhbSBkYXRhIGJlaW5nIGRlbGl2ZXJlZC4gSW4gV2ViUlRDLCBvbmNlIGEgc3RyZWFtIGlzIHN0b3BwZWQgKFwidW5wdWJsaXNoZWRcIilcbiAgICAgIC8vICAgIHRoYXQgY29ubmVjdGlvbiBjYW4gbm90IGJlIHB1bXBlZCBhIG5ldyBzdHJlYW0gYXMgaXQgY2FuIG9uIEZsYXNoJ3MgTmV0U3RyZWFtLlxuICAgICAgLy8gQXMgc3VjaCwgdG8gaGF2ZSB0aGUgY2xpZW50cyBcImJlaGF2ZVwiIHRoZSBzYW1lLCB3ZSB3aWxsIHJlcXVlc3QgYSBkaXNjb25uZWN0IG9uIHVucHVibGlzaC5cbiAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIuZGlzY29ubmVjdCgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY29ubmVjdGlvbiBoYW5kbGVyIGZvciBwbGF5YmFjay5cbiAgICogVXNlZCBpbiBTaGFyZWRPYmplY3QgY29tbXVuaWNhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Q29ubmVjdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZUhhbmRsZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHJlZmVyZW5jZSB0byBwbGF5YmFjayBjb250cm9scyBpZiBhdmFpbGFibGUuXG4gICAqXG4gICAqIEByZXR1cm4ge1BsYXliYWNrQ29udHJvbHN9XG4gICAqL1xuICBnZXRDb250cm9scyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZUhhbmRsZXIgPyB0aGlzLl9zb3VyY2VIYW5kbGVyLmdldENvbnRyb2xzKCkgOiB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbml0aWFsaXphdGlvbiBjb25maWd1cmF0aW9uIHVzZWQgaW4gYGluaXQoKWAuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldE9wdGlvbnMgKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGFyZ2V0IHZpZXcgRWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIGdldFBsYXllciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZUhhbmRsZXIgPyB0aGlzLl9zb3VyY2VIYW5kbGVyLmdldEVtYmVkZGVkVmlldygpIDogdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdHlwZSBvZiBpbXBsZW1lbnRhdGlvbjogYFJUTVBgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gUGxheWJhY2tUeXBlcy5SVE1QLnRvVXBwZXJDYXNlKClcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJUTVBTdWJzY3JpYmVyXG5cbiIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgeyBhcHBseU9yaWVudGF0aW9uIH0gZnJvbSAnLi4vZW52L3RyYW5zbGF0aW9uLXV0aWwnXG5pbXBvcnQgeyBtZXRhZGF0YVJlc29sdXRpb25Ub09iamVjdCB9IGZyb20gJy4uL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgUGxheWJhY2tDb250cm9sbGVyLCBQbGF5YmFja0NvbnRyb2xzSW1wbCB9IGZyb20gJy4vY29udHJvbHMnXG5pbXBvcnQgeyBQbGF5YmFja1N0YXRlLCBQbGF5YmFja1N0YXRlUmVhZGFibGUgfSBmcm9tICcuL2NvbnRyb2xzL3N0YXRlJ1xuaW1wb3J0IHsgU3Vic2NyaWJlckV2ZW50LCBTdWJzY3JpYmVyRXZlbnRUeXBlcyB9IGZyb20gJy4uL2V2ZW50J1xuaW1wb3J0IHsgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0IHsgZGVidWcsIGVycm9yLCB3YXJuIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ0hMU1NvdXJjZUhhbmRsZXInXG5cbi8qKlxuICogU291cmNlIEhhbmRsZXIgZm9yIEhMUy1iYXNlZCBTdWJzY3JpYmVycywgd2hpY2ggc2VydmVzIGFzIGEgUHJlc2VudGF0aW9uIENvbnRyb2xsZXIgYmV0d2VlbiB2aWV3IGFuZCBzdWJzY3JpYmVyLlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQGV4dGVuZHMgU3Vic2NyaWJlclBsYXliYWNrQ29udHJvbGxlclxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEhMU1NvdXJjZUhhbmRsZXIgZXh0ZW5kcyBQbGF5YmFja0NvbnRyb2xsZXIge1xuXG4gIGNvbnN0cnVjdG9yIChtZWRpYSwgdHlwZSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLm1lZGlhID0gbWVkaWFcbiAgICB0aGlzLmNsb25lID0gdGhpcy5tZWRpYS5jbG9uZU5vZGUodHJ1ZSlcbiAgICB0aGlzLnBhcmVudCA9IHRoaXMubWVkaWEucGFyZW50Tm9kZVxuICAgIHRoaXMuaG9sZGVyID0gdGhpcy5fZGV0ZXJtaW5lSG9sZGVyKG1lZGlhKVxuICAgIHRoaXMucGxheWVyVHlwZSA9IHR5cGVcbiAgICB0aGlzLl9tZWRpYVNvdXJjZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2lzVk9EID0gZmFsc2VcbiAgICB0aGlzLl9jb250cm9scyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX29yaWVudGF0aW9uID0gMFxuICAgIHRoaXMuX3N0cmVhbWluZ01vZGUgPSAnVmlkZW8vQXVkaW8nXG4gICAgdGhpcy5fYXV0b0xheW91dE9yaWVudGF0aW9uID0gdHJ1ZVxuICAgIHRoaXMuX3BsYXliYWNrTm90aWZpY2F0aW9uQ2VudGVyID0gdGhpcy5tZWRpYVxuICAgIHRoaXMuX2hhbmRsZU9yaWVudGF0aW9uQ2hhbmdlID0gdGhpcy5faGFuZGxlT3JpZW50YXRpb25DaGFuZ2UuYmluZCh0aGlzKVxuICAgIHRoaXMuX29uT3JpZW50YXRpb25NZXRhZGF0YSA9IHRoaXMuX29uT3JpZW50YXRpb25NZXRhZGF0YS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fb25TdHJlYW1pbmdNb2RlTWV0YWRhdGEgPSB0aGlzLl9vblN0cmVhbWluZ01vZGVNZXRhZGF0YS5iaW5kKHRoaXMpXG4gICAgZW52aXJvbm1lbnQub25GdWxsU2NyZWVuU3RhdGVDaGFuZ2UodGhpcy5faGFuZGxlRnVsbFNjcmVlbkNoYW5nZS5iaW5kKHRoaXMpKVxuICB9XG5cbiAgLyoqXG4gICAqIEVzdGFibGlzaGVkIERPTSBFbGVtZW50IG9yZGVyIGZvciBwbGF5YmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBtZWRpYVxuICAgKiAgICAgICAgVGhlIHRhcmdldCBtZWRpYSBlbGVtZW50OiBlLmcuLCBgdmlkZW9gIG9yIGBhdWRpb2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGV0ZXJtaW5lSG9sZGVyIChtZWRpYSkge1xuICAgIGlmIChtZWRpYS5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygncmVkNXByby1tZWRpYS1jb250YWluZXInKSkge1xuICAgICAgcmV0dXJuIG1lZGlhLnBhcmVudE5vZGVcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBtZWRpYS5wYXJlbnROb2RlXG4gICAgICBjb25zdCBkaXYgPSBlbnZpcm9ubWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtY29udGFpbmVyJylcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZGl2LCBtZWRpYSlcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChtZWRpYSlcbiAgICAgIGRpdi5hcHBlbmRDaGlsZChtZWRpYSlcbiAgICAgIHJldHVybiBkaXZcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAgb2YgRE9NIEVsZW1lbnQgb3JkZXIgdXBvbiBzdG9wIG9mIHBsYXliYWNrLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NsZWFuVXAgKCkge1xuICAgIC8vIFJldHVybiB0byBwcmlvciBET00gbWFuaXB1bGF0aW9uLlxuICAgIGxldCBlbCA9IHRoaXMubWVkaWFcbiAgICBsZXQgc3JjID0gdGhpcy5fbWVkaWFTb3VyY2VcbiAgICBsZXQgZWxQYXJlbnQgPSBlbC5wYXJlbnROb2RlXG4gICAgbGV0IG1lZGlhSG9sZGVyID0gdGhpcy5ob2xkZXJcbiAgICBpZiAoc3JjKSB7XG4gICAgICBlbC5yZW1vdmVDaGlsZChzcmMpXG4gICAgfVxuICAgIGlmIChlbFBhcmVudCkge1xuICAgICAgZWxQYXJlbnQucmVtb3ZlQ2hpbGQoZWwpXG4gICAgICAvLyBUaGUgb2JqZWN0IHBhcmVudCBjb3VsZCBiZSBhIHdyYXBwZXIgY2hpbGQgaW4gdGhlIG9yaWdpbmFsIHBhcmVudCBlbGVtZW50LlxuICAgICAgaWYgKGVsUGFyZW50ICE9PSB0aGlzLnBhcmVudCkge1xuICAgICAgICBlbFBhcmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsUGFyZW50KVxuICAgICAgICBtZWRpYUhvbGRlciA9IHRoaXMucGFyZW50XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVsLnJlbW92ZSgpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHdhcm4oTkFNRSwgYElzc3VlIGluIERPTSBjbGVhbnVwIG9mIEhMUyB2aWRlbyBvYmplY3Q6ICR7ZS5tZXNzYWdlfWApXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWVkaWEgPSB0aGlzLmNsb25lLmNsb25lTm9kZSh0cnVlKVxuICAgIG1lZGlhSG9sZGVyLmFwcGVuZENoaWxkKHRoaXMubWVkaWEpXG4gICAgaWYgKHRoaXMuX2NvbnRyb2xzKSB7XG4gICAgICB0aGlzLl9jb250cm9scy5kZXRhY2goKVxuICAgIH1cbiAgICB0aGlzLm1lZGlhLnNldEF0dHJpYnV0ZSgnYXV0b3BsYXknLCB0cnVlKVxuICAgIHRoaXMuY2xvbmUgPSB0aGlzLm1lZGlhLmNsb25lTm9kZSh0cnVlKVxuICAgIHRoaXMucGFyZW50ID0gdGhpcy5tZWRpYS5wYXJlbnROb2RlXG4gICAgdGhpcy5ob2xkZXIgPSB0aGlzLl9kZXRlcm1pbmVIb2xkZXIodGhpcy5tZWRpYSlcbiAgICB0aGlzLl9vcmllbnRhdGlvbiA9IDBcbiAgICB0aGlzLmlzVk9EID0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NpZ25zIGFuZCBoYW5kbGVycyBldmVudCBub3RpZmljaWF0aW9ucyBjb21pbmcgZnJvbSB0aGUgbWVkaWEgbm90aWZpZXIgKGUuZy4sIGB2aWRlb2Agb3IgYGF1ZGlvYCBlbGVtZW50KS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG5vdGlmaWVyXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYWRkUGxheWJhY2tIYW5kbGVycyAobm90aWZpZXIpIHtcbiAgICBjb25zdCBjb250cm9scyA9IHRoaXMuZ2V0Q29udHJvbHMoKVxuICAgIGNvbnN0IGhhc0NvbnRyb2xzID0gdHlwZW9mIGNvbnRyb2xzICE9PSAndW5kZWZpbmVkJ1xuXG4gICAgbm90aWZpZXIub25jYW5wbGF5ID0gKCkgPT4ge1xuICAgICAgaWYgKGNvbnRyb2xzKSB7XG4gICAgICAgIGNvbnRyb2xzLmVuYWJsZSh0cnVlKVxuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuUExBWUJBQ0tfU1RBVEVfQ0hBTkdFLCB1bmRlZmluZWQsIHtcbiAgICAgICAgY29kZTogUGxheWJhY2tTdGF0ZS5BVkFJTEFCTEUsXG4gICAgICAgIHN0YXRlOiBQbGF5YmFja1N0YXRlUmVhZGFibGVbUGxheWJhY2tTdGF0ZS5BVkFJTEFCTEVdXG4gICAgICB9KSlcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlZPTFVNRV9DSEFOR0UsIHVuZGVmaW5lZCwge1xuICAgICAgICB2b2x1bWU6IG5vdGlmaWVyLnZvbHVtZVxuICAgICAgfSkpXG4gICAgfVxuICAgIG5vdGlmaWVyLm9uZHVyYXRpb25jaGFuZ2UgPSAoZXZlbnQpID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgaWYgKCFpc05hTihub3RpZmllci5kdXJhdGlvbikgJiYgTnVtYmVyLmlzRmluaXRlKG5vdGlmaWVyLmR1cmF0aW9uKSkge1xuICAgICAgICB0aGlzLmlzVk9EID0gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmlzVk9EICYmIGhhc0NvbnRyb2xzKSB7XG4gICAgICAgIGNvbnRyb2xzLnNldFBsYXliYWNrRHVyYXRpb24oMSlcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ29udHJvbHMpIHtcbiAgICAgICAgY29udHJvbHMuc2V0UGxheWJhY2tEdXJhdGlvbihub3RpZmllci5kdXJhdGlvbilcbiAgICAgIH1cbiAgICB9XG4gICAgbm90aWZpZXIub25lbmRlZCA9ICgpID0+IHtcbiAgICAgIGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50Om9uZW5kZWRdJylcbiAgICAgIGlmIChoYXNDb250cm9scykge1xuICAgICAgICBjb250cm9scy5zZXRTdGF0ZShQbGF5YmFja1N0YXRlLklETEUpXG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5QTEFZQkFDS19TVEFURV9DSEFOR0UsIHVuZGVmaW5lZCwge1xuICAgICAgICBjb2RlOiBQbGF5YmFja1N0YXRlLklETEUsXG4gICAgICAgIHN0YXRlOiBQbGF5YmFja1N0YXRlUmVhZGFibGVbUGxheWJhY2tTdGF0ZS5JRExFXVxuICAgICAgfSkpXG4gICAgfVxuICAgIG5vdGlmaWVyLm9udGltZXVwZGF0ZSA9IChldmVudCkgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBpZiAoaGFzQ29udHJvbHMpIHtcbiAgICAgICAgaWYgKCFzZWxmLmlzVk9EKSB7XG4gICAgICAgICAgY29udHJvbHMuc2V0U2Vla1RpbWUoMSwgMSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250cm9scy5zZXRTZWVrVGltZShub3RpZmllci5jdXJyZW50VGltZSwgc2VsZi5pc1ZPRCA/IG5vdGlmaWVyLmR1cmF0aW9uIDogdW5kZWZpbmVkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5QTEFZQkFDS19USU1FX1VQREFURSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIHRpbWU6IG5vdGlmaWVyLmN1cnJlbnRUaW1lLFxuICAgICAgICBkdXJhdGlvbjogbm90aWZpZXIuZHVyYXRpb25cbiAgICAgIH0pKVxuICAgIH1cbiAgICBub3RpZmllci5vbnNlZWtlZCA9IChldmVudCkgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4vLyAgICAgIGRlYnVnKE5BTUUsICdTZWVrZWQuJylcbiAgICB9XG4gICAgbm90aWZpZXIub25zZWVraW5nID0gKGV2ZW50KSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbi8vICAgICAgZGVidWcoTkFNRSwgJ1NlZWtpbmcuJylcbiAgICB9XG4gICAgbm90aWZpZXIub25wbGF5ID0gKCkgPT4ge1xuICAgICAgaWYgKGhhc0NvbnRyb2xzKSB7XG4gICAgICAgIGNvbnRyb2xzLnNldFN0YXRlKFBsYXliYWNrU3RhdGUuUExBWUlORylcbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlBMQVlCQUNLX1NUQVRFX0NIQU5HRSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGNvZGU6IFBsYXliYWNrU3RhdGUuUExBWUlORyxcbiAgICAgICAgc3RhdGU6IFBsYXliYWNrU3RhdGVSZWFkYWJsZVtQbGF5YmFja1N0YXRlLlBMQVlJTkddXG4gICAgICB9KSlcbiAgICB9XG4gICAgbm90aWZpZXIub25wYXVzZSA9ICgpID0+IHtcbiAgICAgIGlmIChoYXNDb250cm9scykge1xuICAgICAgICBjb250cm9scy5zZXRTdGF0ZShQbGF5YmFja1N0YXRlLlBBVVNFRClcbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlBMQVlCQUNLX1NUQVRFX0NIQU5HRSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGNvZGU6IFBsYXliYWNrU3RhdGUuUEFVU0VELFxuICAgICAgICBzdGF0ZTogUGxheWJhY2tTdGF0ZVJlYWRhYmxlW1BsYXliYWNrU3RhdGUuUEFVU0VEXVxuICAgICAgfSkpXG4gICAgfVxuICAgIG5vdGlmaWVyLm9udm9sdW1lY2hhbmdlID0gKGV2ZW50KSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIGlmIChoYXNDb250cm9scyAmJiBjb250cm9scy5nZXRWb2x1bWUoKSAhPT0gdGhpcy5tZWRpYS52b2x1bWUpIHtcbiAgICAgICAgY29udHJvbHMuc2V0Vm9sdW1lKHRoaXMubWVkaWEudm9sdW1lKVxuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuVk9MVU1FX0NIQU5HRSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIHZvbHVtZTogbm90aWZpZXIubXV0ZWQgPyAwIDogbm90aWZpZXIudm9sdW1lXG4gICAgICB9KSlcbiAgICB9XG4gICAgLy8gZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cbiAgICBub3RpZmllci5vbmVuY3J5cHRlZCA9ICgpID0+IHsgZGVidWcoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6ZXZlbnRdIGVuY3J5cHRlZCcpIH1cbiAgICBub3RpZmllci5vbmVtcHRpZWQgPSAoKSA9PiB7IGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmV2ZW50XSBlbXB0aWVkJykgfVxuICAgIG5vdGlmaWVyLm9ubG9hZGVkZGF0YSA9ICgpID0+IHsgXG4gICAgICBkZWJ1ZyhOQU1FLCAnW3ZpZGVvZWxlbWVudDpldmVudF0gbG9hZGVkZGF0YScpIFxuICAgICAgLypcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlZJREVPX0RJTUVOU0lPTlNfQ0hBTkdFLCB1bmRlZmluZWQsIHtcbiAgICAgICAgd2lkdGg6IHRoaXMubWVkaWEudmlkZW9XaWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLm1lZGlhLnZpZGVvSGVpZ2h0XG4gICAgICB9KSlcbiAgICAgICovXG4gICAgfVxuICAgIG5vdGlmaWVyLm9ucmVzaXplID0gKCkgPT4geyBcbiAgICAgIGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmV2ZW50XSByZXNpemUnKVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuVklERU9fRElNRU5TSU9OU19DSEFOR0UsIHVuZGVmaW5lZCwge1xuICAgICAgICB3aWR0aDogdGhpcy5tZWRpYS52aWRlb1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMubWVkaWEudmlkZW9IZWlnaHRcbiAgICAgIH0pKVxuICAgIH1cbiAgICBub3RpZmllci5vbmxvYWRlZG1ldGFkYXRhID0gKCkgPT4ge1xuICAgICAgZGVidWcoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6ZXZlbnRdIGxvYWRlZG1ldGFkYXRhJylcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9TVEFSVCwgdW5kZWZpbmVkLCB7fSkpXG4gICAgfVxuICAgIG5vdGlmaWVyLm9ubG9hZHN0YXJ0ID0gKCkgPT4geyBkZWJ1ZyhOQU1FLCAnW3ZpZGVvZWxlbWVudDpldmVudF0gbG9hZGVkc3RhcnQnKSB9XG4gICAgbm90aWZpZXIub25zdGFsbGVkID0gKCkgPT4geyBkZWJ1ZyhOQU1FLCAnW3ZpZGVvZWxlbWVudDpldmVudF0gc3RhbGxlZCcpIH1cbiAgICBub3RpZmllci5vbnN1c3BlbmQgPSAoKSA9PiB7IGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmV2ZW50XSBzdXNwZW5kJykgfVxuICAgIG5vdGlmaWVyLm9ud2FpdGluZyA9ICgpID0+IHsgZGVidWcoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6ZXZlbnRdIHdhaXRpbmcnKSB9XG4gICAgLy8gICAgbm90aWZpZXIub25wcm9ncmVzcyA9ICgpID0+IHsgZGVidWcoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6ZXZlbnRdIHByb2dyZXNzLiBQbGF5ZWQ6ICcgKyBub3RpZmllci5wbGF5ZWQubGVuZ3RoICsgJywgQnVmZmVyZWQ6ICcgKyBub3RpZmllci5idWZmZXJlZC5sZW5ndGggKyAnLicpIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBjaGFuZ2UgaW4gZnVsbHNjcmVlbiBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc0Z1bGxTY3JlZW5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVGdWxsU2NyZWVuQ2hhbmdlIChpc0Z1bGxTY3JlZW4pIHtcbiAgICBpZiAoaXNGdWxsU2NyZWVuKSB7XG4gICAgICB0aGlzLmhvbGRlci5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLWNvbnRhaW5lci1mdWxsLXNjcmVlbicpXG4gICAgICB0aGlzLm1lZGlhLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtY29udGFpbmVyLWZ1bGwtc2NyZWVuJylcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmhvbGRlci5jbGFzc0xpc3QucmVtb3ZlKCdyZWQ1cHJvLW1lZGlhLWNvbnRhaW5lci1mdWxsLXNjcmVlbicpXG4gICAgICB0aGlzLm1lZGlhLmNsYXNzTGlzdC5yZW1vdmUoJ3JlZDVwcm8tbWVkaWEtY29udGFpbmVyLWZ1bGwtc2NyZWVuJylcbiAgICB9XG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuRlVMTF9TQ1JFRU5fU1RBVEVfQ0hBTkdFLCB1bmRlZmluZWQsIGlzRnVsbFNjcmVlbikpXG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lIHRoZSBzb3VyY2UgZWxlbWVudCBvbiB0aGUgSExTIHBsYXliYWNrIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAgICogICAgICAgIFRoZSBwbGF5YmFjayBlbmRwb2ludCBVUkwuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqICAgICAgICBUaGUgbWltZSB0eXBlIG9mIHRoZSBwbGF5YmFjayBzdHJlYW0uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgaW5pdGlhbGl6YXRpb24gY29uZmlndXJhdGlvbiBtYXAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZW1iZWRNZWRpYVNvdXJjZSAodXJsLCB0eXBlLCBvcHRpb25zKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRyeSB7XG4gICAgICBsZXQgc291cmNlID0gZW52aXJvbm1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJylcbiAgICAgIHNvdXJjZS50eXBlID0gdHlwZVxuICAgICAgc291cmNlLnNyYyA9IHVybFxuICAgICAgdGhpcy5tZWRpYS50eXBlID0gdHlwZVxuICAgICAgaWYgKHRoaXMubWVkaWEuZmlyc3RDaGlsZCkge1xuICAgICAgICB0aGlzLm1lZGlhLmluc2VydEJlZm9yZShzb3VyY2UsIHRoaXMubWVkaWEuZmlyc3RDaGlsZClcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLm1lZGlhLmFwcGVuZENoaWxkKHNvdXJjZSlcbiAgICAgIH1cbiAgICAgIHRoaXMuX21lZGlhU291cmNlID0gc291cmNlXG4gICAgICB0aGlzLl9hdXRvTGF5b3V0T3JpZW50YXRpb24gPSBvcHRpb25zLmF1dG9MYXlvdXRPcmllbnRhdGlvblxuICAgICAgZW52aXJvbm1lbnQub25PcmllbnRhdGlvbk1ldGFkYXRhKHRoaXMubWVkaWEsIHRoaXMuX29uT3JpZW50YXRpb25NZXRhZGF0YSlcbiAgICAgIGVudmlyb25tZW50Lm9uU3RyZWFtaW5nTW9kZU1ldGFkYXRhKHRoaXMubWVkaWEsIHRoaXMuX29uU3RyZWFtaW5nTW9kZU1ldGFkYXRhKVxuICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICBkZWZlcnJlZC5yZWplY3QoZS5tZXNzYWdlKVxuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGVnYXRlIHJlc3BvbmRlciB0byBpbmNvbWluZyBjaGFuZ2VzIG9mIGBvcmllbnRhdGlvbmAgbWV0YWRhdGEgb24gSExTIHBsYXliYWNrIHRyYWNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1ldGRhdGFcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk9yaWVudGF0aW9uTWV0YWRhdGEgKG1ldGFkYXRhKSB7XG4gICAgY29uc3QgeyBcbiAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgcmVzb2x1dGlvblxuICAgIH0gPSBtZXRhZGF0YVxuICAgIGNvbnN0IG9yaWVudGF0aW9uSW50ID0gcGFyc2VJbnQob3JpZW50YXRpb24sIDEwKVxuICAgIGlmIChvcmllbnRhdGlvbiAmJiB0aGlzLl9vcmllbnRhdGlvbiAhPT0gb3JpZW50YXRpb25JbnQpIHtcbiAgICAgIGRlYnVnKE5BTUUsICdNZXRhZGF0YSByZWNlaXZlZDogJyArIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhLCBudWxsLCAyKSlcbiAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gb3JpZW50YXRpb25JbnRcbiAgICAgIGlmICh0aGlzLl9hdXRvTGF5b3V0T3JpZW50YXRpb24pIHtcbiAgICAgICAgYXBwbHlPcmllbnRhdGlvbih0aGlzLm1lZGlhLCB0aGlzLl9vcmllbnRhdGlvbiwgbWV0YWRhdGFSZXNvbHV0aW9uVG9PYmplY3QocmVzb2x1dGlvbikpXG4gICAgICAgIHRoaXMuX2hhbmRsZU9yaWVudGF0aW9uQ2hhbmdlKHRoaXMuX29yaWVudGF0aW9uKVxuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuT1JJRU5UQVRJT05fQ0hBTkdFLCB1bmRlZmluZWQsIHtcbiAgICAgICAgb3JpZW50YXRpb246IHRoaXMuX29yaWVudGF0aW9uLFxuICAgICAgICB2aWV3RWxlbWVudDogdGhpcy5tZWRpYVxuICAgICAgfSkpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfTUVUQURBVEEsIHVuZGVmaW5lZCwgbWV0YWRhdGEpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxlZ2F0ZSByZXNwb25kZXIgdG8gaW5jb21pbmcgY2hhbmdlcyBvZiBgc3RyZWFtaW5nTW9kZWAgbWV0YWRhdGEgb24gSExTIHBsYXliYWNrIHRyYWNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1ldGRhdGFcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblN0cmVhbWluZ01vZGVNZXRhZGF0YSAobWV0YWRhdGEpIHtcbiAgICBjb25zdCB7IHN0cmVhbWluZ01vZGUgfSA9IG1ldGFkYXRhXG4gICAgY29uc3QgcHJldmlvdXNTdHJlYW1pbmdNb2RlID0gdGhpcy5fc3RyZWFtaW5nTW9kZVxuICAgIGlmIChzdHJlYW1pbmdNb2RlICYmIHByZXZpb3VzU3RyZWFtaW5nTW9kZSAhPT0gc3RyZWFtaW5nTW9kZSkge1xuICAgICAgZGVidWcoTkFNRSwgJ01ldGFkYXRhIHJlY2VpdmVkOiAnICsgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEsIG51bGwsIDIpKVxuICAgICAgdGhpcy5fc3RyZWFtaW5nTW9kZSA9IHN0cmVhbWluZ01vZGVcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlNUUkVBTUlOR19NT0RFX0NIQU5HRSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIHN0cmVhbWluZ01vZGU6IHRoaXMuX3N0cmVhbWluZ01vZGUsXG4gICAgICAgIHByZXZpb3VzU3RyZWFtaW5nTW9kZTogcHJldmlvdXNTdHJlYW1pbmdNb2RlLFxuICAgICAgICB2aWV3RWxlbWVudDogdGhpcy5tZWRpYVxuICAgICAgfSkpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfTUVUQURBVEEsIHVuZGVmaW5lZCwgbWV0YWRhdGEpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIHNldHVwIHRoZSBwcmVzZW50YXRpb24gb2YgYSBwbGF5YmFjayBzdHJlYW0gdXNpbmcgSExTLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gICAqICAgICAgICBUaGUgZW5kcG9pbnQgVVJMIGZvciBwbGF5YmFjay5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogICAgICAgIFRoZSBtaW1lIHR5cGUgZm9yIHBsYXliYWNrLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgVGhlIGluaXRpYWxpemF0aW9uIGNvbmZpZ3VyYXRpb24gbWFwLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFkZFNvdXJjZSAodXJsLCB0eXBlLCBvcHRpb25zKSB7XG4gICAgZGVidWcoTkFNRSwgJ1thZGRzb3VyY2VdJylcbiAgICB0aGlzLmhvbGRlciA9IHRoaXMuX2RldGVybWluZUhvbGRlcih0aGlzLm1lZGlhKVxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgY29uc3QgaGFzRGVmaW5lZENvbnRyb2xzID0gb3B0aW9ucy5jb250cm9sc1xuICAgIGNvbnN0IGlzTXV0ZWQgPSBlbnZpcm9ubWVudC5oYXNBdHRyaWJ1dGVEZWZpbmVkKHRoaXMubWVkaWEsICdtdXRlZCcpXG4gICAgY29uc3QgaXNBdXRvcGxheSA9IGVudmlyb25tZW50Lmhhc0F0dHJpYnV0ZURlZmluZWQodGhpcy5tZWRpYSwgJ2F1dG9wbGF5JylcbiAgICAvLyBXaWxsIGhhbmRsZSBhdXRvcGxheSBleHBsaWNpdGx5IHRvIGNhcHR1cmUgaXNzdWVzIHdpdGggYnJvd3NlciByZXN0cmljdGlvbnMgYW5kIHNlbmQgbm90aWZpY2F0aW9ucy5cbiAgICBpZiAoIWlzTXV0ZWQpIHtcbiAgICAgIHRoaXMubWVkaWEuc2V0QXR0cmlidXRlKCdhdXRvcGxheScsIGZhbHNlKVxuICAgIH1cbiAgICBjb25zdCB1c2VQbGF5YmFja0NvbnRyb2xzID0gZW52aXJvbm1lbnQuaGFzQXR0cmlidXRlRGVmaW5lZCh0aGlzLm1lZGlhLCAnY29udHJvbHMnKSAmJiBlbnZpcm9ubWVudC5oYXNDbGFzc0RlZmluZWQodGhpcy5tZWRpYSwgJ3JlZDVwcm8tbWVkaWEnKVxuICAgIHRoaXMuX2VtYmVkTWVkaWFTb3VyY2UodXJsLCB0eXBlLCBvcHRpb25zKVxuICAgICAgLnRoZW4oICgpID0+IHtcbiAgICAgICAgaWYgKGhhc0RlZmluZWRDb250cm9scyB8fCB1c2VQbGF5YmFja0NvbnRyb2xzKSB7XG4gICAgICAgICAgaWYgKGhhc0RlZmluZWRDb250cm9scykge1xuICAgICAgICAgICAgdGhpcy5fY29udHJvbHMgPSBvcHRpb25zLmNvbnRyb2xzXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY29udHJvbHMgPSBuZXcgUGxheWJhY2tDb250cm9sc0ltcGwodGhpcywgdGhpcy5ob2xkZXIpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubWVkaWEuY29udHJvbHMgPSBmYWxzZVxuICAgICAgICAgIHRoaXMuX2NvbnRyb2xzLnNldEFzVk9EKHRoaXMuaXNWT0QpXG4gICAgICAgICAgdGhpcy5fY29udHJvbHMuc2V0TXV0ZWRTdGF0ZShpc011dGVkKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FkZFBsYXliYWNrSGFuZGxlcnModGhpcy5fcGxheWJhY2tOb3RpZmljYXRpb25DZW50ZXIpXG4gICAgICAgIGlmIChpc0F1dG9wbGF5KSB7XG4gICAgICAgICAgdGhpcy5hdHRlbXB0QXV0b3BsYXkob3B0aW9ucy5tdXRlT25BdXRvcGxheVJlc3RyaWN0aW9uKVxuICAgICAgICB9XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUoKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlID0+IGRlZmVycmVkLnJlamVjdChlKSlcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gY29ubmVjdCB0byBzdHJlYW0uXG4gICAqL1xuICBjb25uZWN0ICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2Nvbm5lY3RdJylcbiAgfVxuXG4gIGF0dGVtcHRBdXRvcGxheSAobXV0ZU9uQXV0b3BsYXkgPSBmYWxzZSkge1xuICAgIHRoaXMucGxheSgpXG4gICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgIGlmIChtdXRlT25BdXRvcGxheSkge1xuICAgICAgICAgIHRoaXMubXV0ZSgpXG4gICAgICAgICAgdGhpcy5wbGF5KClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQVVUT19QTEFZQkFDS19NVVRFRCwgdW5kZWZpbmVkLCB7ZWxlbWVudDogdGhpcy5tZWRpYX0pKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5BVVRPX1BMQVlCQUNLX0ZBSUxVUkUsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgIGVycm9yOiAoZXJyLm1lc3NhZ2UgPyBlcnIubWVzc2FnZSA6IGVyciksXG4gICAgICAgICAgICAgICAgZWxlbWVudDogdGhpcy5tZWRpYVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQVVUT19QTEFZQkFDS19GQUlMVVJFLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIGVycm9yOiAoZS5tZXNzYWdlID8gZS5tZXNzYWdlIDogZSksXG4gICAgICAgICAgICBlbGVtZW50OiB0aGlzLm1lZGlhXG4gICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cblxuICBwbGF5ICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3ZpZGVvZWxlbWVudDphY3Rpb25dIHBsYXknKVxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdHJ5IHtcbiAgICAgIGxldCBtYXliZVByb21pc2UgPSB0aGlzLm1lZGlhLnBsYXkoKVxuICAgICAgaWYgKG1heWJlUHJvbWlzZSkge1xuICAgICAgICBtYXliZVByb21pc2VcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhOQU1FLCAnW3ZpZGVvZWxlbWVudDphY3Rpb25dIHBsYXkgKFNUQVJUKScpXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChkZWZlcnJlZC5yZWplY3QpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZyhOQU1FLCAnW3ZpZGVvZWxlbWVudDphY3Rpb25dIHBsYXkgKFNUQVJUKScpXG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUoKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yKE5BTUUsICdbdmlkZW9lbGVtZW50OmFjdGlvbl0gcGxheSAoRkFVTFQpIC0gJyArIGUubWVzc2FnZSlcbiAgICAgIGRlZmVycmVkLnJlamVjdChlKVxuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgcGF1c2UgKCkge1xuICAgIGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmFjdGlvbl0gcGF1c2UnKVxuICAgIHRyeSB7XG4gICAgICB0aGlzLm1lZGlhLnBhdXNlKClcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKE5BTUUsICdbdmlkZW9lbGVtZW50OmFjdGlvbl0gcGF1c2UgKEZBVUxUKSAtICcgKyBlLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHJlc3VtZSAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6YWN0aW9uXSByZXN1bWUnKVxuICAgIHRyeSB7XG4gICAgICBsZXQgbWF5YmVQcm9taXNlID0gdGhpcy5tZWRpYS5wbGF5KClcbiAgICAgIGlmIChtYXliZVByb21pc2UpIHtcbiAgICAgICAgbWF5YmVQcm9taXNlLnRoZW4oKCkgPT4gZGVidWcoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6YWN0aW9uXSBwbGF5IChTVEFSVCknKSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IGVycm9yKE5BTUUsICdbdmlkZW9lbGVtZW50OmFjdGlvbl0gcGxheSAoRkFVTFQpICcgKyAoZXJyLm1lc3NhZ2UgPyBlcnIubWVzc2FnZSA6IGVycikpKVxuICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IoTkFNRSwgJ1t2aWRlb2VsZW1lbnQ6YWN0aW9uXSByZXN1bWUgKEZBVUxUKSAtICcgKyBlLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHN0b3AgKCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLm1lZGlhLnN0b3AoKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgLy8gb2suXG4gICAgfVxuICB9XG5cbiAgbXV0ZSAoKSB7XG4gICAgdGhpcy5tZWRpYS5tdXRlZCA9IHRydWVcbiAgICBjb25zdCBjb250cm9scyA9IHRoaXMuZ2V0Q29udHJvbHMoKVxuICAgIGlmIChjb250cm9scykge1xuICAgICAgY29udHJvbHMuc2V0TXV0ZWRTdGF0ZSh0cnVlKVxuICAgIH1cbiAgfVxuXG4gIHVubXV0ZSAoKSB7XG4gICAgdGhpcy5tZWRpYS5tdXRlZCA9IGZhbHNlXG4gICAgY29uc3QgY29udHJvbHMgPSB0aGlzLmdldENvbnRyb2xzKClcbiAgICBpZiAoY29udHJvbHMpIHtcbiAgICAgIGNvbnRyb2xzLnNldE11dGVkU3RhdGUoZmFsc2UpXG4gICAgfVxuICB9XG5cbiAgc2V0Vm9sdW1lICh2YWx1ZSkge1xuICAgIHRoaXMudW5tdXRlKClcbiAgICB0aGlzLm1lZGlhLnZvbHVtZSA9IHZhbHVlXG4gIH1cblxuICBzZWVrVG8gKHBlcmNlbnRhZ2UsIGR1cmF0aW9uID0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSA9IGR1cmF0aW9uID8gcGVyY2VudGFnZSAqIGR1cmF0aW9uIDogcGVyY2VudGFnZVxuICB9XG5cbiAgdG9nZ2xlRnVsbFNjcmVlbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGVudmlyb25tZW50LnRvZ2dsZUZ1bGxTY3JlZW4odGhpcy5ob2xkZXIpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBlO1xuICAgICAgLy8gbmFkYS5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTm90aWZpY2F0aW9uIG9mIGN1cnJlbnQgc3RyZWFtIGJlaW5nIGluIGFuIHVucHVibGlzaGVkIHN0YXRlLlxuICAgKiBUaGUgc3RyZWFtIGVudGVycyBhbiB1bnB1Ymxpc2hlZCBzdGF0ZSB3aGVuIHRoZSBicm9hZGNhc3RlciBzdG9wIHRoZSBzdHJlYW0gYW5kIHRoZSBzdWJzY3JpYmVyIGlzIHN0aWxsIGNvbm5lY3RlZC5cbiAgICovXG4gIHVucHVibGlzaCAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc3RvcCgpXG4gICAgICB0aGlzLm1lZGlhLm9uZW5kZWQuY2FsbCh0aGlzLm1lZGlhKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgLy8gbmFkYS5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBkaXNjb25uZWN0IHBsYXliYWNrLlxuICAgKi9cbiAgZGlzY29ubmVjdCAoKSB7XG4gICAgdGhpcy5fY2xlYW5VcCgpXG4gIH1cblxuICAvKipcbiAgICogUmVzcG9uZGVyIHRvIGNoYW5nZSBpbiBvcmllbnRhdGlvbiByZWNlaXZlZCB0aHJvdWdoIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gb3JpZW50YXRpb25cbiAgICogICAgICAgIFRoZSBvcmllbnRhdGlvbiB2YWx1ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVPcmllbnRhdGlvbkNoYW5nZSAob3JpZW50YXRpb24pIHtcbiAgICBpZiAodGhpcy5fY29udHJvbHMgJiYgKG9yaWVudGF0aW9uICUgMTgwICE9PSAwKSkge1xuICAgICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1iYWNrZ3JvdW5kJylcbiAgICAgIHRoaXMubWVkaWEuY2xhc3NMaXN0LnJlbW92ZSgncmVkNXByby1tZWRpYS1iYWNrZ3JvdW5kJylcbiAgICB9XG4gIH1cblxuICAvKlxuICAgKiB8fCBTSEFSRUQgT0JKRUNUIElOVEVHUkFUSU9OIE5PVCBBVkFJTEFCTEUgRk9SIEhMUyBQTEFZQkFDSyB8fFxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIGFkZFNoYXJlZE9iamVjdFJlc3BvbnNlSGFuZGxlciAoaGFuZGxlcikge31cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgcmVtb3ZlU2hhcmVkT2JqZWN0UmVzcG9uc2VIYW5kbGVyIChoYW5kbGVyKSB7fVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBzZW5kVG9TaGFyZWRPYmplY3QgKG5hbWUsIGNhbGxOYW1lLCBtZXNzYWdlKSB7fVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBzZW5kUHJvcGVydHlUb1NoYXJlZE9iamVjdCAobmFtZSwga2V5LCB2YWx1ZSkge31cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgZ2V0UmVtb3RlU2hhcmVkT2JqZWN0IChzaGFyZWRPYmplY3ROYW1lKSB7fVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBjb25uZWN0VG9TaGFyZWRPYmplY3QgKHNoYXJlZE9iamVjdE5hbWUpIHt9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIGNsb3NlU2hhcmVkT2JqZWN0IChzaGFyZWRPYmplY3ROYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHBsYXliYWNrIGNvbnRyb2xzIGlmIGF2YWlsYWJsZS5cbiAgICpcbiAgICogQHJldHVybnMge1BsYXliYWNrQ29udHJvbHN9XG4gICAqL1xuICBnZXRDb250cm9scyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRyb2xzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3Vic2NyaWJlciB0eXBlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbnRyb2xsZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXJUeXBlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBmbGFnIG9mIHZpZGVvIGJlaW5nIHJlY29nbml6ZWQgYXMgVk9EIChWaWRlbyBPbiBEZW1hbmQpLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZPRCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVk9EXG4gIH1cblxuICAvKipcbiAgICogU2V0cyBmbGFnIG9mIHZpZGVvIGJlaW5nIGNvbnNpZGVyZWQgYXMgVk9EIChWaWRlbyBPbiBEZW1hbmQpLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAqL1xuICBzZXQgaXNWT0QgKHZhbHVlKSB7XG4gICAgdGhpcy5faXNWT0QgPSB2YWx1ZVxuICAgIGlmICh0aGlzLl9jb250cm9scykge1xuICAgICAgdGhpcy5fY29udHJvbHMuc2V0QXNWT0QodmFsdWUpXG4gICAgfVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgSExTU291cmNlSGFuZGxlclxuXG4iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uL2Vudi9icm93c2VyJ1xuaW1wb3J0ICogYXMgd2Vic29ja2V0IGZyb20gJy4uL2FkYXB0ZXIvd2Vic29ja2V0J1xuaW1wb3J0IFNvY2tldEhlbHBlciBmcm9tICcuLi9oZWxwZXIvc29ja2V0LWhlbHBlcidcbmltcG9ydCBITFNTb3VyY2VIYW5kbGVyIGZyb20gJy4vcmVkNXByby1zb3VyY2UtaGFuZGxlci1obHMnXG5pbXBvcnQgUGxheWJhY2tWaWV3IGZyb20gJy4uL3ZpZXcvcGxheWJhY2snXG5pbXBvcnQgeyBQbGF5YmFja0NvbnRyb2xsZXIgfSBmcm9tICcuL2NvbnRyb2xzL2luZGV4J1xuaW1wb3J0IHsgU3Vic2NyaWJlckV2ZW50IH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgeyBTdWJzY3JpYmVyRXZlbnRUeXBlcyB9IGZyb20gJy4uL2V2ZW50J1xuaW1wb3J0IHsgUGxheWJhY2tUeXBlcyB9IGZyb20gJy4uL2VudW0vcGxheWJhY2snXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgeyBvcHRpb25zVG9IbHNVUkwgfSBmcm9tICcuLi91dGlsL3VybC1lbmRwb2ludCdcbmltcG9ydCB7IGRlYnVnLCB3YXJuLCBlcnJvciB9IGZyb20gJy4uL2xvZydcbmltcG9ydCB7IGhsc1NvY2tldEVuZHBvaW50RnJvbU9wdGlvbnMgYXMgZW5kcG9pbnRGcm9tT3B0aW9ucyB9IGZyb20gJy4uL3V0aWwvdXJsLWVuZHBvaW50J1xuXG5jb25zdCBOQU1FID0gJ0hMU1N1YnNjcmliZXInXG5cbi8qKlxuICogU2ltcGxlIGdlbmVyYXRpb24gb2cgdW5pcXVlIHN1YnNjcmliZXIgaWQuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGdlbmVyYXRlU3Vic2NyaXB0aW9uSWQgPSAoKSA9PiB7XG4gIGNvbnN0IGlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgxMDAwMCkudG9TdHJpbmcoMTYpXG4gIHJldHVybiBgc3Vic2NyaWJlci0ke2lkfWBcbn1cblxuLy8gRGVmYXVsdCB0byBzZWN1cmUgc2V0dGluZ3MuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgcHJvdG9jb2w6ICdodHRwcycsXG4gIHBvcnQ6IDQ0MyxcbiAgYXBwOiAnbGl2ZScsXG4gIG1pbWVUeXBlOiAnYXBwbGljYXRpb24veC1tcGVnVVJMJyxcbiAgbWVkaWFFbGVtZW50SWQ6ICdyZWQ1cHJvLXN1YnNjcmliZXInLFxuICBhdXRvTGF5b3V0T3JpZW50YXRpb246IHRydWUsXG4gIG11dGVPbkF1dG9wbGF5UmVzdHJpY3Rpb246IHRydWUsXG4gIHN1YnNjcmlwdGlvbklkOiBnZW5lcmF0ZVN1YnNjcmlwdGlvbklkKClcbn1cblxuY29uc3QgdXJsUmVnZXggPSAvXmh0dHAofHMpLipcXC5tM3U4L2dcblxuLyoqXG4gKiBNYWluIGVudHJ5IGZvciBITFMtYmFzZWQgU3Vic2NyaWJlci5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqIEBleHRlbmRzIFN1YnNjcmliZXJQbGF5YmFja0NvbnRyb2xsZXJcbiAqL1xuY2xhc3MgSExTU3Vic2NyaWJlciBleHRlbmRzIFBsYXliYWNrQ29udHJvbGxlciB7XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9vcHRpb25zID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fdmlldyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLl92aWV3UmVzb2x2ZXIgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25SZXNvbHZlciA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRoaXMuX2JvdW5kQnViYmxlU3Vic2NyaWJlckV2ZW50cyA9IHRoaXMuYnViYmxlU3Vic2NyaWJlckV2ZW50cy5iaW5kKHRoaXMpXG4gIH1cblxuICBfZ2V0Vmlld1Jlc29sdmVyUHJvbWlzZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdSZXNvbHZlci5wcm9taXNlXG4gIH1cblxuICBfZ2V0U3Vic2NyaXB0aW9uUmVzb2x2ZXJQcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdWJzY3JpcHRpb25SZXNvbHZlci5wcm9taXNlXG4gIH1cblxuICAvKipcbiAgICogUHJveHkgZXZlbnQgYnViYmxlciB0aHJvdWdoIGhhbmRsZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBidWJibGVTdWJzY3JpYmVyRXZlbnRzIChldmVudCkge1xuICAgIGlmIChldmVudC50eXBlID09PSBTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfU1RBUlQpIHtcbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvblJlc29sdmVyLnJlc29sdmUodGhpcylcbiAgICB9XG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoZXZlbnQudHlwZSwgdGhpcywgZXZlbnQuZGF0YSkpXG4gIH1cblxuICAvKipcbiAgICogR2xvbXMgdGhlIFBsYXliYWNrIENvbnRyb2xzIEFQSSBvbnRvIHRoaXMgaW5zdGFuY2UgdG8gcHJvdmlkZSBlYXNlIGluIHVzZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJcbiAgICogICAgICAgIFRoZSBtZXRob2QgcmVxdWVzdCBoYW5kbGVyIHRvIGJpbmQgYW5kIGZvcndhcmQgY2FsbHMgb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2xvbVNvdXJjZUhhbmRsZXJBUEkgKGhhbmRsZXIpIHtcbiAgICB0aGlzLnBsYXkgPSBoYW5kbGVyLnBsYXkuYmluZChoYW5kbGVyKVxuICAgIHRoaXMucGF1c2UgPSBoYW5kbGVyLnBhdXNlLmJpbmQoaGFuZGxlcilcbiAgICB0aGlzLnJlc3VtZSA9IGhhbmRsZXIucmVzdW1lLmJpbmQoaGFuZGxlcilcbiAgICB0aGlzLnN0b3AgPSBoYW5kbGVyLnN0b3AuYmluZChoYW5kbGVyKVxuICAgIHRoaXMubXV0ZSA9IGhhbmRsZXIubXV0ZS5iaW5kKGhhbmRsZXIpXG4gICAgdGhpcy51bm11dGUgPSBoYW5kbGVyLnVubXV0ZS5iaW5kKGhhbmRsZXIpXG4gICAgdGhpcy5zZXRWb2x1bWUgPSBoYW5kbGVyLnNldFZvbHVtZS5iaW5kKGhhbmRsZXIpXG4gICAgdGhpcy5zZWVrVG8gPSBoYW5kbGVyLnNlZWtUby5iaW5kKGhhbmRsZXIpXG4gICAgdGhpcy50b2dnbGVGdWxsU2NyZWVuID0gaGFuZGxlci50b2dnbGVGdWxsU2NyZWVuLmJpbmQoaGFuZGxlcilcbiAgICBoYW5kbGVyLm9uKCcqJywgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChldmVudC50eXBlLCB0aGlzLCBldmVudC5kYXRhKSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFN0aWxsIGluIHVzZSwgYnV0IGhvbGQtb3ZlciBvZiBwcmV2aW91cyAzLnggU0RLIHZlcnNpb25zIGRlc2lnbmVkIHRvIHBhaXIgdmlld3MgYW5kIHN1YnNjcmliZXJzLiBJbiA0LjAuMCBpdCBoYXMgYmVlbiBpbnRlcm5hbGl6ZWQuXG4gICAqIEFQSSBkZXByZWNhdGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldFZpZXdJZk5vdEV4aXN0IChjdXJyZW50VmlldywgbWVkaWFFbGVtZW50SWQgPSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgY3VycmVudFZpZXcgPT09ICd1bmRlZmluZWQnICYmIG1lZGlhRWxlbWVudElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHZpZXcgPSBuZXcgUGxheWJhY2tWaWV3KG1lZGlhRWxlbWVudElkKVxuICAgICAgICB2aWV3LmF0dGFjaFN1YnNjcmliZXIodGhpcylcbiAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIGluaXRpYWxpemUgdGhlIHN1YnNjcmlwdGlvbiBoYW5kbGVyIGZvciBITFMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgaW5pdGlhbGl6YXRpb24gY29uZmlndXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJcbiAgICogICAgICAgIFRoZSBoYW5kbGVyIGluc3RhbmNlIHRoYXQgd2lsbCBtYW5hZ2UgdmlldyBpbnRlcmFjdGlvbiBhbmQgZXZlbnRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRIYW5kbGVyIChvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RyZWFtTmFtZSxcbiAgICAgIG1pbWVUeXBlXG4gICAgfSA9IHRoaXMuX29wdGlvbnNcbiAgICBsZXQgdXJsID0gc3RyZWFtTmFtZS5tYXRjaCh1cmxSZWdleCkgPyBzdHJlYW1OYW1lIDogb3B0aW9uc1RvSGxzVVJMKHRoaXMuX29wdGlvbnMpXG4gICAgdGhpcy5fc291cmNlSGFuZGxlci5vbignKicsIHRoaXMuX2JvdW5kQnViYmxlU3Vic2NyaWJlckV2ZW50cylcbiAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLmFkZFNvdXJjZSh1cmwsIG1pbWVUeXBlLCBvcHRpb25zKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5DT05ORUNUX1NVQ0NFU1MpKVxuICAgICAgICB0aGlzLl90cmFja1N0cmVhbWluZ01vZGVTdGF0ZSh0aGlzLl9zb3VyY2VIYW5kbGVyKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICBlcnJvcihOQU1FLCAnQ291bGQgbm90IGVzdGFibGlzaCBhbiBITFMgU3Vic2NyaWJlcjogJyArIGVycilcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFKSlcbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBub3RpZmljYXRpb24gb24gY2hhbmdlIG9mIHN0cmVhbWluZ01vZGUgd2hpY2ggcmVsYXRlcyB0byBhdWRpby92aWRlbyBtdXRlIG9mIGJyb2FkY2FzdC1zaWRlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gbm90aWZpZXJcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90cmFja1N0cmVhbWluZ01vZGVTdGF0ZSAobm90aWZpZXIpIHtcbiAgICBub3RpZmllci5vbihTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVFJFQU1JTkdfTU9ERV9DSEFOR0UsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHsgXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBzdHJlYW1pbmdNb2RlLFxuICAgICAgICAgIHByZXZpb3VzU3RyZWFtaW5nTW9kZVxuICAgICAgICB9XG4gICAgICB9ID0gZXZlbnRcbiAgICAgIGlmIChzdHJlYW1pbmdNb2RlICE9PSAnRW1wdHknICYmIHByZXZpb3VzU3RyZWFtaW5nTW9kZSA9PT0gJ0VtcHR5Jykge1xuICAgICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc3RyZWFtTmFtZSxcbiAgICAgICAgICBtaW1lVHlwZVxuICAgICAgICB9ID0gdGhpcy5fb3B0aW9uc1xuICAgICAgICBjb25zdCB1cmwgPSBzdHJlYW1OYW1lLm1hdGNoKHVybFJlZ2V4KSA/IHN0cmVhbU5hbWUgOiBvcHRpb25zVG9IbHNVUkwodGhpcy5fb3B0aW9ucylcbiAgICAgICAgdGhpcy5fc291cmNlSGFuZGxlci5hZGRTb3VyY2UodXJsLCBtaW1lVHlwZSwgdGhpcy5fb3B0aW9ucylcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmUoKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKGVycm9yID0+IGVycm9yKE5BTUUsIGVycm9yKSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gaW5pdGlhbGl6ZSB0aGUgSExTLWJhc2VkIFN1YnNjcmliZXIgYmFzZWQgb24gY29uZmlndXJhdGlvbi5cbiAgICogVGhlIHJldHVybmVkIGBQcm9taXNlYCB3aWxsIGVpdGhlciByZXNvbHZlIHdpdGggYSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZSBvciByZWplY3Qgd2l0aCBhbiBlcnJvciBgU3RyaW5nYCBpbiBmYWlsdXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgVGhlIGluaXRpYWxpemF0aW9uIGNvbmZpZ3VyYXRpb24gbWFwLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgaW5pdCAob3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgaWYgKCFlbnZpcm9ubWVudC5zdXBwb3J0c0hMUygpKSB7XG4gICAgICB3YXJuKE5BTUUsIGBDb3VsZCBub3QgcmVzb2x2ZSBITFNTdWJzY3JpYmVyIGluc3RhbmNlLmApXG4gICAgICBkZWZlcnJlZC5yZWplY3QoYENvdWxkIG5vdCByZXNvbHZlIEhMU1N1YnNjcmliZXIgaW5zdGFuY2UuYClcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuY29ubmVjdGlvblBhcmFtcyAmJiAhd2Vic29ja2V0LmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgIC8vIElmIGBjb25uZWN0aW9uUGFyYW1zYCBhcmUgcHJvdmlkZWQgaW4gdGhlIGluaXQgY29uZmlnLFxuICAgICAgLy8gIHRoZW4gYSBzdWJzZXF1ZW50IHZhbGlkYXRpb24gY2FsbCBpcyBtYWRlIG9uIGEgV2ViU29ja2V0IHRvIFxuICAgICAgLy8gIGVuc3VyZSB0aGF0IHRoaXMgY2xpZW50IGlzIGFsbG93ZWQgYWNjZXNzLlxuICAgICAgd2FybihOQU1FLCBgQ291bGQgbm90IHJlc29sdmUgSExTU3Vic2NyaWJlciBpbnN0YW5jZSB3aXRoIGNvbm5lY3Rpb24gcGFyYW1zLiBXZWJTb2NrZXQgc3VwcG9ydCBpcyByZXF1aXJlZC5gKVxuICAgICAgZGVmZXJyZWQucmVqZWN0KE5BTUUsIGBDb3VsZCBub3QgcmVzb2x2ZSBITFNTdWJzY3JpYmVyIGluc3RhbmNlIHdpdGggY29ubmVjdGlvbiBwYXJhbXMuIFdlYlNvY2tldCBzdXBwb3J0IGlzIHJlcXVpcmVkLmApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucylcbiAgICAgIGNvbnN0IHNvY2tldFByb21pc2UgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLmNvbm5lY3Rpb25QYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLl9zb2NrZXRIZWxwZXIgPSBuZXcgU29ja2V0SGVscGVyKHRoaXMsICdITFNTdWJzY3JpcHRpb25Tb2NrZXQnKVxuICAgICAgICAgIGNvbnN0IHNvY2tldHVybCA9IGVuZHBvaW50RnJvbU9wdGlvbnModGhpcy5fb3B0aW9ucywge1xuICAgICAgICAgICAgaWQ6IHRoaXMuX29wdGlvbnMuc3Vic2NyaXB0aW9uSWRcbiAgICAgICAgICB9KVxuICAgICAgICAgIHRoaXMuX3NvY2tldEhlbHBlci5zZXRVcChzb2NrZXR1cmwsIHNvY2tldFByb21pc2UpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBlcnJvcihOQU1FLCBlLm1lc3NhZ2UpXG4gICAgICAgICAgZGVmZXJyZWQucmVqZWN0KE5BTUUsIGBDb3VsZCBub3Qgc2V0IHVwIFdlYlNvY2tldCBmb3IgYXV0aGVudGljYXRpb24gd2l0aCBjb25uZWN0aW9uUGFyYW1zOiAke2UubWVzc2FnZX1gKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb2NrZXRQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfVxuICAgICAgc29ja2V0UHJvbWlzZS5wcm9taXNlXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAvLyBUZWFyIGRvd24gc29ja2V0IGhlbHBlciBpZiBleGlzdHMuXG4gICAgICAgICAgLy8gV2Ugb25seSBuZWVkZWQgaXQgdG8gZG8gdmFsaWRhdGlvbiB3aXRoIG9wdGlvbmFsIGNvbm5lY3Rpb25QYXJhbXMuXG4gICAgICAgICAgaWYgKHRoaXMuX3NvY2tldEhlbHBlcikge1xuICAgICAgICAgICAgdGhpcy5fc29ja2V0SGVscGVyLnRlYXJEb3duKClcbiAgICAgICAgICAgIHRoaXMuX3NvY2tldEhlbHBlciA9IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zZXRWaWV3SWZOb3RFeGlzdCh0aGlzLl92aWV3LCB0aGlzLl9vcHRpb25zLm1lZGlhRWxlbWVudElkKVxuICAgICAgICAgIHRoaXMuX2dldFZpZXdSZXNvbHZlclByb21pc2UoKVxuICAgICAgICAgICAgLnRoZW4odmlldyA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIgPSBuZXcgSExTU291cmNlSGFuZGxlcih2aWV3LnZpZXcsIHRoaXMuZ2V0VHlwZSgpKVxuICAgICAgICAgICAgICB0aGlzLl9nbG9tU291cmNlSGFuZGxlckFQSSh0aGlzLl9zb3VyY2VIYW5kbGVyKVxuICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRIYW5kbGVyKHRoaXMuX29wdGlvbnMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0aGlzKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcilcbiAgICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5DT05ORUNUX0ZBSUxVUkUsIHRoaXMsIGVycm9yKSlcbiAgICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGlsbCBpbiB1c2UgZm9yIGFzc2lnbmluZyBkb2N1bWVudCBlbGVtZW50IHZpZXcgbWFuYWdlbWVudCB0byB0aGlzIGluc3RhbmNlLlxuICAgKiBBUEkgZGVwcmVjYXRlZCBpbiA0LjAuMC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFZpZXcgKHZpZXcpIHtcbiAgICB0aGlzLl92aWV3ID0gdmlld1xuICAgIHRoaXMuX3ZpZXdSZXNvbHZlci5yZXNvbHZlKHZpZXcpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGJlZ2luIHN1YnNjcmliaW5nIHRvIGEgc3RyZWFtLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgICAgICAgICBUaGUgcmV0dXJuZWQgYFByb21pc2VgIHdpbGwgcmVzb2x2ZSBvciByZWplY3Qgb24gc3VjY2Vzc2Z1bCBzdGFydCBvZiBwbGF5YmFjay5cbiAgICovXG4gIHN1YnNjcmliZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFN1YnNjcmlwdGlvblJlc29sdmVyUHJvbWlzZSgpXG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBzdG9wIGEgc3Vic2NyaXB0aW9uLlxuICAgKiBUaGUgcmV0dXJuZWQgYFByb21pc2VgIHdpbGwgZWl0aGVyIHJlc29sdmUgb3IgcmVqZWN0IG9uIHN1Y2Nlc3NmdWwgc3RvcCBvZiBzdWJzY3JpcHRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICB1bnN1YnNjcmliZSAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1t1bnNjdWJzY3JpYmVdJylcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGlmICh0aGlzLl9zb2NrZXRIZWxwZXIpIHtcbiAgICAgIHRoaXMuX3NvY2tldEhlbHBlci50ZWFyRG93bigpXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLnN0b3AoKVxuICAgICAgdGhpcy5fc291cmNlSGFuZGxlci5kaXNjb25uZWN0KClcbiAgICAgIGRlZmVycmVkLnJlc29sdmUoKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlZmVycmVkLnJlamVjdChlLm1lc3NhZ2UpXG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjb25uZWN0aW9uIGhhbmRsZXIgZm9yIHBsYXliYWNrLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRDb25uZWN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlSGFuZGxlclxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgcmVmZXJlbmNlIHRvIHBsYXliYWNrIGNvbnRyb2xzIGlmIGF2YWlsYWJsZS5cbiAgICpcbiAgICogQHJldHVybiB7UGxheWJhY2tDb250cm9sc31cbiAgICovXG4gIGdldENvbnRyb2xzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlSGFuZGxlciA/IHRoaXMuX3NvdXJjZUhhbmRsZXIuZ2V0Q29udHJvbHMoKSA6IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluaXRpYWxpemF0aW9uIGNvbmZpZ3VyYXRpb24gdXNlZCBpbiBgaW5pdCgpYC5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0T3B0aW9ucyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0YXJnZXQgdmlldyBFbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgZ2V0UGxheWVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlldy52aWV3XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdHlwZSBvZiBpbXBsZW1lbnRhdGlvbjogYFJUQ2AuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldFR5cGUgKCkge1xuICAgIHJldHVybiBQbGF5YmFja1R5cGVzLkhMUy50b1VwcGVyQ2FzZSgpXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBITFNTdWJzY3JpYmVyXG4iLCJpbXBvcnQgeyBkZWJ1ZywgZXJyb3IgfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnV2hpcFdoZXBTaWduYWxpbmdIZWxwZXInXG5cbi8qKlxuICogQ29udmVydHMgYSBMaW5rIGhlYWRlciBpbnRvIGEgTWFwIG9mIHByb3BzIGZvciBlYXNpZXIgcGFyc2luZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBsaW5rXG4gKiBAcmV0dXJucyBNYXBcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBoZWFkZXJMaW5rVG9PYmplY3QgPSAobGluaykgPT4ge1xuICBsZXQgYXR0cyA9IGxpbmsuc3BsaXQoJzsnKS5tYXAoKHMpID0+IHMudHJpbSgpKVxuICBsZXQgcHJvcHMgPSBhdHRzLm1hcCgocykgPT4ge1xuICAgIGlmIChzLmNoYXJBdCgwKSA9PT0gJzwnKSB7XG4gICAgICByZXR1cm4gWyd1cmwnLCBzLnN1YnN0cmluZygxLCBzLmxlbmd0aCAtIDEpXVxuICAgIH1cbiAgICByZXR1cm4gcy5zcGxpdCgnPScpXG4gIH0pXG4gIHJldHVybiBwcm9wcy5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjLnNldChjdXJyWzBdLCBjdXJyWzFdKSwgbmV3IE1hcCgpKVxufVxuXG4vKipcbiAqIFBhcnNlcyBsaW5rIHVybCBpbnRvIHByb3RvY29sIGFuZCBob3N0IGZvciBlYXNlIGluIGFzc2VtYmxlIGZvciBjcmVkZW50aWFsZWQgbGlua3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcmV0dXJucyBPYmplY3QgeyBwcm90b2NvbCwgaG9zdCB9XG4gKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgZ2V0SG9zdEFuZFByb3RvY29sRnJvbUxpbmtVcmwgPSAodXJsKSA9PiB7XG4gIGNvbnN0IHBhcnRzID0gdXJsLnNwbGl0KCc6JylcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4geyBwcm90b2NvbDogcGFydHNbMF0sIGhvc3Q6IHBhcnRzWzFdIH1cbiAgfVxuICByZXR1cm4geyBwcm90b2NvbDogdW5kZWZpbmVkLCBob3N0OiB1cmwgfVxufVxuXG5jbGFzcyBXaGlwV2hlcFNpZ25hbGluZ0hlbHBlciB7XG4gIGNvbnN0cnVjdG9yKHVybCkge1xuICAgIHRoaXMuX3VybCA9IHVybFxuICAgIC8vIHRoaXMuX3Jlc291cmNlID0gdXJsLnJlcGxhY2UoL1xcL2VuZHBvaW50XFwvLywgJy9yZXNvdXJjZS8nKVxuICAgIHRoaXMuX3Jlc291cmNlID0gdW5kZWZpbmVkXG4gIH1cblxuICBhc3luYyBnZXRPcHRpb25zKCkge1xuICAgIGRlYnVnKE5BTUUsIGBbd2hpcHdoZXAtb3B0aW9uc10gJHt0aGlzLl91cmx9YClcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLl91cmwsIHtcbiAgICAgICAgbWV0aG9kOiAnT1BUSU9OUycsXG4gICAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgIH0pXG4gICAgICBjb25zdCB7IHN0YXR1cywgaGVhZGVycyB9ID0gcmVzcG9uc2VcbiAgICAgIGlmIChzdGF0dXMgPT09IDIwMCB8fCBzdGF0dXMgPT09IDIwNCkge1xuICAgICAgICBjb25zdCBoZWFkZXJSZWcgPSAvXihMfGwpaW5rL1xuICAgICAgICBjb25zdCBsaW5rcyA9IFtdXG4gICAgICAgIGhlYWRlcnMuZm9yRWFjaCgoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGlmIChoZWFkZXJSZWcuZXhlYyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZigncmVsPVwiaWNlLXNlcnZlclwiJykgPiAtMSkge1xuICAgICAgICAgICAgICBjb25zdCBsaW5rID0gaGVhZGVyTGlua1RvT2JqZWN0KGtleSlcbiAgICAgICAgICAgICAgY29uc3QgdXJsID0gbGluay5nZXQoJ3VybCcpXG4gICAgICAgICAgICAgIGNvbnN0IHsgcHJvdG9jb2wsIGhvc3QgfSA9IGdldEhvc3RBbmRQcm90b2NvbEZyb21MaW5rVXJsKHVybClcbiAgICAgICAgICAgICAgY29uc3QgdXNlcm5hbWUgPSBsaW5rLmdldCgndXNlcm5hbWUnKVxuICAgICAgICAgICAgICBjb25zdCBwYXNzd29yZCA9IGxpbmsuZ2V0KCdjcmVkZW50aWFsJylcbiAgICAgICAgICAgICAgaWYgKHByb3RvY29sICYmIGhvc3QgJiYgdXNlcm5hbWUgJiYgcGFzc3dvcmQpIHtcbiAgICAgICAgICAgICAgICBsaW5rcy5wdXNoKGAke3Byb3RvY29sfTovLyR7dXNlcm5hbWV9OiR7cGFzc3dvcmR9QCR7aG9zdH1gKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHVybCkge1xuICAgICAgICAgICAgICAgIGxpbmtzLnB1c2godXJsKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBkZWJ1ZyhOQU1FLCBgW3doaXB3aGVwLWxpbmtzXTogJHtsaW5rc31gKVxuICAgICAgICByZXR1cm4geyBsaW5rczogbGlua3MubGVuZ3RoID4gMCA/IFt7IHVybHM6IGxpbmtzLmxlbmd0aCA+IDEgPyBsaW5rcyA6IGxpbmtzWzBdIH1dIDogdW5kZWZpbmVkIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcihOQU1FLCBlLm1lc3NhZ2UpXG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBvc3RzIG9mZmVyIHRvIFdISVAgZW5kcG9pbnQgYW5kIHJlc29sdmVzIHdpdGggYW5zd2VyIFNEUCBhbmQgbG9jYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZHBcbiAgICogQHJldHVybnMge29iamVjdH0geyBzZHA6KHN0cmluZyksIGxvY2F0aW9uOihzdHJpbmcpfVxuICAgKi9cbiAgYXN5bmMgcG9zdFNEUE9mZmVyKHNkcCkge1xuICAgIGRlYnVnKE5BTUUsIGBbd2hpcHdoZXAtcG9zdF0gJHt0aGlzLl91cmx9OiBgICsgSlNPTi5zdHJpbmdpZnkoc2RwLCBudWxsLCAyKSlcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLl91cmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vc2RwJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogc2RwLFxuICAgICAgfSlcbiAgICAgIGNvbnN0IHsgc3RhdHVzLCBoZWFkZXJzIH0gPSByZXNwb25zZVxuICAgICAgaWYgKHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgIGxldCBhbnN3ZXJTRFAgPSBhd2FpdCByZXNwb25zZS50ZXh0KClcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBoZWFkZXJzLmdldCgnTG9jYXRpb24nKVxuICAgICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgICBpZiAobG9jYXRpb24ubWF0Y2goL14oaHR0cHxodHRwcykvKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb3VyY2UgPSBsb2NhdGlvblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBuZXcgVVJMKHRoaXMuX3VybClcbiAgICAgICAgICAgIC8vIHBhcnNlZC5wYXRobmFtZSA9IGxvY2F0aW9uXG4gICAgICAgICAgICB0aGlzLl9yZXNvdXJjZSA9IHBhcnNlZC50b1N0cmluZygpXG4gICAgICAgICAgfVxuICAgICAgICAgIGRlYnVnKE5BTUUsIGBbd2hpcHdoZXAtcmVzcG9uc2VdICR7dGhpcy5fcmVzb3VyY2V9OiAke2Fuc3dlclNEUH1gKVxuICAgICAgICAgIHJldHVybiB7IHNkcDogYW5zd2VyU0RQLCBsb2NhdGlvbjogdGhpcy5fcmVzb3VyY2UgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTG9jYXRpb24gbm90IHByb3ZpZGVkIGluIGhlYWRlciByZXNwb25zZSB0byBPZmZlci4nKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDA1KSB7XG4gICAgICAgIC8vIGRlYnVnKE5BTUUsICdSZW1lbWJlciB0byB1cGRhdGUgdGhlIFVSTCBwYXNzZWQgaW50byB0aGUgV0hJUCBvciBXSEVQIGNsaWVudC4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbWVtYmVyIHRvIHVwZGF0ZSB0aGUgVVJMIHBhc3NlZCBpbnRvIHRoZSBXSElQIG9yIFdIRVAgY2xpZW50LicpXG4gICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDA2KSB7XG4gICAgICAgIC8vIGRlYnVnKE5BTUUsICdTdHJlYW0gbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8gcHVibGlzaCBvciBzdWJzY3JpYmUgdG8uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJlYW0gbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8gcHVibGlzaCBvciBzdWJzY3JpYmUgdG8uJylcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDkpIHtcbiAgICAgICAgLy8gZGVidWcoTkFNRSwgJ1N0cmVhbSByZWplY3RlZC4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmVhbSByZWplY3RlZC4nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpXG4gICAgICAgIHRocm93IEVycm9yKGVycm9yTWVzc2FnZSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcihOQU1FLCBlLm1lc3NhZ2UpXG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgdHJpY2tsZShzZHApIHtcbiAgICBkZWJ1ZyhOQU1FLCBgW3doaXB3aGVwLXRyaWNrbGVdICR7dGhpcy5fcmVzb3VyY2V9OiBgICsgSlNPTi5zdHJpbmdpZnkoc2RwLCBudWxsLCAyKSlcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLl9yZXNvdXJjZSwge1xuICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vdHJpY2tsZS1pY2Utc2RwZnJhZycsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IHNkcCxcbiAgICAgIH0pXG4gICAgICBjb25zdCB7IHN0YXR1cywgaGVhZGVycyB9ID0gcmVzcG9uc2VcbiAgICAgIGlmIChzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCkge1xuICAgICAgICAvLyA/P1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpXG4gICAgICAgIGRlYnVnKE5BTUUsIGBbd2hpcHdoZXAtcmVzcG9uc2VdICR7dGhpcy5fcmVzb3VyY2V9OiAke2NhbmRpZGF0ZX1gKVxuICAgICAgICByZXR1cm4geyBjYW5kaWRhdGUgfVxuICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwNSkge1xuICAgICAgICBjb25zb2xlLmxvZygnUmVtZW1iZXIgdG8gdXBkYXRlIHRoZSBVUkwgcGFzc2VkIGludG8gdGhlIFdISVAgb3IgV0hFUCBjbGllbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbWVtYmVyIHRvIHVwZGF0ZSB0aGUgVVJMIHBhc3NlZCBpbnRvIHRoZSBXSElQIG9yIFdIRVAgY2xpZW50JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICAgICAgICB0aHJvdyBFcnJvcihlcnJvck1lc3NhZ2UpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKVxuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHRlYXJEb3duKCkge1xuICAgIGlmICghdGhpcy5fcmVzb3VyY2UpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBkZWJ1ZyhOQU1FLCBgW3doaXB3aGVwLXRlYXJkb3duXWApXG4gICAgYXdhaXQgZmV0Y2godGhpcy5fcmVzb3VyY2UsIHtcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICBtb2RlOiAnY29ycycsXG4gICAgfSlcbiAgICB0aGlzLl91cmwgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9yZXNvdXJjZSA9IHVuZGVmaW5lZFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFdoaXBXaGVwU2lnbmFsaW5nSGVscGVyXG4iLCJpbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgKiBhcyB3ZWJydGMgZnJvbSAnLi4vYWRhcHRlci93ZWJydGMnXG5pbXBvcnQgeyBvcHRpb25zRnJvbVdoaXBXaGVwVXJsIH0gZnJvbSAnLi4vdXRpbC91cmwtZW5kcG9pbnQnXG5pbXBvcnQgUlRDU3Vic2NyaWJlciBmcm9tICcuL3JlZDVwcm8tcnRjJ1xuaW1wb3J0IHsgZGVidWcsIHdhcm4sIGVycm9yLCBMRVZFTFMgfSBmcm9tICcuLi9sb2cnXG5pbXBvcnQgeyBJY2VUcmFuc3BvcnRUeXBlcyB9IGZyb20gJy4uL2VudW0vd2VicnRjJ1xuaW1wb3J0IFJUQ1NlZWthYmxlU291cmNlSGFuZGxlciBmcm9tICcuL3JlZDVwcm8tc291cmNlLWhhbmRsZXItcnRjLXNlZWthYmxlJ1xuaW1wb3J0IFJUQ1NvdXJjZUhhbmRsZXIgZnJvbSAnLi9yZWQ1cHJvLXNvdXJjZS1oYW5kbGVyLXJ0YydcbmltcG9ydCB7IFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLCBTdWJzY3JpYmVyRXZlbnQsIFN1YnNjcmliZXJFdmVudFR5cGVzIH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgU3Vic2NyaXB0aW9uUGVlckhlbHBlciBmcm9tICcuLi9oZWxwZXIvd2VicnRjLWhlbHBlci1zdWInXG5pbXBvcnQgV2hpcFdoZXBTaWduYWxpbmdIZWxwZXIgZnJvbSAnLi4vaGVscGVyL3doaXB3aGVwLXNpZ25hbGluZy1oZWxwZXInXG5cbmNvbnN0IE5BTUUgPSAnV0hFUENsaWVudCdcbmNvbnN0IElDRV9HQVRIRVJfVElNRU9VVCA9IDEwMDBcblxuLyoqXG4gKiBTaW1wbGUgZ2VuZXJhdGlvbiBvZiB1bmlxdWUgc3Vic2NyaWJlciBpZC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgZ2VuZXJhdGVTdWJzY3JpcHRpb25JZCA9ICgpID0+IHtcbiAgY29uc3QgaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweDEwMDAwKS50b1N0cmluZygxNilcbiAgcmV0dXJuIGBzdWJzY3JpYmVyLSR7aWR9YFxufVxuXG4vLyBEZWZhdWx0IHRvIHNlY3VyZSBzZXR0aW5ncy5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBwcm90b2NvbDogJ3dzcycsXG4gIHBvcnQ6IDQ0MyxcbiAgYXBwOiAnbGl2ZScsXG4gIGF1dG9MYXlvdXRPcmllbnRhdGlvbjogdHJ1ZSxcbiAgbWVkaWFFbGVtZW50SWQ6ICdyZWQ1cHJvLXN1YnNjcmliZXInLFxuICBydGNDb25maWd1cmF0aW9uOiB7XG4gICAgaWNlU2VydmVyczogW3sgdXJsczogJ3N0dW46c3R1bjIubC5nb29nbGUuY29tOjE5MzAyJyB9XSxcbiAgICBpY2VDYW5kaWRhdGVQb29sU2l6ZTogMixcbiAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgfSwgLy8gRmF2b3JlZCBvdmVyIGljZVNlcnZlcnMuXG4gIGljZVNlcnZlcnM6IHVuZGVmaW5lZCwgLy8gRGVwcmVjYXRlZC4gUHJlc2VydmVkIGZvciBiYWNrd2FyZC1jb21wYXRpYmlsaXR5LlxuICBpY2VUcmFuc3BvcnQ6IEljZVRyYW5zcG9ydFR5cGVzLlVEUCxcbiAgbXV0ZU9uQXV0b3BsYXlSZXN0cmljdGlvbjogdHJ1ZSxcbiAgbWFpbnRhaW5Db25uZWN0aW9uT25TdWJzY3JpYmVFcnJvcnM6IGZhbHNlLFxuICBzaWduYWxpbmdTb2NrZXRPbmx5OiBmYWxzZSwgLy8gTm8gREMgaW4gU0RQIGF0IHRoZSBtb21lbnRcbiAgZGF0YUNoYW5uZWxDb25maWd1cmF0aW9uOiB1bmRlZmluZWQsXG4gIHNvY2tldFN3aXRjaERlbGF5OiAxMDAwLFxuICBieXBhc3NBdmFpbGFibGU6IGZhbHNlLFxuICBtYWludGFpblN0cmVhbVZhcmlhbnQ6IGZhbHNlLFxuICBlbmFibGVMaXZlU2VlazogZmFsc2UsXG4gIHRyaWNrbGVJY2U6IGZhbHNlLCAvLyBGbGFnIHRvIHVzZSB0cmlja2xlIGljZSB0byBzZW5kIGNhbmRpZGF0ZXNcbn1cblxuY2xhc3MgV0hFUENsaWVudCBleHRlbmRzIFJUQ1N1YnNjcmliZXIge1xuICAvKipcbiAgICogQ29uc3RydWN0b3IuIFByb3ZpZGluZyBhcmd1bWVudHMgd2lsbCBhdXRvbWF0aWNhbGx5IGtpY2sgb2YgY29ubmVjdGlvbiBzZXF1ZW5jZS5cbiAgICogTGVhdmluZyBhcmd1bWVudHMgdW5zZXQgYWxsb3dzIGZvciBtb3JlIGNvbnRyb2wgYW5kIGZvbGxvd3Mgc2FtZSBwYXR0ZXJuIG9mIGluaXQgLT4gc3Vic2NyaWJlIGFzIFJUQ1N1YnNjcmliZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgT3B0aW9uYWwgZW5kcG9pbnQgZm9yIFdIRVAuIEV4YW1wbGU6IGh0dHBzOi8veW91ci1yZWQ1cHJvLmNvbS9saXZlL3doZXAvZW5kcG9pbnQvc3RyZWFtMVxuICAgKiBAcGFyYW0ge0hUTUxNZWRpYUVsZW1lbnR9IGVsZW1lbnQgT3B0aW9uYWwgbWVkaWEgZWxlbWVudCB0byBwbGF5IG1lZGlhIGluLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRyaWNrbGVJY2UgT3B0aW9uYWwgcmVxdWVzdCB0byB0cmlja2xlIGNhbmRpZGF0ZXMuIFByZWZlcnJlZDogZmFsc2UsIHNlbmQgd2l0aCBTRFAgb2ZmZXIuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1cmwsIGVsZW1lbnQsIHRyaWNrbGVJY2UgPSBmYWxzZSkge1xuICAgIHN1cGVyKClcbiAgICBjb25zdCBvcHRpb25zRnJvbVVybCA9IHVybCA/IG9wdGlvbnNGcm9tV2hpcFdoZXBVcmwodXJsKSA6IGRlZmF1bHRPcHRpb25zXG4gICAgb3B0aW9uc0Zyb21VcmwubWVkaWFFbGVtZW50SWQgPSBlbGVtZW50ID8gZWxlbWVudC5pZCA6IGRlZmF1bHRPcHRpb25zLm1lZGlhRWxlbWVudElkXG4gICAgb3B0aW9uc0Zyb21VcmwudHJpY2tsZUljZSA9IHRyaWNrbGVJY2VcblxuICAgIHRoaXMuX3doaXBIZWxwZXIgPSB1bmRlZmluZWRcblxuICAgIGlmICh1cmwpIHtcbiAgICAgIHRoaXMuX2ludGVybmFsQ29ubmVjdChvcHRpb25zRnJvbVVybClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgY29ubmVjdGlvbiBzZXF1ZW5jZSBpZiB1c2VkIGNvbnN0cnVjdG9yIHdpdGggYXJndW1lbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgVGhlIGluaXRpYWxpemF0aW9uIGNvbmZpZ3VyYXRpb24gbWFwLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgX2ludGVybmFsQ29ubmVjdChvcHRpb25zKSB7XG4gICAgYXdhaXQgdGhpcy5pbml0KG9wdGlvbnMpXG4gICAgYXdhaXQgdGhpcy5zdWJzY3JpYmUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgZ2F0aGVyaW5nIHN0YXRlIGNvbXBsZXRlIGZvciBJQ0UuXG4gICAqXG4gICAqIEBwYXJhbSB7UlRDUGVlckNvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAgICogQHJldHVybnMgUHJvbWlzZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgd2FpdFRvR2F0aGVySWNlKGNvbm5lY3Rpb24pIHtcbiAgICBjb25uZWN0aW9uLmFkZFRyYW5zY2VpdmVyKCd2aWRlbycsIHsgZGlyZWN0aW9uOiAncmVjdm9ubHknIH0pXG4gICAgY29ubmVjdGlvbi5hZGRUcmFuc2NlaXZlcignYXVkaW8nLCB7IGRpcmVjdGlvbjogJ3JlY3Zvbmx5JyB9KVxuXG4gICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCBjb25uZWN0aW9uLmNyZWF0ZU9mZmVyKClcbiAgICBjb25uZWN0aW9uLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmIChjb25uZWN0aW9uLmljZUdhdGhlcmluZ1N0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgIHJlc29sdmUoeyBvZmZlciwgbG9jYWw6IGNvbm5lY3Rpb24ubG9jYWxEZXNjcmlwdGlvbiB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZSh7IG9mZmVyLCBsb2NhbDogY29ubmVjdGlvbi5sb2NhbERlc2NyaXB0aW9uIH0pXG4gICAgICAgIH0sIElDRV9HQVRIRVJfVElNRU9VVClcbiAgICAgICAgY29ubmVjdGlvbi5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgIGNvbm5lY3Rpb24uaWNlR2F0aGVyaW5nU3RhdGUgPT09ICdjb21wbGV0ZScgJiYgcmVzb2x2ZSh7IG9mZmVyLCBsb2NhbDogY29ubmVjdGlvbi5sb2NhbERlc2NyaXB0aW9uIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgY2FuZGlkYXRlIHRvIHRoZSBzZXJ2ZXIgb3ZlciBXSEVQLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FuZGlkYXRlXG4gICAqICAgICAgICBUaGUgcGVlciBjYW5kaWRhdGUgZGVzY3JpcHRpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VuZENhbmRpZGF0ZShjYW5kaWRhdGUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3NlbmRjYW5kaWRhdGVdJylcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVENTdWJzY3JpYmVyRXZlbnRUeXBlcy5DQU5ESURBVEVfU1RBUlQsIHRoaXMsIGNhbmRpZGF0ZSkpXG4gIH1cblxuICAvKipcbiAgICogUE9TVHMgU0RQIHRvIFdIRVAgZW5kcG9pbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UlRDU2Vzc2lvbkRlc2NyaXB0aW9ufSBzZXNzaW9uRGVzY3JpcHRpb25cbiAgICpcbiAgICogQHJldHVybnMgeyBzZHAsIGxvY2F0aW9uIH1cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIF9wb3N0T2ZmZXIoc2Vzc2lvbkRlc2NyaXB0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl93aGlwSGVscGVyLnBvc3RTRFBPZmZlcihzZXNzaW9uRGVzY3JpcHRpb24uc2RwKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yKE5BTUUsIGUubWVzc2FnZSB8fCBlKVxuICAgICAgdGhpcy5vblN0cmVhbVVuYXZhaWxhYmxlKGUpXG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIENhbmRpZGF0ZXMgYXMgUEFUQ0ggdG8gV0hFUCBlbmRwb2ludC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNkcCBUaGUgU0RQIHdpdGggY2FuZGlkYXRlc1xuICAgKiBAcmV0dXJucyBQcm9taXNlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBfcG9zdENhbmRpZGF0ZUZyYWdtZW50cyhzZHApIHtcbiAgICBjb25zdCBob3N0RnJhZyA9IHdlYnJ0Yy5nZW5lcmF0ZVNEUENhbmRpZGF0ZUZyYWcoc2RwLCAnaG9zdCcpXG4gICAgY29uc3Qgc3JmbHhGcmFnID0gd2VicnRjLmdlbmVyYXRlU0RQQ2FuZGlkYXRlRnJhZyhzZHAsICdzcmZseCcsIHRydWUpXG4gICAgYXdhaXQgdGhpcy5fd2hpcEhlbHBlci50cmlja2xlKGhvc3RGcmFnKVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBwb3N0U3JmbHggPSAoKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IHRoaXMuX3doaXBIZWxwZXIudHJpY2tsZShzcmZseEZyYWcpXG4gICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgIH0sIDE1MClcbiAgICAgIH1cbiAgICAgIHBvc3RTcmZseCgpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IG9mZmVyIG92ZXIgV0hFUCBzZXJ2aWNlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgX3JlcXVlc3RPZmZlcigpIHtcbiAgICBjb25zdCB7IHRyaWNrbGVJY2UgfSA9IHRoaXMuX29wdGlvbnNcbiAgICBjb25zdCBjb25uZWN0aW9uID0gdGhpcy5nZXRQZWVyQ29ubmVjdGlvbigpXG4gICAgLy8gb2ZmZXI6IHRoZSBvcmlnaW4gb2ZmZXIgU0RQXG4gICAgLy8gbG9jYWw6IHRoZSBsb2NhbCBkZXNjcmlwdGlvbiB3aXRoIGFsbCBjYW5kaWRhdGVzXG4gICAgbGV0IHsgb2ZmZXIsIGxvY2FsIH0gPSBhd2FpdCB0aGlzLndhaXRUb0dhdGhlckljZShjb25uZWN0aW9uKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLk9GRkVSX1NUQVJULCB0aGlzKSlcbiAgICBjb25zdCB7IHNkcCB9ID0gYXdhaXQgdGhpcy5fcG9zdE9mZmVyKHRyaWNrbGVJY2UgPyBvZmZlciA6IGxvY2FsKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLk9GRkVSX0VORCwgdGhpcykpXG4gICAgYXdhaXQgY29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbihuZXcgd2VicnRjLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7IHR5cGU6ICdhbnN3ZXInLCBzZHAgfSkpXG4gICAgaWYgKHRyaWNrbGVJY2UpIHtcbiAgICAgIGNvbnN0IHsgc2RwIH0gPSBsb2NhbFxuICAgICAgYXdhaXQgdGhpcy5fcG9zdENhbmRpZGF0ZUZyYWdtZW50cyhzZHApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3QgYW5kIHRlYXJkb3duIGFmdGVyIGNsb3NlIG9mIHN1YnNjcmlwdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kaXNjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLl93aGlwSGVscGVyKSB7XG4gICAgICB0aGlzLl93aGlwSGVscGVyLnRlYXJEb3duKClcbiAgICB9XG4gICAgdGhpcy5fd2hpcEhlbHBlciA9IHVuZGVmaW5lZFxuICAgIHN1cGVyLl9kaXNjb25uZWN0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGluaXRpYWxpemUgdGhlIFdlYlJUQy1iYXNlZCBTdWJzY3JpYmVyIGJhc2VkIG9uIGNvbmZpZ3VyYXRpb24uXG4gICAqIFRoZSByZXR1cm5lZCBgUHJvbWlzZWAgd2lsbCBlaXRoZXIgcmVzb2x2ZSB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2Ugb3IgcmVqZWN0IHdpdGggYW4gZXJyb3IgYFN0cmluZ2AgaW4gZmFpbHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFRoZSBpbml0aWFsaXphdGlvbiBjb25maWd1cmF0aW9uIG1hcC5cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGluaXQob3B0aW9ucykge1xuICAgIGlmICghd2VicnRjLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBjcmVhdGUgV2ViUlRDIHBsYXliYWNrIGluc3RhbmNlLiBZb3VyIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgV2ViUlRDIGFuZC9vciBXZWJTb2NrZXRzLidcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGlzY29ubmVjdCgpXG4gICAgICB0aGlzLl9vcHRpb25zID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9XG4gICAgICB0aGlzLl9vcHRpb25zLnN1YnNjcmlwdGlvbklkID0gdGhpcy5fb3B0aW9ucy5zdWJzY3JpcHRpb25JZCB8fCBnZW5lcmF0ZVN1YnNjcmlwdGlvbklkKClcbiAgICAgIGNvbnN0IHsgcHJvdG9jb2wsIGhvc3QsIHBvcnQsIGFwcCwgc3RyZWFtTmFtZSwgc3Vic2NyaXB0aW9uSWQgfSA9IHRoaXMuX29wdGlvbnNcbiAgICAgIGNvbnN0IHByb3RvID0gcHJvdG9jb2wgPT09ICd3cycgPyAnaHR0cCcgOiAnaHR0cHMnXG4gICAgICB0aGlzLl93aGlwVXJsID0gYCR7cHJvdG99Oi8vJHtob3N0fToke3BvcnR9LyR7YXBwfS93aGVwL2VuZHBvaW50LyR7c3RyZWFtTmFtZX0/cmVxdWVzdElkPSR7c3Vic2NyaXB0aW9uSWR9YFxuICAgICAgdGhpcy5fd2hpcEhlbHBlciA9IG5ldyBXaGlwV2hlcFNpZ25hbGluZ0hlbHBlcih0aGlzLl93aGlwVXJsKVxuICAgICAgdGhpcy5fcGVlckhlbHBlciA9IG5ldyBTdWJzY3JpcHRpb25QZWVySGVscGVyKHRoaXMpXG4gICAgICB0aGlzLl9tZXNzYWdlVHJhbnNwb3J0ID0gdGhpcy5fd2hpcEhlbHBlclxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBiZWdpbiBzdWJzY3JpYmluZyB0byBhIHN0cmVhbS5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICAgICAgICAgVGhlIHJldHVybmVkIGBQcm9taXNlYCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IG9uIHN1Y2Nlc3NmdWwgc3RhcnQgb2YgcGxheWJhY2suXG4gICAqICAgICAgICBUaGVyZSBhcmUgc2V2ZXJhbCBwcm9jZXNzZXMgdGhhdCBvY2N1ciBpbiBvcmRlciB0byBlc3RhYmxpc2ggYSBXZWJSVEMgc3Vic2NyaXB0aW9uIHRoYXQgaW52b2x2ZSAtIGJ1dCBhcmUgbm90IGxpbWl0ZWQgdG8gLSBJQ0UgY29tbXVuaWNhdGlvbiBhbmQgYXNzaWduaW5nIG9mIGxvY2FsIGFuZCByZW1vdGUgU0RQcyBvbiBwZWVyIGNvbm5lY3Rpb25zLlxuICAgKi9cbiAgYXN5bmMgc3Vic2NyaWJlKCkge1xuICAgIGNvbnN0IHsgc3RyZWFtTmFtZSwgbWVkaWFFbGVtZW50SWQsIHJ0Y0NvbmZpZ3VyYXRpb24sIGVuYWJsZUxpdmVTZWVrIH0gPSB0aGlzLl9vcHRpb25zXG4gICAgbGV0IHsgc2lnbmFsaW5nU29ja2V0T25seSwgZGF0YUNoYW5uZWxDb25maWd1cmF0aW9uIH0gPSB0aGlzLl9vcHRpb25zXG4gICAgLy8gU2V0IGRlZmF1bHQgZGF0YSBjaGFubmVsIGNvbmZpZ3VyYXRpb24gaWYgbm90IGRlZmluZWQgYW5kIHNldmVyaW5nIHNvY2tldCBvbiBzaWduYWwgZW5kLlxuICAgIC8vIFRPRE86IFNldCB0aGlzIGFzIG1vcmUgXCJwcml2YXRlXCIgd2l0aCBgcmVkNXByby08c3RyZWFtbmFtZT5gXG4gICAgY29uc3QgZGF0YUNoYW5uZWxBbGxvd2VkID0gc2lnbmFsaW5nU29ja2V0T25seSAmJiB3ZWJydGMuc3VwcG9ydHNEYXRhQ2hhbm5lbCgpXG4gICAgaWYgKGRhdGFDaGFubmVsQWxsb3dlZCAmJiAhZGF0YUNoYW5uZWxDb25maWd1cmF0aW9uKSB7XG4gICAgICBkYXRhQ2hhbm5lbENvbmZpZ3VyYXRpb24gPSB7XG4gICAgICAgIG5hbWU6IGByZWQ1cHJvYCxcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdGhpcy5fb3B0aW9ucy5zaWduYWxpbmdTb2NrZXRPbmx5ID0gZGF0YUNoYW5uZWxBbGxvd2VkXG5cbiAgICAvLyBUT0RPOiBEQyB0dXJuZWQgb2ZmIGZvciBub3dcbiAgICB0aGlzLl9vcHRpb25zLnNpZ25hbGluZ1NvY2tldE9ubHkgPSBmYWxzZVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3NldFZpZXdJZk5vdEV4aXN0KHRoaXMuX3ZpZXcsIG1lZGlhRWxlbWVudElkKVxuICAgICAgY29uc3QgdmlldyA9IGF3YWl0IHRoaXMuX2dldFZpZXdSZXNvbHZlclByb21pc2UoKVxuICAgICAgaWYgKGVuYWJsZUxpdmVTZWVrKSB7XG4gICAgICAgIGlmIChlbnZpcm9ubWVudC5zdXBwb3J0c0hMUygpIHx8IGVudmlyb25tZW50LnN1cHBvcnRzTm9uTmF0aXZlSExTKCkpIHtcbiAgICAgICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyID0gbmV3IFJUQ1NlZWthYmxlU291cmNlSGFuZGxlcih2aWV3LnZpZXcsIHRoaXMuZ2V0VHlwZSgpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgTkFNRSxcbiAgICAgICAgICAgIGBDb3VsZCBub3QgdXRpbGl6ZSB0aGUgJ2VuYWJsZUxpdmVTZWVrJyByZXF1ZXN0LiBUaGlzIGZlYXR1cmUgcmVxdWlyZXMgZWl0aGVyIG5hdGl2ZSBITFMgcGxheWJhY2sgb3IgaGxzLmpzIGFzIGEgZGVwZW5lbmN5LmBcbiAgICAgICAgICApXG4gICAgICAgICAgdGhpcy5fc291cmNlSGFuZGxlciA9IG5ldyBSVENTb3VyY2VIYW5kbGVyKHZpZXcudmlldywgdGhpcy5nZXRUeXBlKCkpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIgPSBuZXcgUlRDU291cmNlSGFuZGxlcih2aWV3LnZpZXcsIHRoaXMuZ2V0VHlwZSgpKVxuICAgICAgfVxuICAgICAgdGhpcy5fZ2xvbVNvdXJjZUhhbmRsZXJBUEkodGhpcy5fc291cmNlSGFuZGxlcilcbiAgICAgIHRoaXMuX2luaXRIYW5kbGVyKHRoaXMuX29wdGlvbnMsIHRoaXMuX3NvdXJjZUhhbmRsZXIpXG4gICAgICB0aGlzLl9nZXRBdmFpbGFiaWxpdHlSZXNvbHZlclByb21pc2UoKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgIC8qIHBhc3NlZCB1cCB0aHJvdWdoIG92ZXJhcmNoaW5nIHByb21pc2UuICovXG4gICAgICB9KVxuXG4gICAgICBjb25zdCB7IGxpbmtzIH0gPSBhd2FpdCB0aGlzLl93aGlwSGVscGVyLmdldE9wdGlvbnMoKVxuICAgICAgaWYgKGxpbmtzKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMuaWNlU2VydmVycyA9IGxpbmtzXG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IERDIHR1cm5lZCBvZmYgZm9yIG5vd1xuICAgICAgLy8gdGhpcy5fY29ubmVjdChydGNDb25maWd1cmF0aW9uLCBkYXRhQ2hhbm5lbENvbmZpZ3VyYXRpb24sIHRoaXMuX29wdGlvbnMuaWNlU2VydmVycylcbiAgICAgIHRoaXMuX2Nvbm5lY3QocnRjQ29uZmlndXJhdGlvbiwgdW5kZWZpbmVkLCB0aGlzLl9vcHRpb25zLmljZVNlcnZlcnMpXG4gICAgICB0aGlzLl9jb25uZWN0aW9uQ2xvc2VkID0gZmFsc2VcbiAgICAgIHJldHVybiB0aGlzLl9nZXRTdWJzY3JpcHRpb25SZXNvbHZlclByb21pc2UoKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5DT05ORUNUX0ZBSUxVUkUpLCB0aGlzLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIHJlY2VpcHQgb2YgYSBgTWVkaWFTdHJlYW1gLlxuICAgKlxuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cbiAgICogICAgICAgIFRoZSBzdHJlYW0gcmV0dXJuZWQgb24gdGhlIFBlZXIgQ29ubmVjdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIG9uQW5zd2VyTWVkaWFTdHJlYW0oc3RyZWFtID0gdW5kZWZpbmVkKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLkFOU1dFUl9FTkQsIHRoaXMpKVxuICAgIGNvbnN0IHZpZXcgPSBhd2FpdCB0aGlzLl9nZXRWaWV3UmVzb2x2ZXJQcm9taXNlKClcbiAgICB2aWV3LmF0dGFjaFN0cmVhbShzdHJlYW0pXG4gICAgdGhpcy5fbWVkaWFTdHJlYW0gPSBzdHJlYW1cbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVENTdWJzY3JpYmVyRXZlbnRUeXBlcy5PTl9BRERfU1RSRUFNLCB0aGlzLCB0aGlzLl9tZWRpYVN0cmVhbSkpXG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3Igb3BlbiBvZiBQZWVyIENvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvblBlZXJDb25uZWN0aW9uT3BlbigpIHtcbiAgICBzdXBlci5vblBlZXJDb25uZWN0aW9uT3BlbigpXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uUmVzb2x2ZXIucmVzb2x2ZSh0aGlzKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9TVEFSVCwgdGhpcykpXG4gICAgdGhpcy5fcGxheUlmQXV0b3BsYXlTZXQodGhpcy5fb3B0aW9ucywgdGhpcy5fdmlldylcbiAgICB0aGlzLl9zdGFydFNlZWthYmxlKHRoaXMuX29wdGlvbnMsIHRoaXMuX3ZpZXcpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBXZWJTb2NrZXQgY29ubmVjdGlvbiBoZWxwZXIgaWYgZXN0YWJsaXNoZWQuIER1ZSB0byB1c2luZyBXSEVQLCB0aGlzIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdWJzY3JpcHRpb25Tb2NrZXRIZWxwZXJ9XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRDb25uZWN0aW9uKCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBXSEVQQ2xpZW50XG4iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IEltcGxGYWN0b3J5T3JkZXIgZnJvbSAnLi4vdXRpbC9pbXBsLWZhY3Rvcnktb3JkZXInXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uL2NvcmUvZXZlbnQtZW1pdHRlcidcbmltcG9ydCBSVENTdWJzY3JpYmVyIGZyb20gJy4vcmVkNXByby1ydGMnXG5pbXBvcnQgUlRNUFN1YnNjcmliZXIgZnJvbSAnLi9yZWQ1cHJvLXJ0bXAnXG5pbXBvcnQgSExTU3Vic2NyaWJlciBmcm9tICcuL3JlZDVwcm8taGxzJ1xuaW1wb3J0IFdIRVBDbGllbnQgZnJvbSAnLi9yZWQ1cHJvLXdoZXAnXG5cbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IFBsYXliYWNrVHlwZXMgfSBmcm9tICcuLi9lbnVtL3BsYXliYWNrJ1xuaW1wb3J0IHsgZGVidWcsIHdhcm4gfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUmVkNVByb1N1YnNjcmliZXInXG5cbmNvbnN0IHBsYXliYWNrRmFjdG9yeSA9IG5ldyBJbXBsRmFjdG9yeU9yZGVyKClcbmNvbnN0IHBsYXliYWNrSW1wbCA9IChmdW5jdGlvbiAoKSB7XG4gIGxldCBtYXAgPSBuZXcgTWFwKClcbiAgbWFwLnNldChQbGF5YmFja1R5cGVzLlJUQywgUlRDU3Vic2NyaWJlcilcbiAgbWFwLnNldChQbGF5YmFja1R5cGVzLlJUTVAsIFJUTVBTdWJzY3JpYmVyKVxuICBtYXAuc2V0KFBsYXliYWNrVHlwZXMuSExTLCBITFNTdWJzY3JpYmVyKVxuICByZXR1cm4gbWFwXG59KCkpXG5cbi8qKlxuICogTWFpbiBlbnRyeSBmb3IgZmFpbG92ZXIgc3VwcG9ydCBvZiBhbGwgc3Vic2NyaWJlciBpbXBsZW1lbnRhdGlvbnMuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFJlZDVQcm9TdWJzY3JpYmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX29wdGlvbnMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9vcmRlciA9IFtcbiAgICAgIFBsYXliYWNrVHlwZXMuUlRDLFxuICAgICAgUGxheWJhY2tUeXBlcy5SVE1QLFxuICAgICAgUGxheWJhY2tUeXBlcy5ITFNcbiAgICBdXG4gIH1cblxuICAvKipcbiAgICogVXRpbGl6ZXMgRmFpbG92ZXIgUHVibGlzaGVyIEZhY3RvcnkgdG8gYXR0ZW1wdCBpbiBkZXRlcm1pbmluZyBicm93c2VyIHN1cHBvcnQgZm9yIFB1Ymxpc2hlciBmcm9tIGRlZmluZWQgb3JkZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0UGxheWJhY2tGcm9tT3JkZXIgKG9yZGVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHBsYXliYWNrRmFjdG9yeS5jcmVhdGUob3JkZXIsIHBsYXliYWNrSW1wbCwgb3B0aW9ucywgJ2luaXQnKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNwZWNpZmllZCBvcmRlciBmb3IgYXV0by1mYWlsb3Zlci5cbiAgICpcbiAgICogIEByZXR1cm4ge0FycmF5fVxuICAgKiAgICAgICAgICBEZWZhdWx0OiBgWydydGMnLCAncnRtcCcsICdobHMnXWAuXG4gICAqL1xuICBnZXRQbGF5YmFja09yZGVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JkZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSBkZXNpcmVkIGF1dG8tZmFpbG92ZXIgb3JkZXIuXG4gICAqXG4gICAqICBAcGFyYW0ge0FycmF5fSBvcmRlclxuICAgKiAgICAgICAgICBUaGUgZGVzaXJlZCBvcmRlci4gZS5nLCBgWydydGMnLCAncnRtcCcsICdobHMnXWAuXG4gICAqL1xuICBzZXRQbGF5YmFja09yZGVyIChvcmRlcikge1xuICAgIC8vIEFsbG93IGZvciBzdHJpbmcgdmFsdWUgdG8gZGVmaW5lIHNpbmdsZSBpdGVtIGluIG9yZGVyLlxuICAgIG9yZGVyID0gdHlwZW9mIG9yZGVyID09PSAnc3RyaW5nJyA/IFtvcmRlcl0gOiBvcmRlclxuXG4gICAgLy8gRmlsdGVyIG91dCB2YWx1ZXMgbm90IGF2YWlsYWJsZSBpbiBlbnVtZXJhdGlvbiBvZiBwbGF5YmFjayB0eXBlcy5cbiAgICBjb25zdCB0ID0gb3JkZXIuZmlsdGVyKGVudHJ5ID0+IHtcbiAgICAgIGxldCBrZXlcbiAgICAgIGZvciAoa2V5IGluIFBsYXliYWNrVHlwZXMpIHtcbiAgICAgICAgaWYgKFBsYXliYWNrVHlwZXNba2V5XS50b0xvd2VyQ2FzZSgpID09PSBlbnRyeS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSkubWFwKGVudHJ5ID0+IGVudHJ5LnRvTG93ZXJDYXNlKCkpXG5cbiAgICAvLyBEZWZpbmUgbmV3IG9yZGVyLlxuICAgIHRoaXMuX29yZGVyID0gWy4uLm5ldyBTZXQodCldXG4gICAgZGVidWcoTkFNRSwgYFtvcmRlcnVwZGF0ZV06ICR7dGhpcy5fb3JkZXJ9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gaW5pdGlhbGl6ZSBhbmQgZGV0ZXJtaW5lIHRoZSBwcm9wZXIgU3Vic2NyaWJlciBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBjb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiBUaGUgcmV0dXJuZWQgYFByb21pc2VgIHdpbGwgZWl0aGVyIHJlc29sdmUgd2l0aCB0aGUgZGV0ZXJtaW5lZCBTdWJzY3JpYmVyIGluc3RhbmNlIG9yIHJlamVjdCB3aXRoIGFuIGVycm9yIFN0cmluZyBpbiBmYWlsdXJlIHRvIGRldGVybWluZSBTdWJzY3JpYmVyIHR5cGUuXG4gICAqXG4gICAqICBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgICBUaGUgaW5pdGlhbGl6YXRpb24gY29uZmlndXJhdGlvbiBtYXAgZm9yIGVhY2ggZGVzaXJlZCBmYWlsb3ZlciB0ZWNoLlxuICAgKiAgQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIGluaXQgKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9uc1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgZGVidWcoTkFNRSwgJ1tpbml0XScpXG4gICAgdGhpcy5fZ2V0UGxheWJhY2tGcm9tT3JkZXIodGhpcy5fb3JkZXIsIHRoaXMuX29wdGlvbnMpXG4gICAgICAudGhlbihzdWJzY3JpYmVyID0+IHtcbiAgICAgICAgZGVidWcoTkFNRSwgYFtpbml0OnN1Y2Nlc3NdOiBzdWJzY3JpYmVyIGZvdW5kICR7c3Vic2NyaWJlci5nZXRUeXBlKCl9YClcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShzdWJzY3JpYmVyKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICB3YXJuKE5BTUUsIGBbcGxheWVycm9yXTogQ291bGQgbm90IGltcGxlbWVudCBhIHN1YnNjcmliZXI6ICR7ZXJyfWApXG4gICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpXG4gICAgICB9KVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGVudW1lcmF0ZWQgdmFsdWUgU3Vic2NyaWJlciB0eXBlcyB1c2VkIGluIGZhaWxvdmVyIG9yZGVyLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0IHBsYXliYWNrVHlwZXMgKCkge1xuICAgIHJldHVybiBQbGF5YmFja1R5cGVzXG4gIH1cblxufVxuXG5leHBvcnQgeyBSZWQ1UHJvU3Vic2NyaWJlciwgUlRDU3Vic2NyaWJlciwgSExTU3Vic2NyaWJlciwgUlRNUFN1YnNjcmliZXIsIFdIRVBDbGllbnQgfVxuXG4iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0ICogYXMgZW1iZWQgZnJvbSAnLi4vZW52L2VtYmVkJ1xuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uL2Vudi9icm93c2VyJ1xuaW1wb3J0IFJUTVBTaGFyZWRPYmplY3RIYW5kbGVyIGZyb20gJy4uL2hlbHBlci9zaGFyZWRvYmplY3QtaGVscGVyLXJ0bXAnXG5pbXBvcnQgeyB0b0ludCB9IGZyb20gJy4uL3V0aWwnXG5pbXBvcnQgeyBkZWVwQ29weSB9IGZyb20gJy4uL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgRnV0dXJlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0IHsgZGVidWcsIHdhcm4gfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9QdWJsaXNoZXJTb3VyY2VIYW5kbGVyJ1xuXG4vKipcbiAqIERldGVybWluZSB0aGUgdmlkZW8gZGltZW5zaW9ucyBzZXR0aW5nIHZhbHVlIGJhc2VkIG9uIHBvc3NpYmxlIGRlZmluaXRpb24gdXNpbmcgYE1lZGlhQ29uc3RyYWludGAuXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBjb252ZXJ0RGltZW5zaW9uT3B0aW9ucyA9ICh2bykgPT4ge1xuICByZXR1cm4gdm8uZXhhY3QgfHwgdm8uaWRlYWwgfHwgdm8ubWF4IHx8IHZvLm1pbiB8fCB2b1xufVxuXG4vKipcbiAqIERlZmluZSB0aGUgYXVkaW8gYW5kIHZpZGVvIHNldHRpbmdzIGZvciBGbGFzaC5cbiAqIFRoZSBgd2lkdGhgIGFuZCBgaGVpZ2h0YCBhdHRyaWJ1dGVzIHJlbGF0ZSB0byB2aWRlby4gVGhlIGBhdWRpb2AgYXR0cmlidXRlIGlzIGEgYm9vbGVhbiBmbGFnLlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgbWVkaWFDb25zdHJhaW50c1RvRmxhc2h2YXJzID0gKGNvbnN0cmFpbnRzLCBmbGFzaHZhcnMpID0+IHtcbiAgbGV0IGZ2ID0gZGVlcENvcHkoZmxhc2h2YXJzKVxuICBpZiAodHlwZW9mIGNvbnN0cmFpbnRzLnZpZGVvID09PSAnYm9vbGVhbicpIHtcbiAgICBmdi52aWRlbyA9IGNvbnN0cmFpbnRzLnZpZGVvXG4gIH1cbiAgZWxzZSB7XG4gICAgbGV0IGtleVxuICAgIGZvciAoa2V5IGluIGNvbnN0cmFpbnRzLnZpZGVvKSB7XG4gICAgICBmdltrZXldID0gY29udmVydERpbWVuc2lvbk9wdGlvbnMoY29uc3RyYWludHMudmlkZW9ba2V5XSlcbiAgICB9XG4gICAgZnYudmlkZW8gPSB0cnVlXG4gIH1cbiAgZnYuYXVkaW8gPSB0eXBlb2YgY29uc3RyYWludHMuYXVkaW8gPT09ICdib29sZWFuJyA/IGNvbnN0cmFpbnRzLmF1ZGlvIDogdHJ1ZVxuICByZXR1cm4gZnZcbn1cblxuLyoqXG4gKiBUaGUgaW50ZXJuYWwgUHVibGlzaCBTb3VyY2UgSGFuZGxlciBmb3IgYW4gUlRNUFB1Ymxpc2hlci5cbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFB1Ymxpc2hlclNvdXJjZUhhbmRsZXIge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHZpZGVvXG4gICAqICAgICAgICBUaGUgdmlkZW8gRE9NIEVsZW1lbnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqICAgICAgICBUaGUgcHVibGlzaGVyIHR5cGU6IG1vc3QgbGlrZWx5LCBgUlRNUGAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb1Jlc3BvbmRlclxuICAgKiAgICAgICAgT3B0aW9uYWwgcmVzcG9uZGVyIHRvIFNoYXJlZE9iamVjdCBBUEkuIElmIG5vdCBwcm92aWRlZCwgd2lsbCBnZW5lcmF0ZSBhIGBSVE1QU2hhcmVkT2JqZWN0SGFuZGxlcmAgaW5zdGFuY2UgaW50ZXJuYWxseS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yICh2aWRlbywgdHlwZSwgc29SZXNwb25kZXIgPSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnZpZGVvID0gdmlkZW9cbiAgICB0aGlzLmNsb25lID0gdGhpcy52aWRlby5jbG9uZU5vZGUodHJ1ZSlcbiAgICB0aGlzLmhvbGRlciA9IHRoaXMudmlkZW8ucGFyZW50Tm9kZVxuICAgIHRoaXMuX3B1Ymxpc2hlclR5cGUgPSB0eXBlXG4gICAgdGhpcy5fc3dmSWQgPSBudWxsXG4gICAgdGhpcy5fZW1iZWRGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9zb1Jlc3BvbmRlciA9IHNvUmVzcG9uZGVyIHx8IG5ldyBSVE1QU2hhcmVkT2JqZWN0SGFuZGxlcigpXG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdGVkIGFuZCB1c2VkIGJ5IFJUTVBQdWJsaXNoZXIgaW5zdGFuY2UgaW4gcmVjb2duaXppbmcgY29tcGxldGlvbiBvZiBlbWJlZC5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEVtYmVkT3BlcmF0aW9uICgpIHtcbiAgICB0aGlzLl9lbWJlZEZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX2VtYmVkRnV0dXJlKVxuICAgIHJldHVybiB0aGlzLl9lbWJlZEZ1dHVyZS5wcm9taXNlXG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAgb2YgcmVmZXJlbmNlcyBhbmQgbW9kaWZpZWQgZGlzcGxheS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNsZWFuVXAgKCkge1xuICAgIC8vIFJldHVybiB0byBwcmlvciBET00gbWFuaXB1bGF0aW9uLlxuICAgIHRoaXMudmlkZW8ucmVtb3ZlKClcbiAgICB0aGlzLnZpZGVvID0gdGhpcy5jbG9uZS5jbG9uZU5vZGUodHJ1ZSlcbiAgICB0aGlzLmhvbGRlci5hcHBlbmRDaGlsZCh0aGlzLnZpZGVvKVxuICAgIHRoaXMuX2VtYmVkRnV0dXJlID0gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBkZWZpbmUgdGhlIGVtYmVkZGluZyBvcHRpb25zIGZvciBhIFJUTVBQdWJsaXNoZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzd2ZJZFxuICAgKiAgICAgICAgVGhlIHVuaXF1ZSBpZCB0byB1c2UgaW4gZW1iZWRkaW5nIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgaW5pdGlhbGl6YXRpb24gY29uZmlndXJhdGlvbiB0byBkZXRlcm1pbmUgZmxhc2h2YXJzIGZyb20uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzd2ZVcmxcbiAgICogICAgICAgIE9wdGlvbmFsIGxvY2F0aW9uIG9mIHRoZSBTV0YgZmlsZSB0byBlbWJlZC4gRGVmYXVsdCBpcyByZWxhdGl2ZSBwYXRoIHRvIGByZWQ1cHJvLXN1YnNjcmliZXIuc3dmYC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1pbkZsYXNoVmVyc2lvblxuICAgKiAgICAgICAgT3B0aW9uYWwgc2VtdmVyIG9mIG1pbmltdW0gRmxhc2ggdmVyc2lvbiB0byBkZXRlcm1pbmUgc3VwcG9ydC4gRGVmYXVsdCBpcyBgMTAuMC4wYC5cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICAgICAgIFRoZSBgUHJvbWlzZWAgZWl0aGVyIHJlc29sdmVzIG9yIHJlamVjdHMgdGhlIHN1Y2Nlc3Mgb2YgZW1iZWQgb24gcGFnZSB1c2luZyBTV0ZPYmplY3QuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhZGRTb3VyY2UgKHN3ZklkLCBvcHRpb25zLCBzd2ZVcmwgPSBudWxsLCBtaW5GbGFzaFZlcnNpb24gPSBudWxsKSB7XG4gICAgZGVidWcoTkFNRSwgJ1thZGRzb3VyY2VdJylcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIHRoaXMuX3N3ZklkID0gc3dmSWQ7XG4gICAgdGhpcy5fZW1iZWRGdXR1cmUgPSBGdXR1cmUuY3JlYXRlSWZOb3RFeGlzdCh0aGlzLl9lbWJlZEZ1dHVyZSlcbiAgICBjb25zdCBkZWZlcnJlZCA9IHRoaXMuX2VtYmVkRnV0dXJlXG4gICAgb3B0aW9ucy5zd2YgPSBzd2ZVcmwgfHwgb3B0aW9ucy5zd2ZcbiAgICBvcHRpb25zLm1pbkZsYXNoVmVyc2lvbiA9IG1pbkZsYXNoVmVyc2lvbiB8fCBvcHRpb25zLm1pbkZsYXNoVmVyc2lvblxuICAgIGVtYmVkLmRlZmluZUVtYmVkRWxlbWVudCh0aGlzLnZpZGVvLCB0aGlzLmhvbGRlcilcbiAgICAgIC50aGVuKGVsZW1lbnRJZCA9PiB7XG4gICAgICAgIGRlYnVnKE5BTUUsICdbZWxlbWVudDpjb21wbGV0ZV0nKVxuICAgICAgICBsZXQgZmxhc2h2YXJzID0ge1xuICAgICAgICAgIGJ1ZmZlcjogb3B0aW9ucy5idWZmZXIgIT0gbnVsbCA/IG9wdGlvbnMuYnVmZmVyIDogMSxcbiAgICAgICAgICBzdHJlYW1Nb2RlOiBvcHRpb25zLnN0cmVhbU1vZGUsXG4gICAgICAgICAgc3RyZWFtTmFtZTogb3B0aW9ucy5zdHJlYW1OYW1lLFxuICAgICAgICAgIGFwcE5hbWU6IG9wdGlvbnMuYXBwLFxuICAgICAgICAgIGhvc3Q6IG9wdGlvbnMuaG9zdFxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgIGZsYXNodmFycy5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvclxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNvbnRleHQpIHtcbiAgICAgICAgICBmbGFzaHZhcnMucm9vbU5hbWUgPSBvcHRpb25zLmNvbnRleHRcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbWJlZFdpZHRoID09PSAnMTAwJScgfHwgb3B0aW9ucy5lbWJlZEhlaWdodCA9PT0gJzEwMCUnKSB7XG4gICAgICAgICAgZmxhc2h2YXJzLmF1dG9zaXplID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb25uZWN0aW9uUGFyYW1zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGZsYXNodmFycy5jb25uZWN0aW9uUGFyYW1zID0gZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuY29ubmVjdGlvblBhcmFtcykpXG4gICAgICAgIH1cbiAgICAgICAgZmxhc2h2YXJzID0gbWVkaWFDb25zdHJhaW50c1RvRmxhc2h2YXJzKG9wdGlvbnMubWVkaWFDb25zdHJhaW50cywgZmxhc2h2YXJzKVxuICAgICAgICByZXR1cm4gZW1iZWQuZW1iZWRTd2ZPYmplY3Qoc3dmSWQsIG9wdGlvbnMsIGZsYXNodmFycywgZW52aXJvbm1lbnQuZ2V0U3dmT2JqZWN0KCksIGVsZW1lbnRJZClcbiAgICAgIH0pXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGRlYnVnKE5BTUUsICdbZW1iZWQ6Y29tcGxldGVdJylcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShzZWxmKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4gZGVmZXJyZWQucmVqZWN0KGVycikpXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGNvbm5lY3QgdG8gc2VydmVyIGZvciBhIGJyb2FkY2FzdCBzZXNzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcHVibGlzaE9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbm5lY3QgKHB1Ymxpc2hPcHRpb25zKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tjb25uZWN0XScpXG4gICAgY29uc3QgZWwgPSBlbnZpcm9ubWVudC5nZXRFbWJlZE9iamVjdCh0aGlzLl9zd2ZJZClcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLmNvbm5lY3QocHVibGlzaE9wdGlvbnMpXG4gICAgICB0aGlzLl9zb1Jlc3BvbmRlci5jb25uZWN0KHRoaXMuX3N3ZklkKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHdhcm4oTkFNRSwgJ0NvdWxkIG5vdCBkZXRlcm1pbmUgZW1iZWRkZWQgZWxlbWVudCB3aXRoIHN3ZiBpZDogJyArIHRoaXMuX3N3ZklkICsgJy4nKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGRpc2Nvbm5lY3QgZnJvbSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNjb25uZWN0ICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2Rpc2Nvbm5lY3RdJylcbiAgICB0cnkge1xuICAgICAgY29uc3QgZWwgPSBlbnZpcm9ubWVudC5nZXRFbWJlZE9iamVjdCh0aGlzLl9zd2ZJZClcbiAgICAgIGlmIChlbCkge1xuICAgICAgICBlbC5kaXNjb25uZWN0KClcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBuYWRhLlxuICAgIH1cbiAgICB0aGlzLmNsZWFuVXAoKVxuICAgIHRoaXMuX3NvUmVzcG9uZGVyLmRpc2Nvbm5lY3QoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gc2VuZCBhIG1lc3NhZ2UgdG8gYWxsIHN1YnNjcmliZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kTmFtZVxuICAgKiAgICAgICAgVGhlIG1ldGhvZCBuYW1lIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWVzc2FnZSB0byBiZSBhY2NlcHRlZCBieSBhbGwgc3Vic2NyaWJlcnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqICAgICAgICBUaGUgZGF0YSBvYmplY3QgdG8gc2VuZCBhc3NvY2lhdGVkIHdpdGggdGhlIG1ldGhvZCBuYW1lLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2VuZCAobWV0aG9kTmFtZSwgZGF0YSkge1xuICAgIGNvbnN0IGVsID0gZW52aXJvbm1lbnQuZ2V0RW1iZWRPYmplY3QodGhpcy5fc3dmSWQpXG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5zZW5kKG1ldGhvZE5hbWUsIGRhdGEpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSByZXNwb25zZSBoYW5kbGVyIG9uIFNoYXJlZE9iamVjdCBjaGFubmVsIHJlc3BvbmRlci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFkZFNoYXJlZE9iamVjdFJlc3BvbnNlSGFuZGxlciAoaGFuZGxlcikge1xuICAgIHRoaXMuX3NvUmVzcG9uZGVyLmFkZFJlc3BvbnNlSGFuZGxlcihoYW5kbGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSByZXNwb25zZSBoYW5kbGVyIG9uIFNoYXJlZE9iamVjdCBjaGFubmVsIHJlc3BvbmRlci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlbW92ZVNoYXJlZE9iamVjdFJlc3BvbnNlSGFuZGxlciAoaGFuZGxlcikge1xuICAgIHRoaXMuX3NvUmVzcG9uZGVyLnJlbW92ZVJlc3BvbnNlSGFuZGxlcihoYW5kbGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIG1lc3NhZ2Ugb24gU2hhcmVkT2JqZWN0IGNoYW5uZWwgcmVzcG9uZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiAgICAgICAgVGhlIFNoYXJlZE9iamVjdCBuYW1lLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2FsbE5hbWVcbiAgICogICAgICAgIFRoZSBtZXRob2QgbmFtZSB0byBiZSBpbnZva2VkLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiAgICAgICAgVGhlIHN0cnVjdHVyZWQgdmFsdWUgdG8gc2VuZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlbmRUb1NoYXJlZE9iamVjdCAobmFtZSwgY2FsbE5hbWUsIG1lc3NhZ2UpIHtcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5zZW5kVG9TaGFyZWRPYmplY3QobmFtZSwgY2FsbE5hbWUsIG1lc3NhZ2UpXG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgcHJvcGVydHkgdXBkYXRlIG9uIFNoYXJlZE9iamVjdCBjaGFubmVsIHJlc3BvbmRlci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogICAgICAgIFRoZSBTaGFyZWRPYmplY3QgbmFtZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiAgICAgICAgVGhlIHByb3BlcnR5IG5hbWUgb24gdGhlIFNoYXJlZE9iamVjdC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICBUaGUgc3RydWN0dXJlZCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlbmRQcm9wZXJ0eVRvU2hhcmVkT2JqZWN0IChuYW1lLCBrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5fc29SZXNwb25kZXIuc2VuZFByb3BlcnR5VG9TaGFyZWRPYmplY3QobmFtZSwga2V5LCB2YWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0cyB0byBnZXQgU2hhcmVkT2JqZWN0IGluc3RhbmNlIGZyb20gdGhlIFNoYXJlZE9iamVjdCBjaGFubmVsIHJlc3BvbmRlci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFJlbW90ZVNoYXJlZE9iamVjdCAoc2hhcmVkT2JqZWN0TmFtZSkge1xuICAgIHRoaXMuX3NvUmVzcG9uZGVyLmdldFJlbW90ZVNoYXJlZE9iamVjdChzaGFyZWRPYmplY3ROYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gY29ubmVjdCB0byBhIHNoYXJlZCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaGFyZWRPYmplY3ROYW1lXG4gICAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgU2hhcmVkT2JqZWN0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29ubmVjdFRvU2hhcmVkT2JqZWN0IChzaGFyZWRPYmplY3ROYW1lKSB7XG4gICAgdGhpcy5fc29SZXNwb25kZXIuY29ubmVjdFRvU2hhcmVkT2JqZWN0KHNoYXJlZE9iamVjdE5hbWUpXG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBjbG9zZSBjb25uZWN0aW9uIHRvIGEgc2hhcmVkIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNoYXJlZE9iamVjdE5hbWVcbiAgICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSBTaGFyZWRPYmplY3QuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjbG9zZVNoYXJlZE9iamVjdCAoc2hhcmVkT2JqZWN0TmFtZSkge1xuICAgIHRoaXMuX3NvUmVzcG9uZGVyLmNsb3NlU2hhcmVkT2JqZWN0KHNoYXJlZE9iamVjdE5hbWUpXG4gIH1cblxuICAvKipcbiAgICogRGVwcmVjYXRlZC4gUmVxdWVzdCB0byB1cGRhdGUgYnJvYWRjYXN0IGRpbWVuc2lvbnMgYmVmb3JlIGEgYnJvYWRjYXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcXVhbGl0eVxuICAgKiAgICAgICAgRXhwZWN0cyBvYmplY3Qgd2l0aCBmb2xsb3dpbmcgc3RydWN0dXI6IGB7dmlkZW86IHt3aWR0aDpJbnQsIGhlaWdodEludH19XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRNZWRpYVF1YWxpdHkgKHF1YWxpdHkpIHtcbiAgICBjb25zdCBlbCA9IGVudmlyb25tZW50LmdldEVtYmVkT2JqZWN0KHRoaXMuX3N3ZklkKVxuICAgIGlmIChlbCkge1xuICAgICAgaWYgKHF1YWxpdHkudmlkZW8gJiYgdHlwZW9mIHF1YWxpdHkudmlkZW8gIT09ICdib29sZWFuJykge1xuICAgICAgICBjb25zdCB3ID0gIWlzTmFOKHF1YWxpdHkudmlkZW8ud2lkdGgpID8gdG9JbnQocXVhbGl0eS52aWRlby53aWR0aCkgOiBOdW1iZXIuaXNOYU47XG4gICAgICAgIGNvbnN0IGggPSAhaXNOYU4ocXVhbGl0eS52aWRlby5oZWlnaHQpID8gdG9JbnQocXVhbGl0eS52aWRlby5oZWlnaHQpIDogTnVtYmVyLmlzTmFOO1xuICAgICAgICBlbC51cGRhdGVSZXNvbHV0aW9uKHcsIGgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHR5cGUgb2YgaW1wbGVtZW50YXRpb246IGBSVE1QYC5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1Ymxpc2hlclR5cGVcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFB1Ymxpc2hlclNvdXJjZUhhbmRsZXJcblxuIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCB7IGRlYnVnLCBlcnJvciB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSNVByb1B1Ymxpc2hWaWV3J1xuY29uc3QgcHVibGlzaGVySWQgPSAncmVkNXByby1wdWJsaXNoZXInXG5cbi8qKlxuICogQnJpZGdlIGJldHdlZW4gRE9NIEVsZW1lbnQgdmlldyBhbmQgUHVibGlzaGVyIGltcGxlbWVudGF0aW9uLlxuICogU3RpbGwgdXNlZCwgYnV0IGludGVybmFsaXplZCBhcyBvZiA0LjAuMC4gVXAgZm9yIGRlcHJlY2F0aW9uLCB1cCBmb3IgZGlzY3Vzc2lvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBQdWJsaXNoVmlldyB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbGVtZW50SWRcbiAgICogICAgICAgIFRoZSBlbGVtZW50IGBpZGAgdG8gdXNlIGZvciBwbGF5YmFjayBkaXNwbGF5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGVsZW1lbnRJZCA9IHB1Ymxpc2hlcklkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3RhcmdldEVsZW1lbnQgPSBlbnZpcm9ubWVudC5yZXNvbHZlRWxlbWVudChlbGVtZW50SWQpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IoTkFNRSwgYENvdWxkIG5vdCBpbnN0YW50aWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBSZWQ1UHJvUHVibGlzaGVyLiBSZWFzb246ICR7ZS5tZXNzYWdlfWApXG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cbiAgYXR0YWNoUHVibGlzaGVyIChwdWJsaXNoZXIpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2F0dGFjaHB1Ymxpc2hlcl0nKVxuICAgIHB1Ymxpc2hlci5zZXRWaWV3KHRoaXMsIGVudmlyb25tZW50LmdldEVsZW1lbnRJZCh0aGlzLl90YXJnZXRFbGVtZW50KSlcbiAgfVxuXG4gIHByZXZpZXcgKG1lZGlhU3RyZWFtKSB7XG4gICAgbGV0IGF1dG9wbGF5ID0gdGhpcy5pc0F1dG9wbGF5XG4gICAgZGVidWcoTkFNRSwgYFtwcmV2aWV3XTogYXV0b3BsYXkoJHthdXRvcGxheX0pYClcbiAgICBlbnZpcm9ubWVudC5zZXRWaWRlb1NvdXJjZSh0aGlzLl90YXJnZXRFbGVtZW50LCBtZWRpYVN0cmVhbSwgYXV0b3BsYXkpXG4gIH1cblxuICB1bnByZXZpZXcgKCkge1xuICAgIGVudmlyb25tZW50LnNldFZpZGVvU291cmNlKHRoaXMuX3RhcmdldEVsZW1lbnQsIG51bGwsIHRoaXMuaXNBdXRvcGxheSlcbiAgfVxuXG4gIGdldCBpc0F1dG9wbGF5ICgpIHtcbiAgICByZXR1cm4gZW52aXJvbm1lbnQuaGFzQXR0cmlidXRlRGVmaW5lZCh0aGlzLl90YXJnZXRFbGVtZW50LCAnYXV0b3BsYXknKVxuICB9XG5cbiAgZ2V0IHZpZXcgKCkge1xuICAgIHJldHVybiB0aGlzLl90YXJnZXRFbGVtZW50XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBQdWJsaXNoVmlld1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydCBjb25zdCBQdWJsaXNoVHlwZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgUlRNUDogJ3J0bXAnLFxuICBSVEM6ICdydGMnXG59KVxuXG5leHBvcnQgY29uc3QgUHVibGlzaE1vZGVUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuICBMSVZFOiAnbGl2ZScsXG4gIFJFQ09SRDogJ3JlY29yZCcsXG4gIEFQUEVORDogJ2FwcGVuZCdcbn0pXG5cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEVhc3kgZGVjb3JhdG9yIGZvciBzZXR0aW5nIGEgbXV0YWJsZSwgaXRlcmF0YWJsZSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgaW5mbGF0ZSA9IChvYmosIHByb3AsIHZhbHVlKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KVxufVxuXG4vKipcbiAqIERlZmF1bHQgYGV4YWN0YCBzZXR0aW5nIGZvciBgdmlkZW9gIG9uIGBNZWRpYUNvbnN0cmFpbnRgIGZvciBXZWJSVEMgYnJvYWRjYXN0LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFJUQ01lZGlhVmlkZW9Db25zdHJhaW50IHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgaW5mbGF0ZSh0aGlzLCAnd2lkdGgnLCB7XG4gICAgICBleGFjdDogNjQwXG4gICAgfSlcbiAgICBpbmZsYXRlKHRoaXMsICdoZWlnaHQnLCB7XG4gICAgICBleGFjdDogNDgwXG4gICAgfSlcbiAgfVxuXG59XG5cbi8qKlxuICogRGVmYXVsdCBSVE1QIHZpZGVvIHNldHRpbmdzIGZvciBicmFvZGNhc3QuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUlRNUE1lZGlhVmlkZW9Db25zdHJhaW50IHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgaW5mbGF0ZSh0aGlzLCAnd2lkdGgnLCA2NDApXG4gICAgaW5mbGF0ZSh0aGlzLCAnaGVpZ2h0JywgNDgwKVxuICAgIGluZmxhdGUodGhpcywgJ2ZvcmNlJywgZmFsc2UpXG4gICAgaW5mbGF0ZSh0aGlzLCAnZnJhbWVyYXRlJywgMTUpXG4gICAgaW5mbGF0ZSh0aGlzLCAnYmFuZHdpZHRoJywgNTAwMDApXG4gICAgaW5mbGF0ZSh0aGlzLCAncXVhbGl0eScsIDgwKVxuICAgIGluZmxhdGUodGhpcywgJ3Byb2ZpbGUnLCAnYmFzZWxpbmUnKVxuICAgIGluZmxhdGUodGhpcywgJ2xldmVsJywgMy4xKVxuICB9XG5cbn1cblxuLyoqXG4gKiBEZWZhdWx0IFdlYlJUQyBtZWRpYSBzZXR0aW5ncyBmb3IgYnJvYWRjYXN0LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFJUQ01lZGlhQ29uc3RyYWludCB7XG5cbiAgY29uc3RydWN0b3IgKGF1ZGlvID0gdHJ1ZSwgdmlkZW8gPSB1bmRlZmluZWQpIHtcbiAgICBpbmZsYXRlKHRoaXMsICdhdWRpbycsIGF1ZGlvKVxuICAgIGluZmxhdGUodGhpcywgJ3ZpZGVvJywgdmlkZW8gfHwgbmV3IFJUQ01lZGlhVmlkZW9Db25zdHJhaW50KCkpXG4gIH1cbn1cblxuLyoqXG4gKiBEZWZhdWx0IFJUTVAgbWVkaWEgc2V0dGluZ3MgZm9yIGJyb2FkY2FzdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBSVE1QTWVkaWFDb25zdHJhaW50IHtcblxuICBjb25zdHJ1Y3RvciAoYXVkaW8gPSB0cnVlLCB2aWRlbyA9IHVuZGVmaW5lZCkge1xuICAgIGluZmxhdGUodGhpcywgJ2F1ZGlvJywgYXVkaW8pXG4gICAgaW5mbGF0ZSh0aGlzLCAndmlkZW8nLCB2aWRlbyB8fCBuZXcgUlRNUE1lZGlhVmlkZW9Db25zdHJhaW50KCkpXG4gIH1cbn1cblxuZXhwb3J0IHsgUlRDTWVkaWFDb25zdHJhaW50LCBSVE1QTWVkaWFDb25zdHJhaW50IH1cblxuIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vY29yZS9ldmVudC1lbWl0dGVyJ1xuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uL2Vudi9icm93c2VyJ1xuaW1wb3J0IFB1Ymxpc2hlclNvdXJjZUhhbmRsZXIgZnJvbSAnLi9wdWItc291cmNlLWhhbmRsZXInXG5pbXBvcnQgUHVibGlzaFZpZXcgZnJvbSAnLi4vdmlldy9wdWJsaXNoJ1xuaW1wb3J0IHsgUHVibGlzaGVyRXZlbnQgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IFB1Ymxpc2hUeXBlcyB9IGZyb20gJy4uL2VudW0vcHVibGlzaCdcbmltcG9ydCB7IFB1Ymxpc2hlckV2ZW50VHlwZXMsIFJUTVBQdWJsaXNoZXJFdmVudFR5cGVzIH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgeyBSVE1QTWVkaWFDb25zdHJhaW50IH0gZnJvbSAnLi9jb25zdHJhaW50J1xuaW1wb3J0IHsgZGVidWcsIGVycm9yIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1JUTVBQdWJsaXNoZXInXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgcHJvdG9jb2w6ICdydG1wJyxcbiAgcG9ydDogMTkzNSxcbiAgc3RyZWFtTW9kZTogJ2xpdmUnLFxuICBtZWRpYUVsZW1lbnRJZDogJ3JlZDVwcm8tcHVibGlzaGVyJyxcbiAgZW1iZWRXaWR0aDogJzEwMCUnLCAvLyBET00gZGlzcGxheSBzdHlsZVxuICBlbWJlZEhlaWdodDogJzEwMCUnLCAvLyBET00gZGlzcGxheSBzdHlsZVxuICBtaW5GbGFzaFZlcnNpb246ICcxMC4wLjAnLFxuICBzd2Y6ICdsaWIvcmVkNXByby9yZWQ1cHJvLXB1Ymxpc2hlci5zd2YnLFxuICBzd2ZvYmplY3RVUkw6ICdsaWIvc3dmb2JqZWN0L3N3Zm9iamVjdC5qcycsXG4gIHByb2R1Y3RJbnN0YWxsVVJMOiAnbGliL3N3Zm9iamVjdC9wbGF5ZXJQcm9kdWN0SW5zdGFsbC5zd2YnLFxuICBtZWRpYUNvbnN0cmFpbnRzOiBuZXcgUlRNUE1lZGlhQ29uc3RyYWludCgpXG59XG5cbi8qKlxuICogTWFpbiBlbnRyeSBmb3IgRmxhc2gtYmFzZWQgUHVibGlzaGVyLlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5jbGFzcyBSVE1QUHVibGlzaGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX29wdGlvbnMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl92aWV3ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fc291cmNlSGFuZGxlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2VsZW1lbnRJZCA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2Nvbm5lY3RGdXR1cmUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGlsbCBpbiB1c2UgZm9yIGFzc2lnbmluZyBkb2N1bWVudCBlbGVtZW50IHZpZXcgbWFuYWdlbWVudCB0byB0aGlzIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldFZpZXdJZk5vdEV4aXN0IChjdXJyZW50VmlldywgbWVkaWFFbGVtZW50SWQgPSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgY3VycmVudFZpZXcgPT09ICd1bmRlZmluZWQnICYmIG1lZGlhRWxlbWVudElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHZpZXcgPSBuZXcgUHVibGlzaFZpZXcobWVkaWFFbGVtZW50SWQpXG4gICAgICAgIHZpZXcuYXR0YWNoUHVibGlzaGVyKHRoaXMpXG4gICAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RpbGwgaW4gdXNlIGZvciBhc3NpZ25pbmcgZG9jdW1lbnQgZWxlbWVudCB2aWV3IG1hbmFnZW1lbnQgdG8gdGhpcyBpbnN0YW5jZS5cbiAgICogQVBJIGRlcHJlY2F0ZWQgaW4gNC4wLjAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRWaWV3ICh2aWV3LCBlbGVtZW50SWQpIHtcbiAgICB0aGlzLl92aWV3ID0gdmlld1xuICAgIHRoaXMuX2VsZW1lbnRJZCA9IGVsZW1lbnRJZFxuICAgIGlmICh0aGlzLl9zb3VyY2VIYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIuZGlzY29ubmVjdCgpXG4gICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyID0gdW5kZWZpbmVkXG4gICAgfVxuICAgIGlmICh0aGlzLl92aWV3KSB7XG4gICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyID0gbmV3IFB1Ymxpc2hlclNvdXJjZUhhbmRsZXIodGhpcy5fdmlldy52aWV3LCB0aGlzLmdldFR5cGUoKSlcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fc291cmNlSGFuZGxlcikge1xuICAgICAgdGhpcy5fc291cmNlSGFuZGxlci5hZGRTb3VyY2UodGhpcy5fZWxlbWVudElkLCB0aGlzLl9vcHRpb25zKVxuICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICBlcnJvcihOQU1FLCBgQ291bGQgbm90IGVzdGFibGlzaCBwcm9wZXIgUlRNUCBwdWJsaXNoZXI6ICR7ZXJyfWApXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChSVE1QUHVibGlzaGVyRXZlbnRUeXBlcy5FTUJFRF9GQUlMVVJFLCB0aGlzKSlcbiAgICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSB3aW5kb3cgZ2xvYmFsIGNhbGxiYWNrIHVzZWQgYnkgRmxhc2ggcHVibGlzaGVyIHRvIHJlY29nbml6ZSBlbWJlZCBjb21wbGV0ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRVcENvbm5lY3RDYWxsYmFjayAocHJvbWlzZSkge1xuICAgIHdpbmRvdy5zZXRBY3RpdmVJZCA9IChzdWNjZXNzSWQpID0+IHtcbiAgICAgIC8vIHN1Y2Nlc3NJZCA9PT0gX29wdGlvbnMuc3RyZWFtTmFtZVxuICAgICAgZGVidWcoTkFNRSwgYEVtYmVkIGFuZCBjb25uZWN0KCkgY29tcGxldGUgZm9yIHB1Ymxpc2hlciBzd2YuIHN1Y2Nlc3NJZCgke3N1Y2Nlc3NJZH0pLmApXG4gICAgICBwcm9taXNlLnJlc29sdmUodGhpcylcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUlRNUFB1Ymxpc2hlckV2ZW50VHlwZXMuRU1CRURfU1VDQ0VTUywgdGhpcykpXG4gICAgICB0aGlzLl90ZWFyRG93bkNvbm5lY3RDYWxsYmFjaygpXG4gICAgfVxuICAgIC8vIFRPRE86IFNldHVwIHRpbWVvdXQgdG8gcmVqZWN0P1xuICB9XG5cbiAgLyoqXG4gICAqIFRlYXIgZG93biBnbG9iYWwgY2FsbGJhY2sgdXNlZCBpbiBGbGFzaCBwdWJsaXNoZXIgcmVjb2duaXplIG9mIGVtYmVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RlYXJEb3duQ29ubmVjdENhbGxiYWNrICgpIHtcbiAgICB3aW5kb3cuc2V0QWN0aXZlSWQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgZ2xvYmFsIGZ1bmN0aW9uIGhhbmRsZXJzIGZvciBFeHRlcm5hbEludGVyZmFjZSB0byBpbnZva2UgZm9yIEFQSSBjb21tdW5pY2F0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2VzdGFibGlzaEV4dEludEhhbmRsZXJzICgpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZVxuICAgIGNvbnN0IGludm9rZUZuID0gKGxhYmVsKSA9PiB7XG4gICAgICByZXR1cm4gWydwdWJsaXNoZXInLCBsYWJlbCwgaWQuc3BsaXQoJy0nKS5qb2luKCdfJyldLmpvaW4oJ18nKVxuICAgIH1cbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvQ29ubmVjdENsb3NlZCcpXSA9ICgpID0+IHtcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5DT05ORUNUSU9OX0NMT1NFRCwgdGhpcykpXG4gICAgfVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9Db25uZWN0U3VjY2VzcycpXSA9ICgpID0+IHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5DT05ORUNUX1NVQ0NFU1MsIHRoaXMpKVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9VbnB1Ymxpc2hTdWNjZXNzJyldID0gKCkgPT4gdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlVOUFVCTElTSF9TVUNDRVNTLCB0aGlzKSlcbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvUHVibGlzaFN0YXJ0JyldID0gKCkgPT4ge1xuICAgICAgdGhpcy5fY29ubmVjdEZ1dHVyZS5yZXNvbHZlKHRoaXMpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuUFVCTElTSF9TVEFSVCwgdGhpcykpXG4gICAgfVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9QdWJsaXNoTWV0YWRhdGEnKV0gPSAobWV0YWRhdGEpID0+IHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5QVUJMSVNIX01FVEFEQVRBLCB0aGlzLCBtZXRhZGF0YSkpXG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1B1Ymxpc2hJbnN1ZmZpY2llbnRCVycpXSA9IChkYXRhKSA9PiB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuUFVCTElTSF9JTlNVRkZJQ0lFTlRfQkFORFdJRFRILCB0aGlzLCBkYXRhKSlcbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvUHVibGlzaFN1ZmZpY2llbnRCVycpXSA9IChkYXRhKSA9PiB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuUFVCTElTSF9TVUZGSUNJRU5UX0JBTkRXSURUSCwgdGhpcywgZGF0YSkpXG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1B1Ymxpc2hSZWNvdmVyaW5nQlcnKV0gPSAoZGF0YSkgPT4gdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlBVQkxJU0hfUkVDT1ZFUklOR19CQU5EV0lEVEgsIHRoaXMsIGRhdGEpKVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9Db25uZWN0RmFpbHVyZScpXSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2Nvbm5lY3RGdXR1cmUucmVqZWN0KFB1Ymxpc2hlckV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFKVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLkNPTk5FQ1RfRkFJTFVSRSwgdGhpcykpXG4gICAgfVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9QdWJsaXNoRmFpbCcpXSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2Nvbm5lY3RGdXR1cmUucmVqZWN0KFB1Ymxpc2hlckV2ZW50VHlwZXMuUFVCTElTSF9GQUlMKVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlBVQkxJU0hfRkFJTCwgdGhpcykpXG4gICAgfVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9QdWJsaXNoSW52YWxpZE5hbWUnKV0gPSgpID0+IHtcbiAgICAgIHRoaXMuX2Nvbm5lY3RGdXR1cmUucmVqZWN0KFB1Ymxpc2hlckV2ZW50VHlwZXMuUFVCTElTSF9JTlZBTElEX05BTUUpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuUFVCTElTSF9JTlZBTElEX05BTUUsIHRoaXMpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGluaXRpYWxpemUgdGhlIEZsYXNoLWJhc2VkIFB1Ymxpc2hlciBiYXNlZCBvbiBjb25maWd1cmF0aW9uLlxuICAgKiBUaGUgcmV0dXJuZWQgYFByb21pc2VgIHdpbGwgZWl0aGVyIHJlc29sdmUgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlIG9yIHJlamVjdCB3aXRoIGFuIGVycm9yIGBTdHJpbmdgIGluIGZhaWx1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgaW5pdGlhbGl6YXRpb24gY29uZmlndXJhdGlvbiBtYXAuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBpbml0IChvcHRpb25zKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGNvbnN0IHZlcnNpb24gPSBvcHRpb25zLm1pbkZsYXNoVmVyc2lvbiB8fCBkZWZhdWx0T3B0aW9ucy5taW5GbGFzaFZlcnNpb25cbiAgICBpZiAoIWVudmlyb25tZW50LnN1cHBvcnRzRmxhc2hWZXJzaW9uKHZlcnNpb24pKSB7XG4gICAgICBkZWZlcnJlZC5yZWplY3QoYENvdWxkIG5vdCByZXNvbHZlIFJUTVBQdWJsaXNoZXIgaW5zdGFuY2UuIFJlcXVpcmVzIG1pbmltdW0gRmxhc2ggUGxheWVyIGluc3RhbGwgb2YgJHt2ZXJzaW9ufWApXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKVxuICAgICAgdHJ5IHtcbiAgICAgICAgZW52aXJvbm1lbnQuaW5qZWN0U2NyaXB0KHRoaXMuX29wdGlvbnMuc3dmb2JqZWN0VVJMKVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKE5BTUUsICdTV0ZPYmplY3QgZW1iZWRkZWQuJylcbiAgICAgICAgICAgIGlmIChzZWxmLl9zb3VyY2VIYW5kbGVyKSB7XG4gICAgICAgICAgICAgIGRlYnVnKE5BTUUsICdQdWJsaXNoIGhhbmRsZXIgZXN0YWJsaXNoZWQuJylcbiAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3NvdXJjZUhhbmRsZXIuYWRkU291cmNlKHNlbGYuX2VsZW1lbnRJZCwgc2VsZi5fb3B0aW9ucylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRlYnVnKE5BTUUsICdQdWJsaXNoIGhhbmRsZXIgbm90IGVzdGFibGlzaGVkLicpXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBzZWxmLl9zZXRWaWV3SWZOb3RFeGlzdChzZWxmLl92aWV3LCBzZWxmLl9vcHRpb25zLm1lZGlhRWxlbWVudElkKVxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShzZWxmKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICBlcnJvcihOQU1FLCBgQ291bGQgbm90IGVtYmVkIEZsYXNoLWJhc2VkIFJUTVAgUHVibGlzaGVyLiBSZWFzb246ICR7ZXJyfWApXG4gICAgICAgICAgICBpZiAoc2VsZi5fc291cmNlSGFuZGxlcikge1xuICAgICAgICAgICAgICBzZWxmLl9zb3VyY2VIYW5kbGVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycilcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUlRNUFB1Ymxpc2hlckV2ZW50VHlwZXMuRU1CRURfRkFJTFVSRSwgc2VsZikpXG4gICAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGBDb3VsZCBub3QgaW5qZWN0IEZsYXNoLWJhc2VkIFB1Ymxpc2hlciBpbnRvIHRoZSBwYWdlLiBSZWFzb246ICR7ZS5tZXNzYWdlfWApXG4gICAgICAgIHNlbGYudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUlRNUFB1Ymxpc2hlckV2ZW50VHlwZXMuRU1CRURfRkFJTFVSRSwgc2VsZikpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBiZWluZyBhIGJyb2FkY2FzdCBzZXNzaW9uIGFmdGVyIGluaXRpbGl6YXRpb24gaGFzIG9jY3VyZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJlYW1OYW1lXG4gICAqICAgICAgICBPcHRpb25hbCBzdHJlYW0gbmFtZSB0byBicm9hZGNhc3Qgb24sIG90aGVyd2lzZSBkZWZhdWx0aW5nIHRvIHRoZSBgc3RyZWFtTmFtZWAgcHJvdmlkZWQgaW4gYGluaXQoKWAgY29uZmlndXJhdGlvbi5cbiAgICogQHBhcmFtIHtQcm9taXNlfSBwcm9taXNlXG4gICAqICAgICAgICBPcHRpb25hbCBgUHJvbWlzZWAgb2JqZWN0IHRvIHJlc29sdmUvcmVqZWN0IG9uIGJhc2VkIG9uIHNlcXVlbmNlIG9mIGV2ZW50cyBpbiBlc3RhYmxpc2hpbmcgYSBicm9hZGNhc3QsIG90aGVyd2lzZSBkZWZhdWx0aW5nIHRvIGBQcm9taXNlYCBjcmVhdGVkIGludGVybmFsbHkgYW5kIHJldHVybmVkLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgICAgICAgVGhlIHJldHVybmVkIGBQcm9taXNlYCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IG9uIHN1Y2Nlc3NmdWwgc3RhcnQgb2YgYSBicm9hZGNhc3QuPGJyPlxuICAgKiAgICAgICAgVGhlcmUgYXJlIHNldmVyYWwgcHJvY2Vzc2VzIHRoYXQgb2NjdXIgaW4gb3JkZXIgdG8gZXN0YWJsaXNoIGEgRmxhc2gtYmFzZWQgYnJvYWRjYXN0IHRoYXQgaW52b2x2ZSAtIGJ1dCBhcmUgbm90IGxpbWl0ZWQgdG8gLSBwcm9wZXIgZW1iZWQgb2YgRmxhc2ggb2JqZWN0IG9uIHBhZ2Ugd2l0aCBmbGFzaHZhcnMgdXNlZCBpbiBlc3RhYmxpc2hpbmcgUlRNUC1iYXNlZCBOZXRDb25uZWN0aW9uLlxuICAgKi9cbiAgcHVibGlzaCAoc3RyZWFtTmFtZSA9IHVuZGVmaW5lZCwgcHJvbWlzZSA9IHVuZGVmaW5lZCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgY29uc3QgZGZkID0gcHJvbWlzZSB8fCBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICB0aGlzLl9zZXRVcENvbm5lY3RDYWxsYmFjayhkZmQpXG4gICAgdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lID0gc3RyZWFtTmFtZSB8fCB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWVcbiAgICBjb25zdCBwdWJsaXNoT3B0aW9ucyA9IHRoaXMuX29wdGlvbnNcbiAgICB0cnkge1xuICAgICAgbGV0IHNyY0hhbmRsZXIgPSB0aGlzLl9zb3VyY2VIYW5kbGVyXG4gICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLmdldEVtYmVkT3BlcmF0aW9uKClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGRlYnVnKE5BTUUsICdbaGFuZGxlcjplbWJlZDpjb21wbGV0ZV0nKVxuICAgICAgICAgIGNvbnN0IGVsID0gZW52aXJvbm1lbnQuZ2V0RW1iZWRPYmplY3QodGhpcy5fZWxlbWVudElkKVxuICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgdGhpcy5fZXN0YWJsaXNoRXh0SW50SGFuZGxlcnMoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgY291bnQgPSAwXG4gICAgICAgICAgY29uc3QgbGltaXQgPSAxMDBcbiAgICAgICAgICBsZXQgdHJ5Q29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxldCB0aW1lb3V0XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgICAgICAgICAgICAgc3JjSGFuZGxlci5jb25uZWN0KEpTT04uc3RyaW5naWZ5KHB1Ymxpc2hPcHRpb25zKSlcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCsrID4gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IGVcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdHJ5Q29ubmVjdCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAzMDApXG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeUNvbm5lY3QoKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICBkZmQucmVqZWN0KGVycilcbiAgICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFLCB0aGlzKSlcbiAgICAgICAgfSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcihOQU1FLCAnW2hhbmRsZXI6ZW1iZWQ6ZXJyb3JdJylcbiAgICAgIGRmZC5yZWplY3QoYENvdWxkIG5vdCBpbml0aWF0ZSBjb25uZWN0aW9uIHNlcXVlbmNlLiBSZWFzb246ICR7ZS5tZXNzYWdlfWApXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFLCB0aGlzKSlcbiAgICAgIHRoaXMuX3RlYXJEb3duQ29ubmVjdENhbGxiYWNrKClcbiAgICB9XG4gICAgdGhpcy5fY29ubmVjdEZ1dHVyZSA9IGRmZFxuICAgIHJldHVybiBkZmQucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gc3RvcCBhIGJyb2FkY2FzdC5cbiAgICogVGhlIHJldHVybmVkIGBQcm9taXNlYCB3aWxsIGVpdGhlciByZXNvbHZlIG9yIHJlamVjdCBvbiBzdWNjZXNzZnVsIHN0b3Agb2YgYnJvYWRjYXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgdW5wdWJsaXNoICgpIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRyeSB7XG4gICAgICBlbnZpcm9ubWVudC5nZXRFbWJlZE9iamVjdCh0aGlzLl9lbGVtZW50SWQpLnVucHVibGlzaCgpXG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKClcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yKE5BTUUsIGBDb3VsZCBub3QgaW5pdGlhdGUgcHVibGlzaCBzZXF1ZW5jZS4gUmVhc29uOiAke2UubWVzc2FnZX1gKVxuICAgICAgZGVmZXJyZWQucmVqZWN0KGUubWVzc2FnZSlcbiAgICB9XG4gICAgdGhpcy5fY29ubmVjdEZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBzZW5kIGEgbWVzc2FnZSB0byBhbGwgc3Vic2NyaWJlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2ROYW1lXG4gICAqICAgICAgICBUaGUgbWV0aG9kIG5hbWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBtZXNzYWdlIHRvIGJlIGFjY2VwdGVkIGJ5IGFsbCBzdWJzY3JpYmVycy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogICAgICAgIFRoZSBkYXRhIG9iamVjdCB0byBzZW5kIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWV0aG9kIG5hbWUuXG4gICAqL1xuICBzZW5kIChtZXRob2ROYW1lLCBkYXRhKSB7XG4gICAgdGhpcy5fc291cmNlSGFuZGxlci5zZW5kKG1ldGhvZE5hbWUsIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IGRhdGEgOiBKU09OLnN0cmluZ2lmeShkYXRhKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkLiBSZXF1ZXN0IHRvIHVwZGF0ZSBicm9hZGNhc3QgZGltZW5zaW9ucyBiZWZvcmUgYSBicm9hZGNhc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBxdWFsaXR5XG4gICAqICAgICAgICBFeHBlY3RzIG9iamVjdCB3aXRoIGZvbGxvd2luZyBzdHJ1Y3R1cjogYHt2aWRlbzoge3dpZHRoOkludCwgaGVpZ2h0SW50fX1cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldE1lZGlhUXVhbGl0eSAocXVhbGl0eSkge1xuICAgIGlmICh0aGlzLl9zb3VyY2VIYW5kbGVyKSB7XG4gICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLnNldE1lZGlhUXVhbGl0eShxdWFsaXR5KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIHRvIG92ZXJsYXkgb3B0aW9ucyBvdmVyIGN1cnJlbnQgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG5ld09wdGlvbnNcbiAgICogICAgICAgIFRoZSBvcHRpb25zIHRvIG92ZXJsYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvdmVybGF5T3B0aW9ucyAobmV3T3B0aW9ucykge1xuICAgIHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHRoaXMuX29wdGlvbnMsIG5ld09wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgRmxhc2gvUlRNUCBjb25uZWN0aW9uIGhlbHBlciBpZiBlc3RhYmxpc2hlZC5cbiAgICogVXNlZCBpbiBTaGFyZWRPYmplY3QgY29tbXVuaWNhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7UHVibGlzaGVyU291cmNlSGFuZGxlcn1cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldENvbm5lY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VIYW5kbGVyXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5pdGlhbGl6YXRpb24gY29uZmlndXJhdGlvbiB1c2VkIGluIGBpbml0KClgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRPcHRpb25zICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHR5cGUgb2YgaW1wbGVtZW50YXRpb246IGBSVE1QYC5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuIFB1Ymxpc2hUeXBlcy5SVE1QLnRvVXBwZXJDYXNlKClcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJUTVBQdWJsaXNoZXJcbiIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgU29ja2V0SGVscGVyIGZyb20gJy4vc29ja2V0LWhlbHBlcidcbmltcG9ydCB7IGlzT2JqZWN0RW1wdHkgfSBmcm9tICcuLi91dGlsL29iamVjdCdcbmltcG9ydCB7IGRlYnVnLCB3YXJuIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvUHVibGlzaGVyU29ja2V0J1xuXG4vKipcbiAqIFB1Ymxpc2hlci1iYXNlZCBleHRlbnNpb24gb2YgYFNvY2tldEhlbHBlcmAuXG4gKlxuICogQGV4dGVuZHMge1NvY2tldEhlbHBlcn1cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBQdWJsaXNoZXJTb2NrZXRIZWxwZXIgZXh0ZW5kcyBTb2NrZXRIZWxwZXIge1xuXG4gIGNvbnN0cnVjdG9yIChyZXNwb25kZXIpIHtcbiAgICBzdXBlcihyZXNwb25kZXIsIE5BTUUpXG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgdG8gcmVzcG9uZCB0byBtZXNzYWdlcyBjb21pbmcgb3ZlciBXZWJTb2NrZXQuXG4gICAqL1xuICByZXNwb25kIChtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UuZGF0YSkge1xuICAgICAgbGV0IGpzb24gPSB0aGlzLmdldEpzb25Gcm9tU29ja2V0TWVzc2FnZShtZXNzYWdlKVxuICAgICAgaWYgKCFzdXBlci5yZXNwb25kKG1lc3NhZ2UpKSB7XG4gICAgICAgIGlmIChqc29uLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChqc29uLmRhdGEuc2RwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChqc29uLmRhdGEuc2RwLnR5cGUgPT09ICdhbnN3ZXInKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNEUEFuc3dlcihqc29uLmRhdGEpXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChqc29uLmRhdGEuY2FuZGlkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdEVtcHR5KGpzb24uZGF0YS5jYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbkVtcHR5Q2FuZGlkYXRlKClcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbkFkZEljZUNhbmRpZGF0ZShqc29uLmRhdGEuY2FuZGlkYXRlKVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoanNvbi5kYXRhLnR5cGUgPT09ICdzdGF0dXMnKSB7XG4gICAgICAgICAgICBpZiAoanNvbi5kYXRhLmNvZGUgPT09ICdOZXRDb25uZWN0aW9uLklDRS5UcmljbGVDb21wbGV0ZWQnIHx8XG4gICAgICAgICAgICAgICBqc29uLmRhdGEuY29kZSA9PT0gJ05ldENvbm5lY3Rpb24uSUNFLlRyaWNrbGVDb21wbGV0ZWQnKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNvY2tldEljZUNhbmRpZGF0ZUVuZCgpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGpzb24uZGF0YS5jb2RlID09PSAnTmV0Q29ubmVjdGlvbi5QdWJsaXNoLkluc3VmZmljaWVudEJXJykge1xuICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25JbnN1ZmZpY2llbnRCYW5kd2lkdGgoanNvbi5kYXRhKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChqc29uLmRhdGEuY29kZSA9PT0gJ05ldENvbm5lY3Rpb24uUHVibGlzaC5TdWZmaWNpZW50QlcnKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblN1ZmZpY2llbnRCYW5kd2lkdGgoanNvbi5kYXRhKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChqc29uLmRhdGEuY29kZSA9PT0gJ05ldENvbm5lY3Rpb24uUHVibGlzaC5SZWNvdmVyaW5nQlcnKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblJlY292ZXJpbmdCYW5kd2lkdGgoanNvbi5kYXRhKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uUHVibGlzaGVyU3RhdHVzKGpzb24uZGF0YSlcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGpzb24udHlwZSAhPT0gdW5kZWZpbmVkICYmIGpzb24udHlwZS50b0xvd2VyQ2FzZSgpID09PSAnbWV0YWRhdGEnKSB7XG4gICAgICAgICAgICAgIC8vIEl0IGlzIGEgYHNlbmRgIEFQSSBpbnZvY2F0aW9uLlxuICAgICAgICAgICAgICBpZiAoanNvbi5tZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNlbmRSZWNlaXZlZChqc29uLm1ldGhvZCwganNvbi5kYXRhKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uTWV0YURhdGEoanNvbi5kYXRhKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU29ja2V0TWVzc2FnZSh0aGlzLCBtZXNzYWdlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKE5BTUUsICdbd3Mub25tZXNzYWdlXSAtIE5vIE1lc3NhZ2UgRGF0YS4nKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQb3N0cyBhbiB1bnB1Ymxpc2ggcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9XG4gICAqICAgICAgICBUaGUgc3RyZWFtIG5hbWUgdG8gdW5wdWJsaXNoLlxuICAgKi9cbiAgcG9zdFVucHVibGlzaCAoc3RyZWFtTmFtZSkge1xuICAgIGlmICh0aGlzLl93ZWJzb2NrZXQgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl9vcGVuU3RhdGUgIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICB0aGlzLnBvc3Qoe1xuICAgICAgdW5wdWJsaXNoOiBzdHJlYW1OYW1lXG4gICAgfSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gbGVhdmUgZ3JvdXAgZnJvbSBjb25mZXJlbmNlIHBhcnRpY2lwYW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBcbiAgICogICAgICAgIFRoZSBncm91cCBuYW1lIHRvIGxlYXZlLlxuICAgKi9cbiAgcG9zdFVuam9pbiAoZ3JvdXAsIHN0cmVhbU5hbWUpIHtcbiAgICBpZiAodGhpcy5fd2Vic29ja2V0ID09PSB1bmRlZmluZWQgfHwgdGhpcy5fb3BlblN0YXRlICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgZGVidWcoTkFNRSwgYFtwZWVyY29ubmVjdGlvbjpsZWF2ZWdyb3VwXWApXG4gICAgcmV0dXJuIHRoaXMucG9zdCh7XG4gICAgICBsZWF2ZUdyb3VwOiBncm91cCxcbiAgICAgIHN0cmVhbU5hbWU6IHN0cmVhbU5hbWVcbiAgICB9KVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUHVibGlzaGVyU29ja2V0SGVscGVyXG4iLCIndXNlIHN0cmljdCdcbmltcG9ydCAqIGFzIHdlYnJ0YyBmcm9tICcuLi9hZGFwdGVyL3dlYnJ0YydcbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCBXZWJSVENQZWVySGVscGVyIGZyb20gJy4vd2VicnRjLWhlbHBlcidcbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IGRlYnVnLCB3YXJuIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvUHVibGlzaFBlZXInXG5cbi8qKlxuICogUHJveHkgdG8gUGVlciBDb25uZWN0aW9uIGZvciBQdWJsaXNoZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFB1Ymxpc2hlclBlZXJIZWxwZXIgZXh0ZW5kcyBXZWJSVENQZWVySGVscGVyIHtcbiAgY29uc3RydWN0b3IocmVzcG9uZGVyKSB7XG4gICAgc3VwZXIocmVzcG9uZGVyLCBOQU1FKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgaGFuZGxlcnMgYXNzaWduZWQgdG8gdGhlIHBlZXIgY29ubmVjdGlvbiBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtSVENQZWVyQ29ubmVjdGlvbn0gY29ubmVjdGlvblxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbW92ZUNvbm5lY3Rpb25IYW5kbGVycyhjb25uZWN0aW9uKSB7XG4gICAgY29ubmVjdGlvbi5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IHVuZGVmaW5lZFxuICAgIGNvbm5lY3Rpb24ub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSB1bmRlZmluZWRcbiAgICBjb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gdW5kZWZpbmVkXG4gICAgY29ubmVjdGlvbi5vbnRyYWNrID0gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogQXNzaWducyBoYW5kbGVycyB0byBldmVudHMgb24gdGhlIHBlZXIgY29ubmVjdGlvbiBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtSVENQZWVyQ29ubmVjdGlvbn0gY29ubmVjdGlvblxuICAgKiBAcGFyYW0ge1Byb21pc2V9IHByb21pc2VcbiAgICogICAgICAgIFRoZSBgUHJvbWlzZWAgdG8gcmVzb2x2ZSBvciByZWplY3Qgb24gc3VjY2VzcyBvZiBjb25uZWN0aW9uLlxuICAgKi9cbiAgX2FkZENvbm5lY3Rpb25IYW5kbGVycyhjb25uZWN0aW9uLCBwcm9taXNlKSB7XG4gICAgbGV0IHJlY29ubmVjdFRpbWVvdXRcbiAgICBjb25zdCB0aW1lb3V0TGltaXQgPSA1MDAwXG5cbiAgICBjb25uZWN0aW9uLm9udHJhY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgIGRlYnVnKE5BTUUsIGBbcGVlcjpvbnRyYWNrXWApXG4gICAgICBjb25zb2xlLmxvZyhldmVudClcbiAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblBlZXJDb25uZWN0aW9uVHJhY2tBZGQoZXZlbnQudHJhY2spXG4gICAgfVxuXG4gICAgY29ubmVjdGlvbi5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGRlYnVnKE5BTUUsIGBbcGVlci5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZV0gLSBTdGF0ZTogJHtjb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZX1gKVxuICAgICAgaWYgKGNvbm5lY3Rpb24uY29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICBkZWJ1ZyhOQU1FLCAnW3BlZXJjb25uZWN0aW9uOm9wZW5dJylcbiAgICAgICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgICBwcm9taXNlLnJlc29sdmUodGhpcylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25QZWVyQ29ubmVjdGlvbk9wZW4oKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb24uY29ubmVjdGlvblN0YXRlID09PSAnZmFpbGVkJyB8fCBjb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgd2FybihOQU1FLCAnW3BlZXJjb25uZWN0aW9uOmVycm9yXScpXG4gICAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgICAgcHJvbWlzZS5yZWplY3QoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25QZWVyQ29ubmVjdGlvbkZhaWwoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29ubmVjdGlvbi5vbmljZWNhbmRpZGF0ZSA9IChldmVudCkgPT4ge1xuICAgICAgZGVidWcoTkFNRSwgYFtwZWVyLm9uaWNlY2FuZGlkYXRlXSAtIFBlZXIgQ2FuZGlkYXRlOiAke2V2ZW50LmNhbmRpZGF0ZX1gKVxuICAgICAgaWYgKGV2ZW50LmNhbmRpZGF0ZSkge1xuICAgICAgICB0aGlzLl9yZXNwb25kZXIub25JY2VDYW5kaWRhdGUoZXZlbnQuY2FuZGlkYXRlKVxuICAgICAgfSBlbHNlIGlmIChldmVudC5jYW5kaWRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gbnVsbCBtZWFucyB0aGV5IGhhdmUgZmluaXNoZWQgc2VuZGluZyBjYW5kaWRhdGVzIGJhY2sgYW5kIGZvcnRoP1xuICAgICAgICAvLyB0aGlzLl9yZXNwb25kZXIub25JY2VDYW5kaWRhdGVUcmlja2xlRW5kKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25uZWN0aW9uLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGNvbm5lY3Rpb24uaWNlQ29ubmVjdGlvblN0YXRlXG4gICAgICBkZWJ1ZyhOQU1FLCBgW3BlZXIub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2VdIC0gU3RhdGU6ICR7c3RhdGV9YClcbiAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcgJiYgZW52aXJvbm1lbnQuZ2V0SXNFZGdlKCkpIHtcbiAgICAgICAgLy8gU3VwcG9ydCBmb3IgT1JUQyBvcmRlciBvZiBjYW5kaWRhdGVzLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIGludm9rZWQgZnJvbSBhIGBvbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlYCBldmVudCBvbiB0aGUgQ29ubmVjdGlvbi5cbiAgICAgICAgLy8gRWRnZSBkb2Vzbid0IG5vdGlmeSBvbiB0aGF0IGV2ZW50LlxuICAgICAgICBkZWJ1ZyhOQU1FLCAnW2VkZ2Uvb3J0Yzpub3RpZnkgY29tcGxldGVdJylcbiAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uUGVlckdhdGhlcmluZ0NvbXBsZXRlKClcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgIGlmIChyZWNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHJlY29ubmVjdFRpbWVvdXQpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uUGVlckNvbm5lY3Rpb25DbG9zZShldmVudClcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgIC8vIG1heSByZWNlaXZlIGEgZGlzY29ubmVjdCB0ZW1wb3JhcmlseSB0aGF0IHdpbGwgdGhlbiByZXR1cm4gdG8gYSBjb25uZWN0aW9uLlxuICAgICAgICByZWNvbm5lY3RUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgZGVidWcoTkFNRSwgYFtwZWVyLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlXSAtIFJlY29ubmVjdCB0aW1lb3V0IHJlYWNoZWQuIENsb3NpbmcgUGVlckNvbm5lY3Rpb24uYClcbiAgICAgICAgICBjbGVhclRpbWVvdXQocmVjb25uZWN0VGltZW91dClcbiAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25QZWVyQ29ubmVjdGlvbkNsb3NlKGV2ZW50KVxuICAgICAgICB9LCB0aW1lb3V0TGltaXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVjb25uZWN0VGltZW91dCkge1xuICAgICAgICAgIGRlYnVnKE5BTUUsIGBbcGVlci5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZV0gLSBDbGVhcmluZyB0aW1lb3V0IGZvciByZWNvbm5lY3QuYClcbiAgICAgICAgICBjbGVhclRpbWVvdXQocmVjb25uZWN0VGltZW91dClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbm5lY3Rpb24ub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgY29uc3Qgc3RhdGUgPSBjb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlXG4gICAgICBkZWJ1ZyhOQU1FLCBgW3BlZXIub25zaWduYWxpbmdzdGF0ZWNoYW5nZV0gLSBTdGF0ZTogJHtzdGF0ZX1gKVxuICAgIH1cblxuICAgIGNvbm5lY3Rpb24ub25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gY29ubmVjdGlvbi5pY2VHYXRoZXJpbmdTdGF0ZVxuICAgICAgZGVidWcoTkFNRSwgYFtwZWVyLm9uaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2VdIC0gU3RhdGU6ICR7c3RhdGV9YClcbiAgICAgIGlmIChzdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICB0aGlzLl9yZXNwb25kZXIub25QZWVyR2F0aGVyaW5nQ29tcGxldGUoKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbm5lY3Rpb24ub25yZW1vdmVzdHJlYW0gPSAoKSA9PiB7XG4gICAgICBkZWJ1ZyhOQU1FLCBgW3BlZXIub25yZW1vdmVzdHJlYW1dYClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWVzc2FnZSBldmVudCBsaXN0ZW5lciBvbiBSVENEYXRhQ2hhbm5lbFxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uRGF0YUNoYW5uZWxNZXNzYWdlKGV2ZW50KSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGV2ZW50XG4gICAgaWYgKHN1cGVyLl9vbkRhdGFDaGFubmVsTWVzc2FnZShldmVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGxldCBqc29uID0gdGhpcy5nZXRKc29uRnJvbVNvY2tldE1lc3NhZ2UobWVzc2FnZSlcbiAgICBpZiAoanNvbiA9PT0gbnVsbCkge1xuICAgICAgd2Fybih0aGlzLl9uYW1lLCAnRGV0ZXJtaW5lZCB3ZWJzb2NrZXQgcmVzcG9uc2Ugbm90IGluIGNvcnJlY3QgZm9ybWF0LiBBYm9ydGluZyBtZXNzYWdlIGhhbmRsZS4nKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgZGVidWcodGhpcy5fbmFtZSwgJ1tkYXRhY2hhbm5lbC1yZXNwb25zZV06ICcgKyBKU09OLnN0cmluZ2lmeShqc29uLCBudWxsLCAyKSlcbiAgICBjb25zdCB7IGRhdGEgfSA9IGpzb25cbiAgICBpZiAoZGF0YSAmJiBkYXRhLnR5cGUgPT09ICdzdGF0dXMnKSB7XG4gICAgICBpZiAoZGF0YS5jb2RlID09PSAnTmV0U3RyZWFtLlBsYXkuVW5wdWJsaXNoTm90aWZ5Jykge1xuICAgICAgICB0aGlzLl9yZXNwb25kZXIub25VbnB1Ymxpc2goKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgZGVidWcoTkFNRSwgYFtkYXRhY2hhbm5lbC5tZXNzYWdlXSBzdGF0dXMgOjogJHtkYXRhLmNvZGV9YClcbiAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblB1Ymxpc2hlclN0YXR1cyhkYXRhKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgdGhpcy5fcmVzcG9uZGVyLm9uRGF0YUNoYW5uZWxNZXNzYWdlKHRoaXMuX2RhdGFDaGFubmVsLCBtZXNzYWdlKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gYGdldFVzZXJNZWRpYWAgb24gYnJvd3Nlci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRyYWludHNcbiAgICogICAgICAgIFRoZSBgTWVkaWFDb25zdHJhaW50c2Agb2JqZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3Rpb25DQlxuICAgKiAgICAgICAgQ2FsbGJhY2sgZm9yIHJlamVjdGlvbnMgb24gZ2V0VXNlck1lZGlhIGFzIHRoZSBTREsgZGV0ZXJtaW5lcyBwb3NzaWJsZSBuZWFyZXN0IG5laWdoYm9yLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzLCByZWplY3Rpb25DQikge1xuICAgIHJldHVybiB3ZWJydGMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzLCByZWplY3Rpb25DQilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGZvcmNlIGBnZXRVc2VyTWVkaWFgIHJlcXVlc3QgdXNpbmcgdGhlIHByb3ZpZGVkIGNvbnN0cmFpbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uc3RyYWludHNcbiAgICogICAgICAgIFRoZSBgTWVkaWFDb25zdHJhaW50c2AgdG8gZm9yY2UgaW4gcmVxdWVzdCBvbiBgZ2V0VXNlck1lZGlhYC5cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIGZvcmNlVXNlck1lZGlhKGNvbnN0cmFpbnRzKSB7XG4gICAgcmV0dXJuIHdlYnJ0Yy5mb3JjZVVzZXJNZWRpYShjb25zdHJhaW50cylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGNyZWF0ZSBhbiBPZmZlciB0aHJvdWdoIHRoZSBQZWVyIENvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBiYW5kd2lkdGhcbiAgICogICAgICAgIFRoZSBvcHRpb25hbCBiYW5kd2lkdGggY29uZmlndXJhdGlvbiB0byB1c2UgaW4gbXVuZ2luZyBTRFAgYmVmb3JlIHNlbmRpbmcgb2ZmZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2VWUDhcbiAgICogICAgICAgIFRoZSBvcHRpb25hbCBmbGFnIHRvIGZvcmNlIFZQOCBlbmNvZGluZy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBmb3JjZVNEUFN0cmlwZVxuICAgKiAgICAgICAgVGhlIG9wdGlvbmFsIGZsYWcgdG8gZm9yY2Ugc3RyaXBwaW5nIG9mIFNEUCBpbiBvcmRlciB0byBrZWVwIHVuZGVyIGNoYXIgbGltaXQgaW4gTWVzc2FnZS4gVXNlZCBieSBDb25mZXJlbmNlUGFydGljaXBhbnQuXG4gICAqIEBwYXJhbSB7UHJvbWlzZX0gcHJvbWlzZVxuICAgKiAgICAgICAgVGhlIGBQcm9taXNlYCB0byByZXNvbHZlIG9yIHJlamVjdCBvbiBzdWNjZXNzIG9mIHNlbmRpbmcgb2ZmZXIgb24gUGVlciBDb25uZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgY3JlYXRlT2ZmZXIoYmFuZHdpZHRoID0gbnVsbCwgZm9yY2VWUDggPSBmYWxzZSwgZm9yY2VTRFBTdHJpcCA9IGZhbHNlLCBvZmZlclByb21pc2UgPSBudWxsKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tjcmVhdGVvZmZlcl0nKVxuICAgIGNvbnN0IHAgPSBvZmZlclByb21pc2UgfHwgbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdGhpcy5fcGVlckNvbm5lY3Rpb25cbiAgICAgIC5jcmVhdGVPZmZlcigpXG4gICAgICAudGhlbigoc2Vzc2lvbkRlc2NyaXB0aW9uKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0TG9jYWxEZXNjcmlwdGlvbihzZXNzaW9uRGVzY3JpcHRpb24sIGJhbmR3aWR0aClcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBzZHAgfSA9IHNlc3Npb25EZXNjcmlwdGlvblxuICAgICAgICAgICAgaWYgKGJhbmR3aWR0aCkge1xuICAgICAgICAgICAgICBzZHAgPSB3ZWJydGMudXBkYXRlQmFuZHdpZHRoKGJhbmR3aWR0aCwgc2RwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RyaXBzIFNEUCB0byBqdXN0IHVzZSBPcHVzICYgSDI2NC4gQ3V0cyBTRFAgc2l6ZSBkb3duLlxuICAgICAgICAgICAgaWYgKGZvcmNlU0RQU3RyaXApIHtcbiAgICAgICAgICAgICAgc2RwID0gd2VicnRjLnN0cmlwUlRQTWFwcyhzZHApXG4gICAgICAgICAgICAgIHNkcCA9IHdlYnJ0Yy5zdHJpcE5vbkgyNjRGcm9tVmlkZW8oc2RwKVxuICAgICAgICAgICAgICBzZHAgPSB3ZWJydGMuZmxpcFJlY3ZPbmx5T25FeHRyYUF1ZGlvKHNkcClcbiAgICAgICAgICAgICAgc2RwID0gd2VicnRjLmZsaXBSZWN2T25seU9uRXh0cmFWaWRlbyhzZHApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9yY2VWUDgpIHtcbiAgICAgICAgICAgICAgc2RwID0gc2RwLnJlcGxhY2VBbGwoJ0gyNjQnLCAnSDI2NScpXG4gICAgICAgICAgICAgIGRlYnVnKE5BTUUsICdbY3JlYXRlb2ZmZXJdIEZPUkNJTkcgVlA4JylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbi5zZHAgPSBzZHBcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNEUFN1Y2Nlc3MoKVxuICAgICAgICAgICAgcC5yZXNvbHZlKHNlc3Npb25EZXNjcmlwdGlvbilcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25TRFBFcnJvcihlcnIpXG4gICAgICAgICAgICBwLnJlamVjdChlcnIpXG4gICAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBkZWJ1ZyhOQU1FLCAnW2NyZWF0ZW9mZmVyOmVycm9yXScpXG4gICAgICAgIHAucmVqZWN0KGVycilcbiAgICAgIH0pXG4gICAgcmV0dXJuIHAuaGFzT3duUHJvcGVydHkoJ3Byb21pc2UnKSA/IHAucHJvbWlzZSA6IHBcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGNyZWF0ZSBhbiBPZmZlciB0aHJvdWdoIHRoZSBQZWVyIENvbm5lY3Rpb24gd2l0aG91dCBpbW1lZGlhdGVseSBzZXR0aW5nIGFzIGxvY2FsIGRlc2NyaXB0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYmFuZHdpZHRoXG4gICAqICAgICAgICBUaGUgb3B0aW9uYWwgYmFuZHdpZHRoIGNvbmZpZ3VyYXRpb24gdG8gdXNlIGluIG11bmdpbmcgU0RQIGJlZm9yZSBzZW5kaW5nIG9mZmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlVlA4XG4gICAqICAgICAgICBUaGUgb3B0aW9uYWwgZmxhZyB0byBmb3JjZSBWUDggZW5jb2RpbmcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2VTRFBTdHJpcGVcbiAgICogICAgICAgIFRoZSBvcHRpb25hbCBmbGFnIHRvIGZvcmNlIHN0cmlwcGluZyBvZiBTRFAgaW4gb3JkZXIgdG8ga2VlcCB1bmRlciBjaGFyIGxpbWl0IGluIE1lc3NhZ2UuIFVzZWQgYnkgQ29uZmVyZW5jZVBhcnRpY2lwYW50LlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlT2ZmZXJXaXRob3V0U2V0TG9jYWwoYmFuZHdpZHRoID0gbnVsbCwgZm9yY2VWUDggPSBmYWxzZSwgZm9yY2VTRFBTdHJpcCA9IGZhbHNlKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tjcmVhdGVvZmZlcjp3aXRob3V0bG9jYWxdJylcbiAgICB0cnkge1xuICAgICAgbGV0IHNlc3Npb25EZXNjcmlwdGlvbiA9IGF3YWl0IHRoaXMuX3BlZXJDb25uZWN0aW9uLmNyZWF0ZU9mZmVyKClcbiAgICAgIGxldCB7IHNkcCB9ID0gc2Vzc2lvbkRlc2NyaXB0aW9uXG4gICAgICBpZiAoYmFuZHdpZHRoKSB7XG4gICAgICAgIHNkcCA9IHdlYnJ0Yy51cGRhdGVCYW5kd2lkdGgoYmFuZHdpZHRoLCBzZHApXG4gICAgICB9XG4gICAgICAvLyBTdHJpcHMgU0RQIHRvIGp1c3QgdXNlIE9wdXMgJiBIMjY0LiBDdXRzIFNEUCBzaXplIGRvd24uXG4gICAgICBpZiAoZm9yY2VTRFBTdHJpcCkge1xuICAgICAgICBzZHAgPSB3ZWJydGMuc3RyaXBSVFBNYXBzKHNkcClcbiAgICAgICAgc2RwID0gd2VicnRjLnN0cmlwTm9uSDI2NEZyb21WaWRlbyhzZHApXG4gICAgICAgIHNkcCA9IHdlYnJ0Yy5mbGlwUmVjdk9ubHlPbkV4dHJhQXVkaW8oc2RwKVxuICAgICAgICBzZHAgPSB3ZWJydGMuZmxpcFJlY3ZPbmx5T25FeHRyYVZpZGVvKHNkcClcbiAgICAgIH1cbiAgICAgIGlmIChmb3JjZVZQOCkge1xuICAgICAgICBzZHAgPSBzZHAucmVwbGFjZUFsbCgnSDI2NCcsICdIMjY1JylcbiAgICAgICAgZGVidWcoTkFNRSwgJ1tjcmVhdGVvZmZlcl0gRk9SQ0lORyBWUDgnKVxuICAgICAgfVxuICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uLnNkcCA9IHNkcFxuICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU0RQU3VjY2VzcygpXG4gICAgICByZXR1cm4gc2Vzc2lvbkRlc2NyaXB0aW9uXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoTkFNRSwgJ1tjcmVhdGVvZmZlcjplcnJvcl0nKVxuICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU0RQRXJyb3IoZSlcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUG9zdHMgYW4gdW5wdWJsaXNoIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfVxuICAgKiAgICAgICAgVGhlIHN0cmVhbSBuYW1lIHRvIHVucHVibGlzaC5cbiAgICovXG4gIHBvc3RVbnB1Ymxpc2goc3RyZWFtTmFtZSkge1xuICAgIC8vIGVsc2VcbiAgICBjb25zdCBjb21wbGV0ZSA9IHRoaXMucG9zdCh7XG4gICAgICB1bnB1Ymxpc2g6IHN0cmVhbU5hbWUsXG4gICAgfSlcbiAgICBkZWJ1ZyhOQU1FLCBgW3BlZXJjb25uZWN0aW9uOnVucHVibGlzaF0gY29tcGxldGU6ICR7Y29tcGxldGV9YClcbiAgICByZXR1cm4gY29tcGxldGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGxlYXZlIGdyb3VwIGZyb20gY29uZmVyZW5jZSBwYXJ0aWNpcGFudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwXG4gICAqICAgICAgICBUaGUgZ3JvdXAgbmFtZSB0byBsZWF2ZS5cbiAgICovXG4gIHBvc3RVbmpvaW4oZ3JvdXAsIHN0cmVhbU5hbWUpIHtcbiAgICBkZWJ1ZyhOQU1FLCBgW3BlZXJjb25uZWN0aW9uOmxlYXZlZ3JvdXBdYClcbiAgICByZXR1cm4gdGhpcy5wb3N0KHtcbiAgICAgIGxlYXZlR3JvdXA6IGdyb3VwLFxuICAgICAgc3RyZWFtTmFtZTogc3RyZWFtTmFtZSxcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFB1Ymxpc2hlclBlZXJIZWxwZXJcbiIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uL2NvcmUvZXZlbnQtZW1pdHRlcidcbmltcG9ydCAqIGFzIHdlYnJ0YyBmcm9tICcuLi9hZGFwdGVyL3dlYnJ0YydcbmltcG9ydCAqIGFzIHdlYnNvY2tldCBmcm9tICcuLi9hZGFwdGVyL3dlYnNvY2tldCdcbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCBQdWJsaXNoZXJTb2NrZXRIZWxwZXIgZnJvbSAnLi4vaGVscGVyL3NvY2tldC1oZWxwZXItcHViJ1xuaW1wb3J0IFB1Ymxpc2hlclBlZXJIZWxwZXIgZnJvbSAnLi4vaGVscGVyL3dlYnJ0Yy1oZWxwZXItcHViJ1xuaW1wb3J0IFB1Ymxpc2hWaWV3IGZyb20gJy4uL3ZpZXcvcHVibGlzaCdcbmltcG9ydCB7IFB1Ymxpc2hlckV2ZW50IH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgeyBNZXNzYWdlVHJhbnNwb3J0U3RhdGVFdmVudCwgTWVzc2FnZVRyYW5zcG9ydFN0YXRlRXZlbnRUeXBlcyB9IGZyb20gJy4uL2V2ZW50J1xuaW1wb3J0IHsgUHVibGlzaE1vZGVUeXBlcyB9IGZyb20gJy4uL2VudW0vcHVibGlzaCdcbmltcG9ydCB7IFB1Ymxpc2hUeXBlcyB9IGZyb20gJy4uL2VudW0vcHVibGlzaCdcbmltcG9ydCB7IEljZVRyYW5zcG9ydFR5cGVzIH0gZnJvbSAnLi4vZW51bS93ZWJydGMnXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UsIEZ1dHVyZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IFB1Ymxpc2hlckV2ZW50VHlwZXMsIFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCB7IFJUQ01lZGlhQ29uc3RyYWludCB9IGZyb20gJy4vY29uc3RyYWludCdcbmltcG9ydCB7IHJ0Y1NvY2tldEVuZHBvaW50RnJvbU9wdGlvbnMgYXMgZW5kcG9pbnRGcm9tT3B0aW9ucyB9IGZyb20gJy4uL3V0aWwvdXJsLWVuZHBvaW50J1xuaW1wb3J0IHsgZGVidWcgYXMgZGVidWdMb2cgfSBmcm9tICcuLi9sb2cnXG5pbXBvcnQgeyBlcnJvciBhcyBlcnJvckxvZyB9IGZyb20gJy4uL2xvZydcbmltcG9ydCB7IHdhcm4gYXMgd2FybkxvZyB9IGZyb20gJy4uL2xvZydcbmltcG9ydCB7IExFVkVMUyB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgcHViU3RhcnRSZWdleCA9IC8oLiopIHN0YXJ0aW5nL2lcbmNvbnN0IHB1YlN0b3BSZWdleCA9IC8oLiopIHN0b3BwaW5nL2lcbmNvbnN0IE5BTUUgPSAnUlRDUHVibGlzaGVyJ1xuY29uc3QgZGVidWcgPSAobWVzc2FnZSkgPT4ge1xuICBkZWJ1Z0xvZyhOQU1FLCBtZXNzYWdlKVxufVxuY29uc3Qgd2FybiA9IChtZXNzYWdlKSA9PiB7XG4gIHdhcm5Mb2coTkFNRSwgbWVzc2FnZSlcbn1cbmNvbnN0IGVycm9yID0gKG1lc3NhZ2UpID0+IHtcbiAgZXJyb3JMb2coTkFNRSwgbWVzc2FnZSlcbn1cblxuLy8gRGVmYXVsdCB0byBzZWN1cmUgc2V0dGluZ3MuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgcHJvdG9jb2w6ICd3c3MnLFxuICBwb3J0OiA0NDMsXG4gIGFwcDogJ2xpdmUnLFxuICBzdHJlYW1Nb2RlOiBQdWJsaXNoTW9kZVR5cGVzLkxJVkUsXG4gIGtleUZyYW1lcmF0ZTogMzAwMCxcbiAgbWVkaWFFbGVtZW50SWQ6ICdyZWQ1cHJvLXB1Ymxpc2hlcicsXG4gIHJ0Y0NvbmZpZ3VyYXRpb246IHtcbiAgICBpY2VTZXJ2ZXJzOiBbeyB1cmxzOiAnc3R1bjpzdHVuMi5sLmdvb2dsZS5jb206MTkzMDInIH1dLFxuICAgIGljZUNhbmRpZGF0ZVBvb2xTaXplOiAyLFxuICAgIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLFxuICB9LCAvLyBGYXZvcmVkIG92ZXIgaWNlU2VydmVycy5cbiAgaWNlU2VydmVyczogdW5kZWZpbmVkLCAvLyBEZXByZWNhdGVkLiBQcmVzZXJ2ZWQgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHkuXG4gIGljZVRyYW5zcG9ydDogSWNlVHJhbnNwb3J0VHlwZXMuVURQLFxuICBiYW5kd2lkdGg6IHtcbiAgICBhdWRpbzogNTYsXG4gICAgdmlkZW86IDUxMixcbiAgfSxcbiAgY2xlYXJNZWRpYU9uVW5wdWJsaXNoOiBmYWxzZSxcbiAgbWVkaWFDb25zdHJhaW50czogbmV3IFJUQ01lZGlhQ29uc3RyYWludCgpLFxuICBvbkdldFVzZXJNZWRpYTogdW5kZWZpbmVkLFxuICBzaWduYWxpbmdTb2NrZXRPbmx5OiB0cnVlLFxuICBkYXRhQ2hhbm5lbENvbmZpZ3VyYXRpb246IHVuZGVmaW5lZCxcbiAgZm9yY2VWUDg6IGZhbHNlLFxuICBzb2NrZXRTd2l0Y2hEZWxheTogMTAwMCxcbiAgYnlwYXNzQXZhaWxhYmxlOiBmYWxzZSxcbn1cblxuY29uc3QgZ2V0Q29uc3RyYWludHNGcm9tTWVkaWFTdHJlYW0gPSAoc3RyZWFtKSA9PiB7XG4gIGxldCBjb25zdHJhaW50cyA9IHsgYXVkaW86IGZhbHNlLCB2aWRlbzogZmFsc2UgfVxuICBsZXQgc2V0dGluZ3MgPSB7IGF1ZGlvOiBmYWxzZSwgdmlkZW86IGZhbHNlIH1cbiAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgaWYgKHRyYWNrLmtpbmQgPT09ICd2aWRlbycpIHtcbiAgICAgIHNldHRpbmdzLnZpZGVvID0gdHJhY2suZ2V0U2V0dGluZ3MoKVxuICAgICAgY29uc3RyYWludHMudmlkZW8gPSB0cmFjay5nZXRDb25zdHJhaW50cygpXG4gICAgfSBlbHNlIGlmICh0cmFjay5raW5kID09PSAnYXVkaW8nKSB7XG4gICAgICBzZXR0aW5ncy5hdWRpbyA9IHRyYWNrLmdldFNldHRpbmdzKClcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gdHJhY2suZ2V0Q29uc3RyYWludHMoKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHsgcmVxdWVzdGVkOiBjb25zdHJhaW50cywgYWNjZXB0ZWQ6IHNldHRpbmdzIH1cbn1cblxuLyoqXG4gKiBNYWluIGVudHJ5IGZvciBXZWJSVEMtYmFzZWQgUHVibGlzaGVyLlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5jbGFzcyBSVENQdWJsaXNoZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fb3B0aW9ucyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3ZpZXcgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wZWVySGVscGVyID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fc29ja2V0SGVscGVyID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fbWVzc2FnZVRyYW5zcG9ydCA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX21lZGlhU3RyZWFtID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fc3dpdGNoQ2hhbm5lbFJlcXVlc3QgPSB1bmRlZmluZWRcblxuICAgIHRoaXMuX3N0cmVhbUZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2F2YWlsYWJsZUZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3BlZXJGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9vZmZlckZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3NlbmRPZmZlckZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3RyaWNrbGVFbmRGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wdWJsaXNoRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fdW5wdWJsaXNoRnV0dXJlID0gdW5kZWZpbmVkXG5cbiAgICB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlID0gdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fZ1VNUmVqZWN0aW9uSGFuZGxlciA9IHRoaXMuX29uR1VNUmVqZWN0aW9uLmJpbmQodGhpcylcbiAgfVxuXG4gIF9nZXRNZWRpYVN0cmVhbSgpIHtcbiAgICB0aGlzLl9zdHJlYW1GdXR1cmUgPSBGdXR1cmUuY3JlYXRlSWZOb3RFeGlzdCh0aGlzLl9zdHJlYW1GdXR1cmUpXG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbUZ1dHVyZS5wcm9taXNlXG4gIH1cblxuICBfZ2V0VHJpY2tsZUVuZCgpIHtcbiAgICByZXR1cm4gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fdHJpY2tsZUVuZEZ1dHVyZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIGludGVybmFsIGBnZXRVc2VyTWVkaWFgIGxvZ2ljIHRvIGRldGVybWluZSBicm9hZGNhc3QgY29uc3RyYWludHMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgaW5pdGlhbGl6YXRpb24gb3B0aW9ucyBwcm92aWRlZCBpbiBgaW5pdCgpYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9ndW0ob3B0aW9ucykge1xuICAgIC8vIFNhZmFyaSBpc3N1ZSBpbiB3aGljaCwgaWYgdGhlIE1lZGlhU3RyZWFtIHRyYWNrIGxpc3Rpbmcgc3RhcnRzIHdpdGggYHZpZGVvYCwgYnJvYWRjYXN0aW5nIHdpbGwgZmFpbC5cbiAgICBjb25zdCBfaXNNZWRpYVN0cmVhbVRyYWNrTGlzdGluZ011bmdlZCA9IChtZWRpYVN0cmVhbSkgPT4ge1xuICAgICAgaWYgKCFtZWRpYVN0cmVhbSkgcmV0dXJuIGZhbHNlXG4gICAgICBjb25zdCB0cmFja3MgPSBtZWRpYVN0cmVhbS5nZXRUcmFja3MoKVxuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlcmUgYXJlIDIgdHJhY2tzIChvbmUgdmlkZW8gYW5kIG9uZSBhdWRpbyksIG90aGVyd2lzZSwgaXQgaXMgT0sgdG8gYnJvYWRjYXN0IHZpZGVvIG9ubHkuXG4gICAgICBpZiAodHJhY2tzICYmIHRyYWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJldHVybiB0cmFja3NbMF0ua2luZCA9PT0gJ3ZpZGVvJ1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMub25HZXRVc2VyTWVkaWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVidWcoJ1JlcXVlc3RpbmcgZ1VNIGZyb20gdXNlci1kZWZpbmVkIGNvbmZpZ3VyYXRpb246b25HZXRVc2VyTWVkaWEuJylcbiAgICAgIG9wdGlvbnNcbiAgICAgICAgLm9uR2V0VXNlck1lZGlhKClcbiAgICAgICAgLnRoZW4oKG1lZGlhKSA9PiB7XG4gICAgICAgICAgaWYgKF9pc01lZGlhU3RyZWFtVHJhY2tMaXN0aW5nTXVuZ2VkKG1lZGlhKSkge1xuICAgICAgICAgICAgZGVidWcoJ1dlIHJlY2VpdmVkIGEgTWVkaWFTdHJlYW0gd2l0aCBtaXNtYXRjaGluZyB0cmFjayBsaXN0aW5nLiBUcnlpbmcgYWdhaW4uLi4nKVxuICAgICAgICAgICAgdGhpcy5fZ3VtKG9wdGlvbnMpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKFxuICAgICAgICAgICAgbmV3IFB1Ymxpc2hlckV2ZW50KFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMuQ09OU1RSQUlOVFNfQUNDRVBURUQsIHRoaXMsIGdldENvbnN0cmFpbnRzRnJvbU1lZGlhU3RyZWFtKG1lZGlhKSlcbiAgICAgICAgICApXG4gICAgICAgICAgdGhpcy5fc3RyZWFtRnV0dXJlLnJlc29sdmUobWVkaWEpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgZXJyb3IoYENvdWxkIG5vdCByZXNvbHZlIE1lZGlhU3RyZWFtIGZyb20gcHJvdmlkZWQgZ1VNLiBFcnJvciAtICR7ZXJyfWApXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKFxuICAgICAgICAgICAgbmV3IFB1Ymxpc2hlckV2ZW50KFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMuQ09OU1RSQUlOVFNfUkVKRUNURUQsIHRoaXMsIHtcbiAgICAgICAgICAgICAgY29uc3RyYWludHM6IG9wdGlvbnMubWVkaWFDb25zdHJhaW50cyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICAgIHRoaXMuX3N0cmVhbUZ1dHVyZS5yZWplY3QoZXJyKVxuICAgICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZyhgUmVxdWVzdGluZyBnVU0gdXNpbmcgbWVkaWFDb25zdHJhaW50czogJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLm1lZGlhQ29uc3RyYWludHMsIG51bGwsIDIpfWApXG4gICAgICB0aGlzLl9wZWVySGVscGVyXG4gICAgICAgIC5nZXRVc2VyTWVkaWEob3B0aW9ucy5tZWRpYUNvbnN0cmFpbnRzLCB0aGlzLl9nVU1SZWplY3Rpb25IYW5kbGVyKVxuICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgaWYgKF9pc01lZGlhU3RyZWFtVHJhY2tMaXN0aW5nTXVuZ2VkKHJlcy5tZWRpYSkpIHtcbiAgICAgICAgICAgIGRlYnVnKCdXZSByZWNlaXZlZCBhIE1lZGlhU3RyZWFtIHdpdGggbWlzbWF0Y2hpbmcgdHJhY2sgbGlzdGluZy4gVHJ5aW5nIGFnYWluLi4uJylcbiAgICAgICAgICAgIHRoaXMuX2d1bShvcHRpb25zKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGRlYnVnKGBGb3VuZCB2YWxpZCBjb25zdHJhaW50czogJHtKU09OLnN0cmluZ2lmeShyZXMuY29uc3RyYWludHMsIG51bGwsIDIpfWApXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKFxuICAgICAgICAgICAgbmV3IFB1Ymxpc2hlckV2ZW50KFxuICAgICAgICAgICAgICBSVENQdWJsaXNoZXJFdmVudFR5cGVzLkNPTlNUUkFJTlRTX0FDQ0VQVEVELFxuICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICBnZXRDb25zdHJhaW50c0Zyb21NZWRpYVN0cmVhbShyZXMubWVkaWEpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5ESU1FTlNJT05fQ0hBTkdFLCB0aGlzLCByZXMuY29uc3RyYWludHMpKVxuICAgICAgICAgIHRoaXMuX3N0cmVhbUZ1dHVyZS5yZXNvbHZlKHJlcy5tZWRpYSlcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChyZWopID0+IHtcbiAgICAgICAgICBkZWJ1ZyhgQ291bGQgbm90IGZpbmQgdmFsaWQgY29uc3RyYWludCByZXNvbHV0aW9ucyBmcm9tOiAke0pTT04uc3RyaW5naWZ5KHJlai5jb25zdHJhaW50cywgbnVsbCwgMil9YClcbiAgICAgICAgICBlcnJvcihgQ291bGQgbm90IHJlc29sdmUgTWVkaWFTdHJlYW0gZnJvbSBwcm92aWRlZCBtZWRpYUNvbnN0cmFpbnRzLiBFcnJvciAtICR7cmVqLmVycm9yfWApXG4gICAgICAgICAgZGVidWcoXG4gICAgICAgICAgICBgQXR0ZW1wdGluZyB0byBmaW5kIHJlc29sdXRpb25zIGZyb20gb3JpZ2luYWwgcHJvdmlkZWQgY29uc3RyYWludHM6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgIHJlai5jb25zdHJhaW50cyxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgKX1gXG4gICAgICAgICAgKVxuICAgICAgICAgIHRoaXMudHJpZ2dlcihcbiAgICAgICAgICAgIG5ldyBQdWJsaXNoZXJFdmVudChSVENQdWJsaXNoZXJFdmVudFR5cGVzLkNPTlNUUkFJTlRTX1JFSkVDVEVELCB0aGlzLCB7IGNvbnN0cmFpbnRzOiByZWouY29uc3RyYWludHMgfSlcbiAgICAgICAgICApXG4gICAgICAgICAgLy8gYWxsb3dpbmcgdG8gdHJ5IG9yaWdpbmFsIGNvbnN0cmFpbnQgcmVxdWVzdGVkLlxuICAgICAgICAgIG9wdGlvbnMub25HZXRVc2VyTWVkaWEgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGVlckhlbHBlci5mb3JjZVVzZXJNZWRpYShyZWouY29uc3RyYWludHMpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2d1bShvcHRpb25zKVxuICAgICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmb3IgcmVqZWN0aW9uIG9uIGNvbnN0cmFpbnRzIGZyb20gUlRDIFBlZXIgSGVscGVyIGFuZCBnZXRVc2VyTWVkaWEgcmVxdWVzdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7TWVkaWFDb25zdHJhaW50c30gcmVqZWN0ZWRDb25zdHJhaW50c1xuICAgKiAgICAgICAgVGhlIE1lZGlhQ29uc3RyYWludHMgdGhhdCB3ZXJlIHJlamVjdGVkIGZyb20gdGhlIGBnZXRVc2VyTWVkaWFgIGNhbGwuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25HVU1SZWplY3Rpb24ocmVqZWN0ZWRDb25zdHJhaW50cykge1xuICAgIHRoaXMudHJpZ2dlcihcbiAgICAgIG5ldyBQdWJsaXNoZXJFdmVudChSVENQdWJsaXNoZXJFdmVudFR5cGVzLkNPTlNUUkFJTlRTX1JFSkVDVEVELCB0aGlzLCB7IGNvbnN0cmFpbnRzOiByZWplY3RlZENvbnN0cmFpbnRzIH0pXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgdXBvbiBgb25vcmllbnRhdGlvbmNoYW5nZWAgb2YgdGhlIGJyb3dzZXIuIE1vYmlsZSBicm93c2VycyBvbmx5LlxuICAgKlxuICAgKiBAcGFyYW0ge2ludH0gb3JpZW50YXRpb25cbiAgICogICAgICAgIFRoZSBvcmllbnRhdGlvbiB2YWx1ZSBvZiB0aGUgZGV2aWNlIGJyb3dzZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25PcmllbnRhdGlvbkNoYW5nZShvcmllbnRhdGlvbikge1xuICAgIGlmICh0aGlzLmdldE1lc3NhZ2VUcmFuc3BvcnQoKSkge1xuICAgICAgdGhpcy5nZXRNZXNzYWdlVHJhbnNwb3J0KCkucG9zdCh7XG4gICAgICAgIHNlbmQ6IHtcbiAgICAgICAgICBtZXRob2Q6ICdvbk1ldGFEYXRhJyxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBkZXZpY2VPcmllbnRhdGlvbjogb3JpZW50YXRpb24sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgdXBvbiByZWNlaXB0IGZyb20gYF9ndW1gIHdpdGggTWVkaWFTdHJlYW0gaW5zdGFuY2UgcmV0dXJuZWQgZnJvbSBicm93c2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBtZWRpYVN0cmVhbVxuICAgKiAgICAgICAgVGhlIGBNZWRpYVN0cmVhbWAgb2JqZWN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uTWVkaWFTdHJlYW1SZWNlaXZlZChtZWRpYVN0cmVhbSkge1xuICAgIHRoaXMuX21lZGlhU3RyZWFtID0gbWVkaWFTdHJlYW1cbiAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMuTUVESUFfU1RSRUFNX0FWQUlMQUJMRSwgdGhpcywgbWVkaWFTdHJlYW0pKVxuICAgIGlmICh0aGlzLl92aWV3KSB7XG4gICAgICB0aGlzLl92aWV3LnByZXZpZXcodGhpcy5fbWVkaWFTdHJlYW0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0aWxsIGluIHVzZSwgYnV0IGhvbGQtb3ZlciBvZiBwcmV2aW91cyAzLnggU0RLIHZlcnNpb25zIGRlc2lnbmVkIHRvIHBhaXIgdmlld3MgYW5kIHB1Ymxpc2hlcnMuIEluIDQuMC4wIGl0IGhhcyBiZWVuIGludGVybmFsaXplZC5cbiAgICogQVBJIGRlcHJlY2F0ZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0Vmlld0lmTm90RXhpc3QoY3VycmVudFZpZXcsIG1lZGlhRWxlbWVudElkID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBjdXJyZW50VmlldyA9PT0gJ3VuZGVmaW5lZCcgJiYgbWVkaWFFbGVtZW50SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IHZpZXcgPSBuZXcgUHVibGlzaFZpZXcobWVkaWFFbGVtZW50SWQpXG4gICAgICB2aWV3LmF0dGFjaFB1Ymxpc2hlcih0aGlzKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IGF2YWlsYWJpbGl0eSBiYXNlZCBvbiB1bmlxdWUgYHN0cmVhbU5hbWVgLlxuICAgKiBUaGUgcmV0dXJuIGZyb20gdGhlIFdlYlNvY2tldCByZXF1ZXN0IHdpbGwgZWl0aGVyIGludm9rZSBgb25TdHJlYW1BdmFpbGFibGVgIG9yIGBvblN0cmVhbVVuYXZhaWxhYmxlYC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmVhbU5hbWVcbiAgICogICAgICAgIFRoZSB1bmlxdWUgc3RyZWFtIG5hbWUgdG8gY2hlY2sgaWYgaXQgaXMgX3VuYXZhaWxhYmxlXyAtIG1lYW5pbmcgZnJlZSB0byBwdWJsaXNoIGFnYWluc3QuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgICAgICBUaGUgcHJvbWlzZSB3aWxsIHJlc29sdmUvcmVqZWN0IHRoZSBgX2F2YWlsYWJsZUZ1dHVyZWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVxdWVzdEF2YWlsYWJpbGl0eShzdHJlYW1OYW1lKSB7XG4gICAgZGVidWcoJ1tyZXF1ZXN0YXZhaWxhYmlsaXR5XScpXG4gICAgLy90aGlzLl9hdmFpbGFibGVGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9hdmFpbGFibGVGdXR1cmUgPSBGdXR1cmUuY3JlYXRlSWZOb3RFeGlzdCh0aGlzLl9hdmFpbGFibGVGdXR1cmUpXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuYnlwYXNzQXZhaWxhYmxlKSB7XG4gICAgICB0aGlzLl9hdmFpbGFibGVGdXR1cmUucmVzb2x2ZSh0cnVlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdCh7XG4gICAgICAgIGlzQXZhaWxhYmxlOiBzdHJlYW1OYW1lLFxuICAgICAgICBidW5kbGU6IHRydWUsXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYXZhaWxhYmxlRnV0dXJlLnByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIHNldHVwIFJUQ1BlZXJDb25uZWN0aW9uIGluc3RhbmNlIGZvciBleGNoYW5nZSBvZiBTRFAgbG9jYWxseSBhbmQgcmVtb3RlbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7UlRDQ29uZmlndXJhdGlvbn0gcnRjQ29uZmlndXJhdGlvblxuICAgKiAgICAgICAgQSBjdXN0b20gUlRDQ29uZmlndXJhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YUNoYW5uZWxDb25maWd1cmF0aW9uXG4gICAqICAgICAgICBPcHRpb25hbCBjb25maWd1cmF0aW9uIGZvciBkYXRhIGNoYW5uZWwgY29tbXVuaWNhdG9uLlxuICAgKiBAcGFyYW0ge0FycmF5fSBpY2VTZXJ2ZXJzXG4gICAqICAgICAgICBMaXN0IG9mIElDRSBzZXJ2ZXJzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgICAgICBUaGUgcHJvbWlzZSB3aWxsIHJlc29sdmUvcmVqZWN0IHRoZSBgX3BlZXJGdXR1cmVgLlxuICAgKlxuICAgKiBAbm90ZSBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwga2VlcGluZyBhcmd1bWVudHMgYXMgb3B0aW9uYWwsIHdpdGggYXQgbGVhc3Qgb25lIGJlaW5nIGZ1bGZpbGxlZC4gVGhlIGBjb25maWd1cmF0aW9uYCBwYXJhbSB3aWxsIGJlIGZhdm9yZWQgYWZ0ZXIgNS40LjAsIGBpY2VTZXJ2ZXJzYCBpcyB1cCBmb3IgZGVwcmVjYXRpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlUGVlckNvbm5lY3Rpb24oY29uZmlndXJhdGlvbiwgZGF0YUNoYW5uZWxDb25maWd1cmF0aW9uID0gdW5kZWZpbmVkLCBpY2VTZXJ2ZXJzID0gdW5kZWZpbmVkKSB7XG4gICAgZGVidWcoJ1tjcmVhdGVwZWVlcl0nKVxuICAgIHRoaXMuX3BlZXJGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wZWVyRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fcGVlckZ1dHVyZSlcblxuICAgIGlmIChpY2VTZXJ2ZXJzICYmIGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdUaGUgaWNlU2VydmVycyBjb25maWd1cmF0aW9uIHByb3BlcnR5IGlzIGNvbnNpZGVyZWQgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgcnRjQ29uZmlndXJhdGlvbiBjb25maWd1cmF0aW9uIHByb3BlcnR5IHVwb24gd2hpY2ggeW91IGNhbiBhc3NpZ24gaWNlU2VydmVycy4gUmVmZXJlbmNlOiBodHRwczovL3d3dy5yZWQ1cHJvLmNvbS9kb2NzL3N0cmVhbWluZy9taWdyYXRpb25ndWlkZS5odG1sJ1xuICAgICAgKVxuICAgICAgY29uZmlndXJhdGlvbi5pY2VTZXJ2ZXJzID0gaWNlU2VydmVyc1xuICAgIH1cbiAgICBsZXQgcFxuICAgIGlmIChjb25maWd1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHAgPSB0aGlzLl9wZWVySGVscGVyLnNldFVwV2l0aFBlZXJDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24sIGRhdGFDaGFubmVsQ29uZmlndXJhdGlvbiwgdGhpcy5fcGVlckZ1dHVyZSlcbiAgICB9IGVsc2Uge1xuICAgICAgcCA9IHRoaXMuX3BlZXJIZWxwZXIuc2V0VXAoaWNlU2VydmVycywgdGhpcy5fcGVlckZ1dHVyZSwgdGhpcy5fb3B0aW9ucy5ydGNwTXV4UG9saWN5KVxuICAgIH1cbiAgICByZXR1cm4gcFxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gZ2VuZXJhdGUgb2ZmZXIgb24gUGVlciBDb25uZWN0aW9uIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYmFuZHdpZHRoXG4gICAqICAgICAgICBPcHRpb25hbCBiYW5kd2lkdGggY29uZmlndXJhdGlvbiBvYmplY3QgdG8gbXVuZ2UgU0RQLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgICAgICAgVGhlIHByb21pc2Ugd2lsbCByZXNvbHZlL3JlamVjdCBhIHN1Y2Nlc3MgaW4gY3JlYXRpb24gb2YgdGhlIG9mZmVyIHRocm91Z2ggdGhlIFBlZXIgQ29ubmVjdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jcmVhdGVPZmZlcihiYW5kd2lkdGggPSBudWxsLCBmb3JjZVZQOCA9IGZhbHNlKSB7XG4gICAgZGVidWcoJ1tjcmVhdGVvZmZlcl0nKVxuICAgIHRoaXMuX29mZmVyRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fb2ZmZXJGdXR1cmUgPSBGdXR1cmUuY3JlYXRlSWZOb3RFeGlzdCh0aGlzLl9vZmZlckZ1dHVyZSlcbiAgICB0aGlzLl9wZWVySGVscGVyLmNyZWF0ZU9mZmVyKGJhbmR3aWR0aCwgZm9yY2VWUDgsIGZhbHNlLCB0aGlzLl9vZmZlckZ1dHVyZSlcbiAgICByZXR1cm4gdGhpcy5fb2ZmZXJGdXR1cmUucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gc2V0IGEgcmVtb3RlIGRlc2NyaXB0aW9uIG9uIFBlZXIgQ29ubmVjdGlvbiBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHNkcFxuICAgKiAgICAgICAgT2JqZWN0IGRlc2NyaWJpbmcgdGhlIFNlc3Npb24gRGVzY3JpcHRpb24uXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgICAgICBUaGUgcHJvbWlzZSB3aWxsIHJlc29sdmUvcmVqZWN0IGluIGEgc3VjY2VzcyBpbiBzZXR0aW5nIHRoZSByZW1vdGUgU0RQIG9uIHRoZSBQZWVyIENvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0UmVtb3RlRGVzY3JpcHRpb24oc2RwKSB7XG4gICAgZGVidWcoJ1tzZXRyZW1vdGVkZXNjcmlwdGlvbl0nKVxuICAgIHJldHVybiB0aGlzLl9wZWVySGVscGVyLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkcClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIHNlbmQgb2ZmZXIgb24gV2ViU29ja2V0IGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2RwXG4gICAqICAgICAgICBPYmplY3QgZGVzY3JpYmluZyB0aGUgU2Vzc2lvbiBEZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmVhbU5hbWVcbiAgICogICAgICAgIFRoZSB1bmlxdWUgc3RyZWFtIG5hbWUgb2YgdGhlIGJyb2FkY2FzdC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydFxuICAgKiAgICAgICAgVGhlIHRyYW5zcG9ydCB0eXBlLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgICAgICAgVGhlIHByb21pc2Ugd2lsbCByZXNvbHZlL3JlamVjdCBvbiB0aGUgc3VjY2VzcyBvZiBkZWxpdmVyaW5nIGFuIG9mZmVyIG92ZXIgdGhlIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZW5kT2ZmZXIoc2RwLCBzdHJlYW1OYW1lLCB0cmFuc3BvcnQpIHtcbiAgICBkZWJ1ZygnW3NlbmRvZmZlcl0nKVxuICAgIHRoaXMuX3NlbmRPZmZlckZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3NlbmRPZmZlckZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX3NlbmRPZmZGdXR1cmUpXG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnBvc3Qoe1xuICAgICAgaGFuZGxlT2ZmZXI6IHN0cmVhbU5hbWUsXG4gICAgICB0cmFuc3BvcnQ6IHRyYW5zcG9ydCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc2RwOiBzZHAsXG4gICAgICB9LFxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXMuX3NlbmRPZmZlckZ1dHVyZS5wcm9taXNlXG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBzZW5kIElDRSBjYW5kaWRhdGUgb3ZlciB0aGUgV2ViU29ja2V0LlxuICAgKiBUaGlzIGNhbiBoYXBwZW4gc2V2ZXJhbCB0aW1lcyBpbiB0aGUgSUNFIG5lZ290aWF0aW9uIHByb2Nlc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYW5kaWRhdGVcbiAgICogICAgICAgIFRoZSBDYW5kaWRhdGUgdG8gc2VuZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmVhbU5hbWVcbiAgICogICAgICAgIFRoZSBhc3NvY2lhdGVkIHVuaXF1ZSBzdHJlYW0gbmFtZSBvZiB0aGUgYnJvYWRjYXN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlbmRDYW5kaWRhdGUoY2FuZGlkYXRlLCBzdHJlYW1OYW1lKSB7XG4gICAgZGVidWcoJ1tzZW5kY2FuZGlkYXRlXScpXG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnBvc3Qoe1xuICAgICAgaGFuZGxlQ2FuZGlkYXRlOiBzdHJlYW1OYW1lLFxuICAgICAgZGF0YToge1xuICAgICAgICBjYW5kaWRhdGU6IGNhbmRpZGF0ZSxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IG9uIFdlYlNvY2tldCB0byBiZWdpbiBwdWJsaXNoaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyZWFtTmFtZVxuICAgKiAgICAgICAgVGhlIHVuaXF1ZSBzdHJlYW0gbmFtZSBvZiB0aGUgYnJvYWRjYXN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZVxuICAgKiAgICAgICAgVGhlIGJyb2FkY2FzdCBtb2RlOiBgbGl2ZWAsIGByZWNvcmRgIG9yIGBhcHBlbmRgLlxuICAgKiBAcGFyYW0ge2ludH0gZnJhbWVyYXRlXG4gICAqICAgICAgICBUaGUga2V5IGZyYW1lcmF0ZSB0byBicm9hZGNhc3QgYXQuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgICAgICBUaGUgcHJvbWlzZSB3aWxsIHJlc29sdmUvcmVqZWN0IGluIHRoZSByZXF1ZXN0IHRvIGJlaW5nIGEgYnJvYWRjYXN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlcXVlc3RQdWJsaXNoKHN0cmVhbU5hbWUsIHN0cmVhbU1vZGUsIGZyYW1lcmF0ZSkge1xuICAgIGRlYnVnKCdbcmVxdWVzdHB1Ymxpc2hdJylcbiAgICB0aGlzLl9wdWJsaXNoRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcHVibGlzaEZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX3B1Ymxpc2hGdXR1cmUpXG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnBvc3Qoe1xuICAgICAgcHVibGlzaDogc3RyZWFtTmFtZSxcbiAgICAgIG1vZGU6IHN0cmVhbU1vZGUsXG4gICAgICBrZXlGcmFtZXJhdGU6IGZyYW1lcmF0ZSxcbiAgICB9KVxuICAgIHJldHVybiB0aGlzLl9wdWJsaXNoRnV0dXJlLnByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIHN0b3AgYSBjdXJyZW50IGJyb2FkY2FzdC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmVhbU5hbWVcbiAgICogICAgICAgIFRoZSB1bmlxdWUgc3RyZWFtIG5hbWUgYmVpbmcgYnJvYWRjYXN0IG9uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgICAgICAgVGhlIHByb21pc2Ugd2lsbCByZXNvbHZlL3JlamVjdCBvbiBzdWNjZXNzIG9mIHByb3Blcmx5IHN0b3BwaW5nIGEgYnJvYWRjYXN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlcXVlc3RVbnB1Ymxpc2goc3RyZWFtTmFtZSkge1xuICAgIHRoaXMuX3VucHVibGlzaEZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3VucHVibGlzaEZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX3VucHVibGlzaEZ1dHVyZSlcbiAgICAvLyBJZiB3ZSBnZXQgYSBmYWxzZSByZXNwb25zZSBmcm9tIHRyeWluZyB0byBzZW5kIGEgY2xvc2UgUE9TVCxcbiAgICAvLyAgaXQgbWVhbnMgdGhhdCB0aGUgc29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ5IGFub3RoZXIgaW1wZXR1cyAtXG4gICAgLy8gIG1vc3QgbGlrbGV5IGxvc3Mgb2YgbmV0d29yayBvciBzZXJ2ZXIgZmFpbHVyZS5cbiAgICBpZiAoIXRoaXMuZ2V0TWVzc2FnZVRyYW5zcG9ydCgpLnBvc3RVbnB1Ymxpc2goc3RyZWFtTmFtZSkpIHtcbiAgICAgIHRoaXMuX3VucHVibGlzaEZ1dHVyZS5yZXNvbHZlKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3VucHVibGlzaEZ1dHVyZS5wcm9taXNlXG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBpbml0aWFsaXplIHRoZSBXZWJSVEMtYmFzZWQgUHVibGlzaGVyIGJhc2VkIG9uIGNvbmZpZ3VyYXRpb24uXG4gICAqIFRoZSByZXR1cm5lZCBgUHJvbWlzZWAgd2lsbCBlaXRoZXIgcmVzb2x2ZSB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2Ugb3IgcmVqZWN0IHdpdGggYW4gZXJyb3IgYFN0cmluZ2AgaW4gZmFpbHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFRoZSBpbml0aWFsaXphdGlvbiBjb25maWd1cmF0aW9uIG1hcC5cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIGluaXQob3B0aW9ucykge1xuICAgIHRoaXMuX3N0cmVhbUZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgaWYgKCF3ZWJydGMuaXNTdXBwb3J0ZWQoKSB8fCAhd2Vic29ja2V0LmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgIGRlZmVycmVkLnJlamVjdChcbiAgICAgICAgJ0Nhbm5vdCBjcmVhdGUgV2ViUlRDIHBsYXliYWNrIGluc3RhbmNlLiBZb3VyIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgV2ViUlRDIGFuZC9vciBXZWJTb2NrZXRzLidcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKVxuICAgICAgdGhpcy5fcGVlckhlbHBlciA9IG5ldyBQdWJsaXNoZXJQZWVySGVscGVyKHRoaXMpXG4gICAgICB0aGlzLl9zb2NrZXRIZWxwZXIgPSBuZXcgUHVibGlzaGVyU29ja2V0SGVscGVyKHRoaXMpXG4gICAgICB0aGlzLl9tZXNzYWdlVHJhbnNwb3J0ID0gdGhpcy5fbWVzc2FnZVRyYW5zcG9ydCB8fCB0aGlzLl9zb2NrZXRIZWxwZXJcbiAgICAgIHRoaXMuX2dldE1lZGlhU3RyZWFtKClcbiAgICAgICAgLnRoZW4odGhpcy5fb25NZWRpYVN0cmVhbVJlY2VpdmVkLmJpbmQodGhpcykpXG4gICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICB3YXJuKGBbZ3VtXTogJHtlcnJvcn1gKVxuICAgICAgICB9KVxuICAgICAgdGhpcy5fZ3VtKHRoaXMuX29wdGlvbnMpXG4gICAgICAvLyBhdXRvIHByZXZpZXcuXG4gICAgICB0aGlzLl9zZXRWaWV3SWZOb3RFeGlzdCh0aGlzLl92aWV3LCB0aGlzLl9vcHRpb25zLm1lZGlhRWxlbWVudElkKVxuICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0aGlzKVxuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gaW5pdGlhbGl6ZSB0aGUgV2ViUlRDLWJhc2VkIFB1Ymxpc2hlciBiYXNlZCBvbiBjb25maWd1cmF0aW9uIGFuZCBwcmV2aW91c2x5IGVzdGFibGlzaGVkIE1lZGlhU3RyZWFtLlxuICAgKiBVU0UgV0lUSCBDQVVUSU9OLiBJdCBpcyBhc3N1bWVkIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZyBpbiBhY2Nlc3NpbmcgYSBNZWRpYVN0cmVhbSBvdXRzaWRlIG9mIHRoZSBBUEkgYXZhaWxhYmxlIGZyb20gdGhlIFNESy5cbiAgICogVGhlIHJldHVybmVkIGBQcm9taXNlYCB3aWxsIGVpdGhlciByZXNvbHZlIHdpdGggYSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZSBvciByZWplY3Qgd2l0aCBhbiBlcnJvciBgU3RyaW5nYCBpbiBmYWlsdXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgVGhlIGluaXRpYWxpemF0aW9uIGNvbmZpZ3VyYXRpb24gbWFwLlxuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBtZWRpYVN0cmVhbVxuICAgKiAgICAgICAgQSBwcmV2aW91c2x5IGVzdGFibGlzaGVkIE1lZGlhU3RyZWFtLCBtb3N0IGxpa2VseSByZWNlaWV2ZWQgdGhyb3VnaCBnZXRVc2VyTWVkaWEoKSBvdXRzaWRlIG9mIFNESyB1c2UuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBpbml0V2l0aFN0cmVhbShvcHRpb25zLCBtZWRpYVN0cmVhbSkge1xuICAgIGRlYnVnKCdbaW5pdFdpdGhTdHJlYW1dJylcbiAgICB0aGlzLl9zdHJlYW1GdXR1cmUgPSB1bmRlZmluZWRcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGlmICghd2VicnRjLmlzU3VwcG9ydGVkKCkgfHwgIXdlYnNvY2tldC5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICBkZWZlcnJlZC5yZWplY3QoXG4gICAgICAgICdDYW5ub3QgY3JlYXRlIFdlYlJUQyBwbGF5YmFjayBpbnN0YW5jZS4gWW91ciBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFdlYlJUQyBhbmQvb3IgV2ViU29ja2V0cy4nXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucylcbiAgICAgIHRoaXMuX3BlZXJIZWxwZXIgPSBuZXcgUHVibGlzaGVyUGVlckhlbHBlcih0aGlzKVxuICAgICAgdGhpcy5fc29ja2V0SGVscGVyID0gbmV3IFB1Ymxpc2hlclNvY2tldEhlbHBlcih0aGlzKVxuICAgICAgdGhpcy5fbWVzc2FnZVRyYW5zcG9ydCA9IHRoaXMuX21lc3NhZ2VUcmFuc3BvcnQgfHwgdGhpcy5fc29ja2V0SGVscGVyXG4gICAgICAvLyBhdXRvIHByZXZpZXcuXG4gICAgICB0aGlzLl9zZXRWaWV3SWZOb3RFeGlzdCh0aGlzLl92aWV3LCB0aGlzLl9vcHRpb25zLm1lZGlhRWxlbWVudElkKVxuICAgICAgbGV0IG1lZGlhUHJvbWlzZSA9IHRoaXMuX2dldE1lZGlhU3RyZWFtKClcbiAgICAgIG1lZGlhUHJvbWlzZS50aGVuKHRoaXMuX29uTWVkaWFTdHJlYW1SZWNlaXZlZC5iaW5kKHRoaXMpKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgd2FybihgW2d1bV06ICR7ZXJyb3J9YClcbiAgICAgIH0pXG4gICAgICB0aGlzLl9zdHJlYW1GdXR1cmUucmVzb2x2ZShtZWRpYVN0cmVhbSlcbiAgICAgIGRlZmVycmVkLnJlc29sdmUodGhpcylcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGlsbCBpbiB1c2UgZm9yIGFzc2lnbmluZyBkb2N1bWVudCBlbGVtZW50IHZpZXcgbWFuYWdlbWVudCB0byB0aGlzIGluc3RhbmNlLlxuICAgKiBBUEkgZGVwcmVjYXRlZCBpbiA0LjAuMC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFZpZXcodmlldykge1xuICAgIHRoaXMuX3ZpZXcgPSB2aWV3XG4gICAgaWYgKHRoaXMuX21lZGlhU3RyZWFtICYmIHRoaXMuX3ZpZXcpIHtcbiAgICAgIHRoaXMuX3ZpZXcucHJldmlldyh0aGlzLl9tZWRpYVN0cmVhbSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIHByZXZpZXcgdGhlIGdlbmVyYXRlIE1lZGlhU3RyZWFtIGluIHRoZSB0YXJnZXQgdmlldyBwcmlvciB0byBwdWJsaXNoaW5nLlxuICAgKiBBdXRvbWF0aWNhbGx5IGNhbGxlZCB3aGVuIGludm9raW5nIGBwdWJsaXNoKClgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAc2VlICNwdWJsaXNoXG4gICAqL1xuICBwcmV2aWV3KCkge1xuICAgIGRlYnVnKCdbcHJldmlld10nKVxuICAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgICByZXModGhpcylcbiAgICB9KVxuICAgIHRoaXMuX3NldFZpZXdJZk5vdEV4aXN0KHRoaXMuX3ZpZXcsIHRoaXMuX29wdGlvbnMubWVkaWFFbGVtZW50SWQpXG4gICAgcmV0dXJuIHBcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIE1lZGlhU3RyZWFtIGZyb20gdGhlIHRhcmdldCB2aWV3IGFuZCByZWxlYXNlcyB0aGUgY2FtZXJhIGZyb20gdGhlIGJyb3dzZXIuXG4gICAqIElmIGBjbGVhck1lZGlhT25VbnB1Ymxpc2hgIGlzIHNldCBpbiB0aGUgaW5pdGlhbGl6YXRpb24gY29uZmlndXJhdGlvbiwgdGhpcyB3aWxsIGJlIGludm9rZWQgaW50ZXJuYWxseSB3aGVuIGB1bnB1Ymxpc2hgIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHNlZSAjcHJldmlld1xuICAgKi9cbiAgdW5wcmV2aWV3KCkge1xuICAgIGRlYnVnKCdbdW5wcmV2aWV3XScpXG4gICAgaWYgKHRoaXMuX21lZGlhU3RyZWFtKSB7XG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICB0cmFjay5zdG9wKClcbiAgICAgIH0pXG4gICAgfVxuICAgIGlmICh0aGlzLl92aWV3KSB7XG4gICAgICB0aGlzLl92aWV3LnVucHJldmlldygpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gYmVnaW4gYSBicm9hZGNhc3Qgc2Vzc2lvbiBhZnRlciBpbml0aWFsaXphdGlvbiBoYXMgb2NjdXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmVhbU5hbWVcbiAgICogICAgICAgIE9wdGlvbmFsIHN0cmVhbSBuYW1lIHRvIGJyb2FkY2FzdCBvbiwgb3RoZXJ3aXNlIGRlZmF1bHRpbmcgdG8gdGhlIGBzdHJlYW1OYW1lYCBwcm92aWRlZCBpbiBgaW5pdCgpYCBjb25maWd1cmF0aW9uLlxuICAgKiBAcGFyYW0ge1Byb21pc2V9IHByb21pc2VcbiAgICogICAgICAgIE9wdGlvbmFsIGBQcm9taXNlYCBvYmplY3QgdG8gcmVzb2x2ZS9yZWplY3Qgb24gYmFzZWQgb24gc2VxdWVuY2Ugb2YgZXZlbnRzIGluIGVzdGFibGlzaGluZyBhIGJyb2FkY2FzdCwgb3RoZXJ3aXNlIGRlZmF1bHRpbmcgdG8gYFByb21pc2VgIGNyZWF0ZWQgaW50ZXJuYWxseSBhbmQgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgICAgICBUaGUgcmV0dXJuZWQgYFByb21pc2VgIHdpbGwgcmVzb2x2ZSBvciByZWplY3Qgb24gc3VjY2Vzc2Z1bCBzdGFydCBvZiBhIGJyb2FkY2FzdC48YnI+XG4gICAqICAgICAgICBUaGVyZSBhcmUgc2V2ZXJhbCBwcm9jZXNzZXMgdGhhdCBvY2N1ciBpbiBvcmRlciB0byBlc3RhYmxpc2ggYSBXZWJSVEMgYnJvYWRjYXN0IHRoYXQgaW52b2x2ZSAtIGJ1dCBhcmUgbm90IGxpbWl0ZWQgdG8gLSBJQ0UgY29tbXVuaWNhdGlvbiBhbmQgYXNzaWduaW5nIG9mIGxvY2FsIGFuZCByZW1vdGUgU0RQcyBvbiBwZWVyIGNvbm5lY3Rpb25zLlxuICAgKi9cbiAgcHVibGlzaChzdHJlYW1OYW1lID0gbnVsbCwgcHJvbWlzZSA9IG51bGwpIHtcbiAgICBkZWJ1ZygnW3B1Ymxpc2hdJylcbiAgICB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUgPSBzdHJlYW1OYW1lIHx8IHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZVxuICAgIGNvbnN0IHAgPSBwcm9taXNlIHx8IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGNvbnN0IHNvY2tldFByb21pc2UgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBjb25zdCBzb2NrZXR1cmwgPSBlbmRwb2ludEZyb21PcHRpb25zKHRoaXMuX29wdGlvbnMsIHtcbiAgICAgIGlkOiB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUsXG4gICAgfSlcbiAgICB0aGlzLl90cmlja2xlRW5kRnV0dXJlID0gdGhpcy5fZ2V0VHJpY2tsZUVuZCgpXG5cbiAgICBpZiAoIXRoaXMuX3BlZXJIZWxwZXIpIHtcbiAgICAgIHRoaXMuX3BlZXJIZWxwZXIgPSBuZXcgUHVibGlzaGVyUGVlckhlbHBlcih0aGlzKVxuICAgIH1cbiAgICBpZiAodGhpcy5fc29ja2V0SGVscGVyKSB7XG4gICAgICB0aGlzLl9zb2NrZXRIZWxwZXIuY2xlYXJSZXRyeSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NvY2tldEhlbHBlciA9IG5ldyBQdWJsaXNoZXJTb2NrZXRIZWxwZXIodGhpcylcbiAgICAgIHRoaXMuX21lc3NhZ2VUcmFuc3BvcnQgPSB0aGlzLl9zb2NrZXRIZWxwZXJcbiAgICB9XG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnNldFVwKHNvY2tldHVybCwgc29ja2V0UHJvbWlzZSlcblxuICAgIGxldCB7IHJ0Y0NvbmZpZ3VyYXRpb24sIHNpZ25hbGluZ1NvY2tldE9ubHksIGRhdGFDaGFubmVsQ29uZmlndXJhdGlvbiB9ID0gdGhpcy5fb3B0aW9uc1xuICAgIC8vIFNldCBkZWZhdWx0IGRhdGEgY2hhbm5lbCBjb25maWd1cmF0aW9uIGlmIG5vdCBkZWZpbmVkIGFuZCBzZXZlcmluZyBzb2NrZXQgb24gc2lnbmFsIGVuZC5cbiAgICAvLyBUT0RPOiBTZXQgdGhpcyBhcyBtb3JlIFwicHJpdmF0ZVwiIHdpdGggYHJlZDVwcm8tPHN0cmVhbW5hbWU+YFxuICAgIGNvbnN0IGRhdGFDaGFubmVsQWxsb3dlZCA9IHNpZ25hbGluZ1NvY2tldE9ubHkgJiYgd2VicnRjLnN1cHBvcnRzRGF0YUNoYW5uZWwoKVxuICAgIGlmIChkYXRhQ2hhbm5lbEFsbG93ZWQgJiYgIWRhdGFDaGFubmVsQ29uZmlndXJhdGlvbikge1xuICAgICAgZGF0YUNoYW5uZWxDb25maWd1cmF0aW9uID0ge1xuICAgICAgICBuYW1lOiBgcmVkNXByb2AsXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX29wdGlvbnMuc2lnbmFsaW5nU29ja2V0T25seSA9IGRhdGFDaGFubmVsQWxsb3dlZFxuXG4gICAgLy8gTW92ZWQgdGhpcyBvdXQgaW4gb3JkZXIgdG8gaGFuZGxlIHNvY2tldCBlcnJvcnMgd2l0aGluIGFueSBzdGVwIG9mIHByb2Nlc3MuXG4gICAgdGhpcy5fcHVibGlzaEZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX3B1Ymxpc2hGdXR1cmUpXG4gICAgdGhpcy5fcHVibGlzaEZ1dHVyZS5wcm9taXNlLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgZW52aXJvbm1lbnQucmVtb3ZlT3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyKHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UpXG4gICAgICBwLnJlamVjdChlcnJvcilcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5DT05ORUNUX0ZBSUxVUkUsIHRoaXMsIGVycm9yKSlcbiAgICB9KVxuXG4gICAgLy8gMC4gRXN0YWJsaXNoIHNvY2tldCBjb25uZWN0aW9uLlxuICAgIHNvY2tldFByb21pc2UucHJvbWlzZVxuICAgICAgLy8gMS4gV2FpdCBmb3Igc3RyZWFtIGF0dGFjaFxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuQ09OTkVDVF9TVUNDRVNTLCB0aGlzKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE1lZGlhU3RyZWFtKClcbiAgICAgIH0pXG4gICAgICAvLyAyLiBSZXF1ZXN0IGF2YWlsYWJsZSBzdHJlYW0gdG8gcHVibGlzaCBvblxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdEF2YWlsYWJpbGl0eSh0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUsIHRoaXMuX29wdGlvbnMuc3RyZWFtVHlwZSlcbiAgICAgIH0pXG4gICAgICAvLyAzLiBDcmVhdGUgUGVlciBDb25uZWN0aW9uXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVQZWVyQ29ubmVjdGlvbihydGNDb25maWd1cmF0aW9uLCBkYXRhQ2hhbm5lbENvbmZpZ3VyYXRpb24sIHRoaXMuX29wdGlvbnMuaWNlU2VydmVycylcbiAgICAgIH0pXG4gICAgICAvLyA0LiBNYWtlIE9mZmVyIG9uIFBlZXIgQ29ubmVjdGlvblxuICAgICAgLnRoZW4oKGNvbm5lY3Rpb24pID0+IHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChSVENQdWJsaXNoZXJFdmVudFR5cGVzLlBFRVJfQ09OTkVDVElPTl9BVkFJTEFCTEUsIHRoaXMsIGNvbm5lY3Rpb24pKVxuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICAgIGNvbm5lY3Rpb24uYWRkVHJhY2sodHJhY2ssIHRoaXMuX21lZGlhU3RyZWFtKVxuICAgICAgICB9KVxuICAgICAgICAvLyBEZXByZWNhdGVkLlxuICAgICAgICAvLyAgICAgICAgY29ubmVjdGlvbi5hZGRTdHJlYW0odGhpcy5fbWVkaWFTdHJlYW0pXG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVPZmZlcih0aGlzLl9vcHRpb25zLmJhbmR3aWR0aCwgdGhpcy5fb3B0aW9ucy5mb3JjZVZQOClcbiAgICAgIH0pXG4gICAgICAvLyA1LiBTZW5kIE9mZmVyXG4gICAgICAudGhlbigoc2Vzc2lvbkRlc2NyaXB0aW9uKSA9PiB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUlRDUHVibGlzaGVyRXZlbnRUeXBlcy5PRkZFUl9TVEFSVCwgdGhpcywgc2Vzc2lvbkRlc2NyaXB0aW9uKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmRPZmZlcihzZXNzaW9uRGVzY3JpcHRpb24sIHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSwgdGhpcy5fb3B0aW9ucy5pY2VUcmFuc3BvcnQpXG4gICAgICB9KVxuICAgICAgLy8gNi4gU2V0IHRoZSBzZXNzaW9uIGRlc2NyaXB0aW9uIHJlbW90ZWx5XG4gICAgICAudGhlbigoc2RwKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXRSZW1vdGVEZXNjcmlwdGlvbihzZHAuc2RwKVxuICAgICAgfSlcbiAgICAgIC8vIDcuIFdhaXQgdW50aWwgaWNlIHRyaWNrbGUgZW5kXG4gICAgICAudGhlbigoc2RwKSA9PiB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUlRDUHVibGlzaGVyRXZlbnRUeXBlcy5PRkZFUl9FTkQsIHRoaXMsIHNkcCkpXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRUcmlja2xlRW5kKCkucHJvbWlzZVxuICAgICAgfSlcbiAgICAgIC8vIDguIFJlcXVlc3QgdG8gcHVibGlzaCBzdHJlYW1cbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChSVENQdWJsaXNoZXJFdmVudFR5cGVzLklDRV9UUklDS0xFX0NPTVBMRVRFLCB0aGlzKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3RQdWJsaXNoKHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSwgdGhpcy5fb3B0aW9ucy5zdHJlYW1Nb2RlLCB0aGlzLl9vcHRpb25zLmtleUZyYW1lcmF0ZSlcbiAgICAgIH0pXG4gICAgICAvLyA5LiBSZXN1bHRzIGluIHNvY2tldCBtZXNzYWdlIG9mIHB1Ymxpc2ggKHNlZSA6b25QdWJsaXNoU3RhdHVzKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBlbnZpcm9ubWVudC5hZGRPcmllbnRhdGlvbkNoYW5nZUhhbmRsZXIodGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSlcbiAgICAgICAgcC5yZXNvbHZlKHRoaXMpXG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5QVUJMSVNIX1NUQVJULCB0aGlzKSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIGVudmlyb25tZW50LnJlbW92ZU9yaWVudGF0aW9uQ2hhbmdlSGFuZGxlcih0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKVxuICAgICAgICBwLnJlamVjdChlcnJvcilcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLkNPTk5FQ1RfRkFJTFVSRSwgdGhpcywgZXJyb3IpKVxuICAgICAgfSlcbiAgICByZXR1cm4gcC5oYXNPd25Qcm9wZXJ0eSgncHJvbWlzZScpID8gcC5wcm9taXNlIDogcFxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gYmVnaW4gYSBicm9hZGNhc3Qgc2Vzc2lvbiBhZnRlciBpbml0aWFsaXphdGlvbiBoYXMgb2NjdXJlZCBhbmQgd2l0aCBhIHByZXZpb3VzbHkgZXN0YWJsaXNoZWQgV2ViU29ja2V0IGluc3RhbmNlLlxuICAgKiBVU0UgV0lUSCBDQVVUSU9OLiBJdCBpcyBhc3N1bWVkIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZyBieSBwcm92aWRpbmcgYSBwcmV2aW91c2x5IGVzdGFibGlzaGVkIFdlYlNvY2tldCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJTb2NrZXR9IHNvY2tldFxuICAgKiAgICAgICAgVGhlIHByZXZpb3VzIGVzdGFibGlzaGVkIFdlYlNvY2tldCB0byB1c2UgaW4gYnJvYWRjYXN0IHNlc3Npb24gc2lnbmFsbGluZy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmVhbU5hbWVcbiAgICogICAgICAgIE9wdGlvbmFsIHN0cmVhbSBuYW1lIHRvIGJyb2FkY2FzdCBvbiwgb3RoZXJ3aXNlIGRlZmF1bHRpbmcgdG8gdGhlIGBzdHJlYW1OYW1lYCBwcm92aWRlZCBpbiBgaW5pdCgpYCBjb25maWd1cmF0aW9uLlxuICAgKiBAcGFyYW0ge1Byb21pc2V9IHByb21pc2VcbiAgICogICAgICAgIE9wdGlvbmFsIGBQcm9taXNlYCBvYmplY3QgdG8gcmVzb2x2ZS9yZWplY3Qgb24gYmFzZWQgb24gc2VxdWVuY2Ugb2YgZXZlbnRzIGluIGVzdGFibGlzaGluZyBhIGJyb2FkY2FzdCwgb3RoZXJ3aXNlIGRlZmF1bHRpbmcgdG8gYFByb21pc2VgIGNyZWF0ZWQgaW50ZXJuYWxseSBhbmQgcmV0dXJuZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgICAgICBUaGUgcmV0dXJuZWQgYFByb21pc2VgIHdpbGwgcmVzb2x2ZSBvciByZWplY3Qgb24gc3VjY2Vzc2Z1bCBzdGFydCBvZiBhIGJyb2FkY2FzdC48YnI+XG4gICAqICAgICAgICBUaGVyZSBhcmUgc2V2ZXJhbCBwcm9jZXNzZXMgdGhhdCBvY2N1ciBpbiBvcmRlciB0byBlc3RhYmxpc2ggYSBXZWJSVEMgYnJvYWRjYXN0IHRoYXQgaW52b2x2ZSAtIGJ1dCBhcmUgbm90IGxpbWl0ZWQgdG8gLSBJQ0UgY29tbXVuaWNhdGlvbiBhbmQgYXNzaWduaW5nIG9mIGxvY2FsIGFuZCByZW1vdGUgU0RQcyBvbiBwZWVyIGNvbm5lY3Rpb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHVibGlzaFdpdGhTb2NrZXQoc29ja2V0LCBzdHJlYW1OYW1lID0gbnVsbCwgcHJvbWlzZSA9IG51bGwpIHtcbiAgICBkZWJ1ZygnW3B1Ymxpc2hXaXRoU29ja2V0XScpXG4gICAgdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lID0gc3RyZWFtTmFtZSB8fCB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWVcbiAgICBjb25zdCBwID0gcHJvbWlzZSB8fCBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBjb25zdCBzb2NrZXRQcm9taXNlID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdGhpcy5fc29ja2V0SGVscGVyID0gbmV3IFB1Ymxpc2hlclNvY2tldEhlbHBlcih0aGlzKVxuICAgIHRoaXMuX3NvY2tldEhlbHBlci5zZXRVcFdpdGhTb2NrZXQoc29ja2V0LCBzb2NrZXRQcm9taXNlKVxuXG4gICAgLy8gMS4gRXN0YWJsaXNoIGEgc29ja2V0IGhhbmRsZXIgaW5zdGFuY2Ugd2l0aCBwcmV2aW91cyBXZWJTb2NrZXQgaW5zdGFuY2UuXG4gICAgc29ja2V0UHJvbWlzZS5wcm9taXNlXG4gICAgICAvLyAyLiBSZXF1ZXN0IHRvIHB1Ymxpc2ggc3RyZWFtXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0UHVibGlzaCh0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUsIHRoaXMuX29wdGlvbnMuc3RyZWFtTW9kZSwgdGhpcy5fb3B0aW9ucy5rZXlGcmFtZXJhdGUpXG4gICAgICB9KVxuICAgICAgLy8gMy4gUmVzdWx0cyBpbiBzb2NrZXQgbWVzc2FnZSBvZiBwdWJsaXNoIChzZWUgOm9uUHVibGlzaFN0YXR1cylcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgZW52aXJvbm1lbnQuYWRkT3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyKHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UpXG4gICAgICAgIHAucmVzb2x2ZSh0aGlzKVxuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuUFVCTElTSF9TVEFSVCwgdGhpcykpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICBlbnZpcm9ubWVudC5yZW1vdmVPcmllbnRhdGlvbkNoYW5nZUhhbmRsZXIodGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSlcbiAgICAgICAgcC5yZWplY3QoZXJyb3IpXG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5DT05ORUNUX0ZBSUxVUkUsIHRoaXMsIGVycm9yKSlcbiAgICAgIH0pXG4gICAgcmV0dXJuIHAuaGFzT3duUHJvcGVydHkoJ3Byb21pc2UnKSA/IHAucHJvbWlzZSA6IHBcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIHN0b3AgYSBicm9hZGNhc3QuXG4gICAqIFRoZSByZXR1cm5lZCBgUHJvbWlzZWAgd2lsbCBlaXRoZXIgcmVzb2x2ZSBvciByZWplY3Qgb24gc3VjY2Vzc2Z1bCBzdG9wIG9mIGJyb2FkY2FzdC5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBhbmRSZW1vdmVcbiAgICogICAgICAgIEZsYWcgdG8gYWRkaXRpb25hbGx5IHJlbW92ZSB0aGUgcHJldmlldy5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHVucHVibGlzaChhbmRSZW1vdmUgPSBmYWxzZSkge1xuICAgIGRlYnVnKCdbdW5wdWJsaXNoXScpXG4gICAgY29uc3QgY2xlYXJIZWxwZXJzID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3NvY2tldEhlbHBlcikge1xuICAgICAgICBkZWJ1ZygnW3VucHVibGlzaDp0ZWFyZG93bl0nKVxuICAgICAgICB0aGlzLl9zb2NrZXRIZWxwZXIudGVhckRvd24oKVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3BlZXJIZWxwZXIpIHtcbiAgICAgICAgdGhpcy5fcGVlckhlbHBlci50ZWFyRG93bigpXG4gICAgICB9XG4gICAgICB0aGlzLl9zb2NrZXRIZWxwZXIgPSB1bmRlZmluZWRcbiAgICAgIHRoaXMuX3BlZXJIZWxwZXIgPSB1bmRlZmluZWRcbiAgICAgIHRoaXMuX21lc3NhZ2VUcmFuc3BvcnQgPSB1bmRlZmluZWRcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2xlYXJNZWRpYU9uVW5wdWJsaXNoIHx8IGFuZFJlbW92ZSkge1xuICAgICAgdGhpcy51bnByZXZpZXcoKVxuICAgIH1cbiAgICB0aGlzLl9hdmFpbGFibGVGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wZWVyRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fb2ZmZXJGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9zZW5kT2ZmZXJGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl90cmlja2xlRW5kRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcHVibGlzaEZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIGNvbnN0IGYgPSB0aGlzLl9yZXF1ZXN0VW5wdWJsaXNoKHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSwgdGhpcy5fb3B0aW9ucy5ncm91cE5hbWUpXG4gICAgZi50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuX3VucHVibGlzaEZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgICAgLy8gICAgICB0aGlzLl9tZWRpYVN0cmVhbSA9IHVuZGVmaW5lZFxuICAgICAgY2xlYXJIZWxwZXJzKClcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5VTlBVQkxJU0hfU1VDQ0VTUywgdGhpcykpXG4gICAgfSlcbiAgICBlbnZpcm9ubWVudC5yZW1vdmVPcmllbnRhdGlvbkNoYW5nZUhhbmRsZXIodGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSlcbiAgICByZXR1cm4gZlxuICB9XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQuIFVzZSBgbXV0ZUF1ZGlvYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG11dGUoKSB7XG4gICAgLy8gYmFja3dhcmQgY29tYXRpYmlsaXR5IC0gdG8gYmUgZGVwcmVjYXRlZC5cbiAgICB0aGlzLm11dGVBdWRpbygpXG4gIH1cblxuICAvKipcbiAgICogRGVwcmVjYXRlZC4gVXNlIGB1bm11dGVBdWRpb2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1bm11dGUoKSB7XG4gICAgLy8gYmFja3dhcmQgY29tYXRpYmlsaXR5IC0gdG8gYmUgZGVwcmVjYXRlZC5cbiAgICB0aGlzLnVubXV0ZUF1ZGlvKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIG11dGUgdGhlIGF1ZGlvIG9mIHRoZSBicm9hZGNhc3QuXG4gICAqIENhbiBvbmx5IGJlIGNhbGxlZCBvbmNlIHRoZSBicm9hZGNhc3QgaGFzIGJlZ3VuLlxuICAgKi9cbiAgbXV0ZUF1ZGlvKCkge1xuICAgIHRoaXMuZ2V0TWVzc2FnZVRyYW5zcG9ydCgpLnBvc3Qoe1xuICAgICAgbXV0ZToge1xuICAgICAgICBtdXRlQXVkaW86IHRydWUsXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byB1bm11dGUgdGhlIGF1ZGlvIG9mIGEgYnJvYWRjYXN0IHRoYXQgaGFzIGJlZW4gcHJldmlvdXNseSBtdXRlZC5cbiAgICovXG4gIHVubXV0ZUF1ZGlvKCkge1xuICAgIHRoaXMuZ2V0TWVzc2FnZVRyYW5zcG9ydCgpLnBvc3Qoe1xuICAgICAgbXV0ZToge1xuICAgICAgICBtdXRlQXVkaW86IGZhbHNlLFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgLyoqIFJlcXVlc3QgdG8gbXV0ZSAobm90IHNlbmQpIHRoZSB2aWRlbyBvZiB0aGUgYnJvYWRjYXN0LlxuICAgKiBDYW4gb25seSBiZSBjYWxsZWQgb25jZSB0aGUgYnJvYWRjYXN0IGhhcyBiZWd1bi5cbiAgICovXG4gIG11dGVWaWRlbygpIHtcbiAgICB0aGlzLmdldE1lc3NhZ2VUcmFuc3BvcnQoKS5wb3N0KHtcbiAgICAgIG11dGU6IHtcbiAgICAgICAgbXV0ZVZpZGVvOiB0cnVlLFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gdW5tdXRlIChyZXN1bWUgc2VuZGluZykgdGhlIHZpZGVvIG9mIGEgcHJldmlvdXNseSB2aWRlby1tdXRlZCBicm9hZGNhc3QuXG4gICAqL1xuICB1bm11dGVWaWRlbygpIHtcbiAgICB0aGlzLmdldE1lc3NhZ2VUcmFuc3BvcnQoKS5wb3N0KHtcbiAgICAgIG11dGU6IHtcbiAgICAgICAgbXV0ZVZpZGVvOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIHNlbmQgYSBtZXNzYWdlIHRvIGFsbCBzdWJzY3JpYmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZE5hbWVcbiAgICogICAgICAgIFRoZSBtZXRob2QgbmFtZSBhc3NvY2lhdGVkIHdpdGggdGhlIG1lc3NhZ2UgdG8gYmUgYWNjZXB0ZWQgYnkgYWxsIHN1YnNjcmliZXJzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiAgICAgICAgVGhlIGRhdGEgb2JqZWN0IHRvIHNlbmQgYXNzb2NpYXRlZCB3aXRoIHRoZSBtZXRob2QgbmFtZS5cbiAgICovXG4gIHNlbmQobWV0aG9kTmFtZSwgZGF0YSkge1xuICAgIHRoaXMuZ2V0TWVzc2FnZVRyYW5zcG9ydCgpLnBvc3Qoe1xuICAgICAgc2VuZDoge1xuICAgICAgICBtZXRob2Q6IG1ldGhvZE5hbWUsXG4gICAgICAgIGRhdGE6IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoZGF0YSkgOiBkYXRhLFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gaW52b2tlIGEgbWV0aG9kIG9uIHRoZSBBcHBsaWNhdGlvbiBBZGFwdGVyIHJlbGF0ZWQgdG8gdGhlIGBhcHBgIGNvbmZpZyBzZXR0aW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kTmFtZVxuICAgKiAgICAgICAgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBpbnZva2Ugb24gdGh3IEFwcGxpY2F0aW9uIEFkYXB0ZXJcbiAgICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICAgKiAgICAgICAgVGhlIG9yZGVyZWQgbGlzdCBvZiBhcmd1bWVudHMgdG8gaW52b2tlIG9uIHRoZSBtZXRob2QuIERvIG5vdCBwcm92aWRlIGFueXRoaW5nIGlmIHRoZSBtZXRob2QgdGFrZXMgbm8gYXJndW1lbnRzLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgY2FsbFNlcnZlcihtZXRob2ROYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWVzc2FnZVRyYW5zcG9ydCgpLnBvc3RBc3luYyh7XG4gICAgICBjYWxsQWRhcHRlcjoge1xuICAgICAgICBtZXRob2Q6IG1ldGhvZE5hbWUsXG4gICAgICAgIGFyZ3VtZW50czogYXJncyxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhbiBSUEMgbG9nIHRvIHRoZSBzZXJ2ZXIgd2hpY2ggd2lsbCBiZSBwcmludGVkIG91dCBpbiBzZXJ2ZXIgbG9ncy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGxldmVsXG4gICAqICAgICAgICBWYWxpZCB2YWx1ZXM6IFRSQUNFLCBJTkZPLCBERUJVRywgV0FSTiBvciBFUlJPUlxuICAgKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZVxuICAgKiAgICAgICAgRWl0aGVyIGEgU3RyaW5nIG9yIGEgSlNPTi1zZXJpYWxpemFibGUgT2JqZWN0LiBUaGlzIHBhcmFtIHdpbGwgYmUgY29udmVydGVkIHRvIGEgc3RyaW5nIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICovXG4gIHNlbmRMb2cobGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdGhlTGV2ZWwgPSBPYmplY3Qua2V5cyhMRVZFTFMpLmZpbmQoKGwpID0+IGwudG9Mb3dlckNhc2UoKSA9PT0gbGV2ZWwudG9Mb3dlckNhc2UoKSkgPyBsZXZlbCA6IExFVkVMUy5ERUJVR1xuICAgICAgY29uc3QgdGhlTWVzc2FnZSA9IHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IG1lc3NhZ2UgOiBKU09OLnN0cmluZ2lmeShtZXNzYWdlKVxuICAgICAgdGhpcy5nZXRNZXNzYWdlVHJhbnNwb3J0KCkucG9zdCh7XG4gICAgICAgIGxvZzogdGhlTGV2ZWwudG9VcHBlckNhc2UoKSxcbiAgICAgICAgbWVzc2FnZTogdGhlTWVzc2FnZSxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGUubWVzc2FnZSB8fCBlXG4gICAgICBlcnJvcihOQU1FLCBgQ291bGQgbm90IHNlbmQgbG9nIHRvIHNlcnZlci4gTWVzc2FnZSBwYXJhbWV0ZXIgZXhwZWN0ZWQgdG8gYmUgU3RyaW5nIG9yIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdC5gKVxuICAgICAgZXJyb3IoTkFNRSwgbWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgYXZhaWxhYmlsaXR5IG9mIHN0cmVhbSBvbiByZXF1ZXN0IG92ZXIgdGhlIHNvY2tldC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uU3RyZWFtQXZhaWxhYmxlKHJlY2VpcHQpIHtcbiAgICBkZWJ1ZygnW29uc3RyZWFtYXZhaWxhYmxlXTogJyArIEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpKVxuICAgIHRoaXMuX2F2YWlsYWJsZUZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX2F2YWlsYWJsZUZ1dHVyZSlcbiAgICB0aGlzLl9hdmFpbGFibGVGdXR1cmUucmVqZWN0KGBTdHJlYW0gd2l0aCBuYW1lICR7dGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lfSBhbHJlYWR5IGhhcyBhIGJyb2FkY2FzdCBzZXNzaW9uLmApXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlBVQkxJU0hfSU5WQUxJRF9OQU1FLCB0aGlzKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciB1bmF2YWlsYWJpbGl0eSBvZiBzdHJlYW0gb24gcmVxdWVzdCBvdmVyIHRoZSBzb2NrZXQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvblN0cmVhbVVuYXZhaWxhYmxlKHJlY2VpcHQpIHtcbiAgICAvLyBCZWluZyB1bmF2YWlsYWJsZSwgaXMgYSBnb29kIHRoaW5nIGZvciBhbGxvd2luZyB0byBwdWJsaXNoIHVzaW5nIGBvcHRpb25zLnN0cmVhbU5hbWVgXG4gICAgZGVidWcoYFN0cmVhbSAke3RoaXMuX29wdGlvbnMuc3RyZWFtTmFtZX0gZG9lcyBub3QgZXhpc3QuYClcbiAgICBkZWJ1ZygnW29uc3RyZWFtdW5hdmFpbGFibGVdOiAnICsgSlNPTi5zdHJpbmdpZnkocmVjZWlwdCwgbnVsbCwgMikpXG4gICAgdGhpcy5fYXZhaWxhYmxlRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fYXZhaWxhYmxlRnV0dXJlKVxuICAgIHRoaXMuX2F2YWlsYWJsZUZ1dHVyZS5yZXNvbHZlKHRydWUpXG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhbCBldmVudCBoYW5kbGVyIGZvciBhbGwgbWVzc2FnZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvblNvY2tldE1lc3NhZ2Uoc29ja2V0LCBtZXNzYWdlKSB7XG4gICAgdGhpcy50cmlnZ2VyKFxuICAgICAgbmV3IFB1Ymxpc2hlckV2ZW50KFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMuU09DS0VUX01FU1NBR0UsIHRoaXMsIHtcbiAgICAgICAgc29ja2V0OiBzb2NrZXQsXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICB9KVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBXZWJTb2NrZXQgZXJyb3JzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25Tb2NrZXRNZXNzYWdlRXJyb3IobWVzc2FnZSwgZGV0YWlsID0gbnVsbCkge1xuICAgIGVycm9yKGBFcnJvciBpbiBzdHJlYW0gcHVibGlzaDogJHttZXNzYWdlfS5cXG5bT3B0aW9uYWwgZGV0YWlsXTogJHtkZXRhaWx9YClcbiAgICBpZiAodGhpcy5fcHVibGlzaEZ1dHVyZSkge1xuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlBVQkxJU0hfRkFJTCwgdGhpcykpXG4gICAgICB0aGlzLl9wdWJsaXNoRnV0dXJlLnJlamVjdChtZXNzYWdlKVxuICAgICAgdGhpcy51bnB1Ymxpc2goKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBjbG9zZSBvZiBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvblNvY2tldENsb3NlKGNsb3NlRXZlbnQpIHtcbiAgICBkZWJ1ZygnW29uc29ja2V0Y2xvc2VdJylcbiAgICBpZiAodGhpcy5fcGVlckhlbHBlcikge1xuICAgICAgdGhpcy5fcGVlckhlbHBlci50ZWFyRG93bigpXG4gICAgfVxuICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5DT05ORUNUSU9OX0NMT1NFRCwgdGhpcywgY2xvc2VFdmVudCkpXG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgZmFpbCBpbiBQZWVyIENvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvblBlZXJDb25uZWN0aW9uRmFpbCgpIHtcbiAgICBkZWJ1ZygnW29ucGVlcmNvbm5lY3Rpb25mYWlsXScpXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlBVQkxJU0hfRkFJTCwgdGhpcykpXG4gICAgdGhpcy5fcHVibGlzaEZ1dHVyZS5yZWplY3QoJ1BlZXIgQ29ubmVjdGlvbiBGYWlsZWQuJylcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBjbG9zZSBvZiBQZWVyIENvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvblBlZXJDb25uZWN0aW9uQ2xvc2UoZXZlbnQpIHtcbiAgICBkZWJ1ZygnW29ucGVlcmNvbm5lY3Rpb25jbG9zZV0nKVxuICAgIGlmICh0aGlzLl9zb2NrZXRIZWxwZXIpIHtcbiAgICAgIGRlYnVnKCdbb25wZWVyY29ubmVjdGlvbmNsb3NlOnRlYXJkb3duXScpXG4gICAgICB0aGlzLl9zb2NrZXRIZWxwZXIudGVhckRvd24oKVxuICAgIH1cbiAgICB0aGlzLm9uU29ja2V0Q2xvc2UoZXZlbnQpXG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3Igb3BlbiBvZiBQZWVyIENvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvblBlZXJDb25uZWN0aW9uT3BlbigpIHtcbiAgICBkZWJ1ZygnW29ucGVlcmNvbm5lY3Rpb246Om9wZW5dJylcbiAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMuUEVFUl9DT05ORUNUSU9OX09QRU4pLCB0aGlzLCB0aGlzLmdldFBlZXJDb25uZWN0aW9uKCkpXG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgdHJhY2sgYWRkIG9uIFBlZXJDb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25QZWVyQ29ubmVjdGlvblRyYWNrQWRkKHRyYWNrKSB7XG4gICAgZGVidWcoJ1tvbnBlZXJjb25uZWN0aW9uOjp0cmFja10nKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUlRDUHVibGlzaGVyRXZlbnRUeXBlcy5UUkFDS19BRERFRCwgdGhpcywgeyB0cmFjayB9KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBzdWNjZXNzIG9mIFNEUCBvZmZlciBvdmVyIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uU0RQU3VjY2VzcyhyZWNlaXB0KSB7XG4gICAgbGV0IGluZm8gPSByZWNlaXB0ID8gJzogJyArIEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpIDogJydcbiAgICBkZWJ1ZyhgW29uc2Rwc3VjY2Vzc10ke2luZm99YClcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBlcnJvciBpbiBTRFAgb2ZmZXIgb3ZlciBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvblNEUEVycm9yKHJlY2VpcHQpIHtcbiAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuUFVCTElTSF9GQUlMLCB0aGlzKSlcbiAgICBsZXQgZXJyb3JNc2cgPSByZWNlaXB0ID8gJzogJyArIEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpIDogJydcbiAgICBlcnJvcihgW29uc2RwZXJyb3JdJHtlcnJvck1zZ31gKVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIHN1Y2Nlc3MgaW4gU0RQIGFuc3dlciBvdmVyIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uU0RQQW5zd2VyKHNkcCkge1xuICAgIGRlYnVnKCdbc2RwYW5zd2VyXTo6ICcgKyBKU09OLnN0cmluZ2lmeShzZHAsIG51bGwsIDIpKVxuICAgIHRoaXMuX3NlbmRPZmZlckZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX3NlbmRPZmZlckZ1dHVyZSlcbiAgICB0aGlzLl9zZW5kT2ZmZXJGdXR1cmUucmVzb2x2ZShzZHApXG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgcmVxdWVzdCB0byBhZGQgSUNFIGNhbmRpZGF0ZSBvbiBQZWVyIENvbm5lY3Rpb24gaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbkFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpIHtcbiAgICBkZWJ1ZygnW2FkZGljZWNhbmRpZGF0ZV0nKVxuICAgIHRoaXMuX3BlZXJIZWxwZXJcbiAgICAgIC5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBkZWJ1ZygnW2FkZGljZWNhbmRpZGF0ZTpzdWNjZXNzXScpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgd2FybihgW2FkZGljZWNhbmRpZGF0ZTplcnJvcl0gLSAke2Vycn1gKVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciByZWNlaXB0IGFuZCByZXF1ZXN0IHRvIHNlbmQgSUNFIGNhbmRpZGF0ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSkge1xuICAgIGRlYnVnKCdbaWNlY2FuZGlkYXRldHJpY2tsZV0nKVxuICAgIHRoaXMuX3NlbmRDYW5kaWRhdGUoY2FuZGlkYXRlLCB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUpXG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgZW5kIG9mIElDRSB0cmlja2xlIG5lZ290aWF0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25JY2VDYW5kaWRhdGVUcmlja2xlRW5kKCkge1xuICAgIGRlYnVnKCdbaWNlY2FuZGlkYXRldHJpY2tsZTplbmRdJylcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciByZWNlaXB0IG9mIGVtcHR5IGNhbmRpZGF0ZSBkdXJpbmcgSUNFIG5lZ290aWF0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25FbXB0eUNhbmRpZGF0ZSgpIHtcbiAgICBkZWJ1ZygnW2ljZWNhbmRpZGF0ZXRyaWNrbGU6ZW1wdHldJylcbiAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMuUEVFUl9DQU5ESURBVEVfRU5EKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBjb21wbGV0aW9uIG9mIHBlZXIgaWNlIGNhbmRpZGF0ZSBnYXRoZXJpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvblBlZXJHYXRoZXJpbmdDb21wbGV0ZSgpIHtcbiAgICBkZWJ1ZygnW2ljZWNhbmRpZGF0ZWdhdGhlcmluZzplbmRdJylcbiAgICBpZiAodGhpcy5fc29ja2V0SGVscGVyKSB7XG4gICAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdEVuZE9mQ2FuZGlkYXRlcyh0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIGVuZCBvZiBJQ0UgY2FuZGlkYXRlIG5vdGlmaWNhdGlvbiBvdmVyIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uU29ja2V0SWNlQ2FuZGlkYXRlRW5kKCkge1xuICAgIGRlYnVnKCdbc29ja2V0aWNlY2FuZGlkYXRlOmVuZF0nKVxuICAgIHRoaXMuX2dldFRyaWNrbGVFbmQoKS5yZXNvbHZlKClcbiAgICAvLyB0aGlzLl90cmlja2xlRW5kRnV0dXJlID0gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogUHVibGlzaGVyIHN0YXR1cyBldmVudCBoYW5kbGVyIGZvciBzdGFydCBhbmQgc3RvcCBvZiB0aGlzIFB1Ymxpc2hlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uUHVibGlzaGVyU3RhdHVzKHN0YXR1cykge1xuICAgIGRlYnVnKCdbcHVibGlzaGVyc3RhdHVzXSAtICcgKyBKU09OLnN0cmluZ2lmeShzdGF0dXMsIG51bGwsIDIpKVxuICAgIGNvbnN0IHN0b3BSZXN1bHQgPSBwdWJTdG9wUmVnZXguZXhlYyhzdGF0dXMubWVzc2FnZSlcbiAgICBjb25zdCBzdGFydFJlc3VsdCA9IHB1YlN0YXJ0UmVnZXguZXhlYyhzdGF0dXMubWVzc2FnZSlcbiAgICBpZiAoc3RvcFJlc3VsdCAmJiBzdG9wUmVzdWx0WzFdID09PSB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUpIHtcbiAgICAgIHRoaXMuX3VucHVibGlzaEZ1dHVyZS5yZXNvbHZlKClcbiAgICB9IGVsc2UgaWYgKHN0YXJ0UmVzdWx0ICYmIHN0YXJ0UmVzdWx0WzFdID09PSB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUpIHtcbiAgICAgIHRoaXMuX3B1Ymxpc2hGdXR1cmUucmVzb2x2ZSgpXG4gICAgfSBlbHNlIGlmIChzdGF0dXMuY29kZSAmJiBzdGF0dXMuY29kZSA9PT0gJ05ldFN0cmVhbS5QdWJsaXNoLklzQXZhaWxhYmxlJykge1xuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlBVQkxJU0hfQVZBSUxBQkxFLCB0aGlzLnN0YXR1cykpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5QVUJMSVNIX1NUQVRVUywgdGhpcywgc3RhdHVzKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTm90aWZpY2F0aW9uIGZyb20gc2VydmVyIG9uIGluc3VmZmljaWVudCBiYW5kd2lkdGggZm9yIGN1cnJlbnQgYnJvYWRjYXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiAgICAgICAgUHJvdmlkZXMgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGN1cnJlbnQgYmFuZHdpZHRoIGNvbmRpdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbkluc3VmZmljaWVudEJhbmR3aWR0aChkYXRhKSB7XG4gICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlBVQkxJU0hfSU5TVUZGSUNJRU5UX0JBTkRXSURUSCwgdGhpcywgZGF0YSkpXG4gIH1cblxuICAvKipcbiAgICogTm90aWZpY2F0aW9uIGZyb20gc2VydmVyIG9uIHJlY292ZXJlZCBzdWZmaWNpZW50IGJhbmR3aWR0aCBmb3IgY3VycmVudCBicm9hZGNhc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqICAgICAgICBQcm92aWRlcyBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY3VycmVudCBiYW5kd2lkdGggY29uZGl0aW9ucy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uU3VmZmljaWVudEJhbmR3aWR0aChkYXRhKSB7XG4gICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlBVQkxJU0hfU1VGRklDSUVOVF9CQU5EV0lEVEgsIHRoaXMsIGRhdGEpKVxuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmaWNhdGlvbiBmcm9tIHNlcnZlciBvbiBiYW5kd2lkdGggcmVjb3ZlcnkgZGF0YSBmb3IgY3VycmVudCBicm9hZGNhc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqICAgICAgICBQcm92aWRlcyBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY3VycmVudCBiYW5kd2lkdGggY29uZGl0aW9ucy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uUmVjb3ZlcmluZ0JhbmR3aWR0aChkYXRhKSB7XG4gICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlBVQkxJU0hfUkVDT1ZFUklOR19CQU5EV0lEVEgsIHRoaXMsIGRhdGEpKVxuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmaWNhdGlvbiBmcm9tIHNlcnZlciBvbiBzZW5kIG1ldGhvZCBkYXRhLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25TZW5kUmVjZWl2ZWQobWV0aG9kTmFtZSwgZGF0YSkge1xuICAgIGlmIChtZXRob2ROYW1lID09PSAnb25NZXRhRGF0YScpIHtcbiAgICAgIHRoaXMub25NZXRhRGF0YShkYXRhKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbnZpcm9ubWVudC5pbnZva2UobWV0aG9kTmFtZSwgZGF0YSlcbiAgICAgIHRoaXMudHJpZ2dlcihcbiAgICAgICAgbmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuUFVCTElTSF9TRU5EX0lOVk9LRSwgdGhpcywge1xuICAgICAgICAgIG1ldGhvZE5hbWU6IG1ldGhvZE5hbWUsXG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgbGlzdGVuZXIgZm9yIERhdGEgQ2hhbm5lbCBiZWluZyBvcGVuIG9uIHNlcnZlciB0byBzd2l0Y2ggc2lnbmFsaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25EYXRhQ2hhbm5lbEF2YWlsYWJsZShjaGFubmVsTmFtZSkge1xuICAgIGRlYnVnKCdbb25kYXRhY2hhbm5lbDo6YXZhaWxhYmxlXScpXG4gICAgdGhpcy5fc3dpdGNoQ2hhbm5lbFJlcXVlc3QgPSB7XG4gICAgICBzd2l0Y2hDaGFubmVsOiBjaGFubmVsTmFtZSB8fCAncmVkNXBybycsXG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNpZ25hbGluZ1NvY2tldE9ubHkpIHtcbiAgICAgIGxldCB0ID0gc2V0VGltZW91dChcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0KVxuICAgICAgICAgIGlmICh0aGlzLl9zb2NrZXRIZWxwZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvY2tldEhlbHBlci5zZXZlcih0aGlzLl9zd2l0Y2hDaGFubmVsUmVxdWVzdClcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fbWVzc2FnZVRyYW5zcG9ydCA9IHRoaXMuX3BlZXJIZWxwZXJcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoXG4gICAgICAgICAgICBuZXcgTWVzc2FnZVRyYW5zcG9ydFN0YXRlRXZlbnQoTWVzc2FnZVRyYW5zcG9ydFN0YXRlRXZlbnRUeXBlcy5DSEFOR0UsIHRoaXMsIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlcjogdGhpcyxcbiAgICAgICAgICAgICAgdHJhbnNwb3J0OiB0aGlzLl9tZXNzYWdlVHJhbnNwb3J0LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMuX3NvY2tldEhlbHBlciA/IHRoaXMuX29wdGlvbnMuc29ja2V0U3dpdGNoRGVsYXkgOiAxMDBcbiAgICAgIClcbiAgICB9XG4gICAgdGhpcy50cmlnZ2VyKFxuICAgICAgbmV3IFB1Ymxpc2hlckV2ZW50KFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMuREFUQV9DSEFOTkVMX0FWQUlMQUJMRSwgdGhpcywge1xuICAgICAgICBuYW1lOiBjaGFubmVsTmFtZSxcbiAgICAgICAgZGF0YUNoYW5uZWw6IHRoaXMuZ2V0RGF0YUNoYW5uZWwoKSxcbiAgICAgIH0pXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIG5vdGlmaWNhdGlvbnMgb2YgZXJyb3Igb24gb3B0aW9uYWwgZGF0YSBjaGFubmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge1JUQ0RhdGFDaGFubmVsfSBkYXRhQ2hhbm5lbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXJyb3JcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uRGF0YUNoYW5uZWxFcnJvcihkYXRhQ2hhbm5lbCwgZXJyb3IpIHtcbiAgICB0aGlzLnRyaWdnZXIoXG4gICAgICBuZXcgUHVibGlzaGVyRXZlbnQoUlRDUHVibGlzaGVyRXZlbnRUeXBlcy5EQVRBX0NIQU5ORUxfRVJST1IsIHRoaXMsIHtcbiAgICAgICAgZGF0YUNoYW5uZWw6IGRhdGFDaGFubmVsLFxuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICB9KVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBub3RpZmljYXRpb25zIG9mIG1lc3NhZ2Ugb24gb3B0aW9uYWwgZGF0YSBjaGFubmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge1JUQ0RhdGFDaGFubmVsfSBkYXRhQ2hhbm5lbFxuICAgKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25EYXRhQ2hhbm5lbE1lc3NhZ2UoZGF0YUNoYW5uZWwsIG1lc3NhZ2VEYXRhKSB7XG4gICAgdGhpcy50cmlnZ2VyKFxuICAgICAgbmV3IFB1Ymxpc2hlckV2ZW50KFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMuREFUQV9DSEFOTkVMX01FU1NBR0UsIHRoaXMsIHtcbiAgICAgICAgZGF0YUNoYW5uZWw6IGRhdGFDaGFubmVsLFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlRGF0YSxcbiAgICAgIH0pXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmaWNhdGlvbiBmcm9tIG9wdGlvbmFsbHkgb3BlbmVkIFJUQ0RhdGFDaGFubmVsLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25EYXRhQ2hhbm5lbE9wZW4oZGF0YUNoYW5uZWwpIHtcbiAgICB0aGlzLnRyaWdnZXIoXG4gICAgICBuZXcgUHVibGlzaGVyRXZlbnQoUlRDUHVibGlzaGVyRXZlbnRUeXBlcy5EQVRBX0NIQU5ORUxfT1BFTiwgdGhpcywge1xuICAgICAgICBkYXRhQ2hhbm5lbDogZGF0YUNoYW5uZWwsXG4gICAgICB9KVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RpZmljYXRpb24gZnJvbSBvcHRpb25hbGx5IG9wZW5lZCBSVENEYXRhQ2hhbm5lbCBvbiBjbG9zdXJlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25EYXRhQ2hhbm5lbENsb3NlKGRhdGFDaGFubmVsKSB7XG4gICAgdGhpcy50cmlnZ2VyKFxuICAgICAgbmV3IFB1Ymxpc2hlckV2ZW50KFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMuREFUQV9DSEFOTkVMX0NMT1NFLCB0aGlzLCB7XG4gICAgICAgIGRhdGFDaGFubmVsOiBkYXRhQ2hhbm5lbCxcbiAgICAgIH0pXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmaWNhdGlvbiBmcm9tIHNlcnZlciBvbiBtZXRhZGF0YS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uTWV0YURhdGEoZGF0YSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuUFVCTElTSF9NRVRBREFUQSwgdGhpcywgZGF0YSkpXG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byBvdmVybGF5IG9wdGlvbnMgb3ZlciBjdXJyZW50IGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvdmVybGF5T3B0aW9ucyhuZXdPcHRpb25zKSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24odGhpcy5fb3B0aW9ucywgbmV3T3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBNZXNzYWdlIFRyYW5zcG9ydCBpbnN0YW5jZSB0aGF0IHBvc3RzIHJlcXVlc3RzIHRvIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqICBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICAgICAgIEVpdGhlciB0aGUgc29ja2VyIHByb3h5IG9yIHRoZSBwZWVyIGNvbm5lY3Rpb24gcHJveHlcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE1lc3NhZ2VUcmFuc3BvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lc3NhZ2VUcmFuc3BvcnRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IFdlYlNvY2tldCBjb25uZWN0aW9uIGhlbHBlciBpZiBlc3RhYmxpc2hlZC5cbiAgICogVXNlZCBpbiBTaGFyZWRPYmplY3QgY29tbXVuaWNhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7UHVibGlzaGVyU29ja2V0SGVscGVyfVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Q29ubmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc29ja2V0SGVscGVyXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBSVENQZWVyQ29ubmVjdGlvbiBoZWxwZXIgaWYgZXN0YWJsaXNoZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge1JUQ1BlZXJDb25uZWN0aW9ufVxuICAgKi9cbiAgZ2V0UGVlckNvbm5lY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlZXJIZWxwZXIgPyB0aGlzLl9wZWVySGVscGVyLmNvbm5lY3Rpb24gOiB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IFJUQ0RhdGFDaGFubmVsIGlzIGF2YWlsYWJsZS5cbiAgICpcbiAgICogQHJldHVybiB7UlRDRGF0YUNoYW5uZWx9XG4gICAqL1xuICBnZXREYXRhQ2hhbm5lbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGVlckhlbHBlciA/IHRoaXMuX3BlZXJIZWxwZXIuZGF0YUNoYW5uZWwgOiB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgTWVkaWFTdHJlYW1gIGluc3RhbmNlIGlmIGdlbmVyYXRlZCB0aHJvdWdoIGBnZXRVc2VyTWVkaWFgIGFuZCBleGlzdHMgZm9yIGJyb2FkY2FzdC5cbiAgICpcbiAgICogQHJldHVybiB7TWVkaWFTdHJlYW19XG4gICAqL1xuICBnZXRNZWRpYVN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbml0aWFsaXphdGlvbiBjb25maWd1cmF0aW9uIHVzZWQgaW4gYGluaXQoKWAuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0eXBlIG9mIGltcGxlbWVudGF0aW9uOiBgUlRDYC5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gUHVibGlzaFR5cGVzLlJUQy50b1VwcGVyQ2FzZSgpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUlRDUHVibGlzaGVyXG4iLCJpbXBvcnQgKiBhcyB3ZWJydGMgZnJvbSAnLi4vYWRhcHRlci93ZWJydGMnXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgeyBvcHRpb25zRnJvbVdoaXBXaGVwVXJsIH0gZnJvbSAnLi4vdXRpbC91cmwtZW5kcG9pbnQnXG5pbXBvcnQgeyBSVENNZWRpYUNvbnN0cmFpbnQgfSBmcm9tICcuL2NvbnN0cmFpbnQnXG5pbXBvcnQgeyBkZWJ1ZyBhcyBkZWJ1Z0xvZyB9IGZyb20gJy4uL2xvZydcbmltcG9ydCB7IGVycm9yIGFzIGVycm9yTG9nIH0gZnJvbSAnLi4vbG9nJ1xuaW1wb3J0IHsgd2FybiBhcyB3YXJuTG9nIH0gZnJvbSAnLi4vbG9nJ1xuaW1wb3J0IFJUQ1B1Ymxpc2hlciBmcm9tICcuL3JlZDVwcm8tcnRjJ1xuaW1wb3J0IFdoaXBXaGVwU2lnbmFsaW5nSGVscGVyIGZyb20gJy4uL2hlbHBlci93aGlwd2hlcC1zaWduYWxpbmctaGVscGVyJ1xuaW1wb3J0IHsgUHVibGlzaE1vZGVUeXBlcyB9IGZyb20gJy4uL2VudW0vcHVibGlzaCdcbmltcG9ydCB7IEljZVRyYW5zcG9ydFR5cGVzIH0gZnJvbSAnLi4vZW51bS93ZWJydGMnXG5pbXBvcnQgeyBQdWJsaXNoZXJFdmVudCwgUHVibGlzaGVyRXZlbnRUeXBlcywgUlRDUHVibGlzaGVyRXZlbnRUeXBlcyB9IGZyb20gJy4uL2V2ZW50J1xuXG5jb25zdCBOQU1FID0gJ1dISVBDbGllbnQnXG5jb25zdCBJQ0VfR0FUSEVSX1RJTUVPVVQgPSAxMDAwXG5cbmNvbnN0IGRlYnVnID0gKG1lc3NhZ2UpID0+IHtcbiAgZGVidWdMb2coTkFNRSwgbWVzc2FnZSlcbn1cbmNvbnN0IHdhcm4gPSAobWVzc2FnZSkgPT4ge1xuICB3YXJuTG9nKE5BTUUsIG1lc3NhZ2UpXG59XG5jb25zdCBlcnJvciA9IChtZXNzYWdlKSA9PiB7XG4gIGVycm9yTG9nKE5BTUUsIG1lc3NhZ2UpXG59XG5cbi8vIERlZmF1bHQgdG8gc2VjdXJlIHNldHRpbmdzLlxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHByb3RvY29sOiAnaHR0cHMnLFxuICBwb3J0OiA0NDMsXG4gIGFwcDogJ2xpdmUnLFxuICBzdHJlYW1Nb2RlOiBQdWJsaXNoTW9kZVR5cGVzLkxJVkUsXG4gIGtleUZyYW1lcmF0ZTogMzAwMCxcbiAgbWVkaWFFbGVtZW50SWQ6ICdyZWQ1cHJvLXB1Ymxpc2hlcicsXG4gIHJ0Y0NvbmZpZ3VyYXRpb246IHtcbiAgICBpY2VTZXJ2ZXJzOiBbeyB1cmxzOiAnc3R1bjpzdHVuMi5sLmdvb2dsZS5jb206MTkzMDInIH1dLFxuICAgIGljZUNhbmRpZGF0ZVBvb2xTaXplOiAyLFxuICAgIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLFxuICB9LCAvLyBGYXZvcmVkIG92ZXIgaWNlU2VydmVycy5cbiAgaWNlU2VydmVyczogdW5kZWZpbmVkLCAvLyBEZXByZWNhdGVkLiBQcmVzZXJ2ZWQgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHkuXG4gIGljZVRyYW5zcG9ydDogSWNlVHJhbnNwb3J0VHlwZXMuVURQLFxuICBiYW5kd2lkdGg6IHtcbiAgICBhdWRpbzogNTYsXG4gICAgdmlkZW86IDc1MCxcbiAgfSxcbiAgY2xlYXJNZWRpYU9uVW5wdWJsaXNoOiBmYWxzZSxcbiAgbWVkaWFDb25zdHJhaW50czogbmV3IFJUQ01lZGlhQ29uc3RyYWludCgpLFxuICBvbkdldFVzZXJNZWRpYTogdW5kZWZpbmVkLFxuICBkYXRhQ2hhbm5lbENvbmZpZ3VyYXRpb246IHVuZGVmaW5lZCxcbiAgZm9yY2VWUDg6IGZhbHNlLFxuICBieXBhc3NBdmFpbGFibGU6IGZhbHNlLFxuICBzaWduYWxpbmdTb2NrZXRPbmx5OiBmYWxzZSwgLy8gTm8gREMgaW4gU0RQIGF0IHRoZSBtb21lbnRcbiAgdHJpY2tsZUljZTogZmFsc2UsIC8vIEZsYWcgdG8gdXNlIHRyaWNrbGUgaWNlIHRvIHNlbmQgY2FuZGlkYXRlc1xufVxuXG5jbGFzcyBXSElQQ2xpZW50IGV4dGVuZHMgUlRDUHVibGlzaGVyIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yLiBQcm92aWRpbmcgYXJndW1lbnRzIHdpbGwgYXV0b21hdGljYWxseSBraWNrIG9mIGNvbm5lY3Rpb24gc2VxdWVuY2UuXG4gICAqIExlYXZpbmcgYXJndW1lbnRzIHVuc2V0IGFsbG93cyBmb3IgbW9yZSBjb250cm9sIGFuZCBmb2xsb3dzIHNhbWUgcGF0dGVybiBvZiBpbml0IC0+IHB1Ymxpc2ggYXMgUlRDUHVibGlzaGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIE9wdGlvbmFsIGVuZHBvaW50IGZvciBXSElQLiBFeGFtcGxlOiBodHRwczovL3lvdXItcmVkNXByby5jb20vbGl2ZS93aGlwL2VuZHBvaW50L3N0cmVhbTFcbiAgICogQHBhcmFtIHtIVE1MTWVkaWFFbGVtZW50fSBlbGVtZW50IE9wdGlvbmFsIG1lZGlhIGVsZW1lbnQgdG8gcGxheSBtZWRpYSBpbi5cbiAgICogQHBhcmFtIHtib29sZWFufSB0cmlja2xlSWNlIE9wdGlvbmFsIHJlcXVlc3QgdG8gdHJpY2tsZSBjYW5kaWRhdGVzLiBQcmVmZXJyZWQ6IGZhbHNlLCBzZW5kIHdpdGggU0RQIG9mZmVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IodXJsLCBlbGVtZW50LCB0cmlja2xlSWNlID0gZmFsc2UpIHtcbiAgICBzdXBlcigpXG4gICAgY29uc3Qgb3B0aW9uc0Zyb21VcmwgPSB1cmwgPyBvcHRpb25zRnJvbVdoaXBXaGVwVXJsKHVybCkgOiBkZWZhdWx0T3B0aW9uc1xuICAgIG9wdGlvbnNGcm9tVXJsLm1lZGlhRWxlbWVudElkID0gZWxlbWVudCA/IGVsZW1lbnQuaWQgOiBkZWZhdWx0T3B0aW9ucy5tZWRpYUVsZW1lbnRJZFxuICAgIG9wdGlvbnNGcm9tVXJsLnRyaWNrbGVJY2UgPSB0cmlja2xlSWNlXG5cbiAgICB0aGlzLl93aGlwSGVscGVyID0gdW5kZWZpbmVkXG5cbiAgICBpZiAodXJsKSB7XG4gICAgICB0aGlzLl9pbnRlcm5hbENvbm5lY3Qob3B0aW9uc0Zyb21VcmwpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIGNvbm5lY3Rpb24gc2VxdWVuY2UgaWYgdXNlZCBjb25zdHJ1Y3RvciB3aXRoIGFyZ3VtZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFRoZSBpbml0aWFsaXphdGlvbiBjb25maWd1cmF0aW9uIG1hcC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIF9pbnRlcm5hbENvbm5lY3Qob3B0aW9ucykge1xuICAgIGF3YWl0IHRoaXMuaW5pdChvcHRpb25zKVxuICAgIGF3YWl0IHRoaXMucHVibGlzaCgpXG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlcyBnYXRoZXJpbmcgc3RhdGUgY29tcGxldGUgZm9yIElDRS5cbiAgICpcbiAgICogQHBhcmFtIHtSVENQZWVyQ29ubmVjdGlvbn0gY29ubmVjdGlvblxuICAgKiBAcmV0dXJucyBQcm9taXNlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyB3YWl0VG9HYXRoZXJJY2UoY29ubmVjdGlvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoY29ubmVjdGlvbi5pY2VHYXRoZXJpbmdTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICByZXNvbHZlKGNvbm5lY3Rpb24ubG9jYWxEZXNjcmlwdGlvbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlc29sdmUoY29ubmVjdGlvbi5sb2NhbERlc2NyaXB0aW9uKVxuICAgICAgICB9LCBJQ0VfR0FUSEVSX1RJTUVPVVQpXG4gICAgICAgIGNvbm5lY3Rpb24ub25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICBjb25uZWN0aW9uLmljZUdhdGhlcmluZ1N0YXRlID09PSAnY29tcGxldGUnICYmIHJlc29sdmUoY29ubmVjdGlvbi5sb2NhbERlc2NyaXB0aW9uKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQT1NUcyBTRFAgdG8gV0hFUCBlbmRwb2ludC5cbiAgICpcbiAgICogQHBhcmFtIHtSVENTZXNzaW9uRGVzY3JpcHRpb259IHNlc3Npb25EZXNjcmlwdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7IHNkcCwgbG9jYXRpb24gfVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgX3Bvc3RPZmZlcihzZXNzaW9uRGVzY3JpcHRpb24pIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBzZHAgfSA9IHNlc3Npb25EZXNjcmlwdGlvblxuICAgICAgY29uc3QgY2xlYW5lZCA9IHdlYnJ0Yy5jbGVhbldoaXBTRFAoc2RwKVxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3doaXBIZWxwZXIucG9zdFNEUE9mZmVyKGNsZWFuZWQpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IoZS5tZXNzYWdlIHx8IGUpXG4gICAgICAvLyBJdCB3YXMgbW9zdCBsaWtlbHkgcmVqZWN0ZWQgYmVjYXVzZSBzdHJlYW0gYWxyZWFkeSBleGlzdHMuLi5cbiAgICAgIHRoaXMub25TdHJlYW1BdmFpbGFibGUoZSlcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgQ2FuZGlkYXRlcyBhcyBQQVRDSCB0byBXSEVQIGVuZHBvaW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2RwIFRoZSBTRFAgd2l0aCBjYW5kaWRhdGVzXG4gICAqIEByZXR1cm5zIFByb21pc2VcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIF9wb3N0Q2FuZGlkYXRlRnJhZ21lbnRzKHNkcCkge1xuICAgIGNvbnN0IGhvc3RGcmFnID0gd2VicnRjLmdlbmVyYXRlU0RQQ2FuZGlkYXRlRnJhZyhzZHAsICdob3N0JylcbiAgICBjb25zdCBzcmZseEZyYWcgPSB3ZWJydGMuZ2VuZXJhdGVTRFBDYW5kaWRhdGVGcmFnKHNkcCwgJ3NyZmx4JywgdHJ1ZSlcbiAgICBhd2FpdCB0aGlzLl93aGlwSGVscGVyLnRyaWNrbGUoaG9zdEZyYWcpXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHBvc3RTcmZseCA9ICgpID0+IHtcbiAgICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fd2hpcEhlbHBlci50cmlja2xlKHNyZmx4RnJhZylcbiAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgfSwgMTUwKVxuICAgICAgfVxuICAgICAgcG9zdFNyZmx4KClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHJlcXVlc3QgdG8gc2VuZCBJQ0UgY2FuZGlkYXRlIG92ZXIgdGhlIFdlYlNvY2tldC4gV2UncmUgV0hJUHBpbmcuXG4gICAqIFRoaXMgY2FuIGhhcHBlbiBzZXZlcmFsIHRpbWVzIGluIHRoZSBJQ0UgbmVnb3RpYXRpb24gcHJvY2Vzcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhbmRpZGF0ZVxuICAgKiAgICAgICAgVGhlIENhbmRpZGF0ZSB0byBzZW5kLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyZWFtTmFtZVxuICAgKiAgICAgICAgVGhlIGFzc29jaWF0ZWQgdW5pcXVlIHN0cmVhbSBuYW1lIG9mIHRoZSBicm9hZGNhc3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VuZENhbmRpZGF0ZShjYW5kaWRhdGUsIHN0cmVhbU5hbWUpIHtcbiAgICBkZWJ1ZyhKU09OLnN0cmluZ2lmeShjYW5kaWRhdGUsIG51bGwsIDIpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gaW5pdGlhbGl6ZSB0aGUgV2ViUlRDLWJhc2VkIFB1Ymxpc2hlciBiYXNlZCBvbiBjb25maWd1cmF0aW9uLlxuICAgKiBUaGUgcmV0dXJuZWQgYFByb21pc2VgIHdpbGwgZWl0aGVyIHJlc29sdmUgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlIG9yIHJlamVjdCB3aXRoIGFuIGVycm9yIGBTdHJpbmdgIGluIGZhaWx1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgaW5pdGlhbGl6YXRpb24gY29uZmlndXJhdGlvbiBtYXAuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBpbml0KG9wdGlvbnMpIHtcbiAgICB0aGlzLl9vcHRpb25zID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9XG4gICAgY29uc3QgeyBwcm90b2NvbCwgaG9zdCwgcG9ydCwgYXBwLCBzdHJlYW1OYW1lIH0gPSB0aGlzLl9vcHRpb25zXG4gICAgY29uc3QgcHJvdG8gPSBwcm90b2NvbCA9PT0gJ3dzJyA/ICdodHRwJyA6ICdodHRwcydcbiAgICB0aGlzLl93aGlwVXJsID0gYCR7cHJvdG99Oi8vJHtob3N0fToke3BvcnR9LyR7YXBwfS93aGlwL2VuZHBvaW50LyR7c3RyZWFtTmFtZX1gXG4gICAgdGhpcy5fd2hpcEhlbHBlciA9IG5ldyBXaGlwV2hlcFNpZ25hbGluZ0hlbHBlcih0aGlzLl93aGlwVXJsKVxuICAgIHRoaXMuX21lc3NhZ2VUcmFuc3BvcnQgPSB0aGlzLl93aGlwSGVscGVyXG5cbiAgICByZXR1cm4gc3VwZXIuaW5pdChvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gaW5pdGlhbGl6ZSB0aGUgV2ViUlRDLWJhc2VkIFB1Ymxpc2hlciBiYXNlZCBvbiBjb25maWd1cmF0aW9uIGFuZCBwcmV2aW91c2x5IGVzdGFibGlzaGVkIE1lZGlhU3RyZWFtLlxuICAgKiBVU0UgV0lUSCBDQVVUSU9OLiBJdCBpcyBhc3N1bWVkIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZyBpbiBhY2Nlc3NpbmcgYSBNZWRpYVN0cmVhbSBvdXRzaWRlIG9mIHRoZSBBUEkgYXZhaWxhYmxlIGZyb20gdGhlIFNESy5cbiAgICogVGhlIHJldHVybmVkIGBQcm9taXNlYCB3aWxsIGVpdGhlciByZXNvbHZlIHdpdGggYSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZSBvciByZWplY3Qgd2l0aCBhbiBlcnJvciBgU3RyaW5nYCBpbiBmYWlsdXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgVGhlIGluaXRpYWxpemF0aW9uIGNvbmZpZ3VyYXRpb24gbWFwLlxuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBtZWRpYVN0cmVhbVxuICAgKiAgICAgICAgQSBwcmV2aW91c2x5IGVzdGFibGlzaGVkIE1lZGlhU3RyZWFtLCBtb3N0IGxpa2VseSByZWNlaWV2ZWQgdGhyb3VnaCBnZXRVc2VyTWVkaWEoKSBvdXRzaWRlIG9mIFNESyB1c2UuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBpbml0V2l0aFN0cmVhbShvcHRpb25zLCBtZWRpYVN0cmVhbSkge1xuICAgIGNvbnN0IHsgcHJvdG9jb2wsIGhvc3QsIHBvcnQsIGFwcCwgc3RyZWFtTmFtZSB9ID0gdGhpcy5fb3B0aW9uc1xuICAgIHRoaXMuX3doaXBVcmwgPSBgJHtwcm90b2NvbH06Ly8ke2hvc3R9OiR7cG9ydH0vJHthcHB9L3doaXAvZW5kcG9pbnQvJHtzdHJlYW1OYW1lfWBcbiAgICB0aGlzLl93aGlwSGVscGVyID0gbmV3IFdoaXBXaGVwU2lnbmFsaW5nSGVscGVyKHRoaXMuX3doaXBVcmwpXG4gICAgdGhpcy5fbWVzc2FnZVRyYW5zcG9ydCA9IHRoaXMuX3doaXBIZWxwZXJcblxuICAgIHJldHVybiBzdXBlci5pbml0V2l0aFN0cmVhbShvcHRpb25zLCBtZWRpYVN0cmVhbSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGJlZ2luIGEgYnJvYWRjYXN0IHNlc3Npb24gYWZ0ZXIgaW5pdGlhbGl6YXRpb24gaGFzIG9jY3VyZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJlYW1OYW1lXG4gICAqICAgICAgICBPcHRpb25hbCBzdHJlYW0gbmFtZSB0byBicm9hZGNhc3Qgb24sIG90aGVyd2lzZSBkZWZhdWx0aW5nIHRvIHRoZSBgc3RyZWFtTmFtZWAgcHJvdmlkZWQgaW4gYGluaXQoKWAgY29uZmlndXJhdGlvbi5cbiAgICogQHBhcmFtIHtQcm9taXNlfSBwcm9taXNlXG4gICAqICAgICAgICBPcHRpb25hbCBgUHJvbWlzZWAgb2JqZWN0IHRvIHJlc29sdmUvcmVqZWN0IG9uIGJhc2VkIG9uIHNlcXVlbmNlIG9mIGV2ZW50cyBpbiBlc3RhYmxpc2hpbmcgYSBicm9hZGNhc3QsIG90aGVyd2lzZSBkZWZhdWx0aW5nIHRvIGBQcm9taXNlYCBjcmVhdGVkIGludGVybmFsbHkgYW5kIHJldHVybmVkLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgICAgICAgVGhlIHJldHVybmVkIGBQcm9taXNlYCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IG9uIHN1Y2Nlc3NmdWwgc3RhcnQgb2YgYSBicm9hZGNhc3QuPGJyPlxuICAgKiAgICAgICAgVGhlcmUgYXJlIHNldmVyYWwgcHJvY2Vzc2VzIHRoYXQgb2NjdXIgaW4gb3JkZXIgdG8gZXN0YWJsaXNoIGEgV2ViUlRDIGJyb2FkY2FzdCB0aGF0IGludm9sdmUgLSBidXQgYXJlIG5vdCBsaW1pdGVkIHRvIC0gSUNFIGNvbW11bmljYXRpb24gYW5kIGFzc2lnbmluZyBvZiBsb2NhbCBhbmQgcmVtb3RlIFNEUHMgb24gcGVlciBjb25uZWN0aW9ucy5cbiAgICovXG4gIGFzeW5jIHB1Ymxpc2goc3RyZWFtTmFtZSA9IG51bGwsIHByb21pc2UgPSBudWxsKSB7XG4gICAgbGV0IHsgYmFuZHdpZHRoLCBmb3JjZVZQOCwgcnRjQ29uZmlndXJhdGlvbiwgc2lnbmFsaW5nU29ja2V0T25seSwgZGF0YUNoYW5uZWxDb25maWd1cmF0aW9uLCB0cmlja2xlSWNlIH0gPVxuICAgICAgdGhpcy5fb3B0aW9uc1xuICAgIC8vIFNldCBkZWZhdWx0IGRhdGEgY2hhbm5lbCBjb25maWd1cmF0aW9uIGlmIG5vdCBkZWZpbmVkIGFuZCBzZXZlcmluZyBzb2NrZXQgb24gc2lnbmFsIGVuZC5cbiAgICAvLyBUT0RPOiBTZXQgdGhpcyBhcyBtb3JlIFwicHJpdmF0ZVwiIHdpdGggYHJlZDVwcm8tPHN0cmVhbW5hbWU+YFxuICAgIGNvbnN0IGRhdGFDaGFubmVsQWxsb3dlZCA9IHNpZ25hbGluZ1NvY2tldE9ubHkgJiYgd2VicnRjLnN1cHBvcnRzRGF0YUNoYW5uZWwoKVxuICAgIGlmIChkYXRhQ2hhbm5lbEFsbG93ZWQgJiYgIWRhdGFDaGFubmVsQ29uZmlndXJhdGlvbikge1xuICAgICAgZGF0YUNoYW5uZWxDb25maWd1cmF0aW9uID0ge1xuICAgICAgICBuYW1lOiBgcmVkNXByb2AsXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX29wdGlvbnMuc2lnbmFsaW5nU29ja2V0T25seSA9IGRhdGFDaGFubmVsQWxsb3dlZFxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChzdHJlYW1OYW1lKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSA9IHN0cmVhbU5hbWVcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgbGlua3MgfSA9IGF3YWl0IHRoaXMuX3doaXBIZWxwZXIuZ2V0T3B0aW9ucygpXG4gICAgICBpZiAobGlua3MpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5pY2VTZXJ2ZXJzID0gbGlua3NcbiAgICAgIH1cbiAgICAgIC8vIFRPRE86IE5vIERDIHN1cHBvcnQgYXQgdGhpcyB0aW1lLlxuICAgICAgLy8gICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgdGhpcy5fY3JlYXRlUGVlckNvbm5lY3Rpb24ocnRjQ29uZmlndXJhdGlvbiwgZGF0YUNoYW5uZWxDb25maWd1cmF0aW9uLCBsaW5rcyB8fCB0aGlzLl9vcHRpb25zLmljZVNlcnZlcnMpXG4gICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgdGhpcy5fY3JlYXRlUGVlckNvbm5lY3Rpb24oXG4gICAgICAgIHJ0Y0NvbmZpZ3VyYXRpb24sXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgbGlua3MgfHwgdGhpcy5fb3B0aW9ucy5pY2VTZXJ2ZXJzXG4gICAgICApXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMuUEVFUl9DT05ORUNUSU9OX0FWQUlMQUJMRSwgdGhpcywgY29ubmVjdGlvbikpXG4gICAgICBjb25zdCBtZWRpYVN0cmVhbSA9IGF3YWl0IHRoaXMuX2dldE1lZGlhU3RyZWFtKClcbiAgICAgIC8vIFdISVBcbiAgICAgIG1lZGlhU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gY29ubmVjdGlvbi5hZGRUcmFuc2NlaXZlcih0cmFjaywge1xuICAgICAgICAgIGRpcmVjdGlvbjogJ3NlbmRvbmx5JyxcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICAvLyBXQVNcbiAgICAgIC8vIG1lZGlhU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAvLyAgIGNvbm5lY3Rpb24uYWRkVHJhY2sodHJhY2ssIHRoaXMuX21lZGlhU3RyZWFtKVxuICAgICAgLy8gfSlcbiAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGVlckhlbHBlci5jcmVhdGVPZmZlcldpdGhvdXRTZXRMb2NhbChiYW5kd2lkdGgsIGZvcmNlVlA4KVxuICAgICAgYXdhaXQgdGhpcy5fcGVlckhlbHBlci5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKVxuICAgICAgY29uc3QgbG9jYWxEZXNjcmlwdGlvbiA9IGF3YWl0IHRoaXMud2FpdFRvR2F0aGVySWNlKGNvbm5lY3Rpb24pXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMuT0ZGRVJfU1RBUlQsIHRoaXMsIGxvY2FsRGVzY3JpcHRpb24pKVxuICAgICAgY29uc3QgeyBzZHAgfSA9IGF3YWl0IHRoaXMuX3Bvc3RPZmZlcih0cmlja2xlSWNlID8gb2ZmZXIgOiBsb2NhbERlc2NyaXB0aW9uKVxuICAgICAgYXdhaXQgdGhpcy5fc2V0UmVtb3RlRGVzY3JpcHRpb24oeyB0eXBlOiAnYW5zd2VyJywgc2RwOiB3ZWJydGMuc3RyaXBFeHRNYXBzKHNkcCkgfSlcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUlRDUHVibGlzaGVyRXZlbnRUeXBlcy5PRkZFUl9FTkQsIHRoaXMsIHNkcCkpXG4gICAgICBpZiAodHJpY2tsZUljZSkge1xuICAgICAgICBjb25zdCB7IHNkcCB9ID0gbG9jYWxEZXNjcmlwdGlvblxuICAgICAgICBhd2FpdCB0aGlzLl9wb3N0Q2FuZGlkYXRlRnJhZ21lbnRzKHNkcClcbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUlRDUHVibGlzaGVyRXZlbnRUeXBlcy5JQ0VfVFJJQ0tMRV9DT01QTEVURSwgdGhpcykpXG4gICAgICBlbnZpcm9ubWVudC5hZGRPcmllbnRhdGlvbkNoYW5nZUhhbmRsZXIodGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSlcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5QVUJMSVNIX1NUQVJULCB0aGlzKSlcbiAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgIHByb21pc2UucmVzb2x2ZSh0aGlzKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcihlKVxuICAgICAgZW52aXJvbm1lbnQucmVtb3ZlT3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyKHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFLCB0aGlzLCBlKSlcbiAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgIHByb21pc2UucmVqZWN0KGUpXG4gICAgICB9XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gc3RvcCBhIGJyb2FkY2FzdC5cbiAgICogVGhlIHJldHVybmVkIGBQcm9taXNlYCB3aWxsIGVpdGhlciByZXNvbHZlIG9yIHJlamVjdCBvbiBzdWNjZXNzZnVsIHN0b3Agb2YgYnJvYWRjYXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFuZFJlbW92ZVxuICAgKiAgICAgICAgRmxhZyB0byBhZGRpdGlvbmFsbHkgcmVtb3ZlIHRoZSBwcmV2aWV3LlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgdW5wdWJsaXNoKGFuZFJlbW92ZSA9IGZhbHNlKSB7XG4gICAgZGVidWcoJ1t1bnB1Ymxpc2g6dGVhcmRvd25dJylcbiAgICBpZiAodGhpcy5fd2hpcEhlbHBlcikge1xuICAgICAgdGhpcy5fd2hpcEhlbHBlci50ZWFyRG93bigpXG4gICAgfVxuICAgIGlmICh0aGlzLl9wZWVySGVscGVyKSB7XG4gICAgICB0aGlzLl9wZWVySGVscGVyLnRlYXJEb3duKClcbiAgICB9XG4gICAgdGhpcy5fd2hpcEhlbHBlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3BlZXJIZWxwZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9tZXNzYWdlVHJhbnNwb3J0ID0gdW5kZWZpbmVkXG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGVhck1lZGlhT25VbnB1Ymxpc2ggfHwgYW5kUmVtb3ZlKSB7XG4gICAgICB0aGlzLnVucHJldmlldygpXG4gICAgfVxuICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5VTlBVQkxJU0hfU1VDQ0VTUywgdGhpcykpXG4gICAgZW52aXJvbm1lbnQucmVtb3ZlT3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyKHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IFdlYlNvY2tldCBjb25uZWN0aW9uIGhlbHBlciBpZiBlc3RhYmxpc2hlZC4gRHVlIHRvIHVzaW5nIFdISVAsIHRoaXMgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEByZXR1cm4ge1B1Ymxpc2hlclNvY2tldEhlbHBlcn1cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldENvbm5lY3Rpb24oKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFdISVBDbGllbnRcbiIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgSW1wbEZhY3RvcnlPcmRlciBmcm9tICcuLi91dGlsL2ltcGwtZmFjdG9yeS1vcmRlcidcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vY29yZS9ldmVudC1lbWl0dGVyJ1xuaW1wb3J0IFJUTVBQdWJsaXNoZXIgZnJvbSAnLi9yZWQ1cHJvLXJ0bXAnXG5pbXBvcnQgUlRDUHVibGlzaGVyIGZyb20gJy4vcmVkNXByby1ydGMnXG5pbXBvcnQgV0hJUENsaWVudCBmcm9tICcuL3JlZDVwcm8td2hpcCdcblxuaW1wb3J0IHsgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0IHsgUHVibGlzaFR5cGVzIH0gZnJvbSAnLi4vZW51bS9wdWJsaXNoJ1xuaW1wb3J0IHsgZGVidWcsIHdhcm4gfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUmVkNVByb1B1Ymxpc2hlcidcbmNvbnN0IHB1Ymxpc2hGYWN0b3J5ID0gbmV3IEltcGxGYWN0b3J5T3JkZXIoKVxuY29uc3QgcHVibGlzaGVySW1wbCA9IChmdW5jdGlvbiAoKSB7XG4gIGxldCBtYXAgPSBuZXcgTWFwKClcbiAgbWFwLnNldChQdWJsaXNoVHlwZXMuUlRDLCBSVENQdWJsaXNoZXIpXG4gIG1hcC5zZXQoUHVibGlzaFR5cGVzLlJUTVAsIFJUTVBQdWJsaXNoZXIpXG4gIHJldHVybiBtYXBcbn0oKSlcblxuLyoqXG4gKiBNYWluIGVudHJ5IGZvciBmYWlsb3ZlciBzdXBwb3J0IG9mIGFsbCBwdWJsaXNoZXIgaW1wbGVtZW50YXRpb25zLlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5jbGFzcyBSZWQ1UHJvUHVibGlzaGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX29wdGlvbnMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9vcmRlciA9IFtcbiAgICAgIFB1Ymxpc2hUeXBlcy5SVEMsXG4gICAgICBQdWJsaXNoVHlwZXMuUlRNUFxuICAgIF1cbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsaXplcyBGYWlsb3ZlciBQdWJsaXNoZXIgRmFjdG9yeSB0byBhdHRlbXB0IGluIGRldGVybWluaW5nIGJyb3dzZXIgc3VwcG9ydCBmb3IgUHVibGlzaGVyIGZyb20gZGVmaW5lZCBvcmRlci5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRQdWJsaXNoZXJGcm9tT3JkZXIgKG9yZGVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHB1Ymxpc2hGYWN0b3J5LmNyZWF0ZShvcmRlciwgcHVibGlzaGVySW1wbCwgb3B0aW9ucywgJ2luaXQnKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNwZWNpZmllZCBvcmRlciBmb3IgYXV0by1mYWlsb3Zlci5cbiAgICpcbiAgICogIEByZXR1cm4ge0FycmF5fVxuICAgKiAgICAgICAgICBEZWZhdWx0OiBgWydydGMnLCAncnRtcCddYC5cbiAgICovXG4gIGdldFB1Ymxpc2hPcmRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29yZGVyXG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyB0aGUgZGVzaXJlZCBhdXRvLWZhaWxvdmVyIG9yZGVyLlxuICAgKlxuICAgKiAgQHBhcmFtIHtBcnJheX0gb3JkZXJcbiAgICogICAgICAgICAgVGhlIGRlc2lyZWQgb3JkZXIuIGUuZywgYFsncnRjJywgJ3J0bXAnXWAuXG4gICAqXG4gICAqICBAcmV0dXJuIHtSZWQ1UHJvUHVibGlzaGVyfVxuICAgKiAgICAgICAgICBUaGlzIGluc3RhbmNlLlxuICAgKi9cbiAgc2V0UHVibGlzaE9yZGVyIChvcmRlcikge1xuICAgIC8vIEFsbG93IGZvciBzdHJpbmcgdmFsdWUgdG8gZGVmaW5lIHNpbmdsZSBpdGVtIGluIG9yZGVyLlxuICAgIG9yZGVyID0gdHlwZW9mIG9yZGVyID09PSAnc3RyaW5nJyA/IFtvcmRlcl0gOiBvcmRlclxuXG4gICAgLy8gRmlsdGVyIG91dCB2YWx1ZXMgbm90IGF2YWlsYWJsZSBpbiBlbnVtZXJhdGlvbiBvZiBwbGF5YmFjayB0eXBlcy5cbiAgICBjb25zdCB0ID0gb3JkZXIuZmlsdGVyKGVudHJ5ID0+IHtcbiAgICAgIGxldCBrZXlcbiAgICAgIGZvciAoa2V5IGluIFB1Ymxpc2hUeXBlcykge1xuICAgICAgICBpZiAoUHVibGlzaFR5cGVzW2tleV0udG9Mb3dlckNhc2UoKSA9PT0gZW50cnkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0pLm1hcChlbnRyeSA9PiBlbnRyeS50b0xvd2VyQ2FzZSgpKVxuXG4gICAgLy8gRGVmaW5lIG5ldyBvcmRlci5cbiAgICB0aGlzLl9vcmRlciA9IFsuLi5uZXcgU2V0KHQpXVxuICAgIGRlYnVnKE5BTUUsIGBbb3JkZXJ1cGRhdGVdOiAke3RoaXMuX29yZGVyfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGluaXRpYWxpemUgYW5kIGRldGVybWluZSB0aGUgcHJvcGVyIFB1Ymxpc2hlciBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBjb25maWd1cmF0aW9uLlxuICAgKiBUaGUgcmV0dXJuZWQgYFByb21pc2VgIHdpbGwgZWl0aGVyIHJlc29sdmUgd2l0aCB0aGUgZGV0ZXJtaW5lZCBQdWJsaXNoZXIgaW5zdGFuY2Ugb3IgcmVqZWN0IHdpdGggYW4gZXJyb3IgU3RyaW5nIGluIGZhaWx1cmUgdG8gZGV0ZXJtaW5lIFB1Ymxpc2hlciB0eXBlLlxuICAgKlxuICAgKiAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgICAgVGhlIGluaXRpYWxpemF0aW9uIGNvbmZpZ3VyYXRpb24gbWFwIGZvciBlYWNoIGRlc2lyZWQgZmFpbG92ZXIgdGVjaC5cbiAgICogIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBpbml0IChvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBkZWJ1ZyhOQU1FLCAnW3B1Ymxpc2hdJylcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMuX2dldFB1Ymxpc2hlckZyb21PcmRlcih0aGlzLl9vcmRlciwgdGhpcy5fb3B0aW9ucylcbiAgICAgIC50aGVuKHB1Ymxpc2hlciA9PiB7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUocHVibGlzaGVyKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICB3YXJuKE5BTUUsIGBbcHVibGlzaGVycm9yXTogQ291bGQgbm90IGltcGxlbWVudCBhIHB1Ymxpc2hlcjogJHtlcnJ9YClcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycilcbiAgICAgIH0pXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gZW51bWVyYXRlZCB2YWx1ZSBQdWJsaXNoZXIgdHlwZXMgdXNlZCBpbiBmYWlsb3ZlciBvcmRlci5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldCBwdWJsaXNoVHlwZXMgKCkge1xuICAgIHJldHVybiBQdWJsaXNoVHlwZXNcbiAgfVxuXG59XG5cbmV4cG9ydCB7IFJlZDVQcm9QdWJsaXNoZXIsIFJUTVBQdWJsaXNoZXIsIFJUQ1B1Ymxpc2hlciwgV0hJUENsaWVudCB9XG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uL2NvcmUvZXZlbnQtZW1pdHRlcidcbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCB7IFxuICBTaGFyZWRPYmplY3RFdmVudCxcbiAgU2hhcmVkT2JqZWN0RXZlbnRUeXBlcyxcbiAgTWVzc2FnZVRyYW5zcG9ydFN0YXRlRXZlbnRUeXBlc1xufSBmcm9tICcuLi9ldmVudC9pbmRleCdcbmltcG9ydCB7IGRlYnVnIGFzIGRlYnVnTG9nIH0gZnJvbSAnLi4vbG9nJ1xuaW1wb3J0IHsgd2FybiBhcyB3YXJuTG9nIH0gZnJvbSAnLi4vbG9nJ1xuaW1wb3J0IHsgZXJyb3IgYXMgZXJyb3JMb2cgfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUmVkNVByb1NoYXJlZE9iamVjdCdcbmNvbnN0IFNPX1NVQlRZUEVfUFJPUEVSVFkgPSA0XG5jb25zdCBTT19TVUJUWVBFX01FVEhPRCA9IDZcbmNvbnN0IFNPX1NVQlRZUEVfUkVNT1ZFID0gOVxuXG5jb25zdCBkZWJ1ZyA9IChzb05hbWUsIG1lc3NhZ2UpID0+IHtcbiAgZGVidWdMb2coW05BTUUsIHNvTmFtZV0uam9pbignOicpLCBtZXNzYWdlKVxufVxuY29uc3Qgd2FybiA9IChzb05hbWUsIG1lc3NhZ2UpID0+IHtcbiAgd2FybkxvZyhbTkFNRSwgc29OYW1lXS5qb2luKCc6JyksIG1lc3NhZ2UpXG59XG5jb25zdCBlcnJvciA9IChzb05hbWUsIG1lc3NhZ2UpID0+IHtcbiAgZXJyb3JMb2coW05BTUUsIHNvTmFtZV0uam9pbignOicpLCBtZXNzYWdlKVxufVxuXG5jb25zdCBkZWNvZGVNZXNzYWdlSWZKU09OU3RyaW5nID0gKG1lc3NhZ2UpID0+IHtcbiAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UobWVzc2FnZSkgOiBtZXNzYWdlXG59XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgc3RydWN0dXJlIG9mIGEgUHJvcGVydHkgRGF0YSBub3RpZmljYXRpb24gb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFByb3BlcnR5RGF0YSB7XG5cbiAgY29uc3RydWN0b3IgKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmtleSA9IGtleVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICB9XG5cbiAgdG9PYmplY3QgKCkge1xuICAgIGxldCBvYmogPSAge31cbiAgICBvYmpbdGhpcy5rZXldID0gdGhpcy52YWx1ZVxuICAgIHJldHVybiBvYmpcbiAgfVxuXG59XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgc3RydWN0dXJlIG9mIGEgTWV0aG9kIERhdGEgbm90aWZpY2F0aW9uIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBNZXRob2REYXRhIHtcblxuICBjb25zdHJ1Y3RvciAobWV0aG9kTmFtZSwgbWVzc2FnZSkge1xuICAgIHRoaXMubWV0aG9kTmFtZSA9IG1ldGhvZE5hbWVcbiAgICBsZXQgbWVzc2FnZUxpc3RcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICBsZXQgaVxuICAgICAgbGV0IG1zZ1xuICAgICAgbGV0IGxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoXG4gICAgICBtZXNzYWdlTGlzdCA9IFtdXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbXNnID0gZGVjb2RlTWVzc2FnZUlmSlNPTlN0cmluZyhtZXNzYWdlW2ldKVxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgbWVzc2FnZUxpc3QgPSBtZXNzYWdlTGlzdC5jb25jYXQobXNnKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG1lc3NhZ2VMaXN0LnB1c2gobXNnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbWVzc2FnZUxpc3QgPSBbZGVjb2RlTWVzc2FnZUlmSlNPTlN0cmluZyhtZXNzYWdlKV1cbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZUxpc3QubGVuZ3RoID09PSAxID8gbWVzc2FnZUxpc3RbMF0gOiBtZXNzYWdlTGlzdFxuICB9XG5cbiAgdG9PYmplY3QgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtZXRob2ROYW1lOiB0aGlzLm1ldGhvZE5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2VcbiAgICB9XG4gIH1cblxufVxuXG4vKipcbiAqIE1haW4gZW50cnkgZm9yIFNoYXJlZCBPYmplY3QgYXNzb2NpYXRlZCB3aXRoIFB1Ymxpc2hlcnMgYW5kIFN1YnNjcmliZXJzLlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5jbGFzcyBSZWQ1UHJvU2hhcmVkT2JqZWN0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICAvKipcbiAgICogVGhlIEFQSSBvbiB0aGlzIG9iamVjdCBpcyBsaW1pdGVkIGFzIGl0IGNvbW11bmljYXRlcyBhbG9uZyB3aXRoIG1lc3NhZ2UgY2hhbm5lbCBjb25uZWN0aW9uIHdoaWNoIHlvdSBwcm92aWRlIGluIHRoZSBjb25zdHVjdG9yLiBUaGlzIGNvbm5lY3Rpb24gY2FuIGVpdGhlciBiZSBhIHByZXZpb3VzbHkgZXN0YWJsaXNoZWQgUHVibGlzaGVyLCBTdWJzY3JpYmVyIG9yIFJlZDVQcm9TaGFyZWRPYmplY3RTb2NrZXQuXG4gICAqXG4gICAqIEV2ZW50IGhhbmRsZXJzIHNob3VsZCBiZSBhc3NpZ25lZCB0byBuZXcgYFJlZDVQcm9TaGFyZWRPYmplY3RgIGluc3RhbmNlcyBpbiBvcmRlciB0byBoYW5kbGUgbm90aWZpY2F0aW9ucyBvdmVyIHRoZSBjb21tdW5pY2F0aW9uIGNoYW5uZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgU2hhcmVkIE9iamVjdCB0byBjb25uZWN0IHRvLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvblxuICAgKiAgICAgICAgVGhlIGNvbm5lY3Rpb24gZGVsZWdhdGUgdG8gc2VuZCBhbmQgcmVjZWl2ZSBTaGFyZWQgT2JqZWN0IG5vdGlmaWNhdGlvbnMgb24uXG4gICAqICAgICAgICBUaGlzIHdpbGwgZWl0aGVyIGJlIGEgcHJldmlvdXNseSBlc3RhYmxpc2hlZCBQdWJsaXNoZXIgb3IgU3Vic2NyaWJlciBpbnN0YW5jZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChuYW1lLCBjb25uZWN0aW9uKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX25hbWUgPSBuYW1lXG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fdHJhbnNwb3J0Q29udHJvbGxlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX29uY2xvc2UgPSB0aGlzLmNsb3NlLmJpbmQodGhpcylcbiAgICB0aGlzLl9oYW5kbGVUcmFuc3BvcnRTdGF0ZUV2ZW50cyA9IHRoaXMuX2hhbmRsZVRyYW5zcG9ydFN0YXRlRXZlbnRzLmJpbmQodGhpcylcbiAgICB0aGlzLl9oYW5kbGVNZXNzYWdlVHJhbnNwb3J0Q2hhbmdlID0gdGhpcy5faGFuZGxlTWVzc2FnZVRyYW5zcG9ydENoYW5nZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5zZXRNZXNzYWdlVHJhbnNwb3J0Q29udHJvbGxlcihjb25uZWN0aW9uKVxuICB9XG5cbiAgLyoqXG4gICAqIEVzdGFibGlzaGVkIGNvbW11bmljYXRpb24gYW5kIGNvbm5lY3Rpb24gdG8gU2hhcmVkIE9iamVjdCB0aHJvdWdoIG1lc3NhZ2UgdHJhbnNwb3J0IGxheWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNwb3J0XG4gICAqICAgICAgICBUaGUgTWVzc2FnZSBUcmFuc3BvcnQgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZXN0YWJsaXNoVHJhbnNwb3J0ICh0cmFuc3BvcnQpIHtcbiAgICB0cmFuc3BvcnQuYWRkU2hhcmVkT2JqZWN0UmVzcG9uc2VIYW5kbGVyKHRoaXMpXG4gICAgdHJ5IHtcbiAgICAgIGRlYnVnKHRoaXMuX25hbWUsICdbc2hhcmVkb2JqZWN0OmNvbm5lY3Q6YXR0ZW1wdF0nKVxuICAgICAgLy8gSW1tZWRpYXRlbHkgaW52b2tlIHJlcXVlc3Qgb24gc2hhcmVkIG9iamVjdCB0aHJvdWdoIHRoZSBgZ2V0TWVzc2FnZVRyYW5zcG9ydCgpYFxuICAgICAgLy8gIGluc3RhbmNlIG9mIGEgUHVibGlzaGVyIG9yIFN1YnNjcmliZXIgKHdob21ldmVyIGludm9rZWQgdGhpcyBjb25zdHJ1Y3RvcikuXG4gICAgICB0cmFuc3BvcnQub24oJyonLCB0aGlzLl9oYW5kbGVTb2NrZXRTdGF0ZUV2ZW50cylcbiAgICAgIHRyYW5zcG9ydC5nZXRSZW1vdGVTaGFyZWRPYmplY3QodGhpcy5fbmFtZSlcbiAgICAgIGVudmlyb25tZW50LmFkZENsb3NlSGFuZGxlcih0aGlzLl9vbmNsb3NlLCAwKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IodGhpcy5fbmFtZSwgJ1tzaGFyZWRvYmplY3Q6Y29ubmVjdDplcnJvcl06ICcgKyBlLm1lc3NhZ2UpXG4gICAgICB0aGlzLl90cmFuc3BvcnQgPSB1bmRlZmluZWRcbiAgICAgIHRoaXMuX3RyYW5zcG9ydENvbnRyb2xsZXIgPSB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgbGlzdGVuZXIgZm9yIHRyYW5zcG9ydCBjaGFuZ2Ugb24gdGFyZ2V0IE1lc3NhZ2UgVHJhbnNwb3J0IENvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaGFuZGxlTWVzc2FnZVRyYW5zcG9ydENoYW5nZSAoZXZlbnQpIHtcbiAgICBjb25zdCB7IGNvbnRyb2xsZXIgfSA9IGV2ZW50LmRhdGFcbiAgICBsZXQgdCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHQpXG4gICAgICB0aGlzLnNldE1lc3NhZ2VUcmFuc3BvcnRDb250cm9sbGVyKGNvbnRyb2xsZXIpXG4gICAgfSwgMTAwMClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmFsIHN0YXRlIGV2ZW50IGhhbmRsZXIgZnJvbSB1bmRlcmx5aW5nIHNvY2tldCBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hhbmRsZVRyYW5zcG9ydFN0YXRlRXZlbnRzIChldmVudCkge1xuICAgIGRlYnVnKHRoaXMuX25hbWUsIGAke2V2ZW50Lm5hbWV9OiAke2V2ZW50LnR5cGV9YClcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gTWVzc2FnZVRyYW5zcG9ydFN0YXRlRXZlbnRUeXBlcy5DTE9TRSkge1xuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTaGFyZWRPYmplY3RFdmVudChTaGFyZWRPYmplY3RFdmVudFR5cGVzLkNPTk5FQ1RJT05fQ0xPU0VELCB0aGlzLl9uYW1lKSlcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIHBhcnNlIG1lc3NhZ2UgaW50byBhIE9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2VcbiAgICogICAgICAgIEVpdGhlciBhIEpTT04gc3RyaW5nIG9yIG9iamVjdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRKc29uRnJvbVNvY2tldE1lc3NhZ2UgKG1lc3NhZ2UpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlLmRhdGEgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShtZXNzYWdlLmRhdGEpIDogbWVzc2FnZS5kYXRhXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB3YXJuKHRoaXMuX25hbWUsICdDb3VsZCBub3QgcGFyc2UgbWVzc2FnZSBhcyBKU09OLiBNZXNzYWdlPSAnICsgbWVzc2FnZS5kYXRhICsgJy4gRXJyb3I9ICcgKyBlLm1lc3NhZ2UpXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2ggb2YgUFJPUEVSVFlfVVBEQVRFIHdpdGggaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZU9iamVjdFxuICAgKiAgICAgICAgT3B0aW9uYWwgdmFsdWUgb2JqZWN0IHRvIHNlbmQgaW4gbm90aWZpY2F0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX25vdGlmeU9mUHJvcGVydHlWYWx1ZXMgKHZhbHVlT2JqZWN0KSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlT2JqZWN0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTaGFyZWRPYmplY3RFdmVudChTaGFyZWRPYmplY3RFdmVudFR5cGVzLlBST1BFUlRZX1VQREFURSwgdGhpcy5fbmFtZSwge30pKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGxldCBrZXlcbiAgICAgIGZvciAoa2V5IGluIHZhbHVlT2JqZWN0KSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU2hhcmVkT2JqZWN0RXZlbnQoU2hhcmVkT2JqZWN0RXZlbnRUeXBlcy5QUk9QRVJUWV9VUERBVEUsIHRoaXMuX25hbWUsIG5ldyBQcm9wZXJ0eURhdGEoa2V5LCB2YWx1ZU9iamVjdFtrZXldKS50b09iamVjdCgpKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2ggb2YgUFJPUEVSVFlfVVBEQVRFIG9yIE1FVEhPRF9VUERBVEUgYmFzZWQgb24gZXZlbnQocykuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGV2ZW50c1xuICAgKiAgICAgICAgQSBsaXN0IG9mIGV2ZW50cyB0byBpdGVyYXRlIHRocm91Z2ggYW5kIGRpc3BhdGNoIG5vdGlmaWNhdGlvbnMgZnJvbS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9ub3RpZnlPZkV2ZW50cyAoZXZlbnRzKSB7XG4gICAgbGV0IGksIGV2ZW50XG4gICAgbGV0IGhhbmRsZWQgPSBmYWxzZVxuICAgIGNvbnN0IGxlbmd0aCA9IGV2ZW50cy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGV2ZW50ID0gZXZlbnRzW2ldXG4gICAgICBzd2l0Y2ggKGV2ZW50LnN1YnR5cGUpIHtcbiAgICAgICAgY2FzZSBTT19TVUJUWVBFX1JFTU9WRTpcbiAgICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFNoYXJlZE9iamVjdEV2ZW50KFNoYXJlZE9iamVjdEV2ZW50VHlwZXMuUFJPUEVSVFlfUkVNT1ZFLCB0aGlzLl9uYW1lLCB7IGF0dHJpYnV0ZTogZXZlbnQuYXR0cmlidXRlIH0pKVxuICAgICAgICAgIGhhbmRsZWQgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBTT19TVUJUWVBFX1BST1BFUlRZOlxuICAgICAgICAgIGlmIChldmVudC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGFuIGluaXRpYWwgcGF5bG9hZCBvZiBhdHRyaWJ1dGUgdmFsdWVzLlxuICAgICAgICAgICAgdGhpcy5fbm90aWZ5T2ZQcm9wZXJ0eVZhbHVlcyhldmVudC5hdHRyaWJ1dGVzKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFNoYXJlZE9iamVjdEV2ZW50KFNoYXJlZE9iamVjdEV2ZW50VHlwZXMuUFJPUEVSVFlfVVBEQVRFLCB0aGlzLl9uYW1lLCBuZXcgUHJvcGVydHlEYXRhKGV2ZW50LmF0dHJpYnV0ZSwgZXZlbnQudmFsdWUpLnRvT2JqZWN0KCkpKVxuICAgICAgICAgIH1cbiAgICAgICAgICBoYW5kbGVkID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgU09fU1VCVFlQRV9NRVRIT0Q6XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTaGFyZWRPYmplY3RFdmVudChTaGFyZWRPYmplY3RFdmVudFR5cGVzLk1FVEhPRF9VUERBVEUsIHRoaXMuX25hbWUsIG5ldyBNZXRob2REYXRhKGV2ZW50Lm1ldGhvZCwgZXZlbnQudmFsdWUpLnRvT2JqZWN0KCkpKVxuICAgICAgICAgIGhhbmRsZWQgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGJ5IGNvbm5lY3Rpb24gY2hhbm5lbCB0byBoYW5kbGUgbWVzc2FnZSBhbmQgZGlzcGF0Y2ggYXBwcm9wcmlhdGUgbm90aWZpY2F0aW9ucy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlc3BvbmQgKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZS5kYXRhKSB7XG4gICAgICBsZXQganNvbiA9IHRoaXMuX2dldEpzb25Gcm9tU29ja2V0TWVzc2FnZShtZXNzYWdlKVxuICAgICAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICAgICAgd2Fybih0aGlzLl9uYW1lLCAnRGV0ZXJtaW5lZCBtZXNzYWdlIHJlc3BvbnNlIG5vdCBpbiBjb3JyZWN0IGZvcm1hdC4gQWJvcnRpbmcgbWVzc2FnZSBoYW5kbGUuJylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoanNvbi5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGpzb24uZGF0YS5uYW1lID09PSB0aGlzLl9uYW1lKSB7XG4gICAgICAgICAgZGVidWcodGhpcy5fbmFtZSwgJ1tzaGFyZWRvYmplY3QtcmVzcG9uc2VdOiAnICsgSlNPTi5zdHJpbmdpZnkoanNvbiwgbnVsbCwgMikpXG4gICAgICAgICAgaWYgKGpzb24uZGF0YS5zdGF0dXMgPT09ICdTaGFyZWRPYmplY3QuU3RhdHVzLkdldFJlbW90ZScgJiZcbiAgICAgICAgICAgICAganNvbi5kYXRhLm1lc3NhZ2UgPT09ICdTdWNjZXNzJykge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNwb3J0LmNvbm5lY3RUb1NoYXJlZE9iamVjdCh0aGlzLl9uYW1lKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGpzb24uZGF0YS5zdGF0dXMgPT09ICdTaGFyZWRPYmplY3QuU3RhdHVzLkdldFJlbW90ZScgJiZcbiAgICAgICAgICAgICAganNvbi5kYXRhLm1lc3NhZ2UgPT09ICdGYWlsJykge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTaGFyZWRPYmplY3RFdmVudChTaGFyZWRPYmplY3RFdmVudFR5cGVzLkNPTk5FQ1RfRkFJTFVSRSwgdGhpcy5fbmFtZSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoanNvbi5kYXRhLnN0YXR1cyA9PT0gJ1NoYXJlZE9iamVjdC5TdGF0dXMuQ29ubmVjdCcgJiZcbiAgICAgICAgICAgICAganNvbi5kYXRhLm1lc3NhZ2UgPT09ICdTdWNjZXNzJykge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTaGFyZWRPYmplY3RFdmVudChTaGFyZWRPYmplY3RFdmVudFR5cGVzLkNPTk5FQ1RfU1VDQ0VTUywgdGhpcy5fbmFtZSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoanNvbi5kYXRhLnN0YXR1cyA9PT0gJ1NoYXJlZE9iamVjdC5TdGF0dXMuQ29ubmVjdCcgJiZcbiAgICAgICAgICAgICAganNvbi5kYXRhLm1lc3NhZ2UgPT09ICdGYWlsJykge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTaGFyZWRPYmplY3RFdmVudChTaGFyZWRPYmplY3RFdmVudFR5cGVzLkNPTk5FQ1RfRkFJTFVSRSwgdGhpcy5fbmFtZSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoanNvbi5kYXRhLnN0YXR1cyA9PT0gJ1NoYXJlZE9iamVjdC5TdGF0dXMuRGlzY29ubmVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU2hhcmVkT2JqZWN0RXZlbnQoU2hhcmVkT2JqZWN0RXZlbnRUeXBlcy5DT05ORUNUSU9OX0NMT1NFRCwgdGhpcy5fbmFtZSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoanNvbi5kYXRhLnR5cGUgPT09ICdzaGFyZWRvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoanNvbi5kYXRhLmhhc093blByb3BlcnR5KCdldmVudHMnKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm90aWZ5T2ZFdmVudHMoanNvbi5kYXRhLmV2ZW50cylcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoanNvbi5kYXRhLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3RpZnlPZlByb3BlcnR5VmFsdWVzKGpzb24uZGF0YS52YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcodGhpcy5fbmFtZSwgJ1VuaGFuZGxlZCBNZXNzYWdlIGV4Y2hhbmdlOiAnICsgSlNPTi5zdHJpbmdpZnkoanNvbiwgbnVsbCwgMikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gc2VuZCBub3RpZmljYXRpb24gdG8gb3RoZXIgY29ubmVjdGVkIGNsaWVudHMgdXNpbmcgYSB0YXJnZXQgbWV0aG9kIG5hbWUgYW5kIG9iamVjdCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kTmFtZVxuICAgKiAgICAgICAgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBhdHRlbXB0IHRvIGludm9rZSBvbiByZWNlaXZpbmcgY2xpZW50cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogICAgICAgIEEgZGF0YSBvYmplY3QgdG8gc2VuZCBhbG9uZyBhcyB0aGUgcGFyYW1ldGVyIG9mIHRoZSB0YXJnZXQgbWV0aG9kLlxuICAgKi9cbiAgc2VuZCAobWV0aG9kTmFtZSwgZGF0YSkge1xuICAgIGNvbnN0IHRyYW5zcG9ydCA9IHRoaXMuX3RyYW5zcG9ydFxuICAgIGlmICh0cmFuc3BvcnQpIHtcbiAgICAgIHRyYW5zcG9ydC5zZW5kVG9TaGFyZWRPYmplY3QodGhpcy5fbmFtZSwgbWV0aG9kTmFtZSwgZGF0YSlcbiAgICB9IGVsc2Uge1xuICAgICAgd2Fybih0aGlzLl9uYW1lLCAnTm8gV2ViU29ja2V0IGNvbm5lY3Rpb24gYXZhaWxhYmxlIScpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gdXBkYXRlIGEgc3BlY2lmaWMgcHJvcGVydHkgb24gdGhlIGNvbm5lY3RlZCBTaGFyZWQgT2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqICAgICAgICBUaGUgcHJvcGVydHkgbmFtZSB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgKiAgICAgICAgVGhlIHZhbHVlIG9iamVjdCB0byB1cGRhdGUgdGhlIHByb3BlcnR5IHRvLlxuICAgKi9cbiAgc2V0UHJvcGVydHkgKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQuc2VuZFByb3BlcnR5VG9TaGFyZWRPYmplY3QodGhpcy5fbmFtZSwga2V5LCB2YWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGNsb3NlIHRoZSBlc3RhYmxpc2hlZCBTaGFyZWQgT2JqZWN0IGNvbm5lY3Rpb24uIFRoaXMgZG9lcyBub3QgY2xvc2UgdGhlIHVuZGVybHlpbmcgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAqL1xuICBjbG9zZSAoKSB7XG4gICAgY29uc3QgdHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0XG4gICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHJhbnNwb3J0LmNsb3NlU2hhcmVkT2JqZWN0KHRoaXMuX25hbWUpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIG5hZGEuXG4gICAgICB9XG4gICAgICB0cmFuc3BvcnQucmVtb3ZlU2hhcmVkT2JqZWN0UmVzcG9uc2VIYW5kbGVyKHRoaXMpXG4gICAgICB0cmFuc3BvcnQub2ZmKCcqJywgdGhpcy5faGFuZGxlVHJhbnNwb3J0U3RhdGVFdmVudHMpXG4gICAgfVxuICAgIHRoaXMuX3RyYW5zcG9ydCA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3RyYW5zcG9ydENvbnRyb2xsZXIgPSB1bmRlZmluZWRcbiAgICBlbnZpcm9ubWVudC5yZW1vdmVDbG9zZUhhbmRsZXIodGhpcy5fb25jbG9zZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBNZXNzYWdlIFRyYW5zcG9ydCBDb250cm9sbGVyIGluc3RhbmNlXG4gICAqXG4gICAqIEBzZWUgI3NldE1lc3NhZ2VUcmFuc3BvcnRDb250cm9sbGVyXG4gICAqL1xuICBnZXRNZXNzYWdlVHJhbnNwb3J0Q29udHJvbGxlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydENvbnRyb2xsZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NpZ25zIHRoZSBNZXNzYWdlIFRyYW5zcG9ydCBDb250cm9sbGVyIHdoaWNoIGV4cG9zZXMgdGhlIG1lc3NhZ2UgdHJhbnNwb3J0IGxheWVyIG9uIHdoaWNoIGFsbCBjb21tdW5pY2F0aW9uIHRvIGFuZCBmcm9tIHRoZSBTaGFyZWQgT2JqZWN0IGlzIGhhbmRsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250cm9sbGVyXG4gICAqICAgICAgICBUaGUgQ29udHJvbGxlciBmb3IgdGhlIE1lc3NhZ2UgVHJhbnNwb3J0IExheWVyLiBFeHBvc2VzIHRoZSBtZXRob2QgYGdldE1lc3NhZ2VUcmFuc3BvcnRgIHdoaWNoIHJldHVybnMgdGhlIGN1cnJlbnQgbWVzc2FnZSB0cmFuc3BvcnQgbGF5ZXIuXG4gICAqXG4gICAqL1xuICBzZXRNZXNzYWdlVHJhbnNwb3J0Q29udHJvbGxlciAoY29udHJvbGxlcikge1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICAgIHRoaXMuX3RyYW5zcG9ydC5yZW1vdmVTaGFyZWRPYmplY3RSZXNwb25zZUhhbmRsZXIodGhpcylcbiAgICAgIHRoaXMuX3RyYW5zcG9ydC5vZmYoJyonLCB0aGlzLl9oYW5kbGVUcmFuc3BvcnRTdGF0ZUV2ZW50cylcbiAgICAgIGVudmlyb25tZW50LnJlbW92ZUNsb3NlSGFuZGxlcih0aGlzLl9vbmNsb3NlKVxuICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gdW5kZWZpbmVkXG4gICAgICB0aGlzLl90cmFuc3BvcnRDb250cm9sbGVyID0gdW5kZWZpbmVkICAgICAgXG4gICAgfVxuXG4gICAgdGhpcy5fdHJhbnNwb3J0Q29udHJvbGxlciA9IGNvbnRyb2xsZXJcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnRDb250cm9sbGVyLmdldE1lc3NhZ2VUcmFuc3BvcnQoKSAgICBcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0Q29udHJvbGxlciAmJiB0aGlzLl90cmFuc3BvcnQpIHtcbiAgICAgIHRoaXMuX3RyYW5zcG9ydENvbnRyb2xsZXIub24oTWVzc2FnZVRyYW5zcG9ydFN0YXRlRXZlbnRUeXBlcy5DSEFOR0UsIHRoaXMuX2hhbmRsZU1lc3NhZ2VUcmFuc3BvcnRDaGFuZ2UpXG4gICAgICB0aGlzLl9lc3RhYmxpc2hUcmFuc3BvcnQodGhpcy5fdHJhbnNwb3J0KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlIFNoYXJlZCBPYmplY3QgY29ubmVjdGVkIHRvLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXROYW1lICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVkNVByb1NoYXJlZE9iamVjdCIsImltcG9ydCBTb2NrZXRIZWxwZXIgZnJvbSAnLi4vaGVscGVyL3NvY2tldC1oZWxwZXInXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgeyBydGNTb2NrZXRFbmRwb2ludEZyb21PcHRpb25zIGFzIGVuZHBvaW50RnJvbU9wdGlvbnMgfSBmcm9tICcuLi91dGlsL3VybC1lbmRwb2ludCdcbi8vIGltcG9ydCB7IGluZm8sIGRlYnVnLCB3YXJuIH0gZnJvbSAnLi4vbG9nJ1xuXG4vKipcbiAqIEEgYmFyZS1ib25lcyBQcm94eSBmb3IgV2ViU29ja2V0IGNvbm5lY3Rpb24gdG8gYmUgdXNlZCBieSBSZWQ1UHJvU2hhcmVkT2JqZWN0cy5cbiAqL1xuY2xhc3MgUmVkNVByb1NoYXJlZE9iamVjdFNvY2tldCBleHRlbmRzIFNvY2tldEhlbHBlciB7XG5cbiAgY29uc3RydWN0b3IgKHJlc3BvbmRlciA9IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHV1aWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweDEwMDAwKS50b1N0cmluZygxNilcbiAgICBjb25zdCBuYW1lID0gYHNoYXJlZG9iamVjdC0ke3V1aWR9YFxuICAgIHN1cGVyKHJlc3BvbmRlciwgbmFtZSlcbiAgICB0aGlzLmlkID0gbmFtZVxuICAgIHRoaXMuX3NoYXJlZE9iamVjdE5hbWUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWphY2tpbmcgdGhpcyB0byB0cmFjayBTaGFyZWRPYmplY3QgbmFtZSBmb3IgZXZlbnQgbm90aWZpY2F0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UmVtb3RlU2hhcmVkT2JqZWN0IChuYW1lKSB7XG4gICAgc3VwZXIuZ2V0UmVtb3RlU2hhcmVkT2JqZWN0KG5hbWUpXG4gICAgdGhpcy5fc2hhcmVkT2JqZWN0TmFtZSA9IG5hbWVcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBiYXNlZCBvbiBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWd1cmF0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgQ29uZmlndXJhdGlvbiBvYmplY3QgdXNlZCBpbiBjb25zdHJ1Y3Rpb24gV2ViU29ja2V0IGVuZHBvaW50IFVSTCBiYXNlZCBvbiBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICogICAgICAgICAgICAgICAgICBPcHRpb25hbCBpZGVudGlmaWVyIGZvciB0aGUgc2hhcmVkIG9iamVjdCBjb25uZWN0aW9uIGluc3RhbmNlLiBOZWVkcyB0byBiZSB1bmlxdWUuIEF1dG9nZW5lcmF0ZWQgaWYgbGVmdCB1bmRlZmluZWQuXG4gICAqIEBwYXJhbSB7SW50ZWdlcn0gY2FwYWJpbGl0eVxuICAgKiAgICAgICAgICAgICAgICAgIE9wdGlvbmFsIGNhcGFiaWxpdHkgZW51bSBmb3IgY29ubmVjdGlvbi4gMiA9IFNoYXJlZCBPYmplY3QgKyBXZWJTb2NrZXQuIDQgPSBTaGFyZWQgT2JqZWN0ICsgUlRDLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgaW5pdCAoY29uZmlndXJhdGlvbiwgaWQgPSB1bmRlZmluZWQsIGNhcGFiaWxpdHkgPSAyKSB7XG4gICAgY29uc3Qgc29ja2V0UHJvbWlzZSA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRoaXMuaWQgPSBpZCB8fCB0aGlzLmlkXG4gICAgdGhpcy5fbmFtZSA9IHRoaXMuaWRcbiAgICAvLyBjYXBhYmlsaXRpZXMgaXMgdGhlIGludCB0byBub3RpZnkgdGhhdCB0aGVyZSBpcyBubyBhc3NvY2lhdGVkIHJ0YyBjb25uZWN0aW9uLlxuICAgIGNvbnN0IHVybCA9IGVuZHBvaW50RnJvbU9wdGlvbnMoY29uZmlndXJhdGlvbiwge2lkOiB0aGlzLmlkLCBjYXBhYmlsaXRpZXM6IGNhcGFiaWxpdHl9KVxuICAgIHRoaXMuc2V0VXAodXJsLCBzb2NrZXRQcm9taXNlKVxuICAgIHJldHVybiBzb2NrZXRQcm9taXNlLnByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNwb25kcyB0byBtZXNzYWdlcyBjb21pbmcgb3ZlciB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXNwb25kIChtZXNzYWdlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBpZiAoIXN1cGVyLnJlc3BvbmQobWVzc2FnZSkpIHtcbiAgICAgIGlmIChtZXNzYWdlLmRhdGEpIHtcbiAgICAgICAgbGV0IGpzb24gPSB0aGlzLmdldEpzb25Gcm9tU29ja2V0TWVzc2FnZShtZXNzYWdlKVxuICAgICAgICBpZiAoanNvbiAmJiBqc29uLmRhdGEpIHtcbiAgICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGpzb25cbiAgICAgICAgICBpZiAoZGF0YS50eXBlID09PSAnc3RhdHVzJykge1xuICAgICAgICAgICAgaWYgKGRhdGEuY29kZSA9PT0gJ05ldENvbm5lY3Rpb24uQ29ubmVjdC5DbG9zZWQnKSB7XG4gICAgICAgICAgICAgIC8vIFRyaWNrIGludG8gcmVzcG9uZGluZyB0byBkaXNjb25uZWN0IHRocm91Z2ggU2hhcmVkT2JqZWN0IHJlc3BvbmRlci5cbiAgICAgICAgICAgICAgdGhpcy5yZXNwb25kKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ1NoYXJlZE9iamVjdC5TdGF0dXMuRGlzY29ubmVjdCcsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRhdGEuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5fc2hhcmVkT2JqZWN0TmFtZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgdGhpcy5fc2hhcmVkT2JqZWN0TmFtZSA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLmNvZGUgPT09ICdOZXRDb25uZWN0aW9uLklDRS5Ucmlja2xlQ29tcGxldGVkJyAmJiB0aGlzLl9yZXNwb25kZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uSWNlVHJpY2tsZUNvbXBsZXRlKClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS5jb2RlID09PSAnTmV0Q29ubmVjdGlvbi5EYXRhQ2hhbm5lbC5BdmFpbGFibGUnICYmIHRoaXMuX3Jlc3BvbmRlcikge1xuICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25EYXRhQ2hhbm5lbEF2YWlsYWJsZShkYXRhLmRlc2NyaXB0aW9uKVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9yZXNwb25kZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU29ja2V0U3RhdHVzKGRhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnNkcCkge1xuICAgICAgICAgICAgY29uc3QgeyBzZHAgfSA9IGRhdGFcbiAgICAgICAgICAgIGlmIChzZHAudHlwZSA9PT0gJ2Fuc3dlcicgJiYgdGhpcy5fcmVzcG9uZGVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNEUEFuc3dlcihzZHApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChkYXRhLmNhbmRpZGF0ZSAmJiB0aGlzLl9yZXNwb25kZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2FuZGlkYXRlIH0gPSBkYXRhXG4gICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25BZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGNsb3NlIGRvd24gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgKi9cbiAgY2xvc2UgKCkge1xuICAgIHRoaXMuX3NoYXJlZE9iamVjdE5hbWUgPSB1bmRlZmluZWRcbiAgICB0aGlzLnRlYXJEb3duKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlLiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxseSB0byBhY2Nlc3MgdGhlIHVuZGVybHlpbmcgY29tbXVuaWNhdGlvbiBjaGFubmVsIGJ5IHRoZSBTaGFyZWRPYmplY3QgaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRNZXNzYWdlVHJhbnNwb3J0ICgpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2UuIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IHRvIGFjY2VzcyB0aGUgdW5kZXJseWluZyBjb21tdW5pY2F0aW9uIGNoYW5uZWwgYnkgdGhlIFNoYXJlZE9iamVjdCBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldENvbm5lY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBSZWQ1UHJvU2hhcmVkT2JqZWN0U29ja2V0XG4iLCJpbXBvcnQgKiBhcyB3ZWJydGMgZnJvbSAnLi4vYWRhcHRlci93ZWJydGMnXG5pbXBvcnQgV2ViUlRDUGVlckhlbHBlciBmcm9tICcuLi9oZWxwZXIvd2VicnRjLWhlbHBlcidcbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCBSZWQ1UHJvU2hhcmVkT2JqZWN0U29ja2V0IGZyb20gJy4vc29ja2V0J1xuaW1wb3J0IHsgaXNPYmplY3RFbXB0eSB9IGZyb20gJy4uL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHtcbiAgTWVzc2FnZVRyYW5zcG9ydFN0YXRlRXZlbnQsXG4gIE1lc3NhZ2VUcmFuc3BvcnRTdGF0ZUV2ZW50VHlwZXNcbn0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgeyBkZWJ1Zywgd2FybiB9IGZyb20gJy4uL2xvZydcblxuY29uc3Qgc29TdGFydFJlZ2V4ID0gLyguKikgc3RhcnRpbmcvaVxuXG4vKipcbiAqIEEgYmFyZS1ib25lcyBQcm94eSBmb3IgUlRDUGVlckNvbm5lY3Rpb24gdG8gYmUgdXNlZCBieSBSZWQ1UHJvU2hhcmVkT2JqZWN0cy5cbiAqL1xuY2xhc3MgUmVkNVByb1NoYXJlZE9iamVjdFBlZXJDb25uZWN0aW9uIGV4dGVuZHMgV2ViUlRDUGVlckhlbHBlciB7XG5cbiAgY29uc3RydWN0b3IgKHJlc3BvbmRlciA9IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHV1aWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweDEwMDAwKS50b1N0cmluZygxNilcbiAgICBjb25zdCBuYW1lID0gYHNoYXJlZG9iamVjdC0ke3V1aWR9YFxuICAgIHN1cGVyKHJlc3BvbmRlciwgbmFtZSlcbiAgICB0aGlzLmlkID0gbmFtZVxuICAgIHRoaXMuX29wdGlvbnMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9zb2NrZXQgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9zaGFyZWRPYmplY3ROYW1lID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fY29ubmVjdGlvblByb21pc2UgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGhhbmRsZXJzIGFzc2lnbmVkIHRvIHRoZSBwZWVyIGNvbm5lY3Rpb24gaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UlRDUGVlckNvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBfcmVtb3ZlQ29ubmVjdGlvbkhhbmRsZXJzIChjb25uZWN0aW9uKSB7XG4gICAgY29ubmVjdGlvbi5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IHVuZGVmaW5lZFxuICAgIGNvbm5lY3Rpb24ub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSB1bmRlZmluZWRcbiAgICBjb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gdW5kZWZpbmVkXG4gICAgY29ubmVjdGlvbi5vbnRyYWNrID0gdW5kZWZpbmVkXG4gICAgY29ubmVjdGlvbi5vbmRhdGFjaGFubmVsID0gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogQXNzaWducyBoYW5kbGVycyB0byBldmVudHMgb24gdGhlIHBlZXIgY29ubmVjdGlvbiBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtSVENQZWVyQ29ubmVjdGlvbn0gY29ubmVjdGlvblxuICAgKiBAcGFyYW0ge1Byb21pc2V9IHByb21pc2VcbiAgICogICAgICAgIFRoZSBgUHJvbWlzZWAgdG8gcmVzb2x2ZSBvciByZWplY3Qgb24gc3VjY2VzcyBvZiBjb25uZWN0aW9uLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIF9hZGRDb25uZWN0aW9uSGFuZGxlcnMgKGNvbm5lY3Rpb24sIHByb21pc2UpIHsgXG4gICAgbGV0IHJlY29ubmVjdFRpbWVvdXRcbiAgICBjb25zdCB0aW1lb3V0TGltaXQgPSA1MDAwXG5cbiAgICBwcm9taXNlID0gcHJvbWlzZSB8fCB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZVxuICAgIGNvbm5lY3Rpb24ub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBkZWJ1Zyh0aGlzLl9uYW1lLCBgW3BlZXIub25jb25uZWN0aW9uc3RhdGVjaGFuZ2VdIC0gU3RhdGU6ICR7Y29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdGV9YClcbiAgICAgIGlmIChjb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgZGVidWcodGhpcy5fbmFtZSwgJ1twZWVyY29ubmVjdGlvbjpvcGVuXScpXG4gICAgICAgIC8vIFRPRE86IFRoaXMgbWF5IG5lZWQgdG8gbW92ZS5cbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBNZXNzYWdlVHJhbnNwb3J0U3RhdGVFdmVudChNZXNzYWdlVHJhbnNwb3J0U3RhdGVFdmVudFR5cGVzLk9QRU4sIHRoaXMuX25hbWUsIHtwZWVyQ29ubmVjdGlvbjogdGhpc30pKVxuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcgfHxcbiAgICAgICAgY29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgIHdhcm4odGhpcy5fbmFtZSwgJ1twZWVyY29ubmVjdGlvbjplcnJvcl0nKVxuICAgICAgICBpZiAoY29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBNZXNzYWdlVHJhbnNwb3J0U3RhdGVFdmVudChNZXNzYWdlVHJhbnNwb3J0U3RhdGVFdmVudFR5cGVzLkVSUk9SLCB0aGlzLl9uYW1lLCB7cGVlckNvbm5lY3Rpb246IHRoaXMsIGVycm9yOiAnQ29ubmVjdGlvbiBGYWlsZWQuJ30pKVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgICAgcHJvbWlzZS5yZWplY3QoJ0Nvbm5lY3Rpb24gRmFpbGVkLicpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gKGV2ZW50KSA9PiB7XG4gICAgICBkZWJ1Zyh0aGlzLl9uYW1lLCBgW3BlZXIub25pY2VjYW5kaWRhdGVdIC0gUGVlciBDYW5kaWRhdGU6ICR7ZXZlbnQuY2FuZGlkYXRlfWApXG4gICAgICBpZiAoZXZlbnQuY2FuZGlkYXRlKSB7XG4gICAgICAgIHRoaXMuX3NvY2tldC5wb3N0KHtcbiAgICAgICAgICBoYW5kbGVDYW5kaWRhdGU6IHRoaXMuX25hbWUsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgY2FuZGlkYXRlOiBldmVudC5jYW5kaWRhdGVcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmNhbmRpZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICBkZWJ1Zyh0aGlzLl9uYW1lLCAnW2ljZWNhbmRpZGF0ZXRyaWNrbGU6ZW5kXScpXG4gICAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgICAgLy8gcHJvbWlzZS5yZXNvbHZlKHRoaXMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25uZWN0aW9uLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGNvbm5lY3Rpb24uaWNlQ29ubmVjdGlvblN0YXRlXG4gICAgICBkZWJ1Zyh0aGlzLl9uYW1lLCBgW3BlZXIub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2VdIC0gU3RhdGU6ICR7c3RhdGV9YClcbiAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcgJiYgZW52aXJvbm1lbnQuZ2V0SXNFZGdlKCkpIHtcbiAgICAgICAgLy8gU3VwcG9ydCBmb3IgT1JUQyBvcmRlciBvZiBjYW5kaWRhdGVzLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIGludm9rZWQgZnJvbSBhIGBvbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlYCBldmVudCBvbiB0aGUgQ29ubmVjdGlvbi5cbiAgICAgICAgLy8gRWRnZSBkb2Vzbid0IG5vdGlmeSBvbiB0aGF0IGV2ZW50LlxuICAgICAgICBkZWJ1Zyh0aGlzLl9uYW1lLCAnW2VkZ2Uvb3J0Yzpub3RpZnkgY29tcGxldGVdJylcbiAgICAgICAgZGVidWcodGhpcy5fbmFtZSwgJ1tpY2VjYW5kaWRhdGVnYXRoZXJpbmc6ZW5kXScpXG4gICAgICAgIHRoaXMuX3NvY2tldC5wb3N0RW5kT2ZDYW5kaWRhdGVzKHRoaXMuX25hbWUpXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgaWYgKHJlY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQocmVjb25uZWN0VGltZW91dClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IE1lc3NhZ2VUcmFuc3BvcnRTdGF0ZUV2ZW50KE1lc3NhZ2VUcmFuc3BvcnRTdGF0ZUV2ZW50VHlwZXMuRVJST1IsIHRoaXMuX25hbWUsIHtwZWVyQ29ubmVjdGlvbjogdGhpcywgZXJyb3I6ICdDb25uZWN0aW9uIEZhaWxlZC4nfSkpXG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgTWVzc2FnZVRyYW5zcG9ydFN0YXRlRXZlbnQoTWVzc2FnZVRyYW5zcG9ydFN0YXRlRXZlbnRUeXBlcy5DTE9TRSwgdGhpcy5fbmFtZSwge3BlZXJDb25uZWN0aW9uOiB0aGlzLCBldmVudDogZXZlbnR9KSlcbiAgICAgICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgICBwcm9taXNlLnJlamVjdCgnQ29ubmVjdGlvbiBGYWlsZWQuJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgIC8vIG1heSByZWNlaXZlIGEgZGlzY29ubmVjdCB0ZW1wb3JhcmlseSB0aGF0IHdpbGwgdGhlbiByZXR1cm4gdG8gYSBjb25uZWN0aW9uLlxuICAgICAgICByZWNvbm5lY3RUaW1lb3V0ID0gc2V0VGltZW91dCggKCkgPT4ge1xuICAgICAgICAgIGRlYnVnKHRoaXMuX25hbWUsIGBbcGVlci5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZV0gLSBSZWNvbm5lY3QgdGltZW91dCByZWFjaGVkLiBDbG9zaW5nIFBlZXJDb25uZWN0aW9uLmApXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHJlY29ubmVjdFRpbWVvdXQpXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBNZXNzYWdlVHJhbnNwb3J0U3RhdGVFdmVudChNZXNzYWdlVHJhbnNwb3J0U3RhdGVFdmVudFR5cGVzLkNMT1NFLCB0aGlzLl9uYW1lLCB7cGVlckNvbm5lY3Rpb246IHRoaXMsIGV2ZW50OiBldmVudH0pKVxuICAgICAgICB9LCB0aW1lb3V0TGltaXQpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHJlY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgICAgICBkZWJ1Zyh0aGlzLl9uYW1lLCBgW3BlZXIub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2VdIC0gQ2xlYXJpbmcgdGltZW91dCBmb3IgcmVjb25uZWN0LmApXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHJlY29ubmVjdFRpbWVvdXQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25uZWN0aW9uLm9uaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGNvbm5lY3Rpb24uaWNlR2F0aGVyaW5nU3RhdGVcbiAgICAgIGRlYnVnKHRoaXMuX25hbWUsIGBbcGVlci5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlXSAtIFN0YXRlOiAke3N0YXRlfWApXG4gICAgICBpZiAoc3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgZGVidWcodGhpcy5fbmFtZSwgJ1tpY2VjYW5kaWRhdGVnYXRoZXJpbmc6ZW5kXScpXG4gICAgICAgIHRoaXMuX3NvY2tldC5wb3N0RW5kT2ZDYW5kaWRhdGVzKHRoaXMuX25hbWUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZU9mZmVyIChwcm9taXNlID0gdW5kZWZpbmVkKSB7XG4gICAgZGVidWcodGhpcy5fbmFtZSwgYFtwZWVyLmNyZWF0ZW9mZmVyXWApXG4gICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uY3JlYXRlT2ZmZXIoKVxuICAgICAgLnRoZW4oc2RwID0+IHtcbiAgICAgICAgZGVidWcodGhpcy5fbmFtZSwgYFtwZWVyOm9mZmVyXSAke3NkcC5zZHB9YClcbiAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihzZHApXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc29ja2V0LnBvc3Qoe1xuICAgICAgICAgICAgICBoYW5kbGVPZmZlcjogdGhpcy5fbmFtZSxcbiAgICAgICAgICAgICAgdHJhbnNwb3J0OiAndWRwJyxcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHNkcDogc2RwXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZXJyb3IpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogSGlqYWNraW5nIHRoaXMgdG8gdHJhY2sgU2hhcmVkT2JqZWN0IG5hbWUgZm9yIGV2ZW50IG5vdGlmaWNhdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFJlbW90ZVNoYXJlZE9iamVjdCAobmFtZSkge1xuICAgIHN1cGVyLmdldFJlbW90ZVNoYXJlZE9iamVjdChuYW1lKVxuICAgIHRoaXMuX3NoYXJlZE9iamVjdE5hbWUgPSBuYW1lXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gYmFzZWQgb24gY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlndXJhdGlvblxuICAgKiAgICAgICAgICAgICAgICAgIENvbmZpZ3VyYXRpb24gb2JqZWN0IHVzZWQgaW4gY29uc3RydWN0aW9uIG9mIFJUQ1BlZXJDb25uZWN0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICogICAgICAgICAgICAgICAgICBPcHRpb25hbCBpZGVudGlmaWVyIGZvciB0aGUgc2hhcmVkIG9iamVjdCBjb25uZWN0aW9uIGluc3RhbmNlLiBOZWVkcyB0byBiZSB1bmlxdWUuIEF1dG9nZW5lcmF0ZWQgaWYgbGVmdCB1bmRlZmluZWQuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBpbml0IChjb25maWd1cmF0aW9uLCBpZCA9IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHBlZXJQcm9taXNlID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdGhpcy5pZCA9IGlkIHx8IHRoaXMuaWRcbiAgICB0aGlzLl9uYW1lID0gdGhpcy5pZFxuICAgIHRoaXMuX29wdGlvbnMgPSBjb25maWd1cmF0aW9uXG4gICAgdGhpcy5fc29ja2V0ID0gbmV3IFJlZDVQcm9TaGFyZWRPYmplY3RTb2NrZXQodGhpcylcbiAgICB0aGlzLl9zb2NrZXQub24oJ01lc3NhZ2VUcmFuc3BvcnQuT3BlbicsIChldmVudCkgPT4ge1xuICAgICAgZGVidWcodGhpcy5fbmFtZSwgYFtzb2NrZXQ6ZXZlbnRdIC0gJHtldmVudC50eXBlfWApXG4gICAgICB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZSA9IHBlZXJQcm9taXNlXG4gICAgICB0aGlzLnNldFVwV2l0aFBlZXJDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24ucnRjQ29uZmlndXJhdGlvbiwgdGhpcy5nZXREYXRhQ2hhbm5lbENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbikpXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlT2ZmZXIocGVlclByb21pc2UpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBNZXNzYWdlVHJhbnNwb3J0U3RhdGVFdmVudChNZXNzYWdlVHJhbnNwb3J0U3RhdGVFdmVudFR5cGVzLkVSUk9SLCB0aGlzLl9uYW1lLCB7cGVlckNvbm5lY3Rpb246IHRoaXMsIGVycm9yOiBlcnJvcn0pKVxuICAgICAgICAgICAgcGVlclByb21pc2UucmVqZWN0KGVycm9yKVxuICAgICAgICAgIH0pXG4gICAgfSlcbiAgICAvLyBDYXBhYmlsaXR5ID0gNCBmb3IgUlRDIENvbm5lY3Rpb24gb25seS5cbiAgICB0aGlzLl9zb2NrZXQuaW5pdChjb25maWd1cmF0aW9uLCB0aGlzLmlkLCA0KVxuICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBNZXNzYWdlVHJhbnNwb3J0U3RhdGVFdmVudChNZXNzYWdlVHJhbnNwb3J0U3RhdGVFdmVudFR5cGVzLkVSUk9SLCB0aGlzLl9uYW1lLCB7cGVlckNvbm5lY3Rpb246IHRoaXMsIGVycm9yOiBlcnJvcn0pKVxuICAgICAgICBwZWVyUHJvbWlzZS5yZWplY3QoZXJyb3IpXG4gICAgICB9KVxuICAgIHJldHVybiBwZWVyUHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZS4gVGhpcyBpcyB1c2VkIGludGVybmFsbHkgdG8gYWNjZXNzIHRoZSB1bmRlcmx5aW5nIGNvbW11bmljYXRpb24gY2hhbm5lbCBieSB0aGUgU2hhcmVkT2JqZWN0IGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TWVzc2FnZVRyYW5zcG9ydCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvY2tldCB8fCB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBwcm92aWRlZCBvciBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBSVENEYXRhQ2hhbm5lbC5cbiAgICpcbiAgICogIEBwYXJhbSB7T2JqZWN0fSBjb25maWd1cmF0aW9uXG4gICAqICAgICAgICAgIFRoZSBiYXNlIGNvbmZpZ3VyYXRpb24gcHJvdmlkZWQgaW4gYGluaXRgIHRvIGNoZWNrIGZvciBEYXRhQ2hhbm5lbCBjb25maWd1cmF0aW9uIHByb3BlcnR5IG9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0RGF0YUNoYW5uZWxDb25maWd1cmF0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb24uZGF0YUNoYW5uZWxDb25maWd1cmF0aW9uIHx8IHtuYW1lOiAncmVkNXBybyd9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJvdmlkZWQgb3IgZGVmYXVsdCBjaGFubmVsIG5hbWUgZm9yIHRoZSBSVENEYXRhQ2hhbm5lbC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ3VyYXRpb25cbiAgICogICAgICAgIFRoZSBiYXNlIGNvbmZpZ3VyYXRpb24gcHJvdmlkZWQgaW4gYGluaXRgIHRvIGNoZWNrIGZvciBkYXRhIGNoYW5uZWwgbmFtZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldERhdGFDaGFubmVsTmFtZSAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGFDaGFubmVsQ29uZmlndXJhdGlvblxuICAgIH0gPSBjb25maWd1cmF0aW9uXG4gICAgaWYgKGRhdGFDaGFubmVsQ29uZmlndXJhdGlvbiAmJiBkYXRhQ2hhbm5lbENvbmZpZ3VyYXRpb24ubmFtZSkge1xuICAgICAgcmV0dXJuIGRhdGFDaGFubmVsQ29uZmlndXJhdGlvbi5uYW1lXG4gICAgfVxuICAgIHJldHVybiAncmVkNXBybydcbiAgfVxuXG4gIC8vID4+IFJlc3BvbmRlciBEZWxlZ2F0ZSBIYW5kbGVycy5cbiAgb25JY2VUcmlja2xlQ29tcGxldGUgKCkge1xuICAgIGRlYnVnKHRoaXMuX25hbWUsIGBbcGVlcjppY2V0cmlja2xlY29tcGxldGVdYClcbiAgICB0aGlzLl9zb2NrZXQucG9zdCh7XG4gICAgICBzdGFydENoYW5uZWw6IHRoaXMuZ2V0RGF0YUNoYW5uZWxOYW1lKHRoaXMuX29wdGlvbnMpXG4gICAgfSlcbiAgfVxuXG4gIG9uQWRkSWNlQ2FuZGlkYXRlIChjYW5kaWRhdGUpIHtcbiAgICBkZWJ1Zyh0aGlzLl9uYW1lLCBgW3BlZXI6YWRkaWNlY2FuZGlkYXRlXWApXG4gICAgaWYgKCFpc09iamVjdEVtcHR5KGNhbmRpZGF0ZS5jYW5kaWRhdGUpKSB7XG4gICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zyh0aGlzLl9uYW1lLCBgW3BlZXI6b25lbXB0eWNhbmRpZGF0ZV1gKVxuICAgIH1cbiAgfVxuXG4gIG9uU0RQQW5zd2VyIChzZHApIHtcbiAgICBkZWJ1Zyh0aGlzLl9uYW1lLCBgW3BlZXI6aGFuZGxlYW5zd2VyXWApXG4gICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uc2V0UmVtb3RlRGVzY3JpcHRpb24obmV3IHdlYnJ0Yy5SVENTZXNzaW9uRGVzY3JpcHRpb24oc2RwKSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgLy9cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IE1lc3NhZ2VUcmFuc3BvcnRTdGF0ZUV2ZW50KE1lc3NhZ2VUcmFuc3BvcnRTdGF0ZUV2ZW50VHlwZXMuRVJST1IsIHRoaXMuX25hbWUsIHtwZWVyQ29ubmVjdGlvbjogdGhpcywgZXJyb3I6IGVycm9yfSkpXG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlLnJlamVjdChlcnJvcilcbiAgICAgIH0pXG4gIH1cblxuICBvbkRhdGFDaGFubmVsQXZhaWxhYmxlIChjaGFubmVsTmFtZSkge1xuICAgIHRoaXMuX3NvY2tldC5zZXZlcih7c3dpdGNoQ2hhbm5lbDogY2hhbm5lbE5hbWUgfHwgJ3JlZDVwcm8nfSlcbiAgICB0aGlzLl9zb2NrZXQgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZS5yZXNvbHZlKHRoaXMpXG4gIH1cblxuICBvblNvY2tldFN0YXR1cyAoc3RhdHVzRGF0YSkge1xuICAgIGlmIChzdGF0dXNEYXRhLm1lc3NhZ2UpIHtcbiAgICAgIGNvbnN0IHN0YXJ0UmVzdWx0ID0gc29TdGFydFJlZ2V4LmV4ZWMoc3RhdHVzRGF0YS5tZXNzYWdlKVxuICAgICAgZGVidWcodGhpcy5fbmFtZSwgYFtwZWVyOnN0YXR1c10gJHtzdGF0dXNEYXRhLm1lc3NhZ2V9YClcbiAgICAgIGlmIChzdGFydFJlc3VsdCAmJiBzdGFydFJlc3VsdC5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vICAgICAgICBjb25zdCBuYW1lID0gc3RhcnRSZXN1bHRbMV0gXG4gICAgICAgIC8vICAgICAgICBjb25zdCBpc1BlZXJOYW1lID0gbmFtZSA9PT0gdGhpcy5fbmFtZVxuICAgICAgICAvLyAgICAgICAgY29uc3QgaXNEQ05hbWUgPSBuYW1lID09PSB0aGlzLmdldERhdGFDaGFubmVsTmFtZSh0aGlzLl9vcHRpb25zKVxuICAgICAgICAvLyAgICAgICAgdGhpcy5fY29ubmVjdGlvblByb21pc2UucmVzb2x2ZSh0aGlzKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyA8PCBSZXNwb25kZXIgRGVsZWdhdGUgSGFuZGxlcnMuXG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVkNVByb1NoYXJlZE9iamVjdFBlZXJDb25uZWN0aW9uXG4iLCJpbXBvcnQgUmVkNVByb1NoYXJlZE9iamVjdCBmcm9tICcuL3NoYXJlZG9iamVjdCdcbmltcG9ydCBSZWQ1UHJvU2hhcmVkT2JqZWN0U29ja2V0IGZyb20gJy4vc29ja2V0J1xuaW1wb3J0IFJlZDVQcm9TaGFyZWRPYmplY3RQZWVyQ29ubmVjdGlvbiBmcm9tICcuL3BlZXInXG5cbmV4cG9ydCB7XG4gIFJlZDVQcm9TaGFyZWRPYmplY3QsXG4gIFJlZDVQcm9TaGFyZWRPYmplY3RTb2NrZXQsXG4gIFJlZDVQcm9TaGFyZWRPYmplY3RQZWVyQ29ubmVjdGlvblxufVxuIiwiaW1wb3J0IFJUQ1B1Ymxpc2hlciBmcm9tICcuLi9wdWJsaXNoZXIvcmVkNXByby1ydGMuanMnXG5pbXBvcnQge1xuICBSVENDb25mZXJlbmNlUGFydGljaXBhbnRFdmVudCxcbiAgUlRDQ29uZmVyZW5jZVBhcnRpY2lwYW50RXZlbnRUeXBlc1xufSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCB7IEZ1dHVyZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IGRlYnVnLCB3YXJuIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBwdWJTdGFydFJlZ2V4ID0gL3BhcnRpY2lwYW50ICguKikgc3RhcnRpbmcgKC4qKS9pXG4vLyBjb25zdCBwdWJTdG9wUmVnZXggPSAvcGFydGljaXBhbnQgKC4qKSBzdG9wcGluZyAoLiopL2lcbmNvbnN0IHB1YlN0b3BSZWdleCA9IC9MZWF2aW5nIGdyb3VwICguKikvaVxuY29uc3QgTkFNRSA9ICdSVENDb25mZXJlbmNlUGFydGljaXBhbnQnXG5jb25zdCBERUZBVUxUX0dST1VQX05BTUUgPSAnZ3JvdXAwMSdcbmNvbnN0IEdST1VQX1RSQUNLX0NPVU5UID0gM1xuXG4vLyBCdWlsZHMgb2ZmIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gZm9yIFJUQ1B1Ymxpc2hlclxuY29uc3QgZGVmYXVsdENvbmZpZ3VyYXRpb24gPSB7XG4gIGdyb3VwTmFtZTogREVGQVVMVF9HUk9VUF9OQU1FLFxuICBhdXRvR2VuZXJhdGVNZWRpYVN0cmVhbTogdHJ1ZSxcbiAgbWl4QXVkaW9Eb3duOiBmYWxzZVxufVxuXG5jbGFzcyBSVENDb25mZXJlbmNlUGFydGljaXBhbnQgZXh0ZW5kcyBSVENQdWJsaXNoZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fbmFtZSA9IE5BTUVcbiAgICB0aGlzLl9hdWRpb1RyYWNrcyA9IFtdXG4gICAgdGhpcy5fdmlkZW9UcmFja3MgPSBbXVxuICAgIHRoaXMuX2NvbmZlcmVuY2VTdHJlYW0gPSB1bmRlZmluZWRcbiAgICAvLyAgICB0aGlzLl9hdWRpb1N0cmVhbSA9IHVuZGVmaW5lZFxuICAgIC8vICAgIHRoaXMuX2F1ZGlvRWxlbWVudCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYGF1ZGlvYERPTSAgZWxlbWVudC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jcmVhdGVBdWRpb0VsZW1lbnQgKCkge1xuICAgIGxldCBhdWRpb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpXG4gICAgLy8gICAgICAgIGF1ZGlvRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgYXVkaW9FbGVtZW50LmlkID0gJ3JlZDVwcm8tYXVkaW8nXG4gICAgYXVkaW9FbGVtZW50LmNvbnRyb2xzID0gJ2NvbnRyb2xzJ1xuICAgIGF1ZGlvRWxlbWVudC5hdXRvcGxheSA9ICdhdXRvcGxheSdcbiAgICBhdWRpb0VsZW1lbnQucGxheXNpbmxpbmUgPSAncGxheXNpbmxpbmUnXG4gICAgcmV0dXJuIGF1ZGlvRWxlbWVudFxuICB9XG5cbiAgLyoqXG4gICAqIFN0dWZmIHRoZSBtZWRpYSBzdHJlYW0gd2l0aCBhZGRpdGlvbmFsIGF1ZGlvIHRyYWNrcyBmb3IgU0RQIG5lZ290aWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BhY2tTdHJlYW1XaXRoQXVkaW8gKHN0cmVhbSwgYW1vdW50KSB7XG4gICAgY29uc3QgdiA9IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdLmNsb25lKClcbiAgICBzdHJlYW0uYWRkVHJhY2sodilcbiAgICB3aGlsZSgtLWFtb3VudCA+IC0xKSB7XG4gICAgICBsZXQgY29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcbiAgICAgIGxldCBkZXN0ID0gY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uKCk7XG4gICAgICBjb250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN0cmVhbSkuY29ubmVjdChkZXN0KTtcbiAgICAgIHN0cmVhbS5hZGRUcmFjayhkZXN0LnN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGdlbmVyYXRlIG9mZmVyIG9uIFBlZXIgQ29ubmVjdGlvbiBpbnN0YW5jZS5cbiAgICogT3ZlcnJpZGUgdG8gc3VwcG9ydCBTRFAgc3RyaXBwaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYmFuZHdpZHRoXG4gICAqICAgICAgICBPcHRpb25hbCBiYW5kd2lkdGggY29uZmlndXJhdGlvbiBvYmplY3QgdG8gbXVuZ2UgU0RQLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgICAgICAgVGhlIHByb21pc2Ugd2lsbCByZXNvbHZlL3JlamVjdCBhIHN1Y2Nlc3MgaW4gY3JlYXRpb24gb2YgdGhlIG9mZmVyIHRocm91Z2ggdGhlIFBlZXIgQ29ubmVjdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jcmVhdGVPZmZlciAoYmFuZHdpZHRoID0gbnVsbCwgZm9yY2VWUDggPSBmYWxzZSkge1xuICAgIGRlYnVnKCdbY3JlYXRlb2ZmZXJdJylcbiAgICB0aGlzLl9vZmZlckZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX29mZmVyRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fb2ZmZXJGdXR1cmUpXG4gICAgdGhpcy5fcGVlckhlbHBlci5jcmVhdGVPZmZlcihiYW5kd2lkdGgsIGZvcmNlVlA4LCB0cnVlLCB0aGlzLl9vZmZlckZ1dHVyZSlcbiAgICByZXR1cm4gdGhpcy5fb2ZmZXJGdXR1cmUucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gc2VuZCBvZmZlciBvbiBXZWJTb2NrZXQgaW5zdGFuY2UuXG4gICAqIE92ZXJyaWRlIHRvIHJlcXVlc3Qgam9pbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHNkcFxuICAgKiAgICAgICAgT2JqZWN0IGRlc2NyaWJpbmcgdGhlIFNlc3Npb24gRGVzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJlYW1OYW1lXG4gICAqICAgICAgICBUaGUgdW5pcXVlIHN0cmVhbSBuYW1lIG9mIHRoZSBicm9hZGNhc3QuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnRcbiAgICogICAgICAgIFRoZSB0cmFuc3BvcnQgdHlwZS5cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICAgICAgIFRoZSBwcm9taXNlIHdpbGwgcmVzb2x2ZS9yZWplY3Qgb24gdGhlIHN1Y2Nlc3Mgb2YgZGVsaXZlcmluZyBhbiBvZmZlciBvdmVyIHRoZSBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VuZE9mZmVyIChzZHAsIHN0cmVhbU5hbWUsIHRyYW5zcG9ydCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGdyb3VwTmFtZVxuICAgIH0gPSB0aGlzLl9vcHRpb25zXG4gICAgdGhpcy5fc2VuZE9mZmVyRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fc2VuZE9mZmVyRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fc2VuZE9mZkZ1dHVyZSlcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdCh7XG4gICAgICBqb2luR3JvdXA6IGdyb3VwTmFtZSxcbiAgICAgIHN0cmVhbU5hbWU6IHN0cmVhbU5hbWUsXG4gICAgICB0cmFuc3BvcnQ6IHRyYW5zcG9ydCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc2RwOiBzZHBcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB0aGlzLl9zZW5kT2ZmZXJGdXR1cmUucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3Qgb24gV2ViU29ja2V0IHRvIGJlZ2luIHB1Ymxpc2hpbmcuXG4gICAqIE92ZXJyaWRlIHRvIGJ5cGFzcyBwdWJsaXNoIFBPU1QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJlYW1OYW1lXG4gICAqICAgICAgICBUaGUgdW5pcXVlIHN0cmVhbSBuYW1lIG9mIHRoZSBicm9hZGNhc3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlXG4gICAqICAgICAgICBUaGUgYnJvYWRjYXN0IG1vZGU6IGBsaXZlYCwgYHJlY29yZGAgb3IgYGFwcGVuZGAuXG4gICAqIEBwYXJhbSB7aW50fSBmcmFtZXJhdGVcbiAgICogICAgICAgIFRoZSBrZXkgZnJhbWVyYXRlIHRvIGJyb2FkY2FzdCBhdC5cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICAgICAgIFRoZSBwcm9taXNlIHdpbGwgcmVzb2x2ZS9yZWplY3QgaW4gdGhlIHJlcXVlc3QgdG8gYmVpbmcgYSBicm9hZGNhc3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgX3JlcXVlc3RQdWJsaXNoIChzdHJlYW1OYW1lLCBzdHJlYW1Nb2RlLCBrZXlGcmFtZXJhdGUpIHtcbiAgICBjb25zdCB7IGF1dG9HZW5lcmF0ZU1lZGlhU3RyZWFtIH0gPSB0aGlzLl9vcHRpb25zXG4gICAgLy8gQSBDb25mZXJlbmNlIFBhcnRpY2lwYW50IGRvZXMgbm90IHJlcXVlc3QgdG8gc3RhcnQgYSBicm9hZGNhc3Qgc3RyZWFtLlxuICAgIHRoaXMuX3B1Ymxpc2hGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wdWJsaXNoRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fcHVibGlzaEZ1dHVyZSlcbiAgICB0aGlzLl9wdWJsaXNoRnV0dXJlLnJlc29sdmUoKVxuICAgIGlmIChhdXRvR2VuZXJhdGVNZWRpYVN0cmVhbSkge1xuICAgICAgdGhpcy5fY29uZmVyZW5jZVN0cmVhbSA9IHRoaXMuX3N0YXJ0UmVjZWl2ZXJzKClcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgUlRDQ29uZmVyZW5jZVBhcnRpY2lwYW50RXZlbnQoUlRDQ29uZmVyZW5jZVBhcnRpY2lwYW50RXZlbnRUeXBlcy5NRURJQV9TVFJFQU0sIHRoaXMsIHtcbiAgICAgICAgc3RyZWFtOiB0aGlzLl9jb25mZXJlbmNlU3RyZWFtXG4gICAgICB9KSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3B1Ymxpc2hGdXR1cmUucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gc3RvcCBhIGJyb2FkY2FzdC5cbiAgICogVGhlIHJldHVybmVkIGBQcm9taXNlYCB3aWxsIGVpdGhlciByZXNvbHZlIG9yIHJlamVjdCBvbiBzdWNjZXNzZnVsIHN0b3Agb2YgYnJvYWRjYXN0LlxuICAgKiBPdmVycmlkZSB0byBzdG9wIGNvbmZlcmVuY2Ugc3RyZWFtXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICB1bnB1Ymxpc2ggKCkge1xuICAgIGlmICh0aGlzLl9jb25mZXJlbmNlU3RyZWFtKSB7XG4gICAgICB0aGlzLl9jb25mZXJlbmNlU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godCA9PiB0LnN0b3AoKSlcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnVucHVibGlzaCgpXG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBzdG9wIGEgY3VycmVudCBicm9hZGNhc3QuXG4gICAqIE92ZXJyaWRlIHRvIHJlcXVlc3QgdW5qb2luLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyZWFtTmFtZVxuICAgKiAgICAgICAgVGhlIHVuaXF1ZSBzdHJlYW0gbmFtZSBiZWluZyBicm9hZGNhc3Qgb24uXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgICAgICBUaGUgcHJvbWlzZSB3aWxsIHJlc29sdmUvcmVqZWN0IG9uIHN1Y2Nlc3Mgb2YgcHJvcGVybHkgc3RvcHBpbmcgYSBicm9hZGNhc3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgX3JlcXVlc3RVbnB1Ymxpc2ggKHN0cmVhbU5hbWUpIHtcbiAgICBjb25zdCB7XG4gICAgICBncm91cE5hbWVcbiAgICB9ID0gdGhpcy5fb3B0aW9uc1xuICAgIHRoaXMuX3VucHVibGlzaEZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3VucHVibGlzaEZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX3VucHVibGlzaEZ1dHVyZSlcbiAgICAvLyBJZiB3ZSBnZXQgYSBmYWxzZSByZXNwb25zZSBmcm9tIHRyeWluZyB0byBzZW5kIGEgY2xvc2UgUE9TVCxcbiAgICAvLyAgaXQgbWVhbnMgdGhhdCB0aGUgc29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ5IGFub3RoZXIgaW1wZXR1cyAtXG4gICAgLy8gIG1vc3QgbGlrbGV5IGxvc3Mgb2YgbmV0d29yayBvciBzZXJ2ZXIgZmFpbHVyZS5cbiAgICBpZiAoIXRoaXMuZ2V0TWVzc2FnZVRyYW5zcG9ydCgpLnBvc3RVbmpvaW4oZ3JvdXBOYW1lLCBzdHJlYW1OYW1lKSkge1xuICAgICAgdGhpcy5fdW5wdWJsaXNoRnV0dXJlLnJlc29sdmUoKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdW5wdWJsaXNoRnV0dXJlLnByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgbW92aW5nIHN0b3JlZCB0cmFja3MgdG8gc2luZ2xlIE1lZGlhU3RyZWFtIG91dC5cbiAgICpcbiAgICogQHJldHVybiB7TWVkaWFTdHJlYW19XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc3RhcnRSZWNlaXZlcnMgKCkge1xuICAgIGNvbnN0IHJlY2VpdmVyVHJhY2tzID0gdGhpcy5nZXRQZWVyQ29ubmVjdGlvbigpLmdldFRyYW5zY2VpdmVycygpLm1hcCh0ID0+IHtcbiAgICAgIGlmICh0LmN1cnJlbnREaXJlY3Rpb24gPT09ICdyZWN2b25seScpIHtcbiAgICAgICAgcmV0dXJuIHQucmVjZWl2ZXIudHJhY2tcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9KS5maWx0ZXIodCA9PiB0KVxuICAgIGNvbnN0IHsgbWl4QXVkaW9Eb3duIH0gPSB0aGlzLl9vcHRpb25zXG4gICAgbGV0IHN0cmVhbVxuICAgIGxldCBtZWRpYVN0cmVhbSA9IHRoaXMuX2NvbmZlcmVuY2VTdHJlYW0gfHwgbmV3IE1lZGlhU3RyZWFtKClcblxuICAgIGlmICghbWl4QXVkaW9Eb3duKSB7XG5cbiAgICAgIC8vIE9QVElPTiBhIC0gQWRkIGVhY2ggdHJhY2sgYXMgc2luZ3VsYXIgdHJhY2sgdG8gb25lIE1lZGlhU3RyZWFtXG4gICAgICByZWNlaXZlclRyYWNrcy5mb3JFYWNoKHQgPT4gbWVkaWFTdHJlYW0uYWRkVHJhY2sodCkpXG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gT1BUSU9OIEEgLSBNaXggYWxsIHRyYWNrcyBpbnRvIGEgc2luZ2xlIE1lZGlhU3RyZWFtICsgc2luZ2xlIEF1ZGlvVHJhY2tcbiAgICAgIGNvbnN0IGFjID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuICAgICAgLy8gV2ViQXVkaW8gTWVkaWFTdHJlYW0gc291cmNlcyBvbmx5IHVzZSB0aGUgZmlyc3QgdHJhY2suXG4gICAgICBjb25zdCBzb3VyY2VzID0gcmVjZWl2ZXJUcmFja3MubWFwKHQgPT4ge1xuICAgICAgICBpZiAodC5raW5kID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgcmV0dXJuIGFjLmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKG5ldyBNZWRpYVN0cmVhbShbdF0pKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIH0pLmZpbHRlcih0ID0+IHQpXG4gICAgICAvLyBUaGUgZGVzdGluYXRpb24gd2lsbCBvdXRwdXQgb25lIHRyYWNrIG9mIG1peGVkIGF1ZGlvLlxuICAgICAgY29uc3QgZGVzdCA9IGFjLmNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb24oKVxuICAgICAgLy8gTWl4aW5nXG4gICAgICBzb3VyY2VzLmZvckVhY2gocyA9PiBzLmNvbm5lY3QoZGVzdCkpXG4gICAgICBzdHJlYW0gPSBkZXN0LnN0cmVhbVxuICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godCA9PiBtZWRpYVN0cmVhbS5hZGRUcmFjayh0KSlcbiAgICB9XG4gICAgcmVjZWl2ZXJUcmFja3MuZm9yRWFjaCh0ID0+IHtcbiAgICAgIGlmICh0LmtpbmQgPT09ICd2aWRlbycpIHtcbiAgICAgICAgbWVkaWFTdHJlYW0uYWRkVHJhY2sodClcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBtZWRpYVN0cmVhbVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gaW5pdGlhbGl6ZSB0aGUgV2ViUlRDLWJhc2VkIFB1Ymxpc2hlciBiYXNlZCBvbiBjb25maWd1cmF0aW9uLlxuICAgKiBUaGUgcmV0dXJuZWQgYFByb21pc2VgIHdpbGwgZWl0aGVyIHJlc29sdmUgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlIG9yIHJlamVjdCB3aXRoIGFuIGVycm9yIGBTdHJpbmdgIGluIGZhaWx1cmUuXG4gICAqIE92ZXJyaWRlIHRvIGFzc2lnbiBncm91cE5hbWUgaWYgbm90IHNldC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFRoZSBpbml0aWFsaXphdGlvbiBjb25maWd1cmF0aW9uIG1hcC5cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIGluaXQgKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3VwZXIuaW5pdChPYmplY3QuYXNzaWduKGRlZmF1bHRDb25maWd1cmF0aW9uLCBvcHRpb25zKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGluaXRpYWxpemUgdGhlIFdlYlJUQy1iYXNlZCBQdWJsaXNoZXIgYmFzZWQgb24gY29uZmlndXJhdGlvbiBhbmQgTWVkaWFTdHJlYW0uXG4gICAqIFRoZSByZXR1cm5lZCBgUHJvbWlzZWAgd2lsbCBlaXRoZXIgcmVzb2x2ZSB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoaXMgaW5zdGFuY2Ugb3IgcmVqZWN0IHdpdGggYW4gZXJyb3IgYFN0cmluZ2AgaW4gZmFpbHVyZS5cbiAgICogT3ZlcnJpZGUgdG8gYXNzaWduIGdyb3VwTmFtZSBpZiBub3Qgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgVGhlIGluaXRpYWxpemF0aW9uIGNvbmZpZ3VyYXRpb24gbWFwLlxuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cbiAgICogICAgICAgIFRoZSBhbHJlYWR5IGVzdGFibGlzaGVkIE1lZGlhU3RyZWFtLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgaW5pdFdpdGhTdHJlYW0gKG9wdGlvbnMsIHN0cmVhbSkge1xuICAgIHJldHVybiBzdXBlci5pbml0V2l0aFN0cmVhbShPYmplY3QuYXNzaWduKGRlZmF1bHRDb25maWd1cmF0aW9uLCBvcHRpb25zKSwgc3RyZWFtKVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIHRyYWNrIGFkZCBvbiBQZWVyQ29ubmVjdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uUGVlckNvbm5lY3Rpb25UcmFja0FkZCAodHJhY2spIHtcbiAgICBjb25zdCB7IGF1dG9HZW5lcmF0ZU1lZGlhU3RyZWFtIH0gPSB0aGlzLl9vcHRpb25zXG4gICAgaWYgKGF1dG9HZW5lcmF0ZU1lZGlhU3RyZWFtICYmIHRyYWNrLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgICAgIHRoaXMuX2F1ZGlvVHJhY2tzLnB1c2godHJhY2spXG4gICAgfSBlbHNlIGlmIChhdXRvR2VuZXJhdGVNZWRpYVN0cmVhbSAmJiB0cmFjay5raW5kID09PSAndmlkZW8nKSB7XG4gICAgICB0aGlzLl92aWRlb1RyYWNrcy5wdXNoKHRyYWNrKVxuICAgIH1cbiAgICBzdXBlci5vblBlZXJDb25uZWN0aW9uVHJhY2tBZGQodHJhY2spXG4gIH1cblxuICAvKipcbiAgICogUmVjZWlwdCBvZiBNZWRpYVN0cmVhbSBmcm9tIGdVTS5cbiAgICogT3ZlcnJpZGUgdG8gcGFjayB3aXRoIGNvbmZlcmVuY2UgYXVkaW8gdHJhY2tzIG9uIFNEUC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk1lZGlhU3RyZWFtUmVjZWl2ZWQgKG1lZGlhU3RyZWFtKSB7XG4gICAgdGhpcy5fcGFja1N0cmVhbVdpdGhBdWRpbyhtZWRpYVN0cmVhbSwgR1JPVVBfVFJBQ0tfQ09VTlQpXG4gICAgc3VwZXIuX29uTWVkaWFTdHJlYW1SZWNlaXZlZChtZWRpYVN0cmVhbSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBzdWNjZXNzIGluIFNEUCBhbnN3ZXIgb3ZlciBXZWJTb2NrZXQuXG4gICAqIE92ZXJyaWRlIHRvIHJlLWFzc2lnbiBwYXJ0aWNpcGFudC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uU0RQQW5zd2VyIChzZHApIHtcbiAgICBjb25zdCB7XG4gICAgICBzdHJlYW1OYW1lXG4gICAgfSA9IHRoaXMuX29wdGlvbnNcbiAgICAvLyBGbGlwIHN0cmVhbU5hbWUgdG8gcGFydGljaXBhbnQgaWQgZm9yIGZ1cnRoZXIgSUNFIG5lZ290aWF0aW9uLlxuICAgIHRoaXMub3ZlcmxheU9wdGlvbnMoe1xuICAgICAgc3RyZWFtTmFtZTogc2RwLnBhcnRpY2lwYW50SWQsXG4gICAgICBwYXJ0aWNpcGFudElkOiBzZHAucGFydGljaXBhbnRJZCxcbiAgICAgIHB1Ymxpc2hlck5hbWU6IHN0cmVhbU5hbWVcbiAgICB9KVxuICAgIHRoaXMuX3NlbmRPZmZlckZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX3NlbmRPZmZlckZ1dHVyZSlcbiAgICB0aGlzLl9zZW5kT2ZmZXJGdXR1cmUucmVzb2x2ZShzZHApXG4gIH1cblxuICAvKipcbiAgICogUHVibGlzaGVyIHN0YXR1cyBldmVudCBoYW5kbGVyIGZvciBzdGFydCBhbmQgc3RvcCBvZiB0aGlzIFB1Ymxpc2hlciBpbnN0YW5jZS5cbiAgICogT3ZlcnJpZGUgZm9yIHJlZ2V4IG9uIG1lc3NhZ2luZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uUHVibGlzaGVyU3RhdHVzIChzdGF0dXMpIHtcbiAgICBkZWJ1Zyh0aGlzLl9uYW1lLCAnW3B1Ymxpc2hlcnN0YXR1c10gLSAnICsgSlNPTi5zdHJpbmdpZnkoc3RhdHVzLCBudWxsLCAyKSlcbiAgICBjb25zdCBzdG9wUmVzdWx0ID0gcHViU3RvcFJlZ2V4LmV4ZWMoc3RhdHVzLm1lc3NhZ2UpXG4gICAgY29uc3Qgc3RhcnRSZXN1bHQgPSBwdWJTdGFydFJlZ2V4LmV4ZWMoc3RhdHVzLm1lc3NhZ2UpXG4gICAgaWYgKHN0b3BSZXN1bHQgJiYgc3RvcFJlc3VsdFsxXSA9PT0gdGhpcy5fb3B0aW9ucy5ncm91cE5hbWUpIHtcbiAgICAgIHRoaXMuX3VucHVibGlzaEZ1dHVyZS5yZXNvbHZlKClcbiAgICB9IGVsc2UgaWYgKHN0YXJ0UmVzdWx0ICYmIHN0YXJ0UmVzdWx0WzFdID09PSB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUpIHtcbiAgICAgIHRoaXMuX3B1Ymxpc2hGdXR1cmUucmVzb2x2ZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4odGhpcy5fbmFtZSwgJ1B1Ymxpc2hlciBzdGF0dXMgcmVjZWl2ZWQsIGJ1dCBjb3VsZCBub3QgaGFuZGxlLicpXG4gICAgfVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUlRDQ29uZmVyZW5jZVBhcnRpY2lwYW50XG4iLCIvKipcbiAqIE1haW4gZW50cnkgb2YgU0RLLCBhY2Nlc3NpYmxlIG9uIHRoZSBgd2luZG93YCBnbG9iYWwgYXQgYHJlZDVwcm9zZGtgLlxuICpcbiAqIEBmaWxlIHJlZDVwcm8ubWluLmpzXG4gKiBAbW9kdWxlIHJlZDVwcm9zZGtcbiAqXG4gKlxuICovXG5cbi8vIFNES19WRVJTSU9OLCBMT0dfTEVWRUwgaW5qZWN0ZWQgZnJvbSB3ZWJwYWNrIGJ1aWxkLlxuaW1wb3J0IHtcbiAgTEVWRUxTLFxuICBlc3RhYmxpc2hMb2dnZXIsXG4gIGdldFJlY29yZGVkTG9nc1xufSBmcm9tICcuL2xvZydcbmltcG9ydCB7IGdldExvZ2dlciBhcyBfZ2V0TG9nZ2VyIH0gZnJvbSAnLi9sb2cnXG5pbXBvcnQgKiBhcyBzdWJzY3JpYmVyTGliIGZyb20gJy4vc3Vic2NyaWJlci9pbmRleCdcbmltcG9ydCAqIGFzIHB1Ymxpc2hlckxpYiBmcm9tICcuL3B1Ymxpc2hlci9pbmRleCdcbmltcG9ydCAqIGFzIHNoYXJlZE9iamVjdExpYiBmcm9tICcuL3NoYXJlZG9iamVjdC9pbmRleCdcbmltcG9ydCAqIGFzIHBsYXliYWNrRW51bSBmcm9tICcuL2VudW0vcGxheWJhY2snXG5pbXBvcnQgKiBhcyB3ZWJydGNFbnVtIGZyb20gJy4vZW51bS93ZWJydGMnXG5pbXBvcnQgKiBhcyBwdWJsaXNoZXJFdmVudCBmcm9tICcuL2V2ZW50L3B1Ymxpc2hlci1ldmVudCdcbmltcG9ydCAqIGFzIHN1YnNjcmliZXJFdmVudCBmcm9tICcuL2V2ZW50L3N1YnNjcmliZXItZXZlbnQnXG5pbXBvcnQgKiBhcyBzaGFyZWRvYmplY3RFdmVudCBmcm9tICcuL2V2ZW50L3NoYXJlZG9iamVjdC1ldmVudCdcbmltcG9ydCAqIGFzIG1lc3NhZ2VUcmFuc3BvcnRTdGF0ZUV2ZW50IGZyb20gJy4vZXZlbnQvbWVzc2FnZS10cmFuc3BvcnQtZXZlbnQnXG5pbXBvcnQgKiBhcyBwYXJ0aWNpcGFudFN0YXRlRXZlbnQgZnJvbSAnLi9ldmVudC9wYXJ0aWNpcGFudC1ldmVudCdcbmltcG9ydCBQbGF5YmFja1ZpZXcgZnJvbSAnLi92aWV3L3BsYXliYWNrJ1xuaW1wb3J0IFB1Ymxpc2hlclZpZXcgZnJvbSAnLi92aWV3L3B1Ymxpc2gnXG5pbXBvcnQgUlRDQ29uZmVyZW5jZVBhcnRpY2lwYW50IGZyb20gJy4vY29uZmVyZW5jZS9wYXJ0aWNpcGFudCdcblxuLyoqXG4gKiBBIENvbmZlcmVuY2UgUGFydGljaXBhbnQgaXMgYW4gUlRDUHVibGlzaGVyIHRoYXQgY2FuIGNvbnN1bWUgbXVsdGlwbGUgYXVkaW8gdHJhY2tzLlxuICovXG5leHBvcnQgeyBSVENDb25mZXJlbmNlUGFydGljaXBhbnQgfVxuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICAqL1xuLyogU3Vic2NyaXB0aW9uIHJlbGF0ZWQgcmVmZXJlbmNlcy4gKi9cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gICovXG5cbi8qKlxuICogVGhlIGZhaWwtb3ZlciBlbmFibGVkIFN1YnNjcmliZXIgRmFjdG9yeS5cbiAqIEBzZWUgUmVkNVByb1N1YnNjcmliZXJcbiAqL1xuZXhwb3J0IGNvbnN0IFJlZDVQcm9TdWJzY3JpYmVyID0gc3Vic2NyaWJlckxpYi5SZWQ1UHJvU3Vic2NyaWJlclxuLyoqXG4gKiBUaGUgV2ViUlRDIGJhc2VkIFN1YnNjcmliZXIuXG4gKlxuICogQW4gaW5zdGFuY2Ugb2YgYFJUQ1N1YnNjcmliZXJgIGNhbiBiZSBjcmVhdGVkIGV4cGxpY2l0bHkgdXNpbmcgdGhpcyBjbGFzcywgb3IgYnkgdGhlIGBSZWQ1UHJvU3Vic2NyaWJlcmAgZmFpbC1vdmVyIGZhY3RvcnkuXG4gKiBAc2VlIFJUQ1N1YnNjcmliZXJcbiAqL1xuZXhwb3J0IGNvbnN0IFJUQ1N1YnNjcmliZXIgPSBzdWJzY3JpYmVyTGliLlJUQ1N1YnNjcmliZXJcbi8qKlxuICogVGhlIFdlYlJUQyBiYXNlZCBTdWJzY3JpYmVyIHN1cHBvcnRpbmcgV0hFUCBzaWduYWxpbmcuXG4gKiBAc2VlIFdIRVBDbGllbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFdIRVBDbGllbnQgPSBzdWJzY3JpYmVyTGliLldIRVBDbGllbnRcbi8qKlxuICogVGhlIEZsYXNoICh1dGlsaXppbmcgUlRNUCBwcm90b2NvbCkgYmFzZWQgU3Vic2NyaWJlci5cbiAqXG4gKiBBbiBpbnN0YW5jZSBvZiBgUlRNUFN1YnNjcmliZXJgIGNhbiBiZSBjcmVhdGVkIGV4cGxpY2l0bHkgdXNpbmcgdGhpcyBjbGFzcywgb3IgYnkgdGhlIGBSZWQ1UHJvU3Vic2NyaWJlcmAgZmFpbC1vdmVyIGZhY3RvcnkuXG4gKiBAc2VlIFJUTVBTdWJzY3JpYmVyXG4gKi9cbmV4cG9ydCBjb25zdCBSVE1QU3Vic2NyaWJlciA9IHN1YnNjcmliZXJMaWIuUlRNUFN1YnNjcmliZXJcbi8qKlxuICogVGhlIEhMUyAoSFRUUCBMaXZlIFN0cmVhbSkgYmFzZWQgU3Vic2NyaWJlci5cbiAqXG4gKiBBbiBpbnN0YW5jZSBvZiBgSExTU3Vic2NyaWJlcmAgY2FuIGJlIGNyZWF0ZWQgZXhwbGljaXRseSB1c2luZyB0aGlzIGNsYXNzLCBvciBieSB0aGUgYFJlZDVQcm9TdWJzY3JpYmVyYCBmYWlsLW92ZXIgZmFjdG9yeS5cbiAqIEBzZWUgSExTU3Vic2NyaWJlclxuICovXG5leHBvcnQgY29uc3QgSExTU3Vic2NyaWJlciA9IHN1YnNjcmliZXJMaWIuSExTU3Vic2NyaWJlclxuLyoqXG4gKiBTdGlsbCB1c2VkLCBidXQgQVBJLWRlcHJlY2F0ZWQgVmlldyBpbnN0YW5jZSBmb3IgcGxheWJhY2suIEhhcyBkZWZhdWx0IHNldHVwIGluIHZlcnNpb24gNC4wLjAuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgeyBQbGF5YmFja1ZpZXcgfVxuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICAqL1xuLyogQnJvYWRjYXN0IHJlbGF0ZWQgcmVmZXJlbmNlcy4gKi9cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gICovXG5cbi8qKlxuICogVGhlIGZhaWwtb3ZlciBlbmFibGVkIFB1Ymxpc2hlciBGYWN0b3J5LlxuICogQHNlZSBSZWQ1UHJvUHVibGlzaGVyXG4gKi9cbmV4cG9ydCBjb25zdCBSZWQ1UHJvUHVibGlzaGVyID0gcHVibGlzaGVyTGliLlJlZDVQcm9QdWJsaXNoZXJcbi8qKlxuICogVGhlIFdlYlJUQyBiYXNlZCBQdWJsaXNoZXIuPGJyPkFuIGluc3RhbmNlIG9mIGBSVENQdWJsaXNoZXJgIGNhbiBiZSBjcmVhdGVkIGV4cGxpY2l0bHkgdXNpbmcgdGhpcyBjbGFzcywgb3IgYnkgdGhlIGBSZWQ1UHJvUHVibGlzaGVyYCBmYWlsLW92ZXIgZmFjdG9yeS5cbiAqIEBzZWUgUlRDUHVibGlzaGVyXG4gKi9cbmV4cG9ydCBjb25zdCBSVENQdWJsaXNoZXIgPSBwdWJsaXNoZXJMaWIuUlRDUHVibGlzaGVyXG4vKipcbiAqIFRoZSBXZWJSVEMgYmFzZWQgUHVibGlzaGVyIHN1cHBvcnRpbmcgV0hJUCBzaWduYWxpbmcuXG4gKiBAc2VlIFdISVBDbGllbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFdISVBDbGllbnQgPSBwdWJsaXNoZXJMaWIuV0hJUENsaWVudFxuLyoqXG4gKiBUaGUgRmxhc2ggKHV0aWxpemluZyBSVE1QIHByb3RvY29sKSBiYXNlZCBQdWJsaXNoZXIuXG4gKlxuICogQW4gaW5zdGFuY2Ugb2YgYFJUTVBQdWJsaXNoZXJgIGNhbiBiZSBjcmVhdGVkIGV4cGxpY2l0bHkgdXNpbmcgdGhpcyBjbGFzcywgb3IgYnkgdGhlIGBSZWQ1UHJvUHVibGlzaGVyYCBmYWlsLW92ZXIgZmFjdG9yeS5cbiAqIEBzZWUgUlRNUFB1Ymxpc2hlclxuICovXG5leHBvcnQgY29uc3QgUlRNUFB1Ymxpc2hlciA9IHB1Ymxpc2hlckxpYi5SVE1QUHVibGlzaGVyXG4vKipcbiAqIFN0aWxsIHVzZWQsIGJ1dCBBUEktZGVwcmVjYXRlZCBWaWV3IGluc3RhbmNlIGZvciBicm9hZGNhc3QvcHJldmlldy4gSGFzIGRlZmF1bHQgc2V0dXAgaW4gdmVyc2lvbiA0LjAuMC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCB7IFB1Ymxpc2hlclZpZXcgfVxuXG4vKiBQbGF5YmFjayBjb250cm9scyBpbnRlcmZhY2UuICovXG5leHBvcnQgeyBQbGF5YmFja0NvbnRyb2xzIGFzIFBsYXliYWNrQ29udHJvbHMgfSBmcm9tICcuL3N1YnNjcmliZXIvY29udHJvbHMvaW5kZXgnXG5cbi8qIFNoYXJlZCBPYmplY3QgcmVmZXJlbmNlcy4gKi9cbi8qKlxuICogVGhlIFNoYXJkT2JqZWN0IGNsYXNzLlxuICogQHNlZSBSZWQ1UHJvU2hhcmVkT2JqZWN0XG4gKi9cbmV4cG9ydCBjb25zdCBSZWQ1UHJvU2hhcmVkT2JqZWN0ID0gc2hhcmVkT2JqZWN0TGliLlJlZDVQcm9TaGFyZWRPYmplY3RcblxuLyoqXG4gKiBUaGUgU2hhcmVkT2JqZWN0IFNvY2tldCBQcm94eSBjbGFzcy5cbiAqIEBzZWUgUmVkNVByb1NoYXJlZE9iamVjdFNvY2tldFxuICovXG5leHBvcnQgY29uc3QgUmVkNVByb1NoYXJlZE9iamVjdFNvY2tldCA9IHNoYXJlZE9iamVjdExpYi5SZWQ1UHJvU2hhcmVkT2JqZWN0U29ja2V0XG5cbi8qKlxuICogVGhlIFNoYXJlZE9iamVjdCBQZWVyQ29ubmVjdGlvbiBQcm94eSBjbGFzcy5cbiAqIEBzZWUgUmVkNVByb1NoYXJlZE9iamVjdFBlZXJDb25uZWN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBSZWQ1UHJvU2hhcmVkT2JqZWN0UGVlckNvbm5lY3Rpb24gPSBzaGFyZWRPYmplY3RMaWIuUmVkNVByb1NoYXJlZE9iamVjdFBlZXJDb25uZWN0aW9uXG5cbi8qIEV2ZW50cyAqL1xuLyoqXG4gKiBFbnVtZXJhdGlvbiBvZiBjb21tb24gUHVibGlzaGVyIEV2ZW50cy5cbiAqL1xuZXhwb3J0IGNvbnN0IFB1Ymxpc2hlckV2ZW50VHlwZXMgPSBwdWJsaXNoZXJFdmVudC5QdWJsaXNoZXJFdmVudFR5cGVzXG4vKipcbiAqIEVudWVyYXRpb24gb2YgZXZlbnRzIHNwZWNpZmljIHRvIFdlYlJUQy1iYXNlZCBQdWJsaXNoZXJzLlxuICovXG5leHBvcnQgY29uc3QgUlRDUHVibGlzaGVyRXZlbnRUeXBlcyA9IHB1Ymxpc2hlckV2ZW50LlJUQ1B1Ymxpc2hlckV2ZW50VHlwZXNcbi8qKlxuICogRW51bWVyYXRpb24gb2YgZXZlbnRzIHNwZWNpZmljIHRvIGZhaWwtb3ZlciBQdWJsaXNoZXIgZmFjdG9yeS5cbiAqL1xuZXhwb3J0IGNvbnN0IEZhaWxvdmVyUHVibGlzaGVyRXZlbnRUeXBlcyA9IHB1Ymxpc2hlckV2ZW50LkZhaWxvdmVyUHVibGlzaGVyRXZlbnRUeXBlc1xuLyoqXG4gKiBFbnVtZXJhaXRvbiBvZiBjb21tb24gU3Vic2NyaWJlciBFdmVudHMuXG4gKi9cbmV4cG9ydCBjb25zdCBTdWJzY3JpYmVyRXZlbnRUeXBlcyA9IHN1YnNjcmliZXJFdmVudC5TdWJzY3JpYmVyRXZlbnRUeXBlc1xuLyoqXG4gKiBFbnVtZXJhdGlvbiBvZiBldmVudHMgc3BlY2lmaWMgdG8gV2ViUlRDLWJhc2VkIFN1YnNjcmliZXJzLlxuICovXG5leHBvcnQgY29uc3QgUlRDU3Vic2NyaWJlckV2ZW50VHlwZXMgPSBzdWJzY3JpYmVyRXZlbnQuUlRDU3Vic2NyaWJlckV2ZW50VHlwZXNcbi8qKlxuICogRW51bWVyYXRpb24gb2YgZXZlbnRzIHNwZWNpZmljIHRvIFJUTVAtYmFzZWQgU3Vic2NyaWJlcnMuXG4gKi9cbmV4cG9ydCBjb25zdCBSVE1QU3Vic2NyaWJlckV2ZW50VHlwZXMgPSBzdWJzY3JpYmVyRXZlbnQuUlRNUFN1YnNjcmliZXJFdmVudFR5cGVzXG4vKipcbiAqIEVudW1lcmF0aW9uIG9mIGV2ZW50cyBzcGVjaWZpYyB0byBmYWlsLW92ZXIgU3Vic2NyaWJlciBmYWN0b3J5LlxuICovXG5leHBvcnQgY29uc3QgRmFpbG92ZXJTdWJzY3JpYmVyRXZlbnRUeXBlcyA9IHN1YnNjcmliZXJFdmVudC5GYWlsb3ZlclN1YnNjcmliZXJFdmVudFR5cGVzXG4vKipcbiAqIEVudW1lcmF0aW9uIG9mIGV2ZW50cyBmb3IgU2hhcmVkIE9iamVjdHMuXG4gKi9cbmV4cG9ydCBjb25zdCBTaGFyZWRPYmplY3RFdmVudFR5cGVzID0gc2hhcmVkb2JqZWN0RXZlbnQuU2hhcmVkT2JqZWN0RXZlbnRUeXBlc1xuLyoqXG4gKiBFbnVtZXJhdGlvbiBvZiBldmVudHMgZm9yIFdlYlNvY2tldCBzdGF0ZS5cbiovXG5leHBvcnQgY29uc3QgTWVzc2FnZVRyYW5zcG9ydFN0YXRlRXZlbnRUeXBlcyA9IG1lc3NhZ2VUcmFuc3BvcnRTdGF0ZUV2ZW50Lk1lc3NhZ2VUcmFuc3BvcnRTdGF0ZUV2ZW50VHlwZXNcbi8qKlxuICogRW51bWVyYXRpb24gb2YgZXZlbnRzIGZvciBSVENDb25mZXJlbmNlUGFydGljaXBhbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBSVENDb25mZXJlbmNlUGFydGljaXBhbnRFdmVudFR5cGUgPSBwYXJ0aWNpcGFudFN0YXRlRXZlbnQuUlRDQ29uZmVyZW5jZVBhcnRpY2lwYW50RXZlbnRUeXBlc1xuXG4vKiBFbnVtcyAqL1xuLyoqXG4gKiBFbnVtZXJhdGUgQXVkaW8gRW5jb2RlciBvcHRpb25zIGZvciBTdWJzY3JpYmVycy5cbiAqICAqIGBPUFVTYFxuICogICogYFBDTVVgXG4gKiAgKiBgUENNQWBcbiAqICAqIGBTUEVFWGBcbiAqICAqIGBOT05FYFxuICovXG5leHBvcnQgY29uc3QgUGxheWJhY2tBdWRpb0VuY29kZXIgPSBwbGF5YmFja0VudW0uUGxheWJhY2tBdWRpb0VuY29kZXJcbi8qKlxuICogRW51bWVyYXRlZCBWaWRlbyBFbmNvZGVyIG9wdGlvbnMgZm9yIFN1YnNjcmliZXJzLlxuICogICogYFZQOGBcbiAqICAqIGBIMjY0YFxuICogICogYE5PTkVgXG4gKi9cbmV4cG9ydCBjb25zdCBQbGF5YmFja1ZpZGVvRW5jb2RlciA9IHBsYXliYWNrRW51bS5QbGF5YmFja1ZpZGVvRW5jb2RlclxuXG4vKipcbiAqIEVudW1lcmF0ZSBJQ0UgVHJhbnNwb3J0IG9wdGlvbnMgZm9yIFB1Ymxpc2hlcnMgYW5kIFN1YnNjcmliZXJzLlxuICogKiBgVURQYFxuICogKiBgVENQYFxuICovXG5leHBvcnQgY29uc3QgSWNlVHJhbnNwb3J0VHlwZXMgPSB3ZWJydGNFbnVtLkljZVRyYW5zcG9ydFR5cGVzXG5cbmVzdGFibGlzaExvZ2dlcihgJHtMT0dfTEVWRUx9YCB8fCBMRVZFTFMuREVCVUcpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuLyoqXG4gKiBTZXRzIHRoZSBsb2cgbGV2ZWwgZm9yIGxvZ3MgZnJvbSB0aGUgU0RLXG4gKiBAcGFyYW0ge3N0cmluZ30gbGV2ZWxcbiAqICAgIFRoZSBzcGVjaWZpZWQgbG9nIGxldmVsLlxuICogQHBhcmFtIHtCb29sZWFufSByZWNvcmRcbiAqICAgIEZsYWcgdG8gc3RvcmUgYWxsIGZvciBhY2Nlc3MuXG4gKiBAc2VlIExPR19MRVZFTFNcbiAqL1xuZXhwb3J0IGNvbnN0IHNldExvZ0xldmVsID0gKGxldmVsLCByZWNvcmQ9ZmFsc2UpID0+IHtcbiAgaWYgKExFVkVMUy5oYXNPd25Qcm9wZXJ0eShsZXZlbC50b1VwcGVyQ2FzZSgpKSkge1xuICAgIGVzdGFibGlzaExvZ2dlcihsZXZlbCwgcmVjb3JkKVxuICAgIGlmIChjb25zb2xlKSB7XG4gICAgICBjb25zb2xlLmxvZyhgUmVkNSBQcm8gU0RLIFZlcnNpb24gJHtTREtfVkVSU0lPTn1gKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmLG5vLWNvbnNvbGVcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2Nlc3Mgb2Ygc3RvcmVkIGxvZ3MgaWYgc3BlY2lmaWVkIGByZWNvcmRgIHBhcmFtZXRlciBvZiBgc2V0TG9nTGV2ZWxgXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAc2VlIHNldExvZ0xldmVsXG4gKi9cbmV4cG9ydCB7IGdldFJlY29yZGVkTG9ncyB9XG5cbi8qKlxuICogVGhlIGVudW1lcmF0ZWQgbG9nIGxldmVsIFN0cmluZ3MuXG4gKiAgICAqIGBUUkFDRWBcbiAqICAgICogYElORk9gXG4gKiAgICAqIGBERUJVR2BcbiAqICAgICogYFdBUk5gXG4gKiAgICAqIGBFUlJPUmBcbiAqICAgICogYEZBVEFMYFxuICovXG5leHBvcnQgY29uc3QgTE9HX0xFVkVMUyA9IExFVkVMU1xuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIExvZ2dlciBpbnN0YW5jZSB1c2VkIGJ5IHRoZSBTREsuXG4gKlxuICogQHJldHVybnMge0xvZ2dlcn1cbiAqICAgICAgICAgIFRoZSBsb2dnZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRMb2dnZXIgPSBfZ2V0TG9nZ2VyXG4iXSwic291cmNlUm9vdCI6IiJ9